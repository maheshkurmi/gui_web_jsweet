var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var AbstractHTMLComponent = (function () {
            function AbstractHTMLComponent() {
            }
            AbstractHTMLComponent.prototype.bindHTML = function (htmlElement) {
                this.htmlElement = htmlElement;
            };
            AbstractHTMLComponent.prototype.getHTMLElement = function () {
                if (this.htmlElement == null) {
                    this.createHTML();
                    this.initHTML();
                }
                return this.htmlElement;
            };
            AbstractHTMLComponent.prototype.initHTML = function () {
                if (this.htmlElement == null) {
                    this.createHTML();
                }
            };
            return AbstractHTMLComponent;
        }());
        awt.AbstractHTMLComponent = AbstractHTMLComponent;
        AbstractHTMLComponent["__class"] = "java.awt.AbstractHTMLComponent";
        AbstractHTMLComponent["__interfaces"] = ["java.awt.HTMLComponent"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var Adjustable;
        (function (Adjustable) {
            Adjustable.HORIZONTAL = 0;
            Adjustable.VERTICAL = 1;
            Adjustable.NO_ORIENTATION = 2;
        })(Adjustable = awt.Adjustable || (awt.Adjustable = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var AWTEvent = (function (_super) {
            __extends(AWTEvent, _super);
            function AWTEvent(source, id) {
                var _this = this;
                if (((source != null) || source === null) && ((typeof id === 'number') || id === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this, source);
                    this.id = 0;
                    this.consumed = false;
                    (function () {
                        _this.id = id;
                        _this.consumed = false;
                        switch ((id)) {
                            case java.awt.event.ActionEvent.ACTION_PERFORMED_$LI$():
                            case java.awt.event.ItemEvent.ITEM_STATE_CHANGED_$LI$():
                            case java.awt.event.AdjustmentEvent.ADJUSTMENT_VALUE_CHANGED_$LI$():
                            case java.awt.event.TextEvent.TEXT_VALUE_CHANGED_$LI$():
                                _this.consumed = true;
                                break;
                            default:
                        }
                    })();
                }
                else if (((source != null && source instanceof java.awt.Event) || source === null) && id === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var event_1 = __args[0];
                    {
                        var __args_1 = Array.prototype.slice.call(arguments);
                        var source_1 = event_1.target;
                        var id_1 = event_1.id;
                        _super.call(this, source_1);
                        this.id = 0;
                        this.consumed = false;
                        (function () {
                            _this.id = id_1;
                            _this.consumed = false;
                            switch ((id_1)) {
                                case java.awt.event.ActionEvent.ACTION_PERFORMED_$LI$():
                                case java.awt.event.ItemEvent.ITEM_STATE_CHANGED_$LI$():
                                case java.awt.event.AdjustmentEvent.ADJUSTMENT_VALUE_CHANGED_$LI$():
                                case java.awt.event.TextEvent.TEXT_VALUE_CHANGED_$LI$():
                                    _this.consumed = true;
                                    break;
                                default:
                            }
                        })();
                    }
                    (function () {
                        _this.consumed = false;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            AWTEvent.prototype.setSource = function (newSource) {
                if (this.source === newSource) {
                    return;
                }
                this.source = newSource;
            };
            /**
             * Returns a String representation of this object.
             */
            AWTEvent.prototype.toString = function () {
                var srcName = null;
                if (this.source != null && this.source instanceof java.awt.Component) {
                    srcName = this.source.getName();
                }
                else if (this.source != null && this.source instanceof java.awt.MenuComponent) {
                    srcName = this.source.getName();
                }
                return (function (c) { return c["__class"] ? c["__class"] : c.name; })(this.constructor) + "[" + this.paramString() + "] on " + (srcName != null ? srcName : this.source);
            };
            AWTEvent.prototype.paramString = function () {
                return "";
            };
            AWTEvent.prototype.consume = function () {
                switch ((this.id)) {
                    case java.awt.event.KeyEvent.KEY_PRESSED_$LI$():
                    case java.awt.event.KeyEvent.KEY_RELEASED_$LI$():
                    case java.awt.event.MouseEvent.MOUSE_PRESSED_$LI$():
                    case java.awt.event.MouseEvent.MOUSE_RELEASED_$LI$():
                    case java.awt.event.MouseEvent.MOUSE_MOVED_$LI$():
                    case java.awt.event.MouseEvent.MOUSE_DRAGGED_$LI$():
                    case java.awt.event.MouseEvent.MOUSE_ENTERED_$LI$():
                    case java.awt.event.MouseEvent.MOUSE_EXITED_$LI$():
                    case java.awt.event.MouseEvent.MOUSE_WHEEL_$LI$():
                        this.consumed = true;
                        break;
                    default:
                }
            };
            AWTEvent.prototype.isConsumed = function () {
                return this.consumed;
            };
            /**
             * Returns the event type.
             */
            AWTEvent.prototype.getID = function () {
                return this.id;
            };
            /**
             * The event mask for selecting component events.
             */
            AWTEvent.COMPONENT_EVENT_MASK = 1;
            /**
             * The event mask for selecting container events.
             */
            AWTEvent.CONTAINER_EVENT_MASK = 2;
            /**
             * The event mask for selecting focus events.
             */
            AWTEvent.FOCUS_EVENT_MASK = 4;
            /**
             * The event mask for selecting key events.
             */
            AWTEvent.KEY_EVENT_MASK = 8;
            /**
             * The event mask for selecting mouse events.
             */
            AWTEvent.MOUSE_EVENT_MASK = 16;
            /**
             * The event mask for selecting mouse motion events.
             */
            AWTEvent.MOUSE_MOTION_EVENT_MASK = 32;
            /**
             * The event mask for selecting window events.
             */
            AWTEvent.WINDOW_EVENT_MASK = 64;
            /**
             * The event mask for selecting action events.
             */
            AWTEvent.ACTION_EVENT_MASK = 128;
            /**
             * The event mask for selecting adjustment events.
             */
            AWTEvent.ADJUSTMENT_EVENT_MASK = 256;
            /**
             * The event mask for selecting item events.
             */
            AWTEvent.ITEM_EVENT_MASK = 512;
            /**
             * The event mask for selecting text events.
             */
            AWTEvent.TEXT_EVENT_MASK = 1024;
            /**
             * The event mask for selecting input method events.
             */
            AWTEvent.INPUT_METHOD_EVENT_MASK = 2048;
            /**
             * The pseudo event mask for enabling input methods. We're using one bit in
             * the eventMask so we don't need a separate field inputMethodsEnabled.
             */
            AWTEvent.INPUT_METHODS_ENABLED_MASK = 4096;
            /**
             * The event mask for selecting paint events.
             */
            AWTEvent.PAINT_EVENT_MASK = 8192;
            /**
             * The event mask for selecting invocation events.
             */
            AWTEvent.INVOCATION_EVENT_MASK = 16384;
            /**
             * The event mask for selecting hierarchy events.
             */
            AWTEvent.HIERARCHY_EVENT_MASK = 32768;
            /**
             * The event mask for selecting hierarchy bounds events.
             */
            AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK = 65536;
            /**
             * The event mask for selecting mouse wheel events.
             *
             * @since 1.4
             */
            AWTEvent.MOUSE_WHEEL_EVENT_MASK = 131072;
            /**
             * The event mask for selecting window state events.
             *
             * @since 1.4
             */
            AWTEvent.WINDOW_STATE_EVENT_MASK = 262144;
            /**
             * The event mask for selecting window focus events.
             *
             * @since 1.4
             */
            AWTEvent.WINDOW_FOCUS_EVENT_MASK = 524288;
            /**
             * The maximum value for reserved AWT event IDs. Programs defining their own
             * event IDs should use IDs greater than this value.
             */
            AWTEvent.RESERVED_ID_MAX = 1999;
            return AWTEvent;
        }(java.util.EventObject));
        awt.AWTEvent = AWTEvent;
        AWTEvent["__class"] = "java.awt.AWTEvent";
        AWTEvent["__interfaces"] = ["java.io.Serializable"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var BasicStroke = (function () {
            function BasicStroke(width, cap, join, miterlimit, dash, dash_phase) {
                if (width === void 0) { width = 1.0; }
                if (cap === void 0) { cap = BasicStroke.CAP_SQUARE; }
                if (join === void 0) { join = BasicStroke.JOIN_MITER; }
                if (miterlimit === void 0) { miterlimit = 10.0; }
                if (dash === void 0) { dash = null; }
                if (dash_phase === void 0) { dash_phase = 0.0; }
                this.width = 0;
                this.join = 0;
                this.cap = 0;
                this.miterlimit = 0;
                this.dash_phase = 0;
                if (width < 0.0) {
                    throw new java.lang.IllegalArgumentException("negative width");
                }
                if (cap !== BasicStroke.CAP_BUTT && cap !== BasicStroke.CAP_ROUND && cap !== BasicStroke.CAP_SQUARE) {
                    throw new java.lang.IllegalArgumentException("illegal end cap value");
                }
                if (join === BasicStroke.JOIN_MITER) {
                    if (miterlimit < 1.0) {
                        throw new java.lang.IllegalArgumentException("miter limit < 1");
                    }
                }
                else if (join !== BasicStroke.JOIN_ROUND && join !== BasicStroke.JOIN_BEVEL) {
                    throw new java.lang.IllegalArgumentException("illegal line join value");
                }
                if (dash != null) {
                    if (dash_phase < 0.0) {
                        throw new java.lang.IllegalArgumentException("negative dash phase");
                    }
                    var allzero = true;
                    for (var i = 0; i < dash.length; i++) {
                        var d = dash[i];
                        if (d > 0.0) {
                            allzero = false;
                        }
                        else if (d < 0.0) {
                            throw new java.lang.IllegalArgumentException("negative dash length");
                        }
                    }
                    if (allzero) {
                        throw new java.lang.IllegalArgumentException("dash lengths all zero");
                    }
                }
                this.width = width;
                this.cap = cap;
                this.join = join;
                this.miterlimit = miterlimit;
                if (dash != null) {
                    this.dash = (dash).splice(0, dash.length);
                }
                this.dash_phase = dash_phase;
            }
            BasicStroke.prototype.createStrokedShape = function (s) {
                return null;
            };
            BasicStroke.prototype.getLineWidth = function () {
                return this.width;
            };
            BasicStroke.prototype.getEndCap = function () {
                return this.cap;
            };
            BasicStroke.prototype.getLineJoin = function () {
                return this.join;
            };
            BasicStroke.prototype.getMiterLimit = function () {
                return this.miterlimit;
            };
            BasicStroke.prototype.getDashArray = function () {
                if (this.dash == null) {
                    return null;
                }
                return (this.dash).splice(0, this.dash.length);
            };
            BasicStroke.prototype.getDashPhase = function () {
                return this.dash_phase;
            };
            BasicStroke.prototype.hashCode = function () {
                var hash = javaemul.internal.FloatHelper.floatToIntBits(this.width);
                hash = hash * 31 + this.join;
                hash = hash * 31 + this.cap;
                hash = hash * 31 + javaemul.internal.FloatHelper.floatToIntBits(this.miterlimit);
                if (this.dash != null) {
                    hash = hash * 31 + javaemul.internal.FloatHelper.floatToIntBits(this.dash_phase);
                    for (var i = 0; i < this.dash.length; i++) {
                        hash = hash * 31 + javaemul.internal.FloatHelper.floatToIntBits(this.dash[i]);
                    }
                }
                return hash;
            };
            BasicStroke.prototype.equals = function (obj) {
                if (!(obj != null && obj instanceof java.awt.BasicStroke)) {
                    return false;
                }
                var bs = obj;
                if (this.width !== bs.width) {
                    return false;
                }
                if (this.join !== bs.join) {
                    return false;
                }
                if (this.cap !== bs.cap) {
                    return false;
                }
                if (this.miterlimit !== bs.miterlimit) {
                    return false;
                }
                if (this.dash != null) {
                    if (this.dash_phase !== bs.dash_phase) {
                        return false;
                    }
                    if (!java.util.Arrays.equals(this.dash, bs.dash)) {
                        return false;
                    }
                }
                else if (bs.dash != null) {
                    return false;
                }
                return true;
            };
            BasicStroke.JOIN_MITER = 0;
            BasicStroke.JOIN_ROUND = 1;
            BasicStroke.JOIN_BEVEL = 2;
            BasicStroke.CAP_BUTT = 0;
            BasicStroke.CAP_ROUND = 1;
            BasicStroke.CAP_SQUARE = 2;
            return BasicStroke;
        }());
        awt.BasicStroke = BasicStroke;
        BasicStroke["__class"] = "java.awt.BasicStroke";
        BasicStroke["__interfaces"] = ["java.awt.Stroke"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var BorderLayout = (function () {
            /**
             * Constructs a border layout with the specified gaps between components.
             * The horizontal gap is specified by <code>hgap</code> and the vertical gap
             * is specified by <code>vgap</code>.
             *
             * @param hgap
             * the horizontal gap.
             * @param vgap
             * the vertical gap.
             */
            function BorderLayout(hgap, vgap) {
                if (hgap === void 0) { hgap = 0; }
                if (vgap === void 0) { vgap = 0; }
                this.created = false;
                this.hgap = 0;
                this.vgap = 0;
                this.hgap = hgap;
                this.vgap = vgap;
            }
            BorderLayout.prototype.onComponentAdded = function (parent, component, position) {
            };
            BorderLayout.PAGE_START_$LI$ = function () { if (BorderLayout.PAGE_START == null)
                BorderLayout.PAGE_START = BorderLayout.BEFORE_FIRST_LINE; return BorderLayout.PAGE_START; };
            ;
            BorderLayout.PAGE_END_$LI$ = function () { if (BorderLayout.PAGE_END == null)
                BorderLayout.PAGE_END = BorderLayout.AFTER_LAST_LINE; return BorderLayout.PAGE_END; };
            ;
            BorderLayout.LINE_START_$LI$ = function () { if (BorderLayout.LINE_START == null)
                BorderLayout.LINE_START = BorderLayout.BEFORE_LINE_BEGINS; return BorderLayout.LINE_START; };
            ;
            BorderLayout.LINE_END_$LI$ = function () { if (BorderLayout.LINE_END == null)
                BorderLayout.LINE_END = BorderLayout.AFTER_LINE_ENDS; return BorderLayout.LINE_END; };
            ;
            /**
             * Returns the horizontal gap between components.
             *
             * @since JDK1.1
             */
            BorderLayout.prototype.getHgap = function () {
                return this.hgap;
            };
            /**
             * Sets the horizontal gap between components.
             *
             * @param hgap
             * the horizontal gap between components
             * @since JDK1.1
             */
            BorderLayout.prototype.setHgap = function (hgap) {
                this.hgap = hgap;
            };
            /**
             * Returns the vertical gap between components.
             *
             * @since JDK1.1
             */
            BorderLayout.prototype.getVgap = function () {
                return this.vgap;
            };
            /**
             * Sets the vertical gap between components.
             *
             * @param vgap
             * the vertical gap between components
             * @since JDK1.1
             */
            BorderLayout.prototype.setVgap = function (vgap) {
                this.vgap = vgap;
            };
            /**
             * Adds the specified component to the layout, using the specified
             * constraint object. For border layouts, the constraint must be one of the
             * following constants: <code>NORTH</code>, <code>SOUTH</code>,
             * <code>EAST</code>, <code>WEST</code>, or <code>CENTER</code>.
             * <p>
             * Most applications do not call this method directly. This method is called
             * when a component is added to a container using the
             * <code>Container.add</code> method with the same argument types.
             *
             * @param comp
             * the component to be added.
             * @param constraints
             * an object that specifies how and where the component is added
             * to the layout.
             * @see java.awt.Container#add(java.awt.Component, java.lang.Object)
             * @exception IllegalArgumentException
             * if the constraint object is not a string, or if it not one
             * of the five specified constants.
             * @since JDK1.1
             */
            BorderLayout.prototype.addLayoutComponent$java_awt_Component$java_lang_Object = function (comp, constraints) {
                if ((constraints == null) || (typeof constraints === 'string')) {
                    this.addLayoutComponent(constraints, comp);
                }
                else {
                    throw new java.lang.IllegalArgumentException("cannot add to layout: constraint must be a string (or null)");
                }
            };
            /**
             * @deprecated replaced by
             * <code>addLayoutComponent(Component, Object)</code>.
             */
            BorderLayout.prototype.addLayoutComponent = function (name, comp) {
                var _this = this;
                if (((typeof name === 'string') || name === null) && ((comp != null && comp instanceof java.awt.Component) || comp === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        if (name == null) {
                            name = "Center";
                        }
                        var pos = 4;
                        if (("Center" === name)) {
                            _this.center = comp;
                            pos = 4;
                        }
                        else if (("North" === name)) {
                            _this.north = comp;
                            pos = 2;
                        }
                        else if (("South" === name)) {
                            _this.south = comp;
                            pos = 7;
                        }
                        else if (("East" === name)) {
                            _this.east = comp;
                            pos = 5;
                        }
                        else if (("West" === name)) {
                            _this.west = comp;
                            pos = 3;
                        }
                        else if ((BorderLayout.BEFORE_FIRST_LINE === name)) {
                            _this.firstLine = comp;
                        }
                        else if ((BorderLayout.AFTER_LAST_LINE === name)) {
                            _this.lastLine = comp;
                        }
                        else if ((BorderLayout.BEFORE_LINE_BEGINS === name)) {
                            _this.firstItem = comp;
                        }
                        else if ((BorderLayout.AFTER_LINE_ENDS === name)) {
                            _this.lastItem = comp;
                        }
                        else {
                            throw new java.lang.IllegalArgumentException("cannot add to layout: unknown constraint: " + name);
                        }
                        _this.add(comp, pos);
                    })();
                }
                else if (((name != null && name instanceof java.awt.Component) || name === null) && ((comp != null) || comp === null)) {
                    return this.addLayoutComponent$java_awt_Component$java_lang_Object(name, comp);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Removes the specified component from this border layout. This method is
             * called when a container calls its <code>remove</code> or
             * <code>removeAll</code> methods. Most applications do not call this method
             * directly.
             *
             * @param comp
             * the component to be removed.
             * @see java.awt.Container#remove(java.awt.Component)
             * @see java.awt.Container#removeAll()
             */
            BorderLayout.prototype.removeLayoutComponent = function (comp) {
                if (comp === this.center) {
                    this.center = null;
                }
                else if (comp === this.north) {
                    this.north = null;
                }
                else if (comp === this.south) {
                    this.south = null;
                }
                else if (comp === this.east) {
                    this.east = null;
                }
                else if (comp === this.west) {
                    this.west = null;
                }
                if (comp === this.firstLine) {
                    this.firstLine = null;
                }
                else if (comp === this.lastLine) {
                    this.lastLine = null;
                }
                else if (comp === this.firstItem) {
                    this.firstItem = null;
                }
                else if (comp === this.lastItem) {
                    this.lastItem = null;
                }
            };
            BorderLayout.prototype.getLayoutComponent$java_lang_Object = function (constraints) {
                if ((BorderLayout.CENTER === constraints)) {
                    return this.center;
                }
                else if ((BorderLayout.NORTH === constraints)) {
                    return this.north;
                }
                else if ((BorderLayout.SOUTH === constraints)) {
                    return this.south;
                }
                else if ((BorderLayout.WEST === constraints)) {
                    return this.west;
                }
                else if ((BorderLayout.EAST === constraints)) {
                    return this.east;
                }
                else if ((BorderLayout.PAGE_START_$LI$() === constraints)) {
                    return this.firstLine;
                }
                else if ((BorderLayout.PAGE_END_$LI$() === constraints)) {
                    return this.lastLine;
                }
                else if ((BorderLayout.LINE_START_$LI$() === constraints)) {
                    return this.firstItem;
                }
                else if ((BorderLayout.LINE_END_$LI$() === constraints)) {
                    return this.lastItem;
                }
                else {
                    throw new java.lang.IllegalArgumentException("cannot get component: unknown constraint: " + constraints);
                }
            };
            BorderLayout.prototype.getLayoutComponent = function (target, constraints) {
                var _this = this;
                if (((target != null && target instanceof java.awt.Container) || target === null) && ((constraints != null) || constraints === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        var ltr = true;
                        var result = null;
                        if ((BorderLayout.NORTH === constraints)) {
                            result = (_this.firstLine != null) ? _this.firstLine : _this.north;
                        }
                        else if ((BorderLayout.SOUTH === constraints)) {
                            result = (_this.lastLine != null) ? _this.lastLine : _this.south;
                        }
                        else if ((BorderLayout.WEST === constraints)) {
                            result = ltr ? _this.firstItem : _this.lastItem;
                            if (result == null) {
                                result = _this.west;
                            }
                        }
                        else if ((BorderLayout.EAST === constraints)) {
                            result = ltr ? _this.lastItem : _this.firstItem;
                            if (result == null) {
                                result = _this.east;
                            }
                        }
                        else if ((BorderLayout.CENTER === constraints)) {
                            result = _this.center;
                        }
                        else {
                            throw new java.lang.IllegalArgumentException("cannot get component: invalid constraint: " + constraints);
                        }
                        return result;
                    })();
                }
                else if (((target != null) || target === null) && constraints === undefined) {
                    return this.getLayoutComponent$java_lang_Object(target);
                }
                else
                    throw new Error('invalid overload');
            };
            BorderLayout.prototype.getConstraints = function (comp) {
                if (comp == null) {
                    return null;
                }
                if (comp === this.center) {
                    return BorderLayout.CENTER;
                }
                else if (comp === this.north) {
                    return BorderLayout.NORTH;
                }
                else if (comp === this.south) {
                    return BorderLayout.SOUTH;
                }
                else if (comp === this.west) {
                    return BorderLayout.WEST;
                }
                else if (comp === this.east) {
                    return BorderLayout.EAST;
                }
                else if (comp === this.firstLine) {
                    return BorderLayout.PAGE_START_$LI$();
                }
                else if (comp === this.lastLine) {
                    return BorderLayout.PAGE_END_$LI$();
                }
                else if (comp === this.firstItem) {
                    return BorderLayout.LINE_START_$LI$();
                }
                else if (comp === this.lastItem) {
                    return BorderLayout.LINE_END_$LI$();
                }
                return null;
            };
            BorderLayout.prototype.maximumLayoutSize = function (target) {
                return new java.awt.Dimension(javaemul.internal.IntegerHelper.MAX_VALUE, javaemul.internal.IntegerHelper.MAX_VALUE);
            };
            BorderLayout.prototype.getLayoutAlignmentX = function (parent) {
                return 0.5;
            };
            BorderLayout.prototype.getLayoutAlignmentY = function (parent) {
                return 0.5;
            };
            BorderLayout.prototype.invalidateLayout = function (target) {
            };
            BorderLayout.prototype.layoutContainer = function (parent) {
                if (!this.created) {
                    this.parent = parent;
                    this.created = true;
                    var div = parent.getHTMLElement();
                    this.table = document.createElement("table");
                    this.table.style.width = "100%";
                    this.table.style.height = "100%";
                    this.table.style.left = "0px";
                    this.table.style.right = "0px";
                    this.table.style.zIndex = "0";
                    for (var j = 0; j < 3; j++) {
                        var row = document.createElement("tr");
                        this.table.appendChild(row);
                        if (j === 0 || j === 2) {
                            row.style.height = "0%";
                        }
                        for (var i = 0; i < 3; i++) {
                            var col = document.createElement("td");
                            row.appendChild(col);
                            if (i === 0 || i === 2) {
                                col.style.width = "0%";
                            }
                        }
                    }
                    div.appendChild(this.table);
                }
            };
            BorderLayout.prototype.add = function (component, position) {
                var pos = 0;
                for (var j = 0; j < 3; j++) {
                    var row = this.table.childNodes[j];
                    for (var i = 0; i < 3; i++) {
                        var col = row.childNodes[i];
                        if (pos++ === position) {
                            col.appendChild(component.getHTMLElement());
                            component.getHTMLElement().style.width = "100%";
                            component.getHTMLElement().style.height = "100%";
                            return;
                        }
                    }
                }
            };
            /**
             * Returns a string representation of the state of this border layout.
             *
             * @return a string representation of this border layout.
             */
            BorderLayout.prototype.toString = function () {
                return (function (c) { return c["__class"] ? c["__class"] : c.name; })(this.constructor) + "[hgap=" + this.hgap + ",vgap=" + this.vgap + "]";
            };
            /**
             * The north layout constraint (top of container).
             */
            BorderLayout.NORTH = "North";
            /**
             * The south layout constraint (bottom of container).
             */
            BorderLayout.SOUTH = "South";
            /**
             * The east layout constraint (right side of container).
             */
            BorderLayout.EAST = "East";
            /**
             * The west layout constraint (left side of container).
             */
            BorderLayout.WEST = "West";
            /**
             * The center layout constraint (middle of container).
             */
            BorderLayout.CENTER = "Center";
            /**
             * Synonym for PAGE_START. Exists for compatibility with previous versions.
             * PAGE_START is preferred.
             *
             * @see #PAGE_START
             * @since 1.2
             */
            BorderLayout.BEFORE_FIRST_LINE = "First";
            /**
             * Synonym for PAGE_END. Exists for compatibility with previous versions.
             * PAGE_END is preferred.
             *
             * @see #PAGE_END
             * @since 1.2
             */
            BorderLayout.AFTER_LAST_LINE = "Last";
            /**
             * Synonym for LINE_START. Exists for compatibility with previous versions.
             * LINE_START is preferred.
             *
             * @see #LINE_START
             * @since 1.2
             */
            BorderLayout.BEFORE_LINE_BEGINS = "Before";
            /**
             * Synonym for LINE_END. Exists for compatibility with previous versions.
             * LINE_END is preferred.
             *
             * @see #LINE_END
             * @since 1.2
             */
            BorderLayout.AFTER_LINE_ENDS = "After";
            BorderLayout.serialVersionUID = -8658291919501921765;
            return BorderLayout;
        }());
        awt.BorderLayout = BorderLayout;
        BorderLayout["__class"] = "java.awt.BorderLayout";
        BorderLayout["__interfaces"] = ["java.awt.LayoutManager2", "java.awt.LayoutManager", "java.io.Serializable"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var CheckboxGroup = (function () {
            function CheckboxGroup() {
                this.selectedCheckbox = null;
            }
            CheckboxGroup.prototype.getSelectedCheckbox = function () {
                return this.getCurrent();
            };
            CheckboxGroup.prototype.getCurrent = function () {
                return this.selectedCheckbox;
            };
            CheckboxGroup.prototype.setSelectedCheckbox = function (box) {
                this.setCurrent(box);
            };
            CheckboxGroup.prototype.setCurrent = function (box) {
                if (box != null && box.group !== this) {
                    return;
                }
                var oldChoice = this.selectedCheckbox;
                this.selectedCheckbox = box;
                if (oldChoice != null && oldChoice !== box && oldChoice.group === this) {
                    oldChoice.setState(false);
                }
                if (box != null && oldChoice !== box && !box.getState()) {
                    box.setStateInternal(true);
                }
            };
            CheckboxGroup.prototype.toString = function () {
                return (function (c) { return c["__class"] ? c["__class"] : c.name; })(this.constructor) + "[selectedCheckbox=" + this.selectedCheckbox + "]";
            };
            CheckboxGroup.serialVersionUID = 3729780091441768983;
            return CheckboxGroup;
        }());
        awt.CheckboxGroup = CheckboxGroup;
        CheckboxGroup["__class"] = "java.awt.CheckboxGroup";
        CheckboxGroup["__interfaces"] = ["java.io.Serializable"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var Color = (function () {
            /**
             * Creates an sRGB color with the specified red, green, blue, and alpha
             * values in the range (0 - 255).
             *
             * @throws IllegalArgumentException
             * if <code>r</code>, <code>g</code>, <code>b</code> or
             * <code>a</code> are outside of the range 0 to 255, inclusive
             * @param r
             * the red component
             * @param g
             * the green component
             * @param b
             * the blue component
             * @param a
             * the alpha component
             * @see #getRed
             * @see #getGreen
             * @see #getBlue
             * @see #getAlpha
             * @see #getRGB
             */
            function Color(r, g, b, a) {
                var _this = this;
                /**
                 * The color value in the default sRGB <code>ColorSpace</code> as
                 * <code>float</code> components (no alpha). If <code>null</code> after
                 * object construction, this must be an sRGB color constructed with 8-bit
                 * precision, so compute from the <code>int</code> color value.
                 *
                 * @serial
                 * @see #getRGBColorComponents
                 * @see #getRGBComponents
                 */
                this.frgbvalue = null;
                /**
                 * The color value in the native <code>ColorSpace</code> as
                 * <code>float</code> components (no alpha). If <code>null</code> after
                 * object construction, this must be an sRGB color constructed with 8-bit
                 * precision, so compute from the <code>int</code> color value.
                 *
                 * @serial
                 * @see #getRGBColorComponents
                 * @see #getRGBComponents
                 */
                this.fvalue = null;
                /**
                 * The alpha value as a <code>float</code> component. If
                 * <code>frgbvalue</code> is <code>null</code>, this is not valid data, so
                 * compute from the <code>int</code> color value.
                 *
                 * @serial
                 * @see #getRGBComponents
                 * @see #getComponents
                 */
                this.falpha = 0.0;
                if (((typeof r === 'number') || r === null) && ((typeof g === 'number') || g === null) && ((typeof b === 'number') || b === null) && ((typeof a === 'number') || a === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    this.frgbvalue = null;
                    this.fvalue = null;
                    this.falpha = 0.0;
                    this.value = 0;
                    (function () {
                        _this.value = ((a & 255) << 24) | ((r & 255) << 16) | ((g & 255) << 8) | ((b & 255) << 0);
                        Color.testColorValueRange(r, g, b, a);
                    })();
                }
                else if (((typeof r === 'number') || r === null) && ((typeof g === 'number') || g === null) && ((typeof b === 'number') || b === null) && ((typeof a === 'number') || a === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_2 = Array.prototype.slice.call(arguments);
                        var r_1 = ((__args_2[0] * 255 + 0.5) | 0);
                        var g_1 = ((__args_2[1] * 255 + 0.5) | 0);
                        var b_1 = ((__args_2[2] * 255 + 0.5) | 0);
                        var a_1 = ((__args_2[3] * 255 + 0.5) | 0);
                        this.frgbvalue = null;
                        this.fvalue = null;
                        this.falpha = 0.0;
                        this.value = 0;
                        (function () {
                            _this.value = ((a_1 & 255) << 24) | ((r_1 & 255) << 16) | ((g_1 & 255) << 8) | ((b_1 & 255) << 0);
                            Color.testColorValueRange(r_1, g_1, b_1, a_1);
                        })();
                    }
                    (function () {
                        _this.frgbvalue = new Array(3);
                        _this.frgbvalue[0] = r;
                        _this.frgbvalue[1] = g;
                        _this.frgbvalue[2] = b;
                        _this.falpha = a;
                        _this.fvalue = _this.frgbvalue;
                    })();
                }
                else if (((typeof r === 'number') || r === null) && ((typeof g === 'number') || g === null) && ((typeof b === 'number') || b === null) && a === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_3 = Array.prototype.slice.call(arguments);
                        var a_2 = 255;
                        this.frgbvalue = null;
                        this.fvalue = null;
                        this.falpha = 0.0;
                        this.value = 0;
                        (function () {
                            _this.value = ((a_2 & 255) << 24) | ((r & 255) << 16) | ((g & 255) << 8) | ((b & 255) << 0);
                            Color.testColorValueRange(r, g, b, a_2);
                        })();
                    }
                }
                else if (((typeof r === 'number') || r === null) && ((typeof g === 'number') || g === null) && ((typeof b === 'number') || b === null) && a === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_4 = Array.prototype.slice.call(arguments);
                        var r_2 = ((__args_4[0] * 255 + 0.5) | 0);
                        var g_2 = ((__args_4[1] * 255 + 0.5) | 0);
                        var b_2 = ((__args_4[2] * 255 + 0.5) | 0);
                        {
                            var __args_5 = Array.prototype.slice.call(arguments);
                            var a_4 = 255;
                            this.frgbvalue = null;
                            this.fvalue = null;
                            this.falpha = 0.0;
                            this.value = 0;
                            (function () {
                                _this.value = ((a_4 & 255) << 24) | ((r_2 & 255) << 16) | ((g_2 & 255) << 8) | ((b_2 & 255) << 0);
                                Color.testColorValueRange(r_2, g_2, b_2, a_4);
                            })();
                        }
                    }
                    (function () {
                        Color.testColorValueRange(r, g, b, 1.0);
                        _this.frgbvalue = new Array(3);
                        _this.frgbvalue[0] = r;
                        _this.frgbvalue[1] = g;
                        _this.frgbvalue[2] = b;
                        _this.falpha = 1.0;
                        _this.fvalue = _this.frgbvalue;
                    })();
                }
                else if (((typeof r === 'number') || r === null) && ((typeof g === 'boolean') || g === null) && b === undefined && a === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var rgba_1 = __args[0];
                    var hasalpha_1 = __args[1];
                    this.frgbvalue = null;
                    this.fvalue = null;
                    this.falpha = 0.0;
                    this.value = 0;
                    (function () {
                        if (hasalpha_1) {
                            _this.value = rgba_1;
                        }
                        else {
                            _this.value = -16777216 | rgba_1;
                        }
                    })();
                }
                else if (((typeof r === 'number') || r === null) && g === undefined && b === undefined && a === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var rgb_1 = __args[0];
                    this.frgbvalue = null;
                    this.fvalue = null;
                    this.falpha = 0.0;
                    this.value = 0;
                    (function () {
                        _this.value = -16777216 | rgb_1;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            Color.white_$LI$ = function () { if (Color.white == null)
                Color.white = new Color(255, 255, 255); return Color.white; };
            ;
            Color.WHITE_$LI$ = function () { if (Color.WHITE == null)
                Color.WHITE = Color.white_$LI$(); return Color.WHITE; };
            ;
            Color.lightGray_$LI$ = function () { if (Color.lightGray == null)
                Color.lightGray = new Color(192, 192, 192); return Color.lightGray; };
            ;
            Color.LIGHT_GRAY_$LI$ = function () { if (Color.LIGHT_GRAY == null)
                Color.LIGHT_GRAY = Color.lightGray_$LI$(); return Color.LIGHT_GRAY; };
            ;
            Color.gray_$LI$ = function () { if (Color.gray == null)
                Color.gray = new Color(128, 128, 128); return Color.gray; };
            ;
            Color.GRAY_$LI$ = function () { if (Color.GRAY == null)
                Color.GRAY = Color.gray_$LI$(); return Color.GRAY; };
            ;
            Color.darkGray_$LI$ = function () { if (Color.darkGray == null)
                Color.darkGray = new Color(64, 64, 64); return Color.darkGray; };
            ;
            Color.DARK_GRAY_$LI$ = function () { if (Color.DARK_GRAY == null)
                Color.DARK_GRAY = Color.darkGray_$LI$(); return Color.DARK_GRAY; };
            ;
            Color.black_$LI$ = function () { if (Color.black == null)
                Color.black = new Color(0, 0, 0); return Color.black; };
            ;
            Color.BLACK_$LI$ = function () { if (Color.BLACK == null)
                Color.BLACK = Color.black_$LI$(); return Color.BLACK; };
            ;
            Color.red_$LI$ = function () { if (Color.red == null)
                Color.red = new Color(255, 0, 0); return Color.red; };
            ;
            Color.RED_$LI$ = function () { if (Color.RED == null)
                Color.RED = Color.red_$LI$(); return Color.RED; };
            ;
            Color.pink_$LI$ = function () { if (Color.pink == null)
                Color.pink = new Color(255, 175, 175); return Color.pink; };
            ;
            Color.PINK_$LI$ = function () { if (Color.PINK == null)
                Color.PINK = Color.pink_$LI$(); return Color.PINK; };
            ;
            Color.orange_$LI$ = function () { if (Color.orange == null)
                Color.orange = new Color(255, 200, 0); return Color.orange; };
            ;
            Color.ORANGE_$LI$ = function () { if (Color.ORANGE == null)
                Color.ORANGE = Color.orange_$LI$(); return Color.ORANGE; };
            ;
            Color.yellow_$LI$ = function () { if (Color.yellow == null)
                Color.yellow = new Color(255, 255, 0); return Color.yellow; };
            ;
            Color.YELLOW_$LI$ = function () { if (Color.YELLOW == null)
                Color.YELLOW = Color.yellow_$LI$(); return Color.YELLOW; };
            ;
            Color.green_$LI$ = function () { if (Color.green == null)
                Color.green = new Color(0, 255, 0); return Color.green; };
            ;
            Color.GREEN_$LI$ = function () { if (Color.GREEN == null)
                Color.GREEN = Color.green_$LI$(); return Color.GREEN; };
            ;
            Color.magenta_$LI$ = function () { if (Color.magenta == null)
                Color.magenta = new Color(255, 0, 255); return Color.magenta; };
            ;
            Color.MAGENTA_$LI$ = function () { if (Color.MAGENTA == null)
                Color.MAGENTA = Color.magenta_$LI$(); return Color.MAGENTA; };
            ;
            Color.cyan_$LI$ = function () { if (Color.cyan == null)
                Color.cyan = new Color(0, 255, 255); return Color.cyan; };
            ;
            Color.CYAN_$LI$ = function () { if (Color.CYAN == null)
                Color.CYAN = Color.cyan_$LI$(); return Color.CYAN; };
            ;
            Color.blue_$LI$ = function () { if (Color.blue == null)
                Color.blue = new Color(0, 0, 255); return Color.blue; };
            ;
            Color.BLUE_$LI$ = function () { if (Color.BLUE == null)
                Color.BLUE = Color.blue_$LI$(); return Color.BLUE; };
            ;
            /**
             * Checks the color integer components supplied for validity. Throws an
             * {@link IllegalArgumentException} if the value is out of range.
             *
             * @param r
             * the Red component
             * @param g
             * the Green component
             * @param b
             * the Blue component
             */
            Color.testColorValueRange = function (r, g, b, a) {
                if (((typeof r === 'number') || r === null) && ((typeof g === 'number') || g === null) && ((typeof b === 'number') || b === null) && ((typeof a === 'number') || a === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        var rangeError = false;
                        var badComponentString = "";
                        if (a < 0 || a > 255) {
                            rangeError = true;
                            badComponentString = badComponentString + " Alpha";
                        }
                        if (r < 0 || r > 255) {
                            rangeError = true;
                            badComponentString = badComponentString + " Red";
                        }
                        if (g < 0 || g > 255) {
                            rangeError = true;
                            badComponentString = badComponentString + " Green";
                        }
                        if (b < 0 || b > 255) {
                            rangeError = true;
                            badComponentString = badComponentString + " Blue";
                        }
                        if (rangeError === true) {
                            throw new java.lang.IllegalArgumentException("Color parameter outside of expected range:" + badComponentString);
                        }
                    })();
                }
                else if (((typeof r === 'number') || r === null) && ((typeof g === 'number') || g === null) && ((typeof b === 'number') || b === null) && ((typeof a === 'number') || a === null)) {
                    return java.awt.Color.testColorValueRange$float$float$float$float(r, g, b, a);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Checks the color <code>float</code> components supplied for validity.
             * Throws an <code>IllegalArgumentException</code> if the value is out of
             * range.
             *
             * @param r
             * the Red component
             * @param g
             * the Green component
             * @param b
             * the Blue component
             */
            Color.testColorValueRange$float$float$float$float = function (r, g, b, a) {
                var rangeError = false;
                var badComponentString = "";
                if (a < 0.0 || a > 1.0) {
                    rangeError = true;
                    badComponentString = badComponentString + " Alpha";
                }
                if (r < 0.0 || r > 1.0) {
                    rangeError = true;
                    badComponentString = badComponentString + " Red";
                }
                if (g < 0.0 || g > 1.0) {
                    rangeError = true;
                    badComponentString = badComponentString + " Green";
                }
                if (b < 0.0 || b > 1.0) {
                    rangeError = true;
                    badComponentString = badComponentString + " Blue";
                }
                if (rangeError === true) {
                    throw new java.lang.IllegalArgumentException("Color parameter outside of expected range:" + badComponentString);
                }
            };
            /**
             * Returns the red component in the range 0-255 in the default sRGB space.
             *
             * @return the red component.
             * @see #getRGB
             */
            Color.prototype.getRed = function () {
                return (this.getRGB() >> 16) & 255;
            };
            /**
             * Returns the green component in the range 0-255 in the default sRGB space.
             *
             * @return the green component.
             * @see #getRGB
             */
            Color.prototype.getGreen = function () {
                return (this.getRGB() >> 8) & 255;
            };
            /**
             * Returns the blue component in the range 0-255 in the default sRGB space.
             *
             * @return the blue component.
             * @see #getRGB
             */
            Color.prototype.getBlue = function () {
                return (this.getRGB() >> 0) & 255;
            };
            /**
             * Returns the alpha component in the range 0-255.
             *
             * @return the alpha component.
             * @see #getRGB
             */
            Color.prototype.getAlpha = function () {
                return (this.getRGB() >> 24) & 255;
            };
            /**
             * Returns the RGB value representing the color in the default sRGB. (Bits
             * 24-31 are alpha, 16-23 are red, 8-15 are green, 0-7 are blue).
             *
             * @return the RGB value of the color in the default sRGB
             * <code>ColorModel</code>.
             * @see java.awt.image.ColorModel#getRGBdefault
             * @see #getRed
             * @see #getGreen
             * @see #getBlue
             * @since JDK1.0
             */
            Color.prototype.getRGB = function () {
                return this.value;
            };
            /**
             * Creates a new <code>Color</code> that is a brighter version of this
             * <code>Color</code>.
             * <p>
             * This method applies an arbitrary scale factor to each of the three RGB
             * components of this <code>Color</code> to create a brighter version of
             * this <code>Color</code>. The {@code alpha} value is preserved. Although
             * <code>brighter</code> and <code>darker</code> are inverse operations, the
             * results of a series of invocations of these two methods might be
             * inconsistent because of rounding errors.
             *
             * @return a new <code>Color</code> object that is a brighter version of
             * this <code>Color</code> with the same {@code alpha} value.
             * @see java.awt.Color#darker
             * @since JDK1.0
             */
            Color.prototype.brighter = function () {
                var r = this.getRed();
                var g = this.getGreen();
                var b = this.getBlue();
                var alpha = this.getAlpha();
                var i = ((1.0 / (1.0 - Color.FACTOR)) | 0);
                if (r === 0 && g === 0 && b === 0) {
                    return new Color(i, i, i, alpha);
                }
                if (r > 0 && r < i)
                    r = i;
                if (g > 0 && g < i)
                    g = i;
                if (b > 0 && b < i)
                    b = i;
                return new Color(Math.min(((r / Color.FACTOR) | 0), 255), Math.min(((g / Color.FACTOR) | 0), 255), Math.min(((b / Color.FACTOR) | 0), 255), alpha);
            };
            /**
             * Creates a new <code>Color</code> that is a darker version of this
             * <code>Color</code>.
             * <p>
             * This method applies an arbitrary scale factor to each of the three RGB
             * components of this <code>Color</code> to create a darker version of this
             * <code>Color</code>. The {@code alpha} value is preserved. Although
             * <code>brighter</code> and <code>darker</code> are inverse operations, the
             * results of a series of invocations of these two methods might be
             * inconsistent because of rounding errors.
             *
             * @return a new <code>Color</code> object that is a darker version of this
             * <code>Color</code> with the same {@code alpha} value.
             * @see java.awt.Color#brighter
             * @since JDK1.0
             */
            Color.prototype.darker = function () {
                return new Color(Math.max(((this.getRed() * Color.FACTOR) | 0), 0), Math.max(((this.getGreen() * Color.FACTOR) | 0), 0), Math.max(((this.getBlue() * Color.FACTOR) | 0), 0), this.getAlpha());
            };
            /**
             * Computes the hash code for this <code>Color</code>.
             *
             * @return a hash code value for this object.
             * @since JDK1.0
             */
            Color.prototype.hashCode = function () {
                return this.value;
            };
            /**
             * Determines whether another object is equal to this <code>Color</code>.
             * <p>
             * The result is <code>true</code> if and only if the argument is not
             * <code>null</code> and is a <code>Color</code> object that has the same
             * red, green, blue, and alpha values as this object.
             *
             * @param obj
             * the object to test for equality with this <code>Color</code>
             * @return <code>true</code> if the objects are the same; <code>false</code>
             * otherwise.
             * @since JDK1.0
             */
            Color.prototype.equals = function (obj) {
                return (obj != null && obj instanceof java.awt.Color) && obj.getRGB() === this.getRGB();
            };
            /**
             * Returns a string representation of this <code>Color</code>. This method
             * is intended to be used only for debugging purposes. The content and
             * format of the returned string might vary between implementations. The
             * returned string might be empty but cannot be <code>null</code>.
             *
             * @return a string representation of this <code>Color</code>.
             */
            Color.prototype.toString = function () {
                return (function (c) { return c["__class"] ? c["__class"] : c.name; })(this.constructor) + "[r=" + this.getRed() + ",g=" + this.getGreen() + ",b=" + this.getBlue() + "]";
            };
            /**
             * Converts a <code>String</code> to an integer and returns the specified
             * opaque <code>Color</code>. This method handles string formats that are
             * used to represent octal and hexadecimal numbers.
             *
             * @param nm
             * a <code>String</code> that represents an opaque color as a
             * 24-bit integer
             * @return the new <code>Color</code> object.
             * @see java.lang.Integer#decode
             * @exception NumberFormatException
             * if the specified string cannot be interpreted as a
             * decimal, octal, or hexadecimal integer.
             * @since JDK1.1
             */
            Color.decode = function (nm) {
                var intval = javaemul.internal.IntegerHelper.decode(nm);
                var i = (intval | 0);
                return new Color((i >> 16) & 255, (i >> 8) & 255, i & 255);
            };
            /**
             * Finds a color in the system properties.
             * <p>
             * The argument is treated as the name of a system property to be obtained.
             * The string value of this property is then interpreted as an integer which
             * is then converted to a <code>Color</code> object.
             * <p>
             * If the specified property is not found or could not be parsed as an
             * integer then <code>null</code> is returned.
             *
             * @param nm
             * the name of the color property
             * @return the <code>Color</code> converted from the system property.
             * @see java.lang.System#getProperty(java.lang.String)
             * @see java.lang.Integer#getInteger(java.lang.String)
             * @see java.awt.Color#Color(int)
             * @since JDK1.0
             */
            Color.getColor$java_lang_String = function (nm) {
                return Color.getColor(nm, null);
            };
            /**
             * Finds a color in the system properties.
             * <p>
             * The first argument is treated as the name of a system property to be
             * obtained. The string value of this property is then interpreted as an
             * integer which is then converted to a <code>Color</code> object.
             * <p>
             * If the specified property is not found or cannot be parsed as an integer
             * then the <code>Color</code> specified by the second argument is returned
             * instead.
             *
             * @param nm
             * the name of the color property
             * @param v
             * the default <code>Color</code>
             * @return the <code>Color</code> converted from the system property, or the
             * specified <code>Color</code>.
             * @see java.lang.System#getProperty(java.lang.String)
             * @see java.lang.Integer#getInteger(java.lang.String)
             * @see java.awt.Color#Color(int)
             * @since JDK1.0
             */
            Color.getColor = function (nm, v) {
                if (((typeof nm === 'string') || nm === null) && ((v != null && v instanceof java.awt.Color) || v === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        var intval = javaemul.internal.IntegerHelper.getInteger(nm);
                        if (intval == null) {
                            return v;
                        }
                        var i = (intval | 0);
                        return new Color((i >> 16) & 255, (i >> 8) & 255, i & 255);
                    })();
                }
                else if (((typeof nm === 'string') || nm === null) && ((typeof v === 'number') || v === null)) {
                    return java.awt.Color.getColor$java_lang_String$int(nm, v);
                }
                else if (((typeof nm === 'string') || nm === null) && v === undefined) {
                    return java.awt.Color.getColor$java_lang_String(nm);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Finds a color in the system properties.
             * <p>
             * The first argument is treated as the name of a system property to be
             * obtained. The string value of this property is then interpreted as an
             * integer which is then converted to a <code>Color</code> object.
             * <p>
             * If the specified property is not found or could not be parsed as an
             * integer then the integer value <code>v</code> is used instead, and is
             * converted to a <code>Color</code> object.
             *
             * @param nm
             * the name of the color property
             * @param v
             * the default color value, as an integer
             * @return the <code>Color</code> converted from the system property or the
             * <code>Color</code> converted from the specified integer.
             * @see java.lang.System#getProperty(java.lang.String)
             * @see java.lang.Integer#getInteger(java.lang.String)
             * @see java.awt.Color#Color(int)
             * @since JDK1.0
             */
            Color.getColor$java_lang_String$int = function (nm, v) {
                var intval = javaemul.internal.IntegerHelper.getInteger(nm);
                var i = (intval != null) ? (intval | 0) : v;
                return new Color((i >> 16) & 255, (i >> 8) & 255, (i >> 0) & 255);
            };
            /**
             * Converts the components of a color, as specified by the HSB model, to an
             * equivalent set of values for the default RGB model.
             * <p>
             * The <code>saturation</code> and <code>brightness</code> components should
             * be floating-point values between zero and one (numbers in the range
             * 0.0-1.0). The <code>hue</code> component can be any floating-point
             * number. The floor of this number is subtracted from it to create a
             * fraction between 0 and 1. This fractional number is then multiplied by
             * 360 to produce the hue angle in the HSB color model.
             * <p>
             * The integer that is returned by <code>HSBtoRGB</code> encodes the value
             * of a color in bits 0-23 of an integer value that is the same format used
             * by the method {@link #getRGB() getRGB}. This integer can be supplied as
             * an argument to the <code>Color</code> constructor that takes a single
             * integer argument.
             *
             * @param hue
             * the hue component of the color
             * @param saturation
             * the saturation of the color
             * @param brightness
             * the brightness of the color
             * @return the RGB value of the color with the indicated hue, saturation,
             * and brightness.
             * @see java.awt.Color#getRGB()
             * @see java.awt.Color#Color(int)
             * @see java.awt.image.ColorModel#getRGBdefault()
             * @since JDK1.0
             */
            Color.HSBtoRGB = function (hue, saturation, brightness) {
                var r = 0;
                var g = 0;
                var b = 0;
                if (saturation === 0) {
                    r = g = b = ((brightness * 255.0 + 0.5) | 0);
                }
                else {
                    var h = (hue - Math.floor(hue)) * 6.0;
                    var f = h - Math.floor(h);
                    var p = brightness * (1.0 - saturation);
                    var q = brightness * (1.0 - saturation * f);
                    var t = brightness * (1.0 - (saturation * (1.0 - f)));
                    switch (((h | 0))) {
                        case 0:
                            r = ((brightness * 255.0 + 0.5) | 0);
                            g = ((t * 255.0 + 0.5) | 0);
                            b = ((p * 255.0 + 0.5) | 0);
                            break;
                        case 1:
                            r = ((q * 255.0 + 0.5) | 0);
                            g = ((brightness * 255.0 + 0.5) | 0);
                            b = ((p * 255.0 + 0.5) | 0);
                            break;
                        case 2:
                            r = ((p * 255.0 + 0.5) | 0);
                            g = ((brightness * 255.0 + 0.5) | 0);
                            b = ((t * 255.0 + 0.5) | 0);
                            break;
                        case 3:
                            r = ((p * 255.0 + 0.5) | 0);
                            g = ((q * 255.0 + 0.5) | 0);
                            b = ((brightness * 255.0 + 0.5) | 0);
                            break;
                        case 4:
                            r = ((t * 255.0 + 0.5) | 0);
                            g = ((p * 255.0 + 0.5) | 0);
                            b = ((brightness * 255.0 + 0.5) | 0);
                            break;
                        case 5:
                            r = ((brightness * 255.0 + 0.5) | 0);
                            g = ((p * 255.0 + 0.5) | 0);
                            b = ((q * 255.0 + 0.5) | 0);
                            break;
                    }
                }
                return -16777216 | (r << 16) | (g << 8) | (b << 0);
            };
            /**
             * Converts the components of a color, as specified by the default RGB
             * model, to an equivalent set of values for hue, saturation, and brightness
             * that are the three components of the HSB model.
             * <p>
             * If the <code>hsbvals</code> argument is <code>null</code>, then a new
             * array is allocated to return the result. Otherwise, the method returns
             * the array <code>hsbvals</code>, with the values put into that array.
             *
             * @param r
             * the red component of the color
             * @param g
             * the green component of the color
             * @param b
             * the blue component of the color
             * @param hsbvals
             * the array used to return the three HSB values, or
             * <code>null</code>
             * @return an array of three elements containing the hue, saturation, and
             * brightness (in that order), of the color with the indicated red,
             * green, and blue components.
             * @see java.awt.Color#getRGB()
             * @see java.awt.Color#Color(int)
             * @see java.awt.image.ColorModel#getRGBdefault()
             * @since JDK1.0
             */
            Color.RGBtoHSB = function (r, g, b, hsbvals) {
                var hue;
                var saturation;
                var brightness;
                if (hsbvals == null) {
                    hsbvals = new Array(3);
                }
                var cmax = (r > g) ? r : g;
                if (b > cmax)
                    cmax = b;
                var cmin = (r < g) ? r : g;
                if (b < cmin)
                    cmin = b;
                brightness = cmax / 255.0;
                if (cmax !== 0)
                    saturation = (cmax - cmin) / cmax;
                else
                    saturation = 0;
                if (saturation === 0)
                    hue = 0;
                else {
                    var redc = (cmax - r) / (cmax - cmin);
                    var greenc = (cmax - g) / (cmax - cmin);
                    var bluec = (cmax - b) / (cmax - cmin);
                    if (r === cmax)
                        hue = bluec - greenc;
                    else if (g === cmax)
                        hue = 2.0 + redc - bluec;
                    else
                        hue = 4.0 + greenc - redc;
                    hue = hue / 6.0;
                    if (hue < 0)
                        hue = hue + 1.0;
                }
                hsbvals[0] = hue;
                hsbvals[1] = saturation;
                hsbvals[2] = brightness;
                return hsbvals;
            };
            /**
             * Creates a <code>Color</code> object based on the specified values for the
             * HSB color model.
             * <p>
             * The <code>s</code> and <code>b</code> components should be floating-point
             * values between zero and one (numbers in the range 0.0-1.0). The
             * <code>h</code> component can be any floating-point number. The floor of
             * this number is subtracted from it to create a fraction between 0 and 1.
             * This fractional number is then multiplied by 360 to produce the hue angle
             * in the HSB color model.
             *
             * @param h
             * the hue component
             * @param s
             * the saturation of the color
             * @param b
             * the brightness of the color
             * @return a <code>Color</code> object with the specified hue, saturation,
             * and brightness.
             * @since JDK1.0
             */
            Color.getHSBColor = function (h, s, b) {
                return new Color(Color.HSBtoRGB(h, s, b));
            };
            /**
             * Returns a <code>float</code> array containing the color and alpha
             * components of the <code>Color</code>, as represented in the default sRGB
             * color space. If <code>compArray</code> is <code>null</code>, an array of
             * length 4 is created for the return value. Otherwise,
             * <code>compArray</code> must have length 4 or greater, and it is filled in
             * with the components and returned.
             *
             * @param compArray
             * an array that this method fills with color and alpha
             * components and returns
             * @return the RGBA components in a <code>float</code> array.
             */
            Color.prototype.getRGBComponents = function (compArray) {
                var f;
                if (compArray == null) {
                    f = new Array(4);
                }
                else {
                    f = compArray;
                }
                if (this.frgbvalue == null) {
                    f[0] = this.getRed() / 255.0;
                    f[1] = this.getGreen() / 255.0;
                    f[2] = this.getBlue() / 255.0;
                    f[3] = this.getAlpha() / 255.0;
                }
                else {
                    f[0] = this.frgbvalue[0];
                    f[1] = this.frgbvalue[1];
                    f[2] = this.frgbvalue[2];
                    f[3] = this.falpha;
                }
                return f;
            };
            /**
             * Returns a <code>float</code> array containing only the color components
             * of the <code>Color</code>, in the default sRGB color space. If
             * <code>compArray</code> is <code>null</code>, an array of length 3 is
             * created for the return value. Otherwise, <code>compArray</code> must have
             * length 3 or greater, and it is filled in with the components and
             * returned.
             *
             * @param compArray
             * an array that this method fills with color components and
             * returns
             * @return the RGB components in a <code>float</code> array.
             */
            Color.prototype.getRGBColorComponents = function (compArray) {
                var f;
                if (compArray == null) {
                    f = new Array(3);
                }
                else {
                    f = compArray;
                }
                if (this.frgbvalue == null) {
                    f[0] = this.getRed() / 255.0;
                    f[1] = this.getGreen() / 255.0;
                    f[2] = this.getBlue() / 255.0;
                }
                else {
                    f[0] = this.frgbvalue[0];
                    f[1] = this.frgbvalue[1];
                    f[2] = this.frgbvalue[2];
                }
                return f;
            };
            /**
             * Returns a <code>float</code> array containing the color and alpha
             * components of the <code>Color</code>, in the <code>ColorSpace</code> of
             * the <code>Color</code>. If <code>compArray</code> is <code>null</code>,
             * an array with length equal to the number of components in the associated
             * <code>ColorSpace</code> plus one is created for the return value.
             * Otherwise, <code>compArray</code> must have at least this length and it
             * is filled in with the components and returned.
             *
             * @param compArray
             * an array that this method fills with the color and alpha
             * components of this <code>Color</code> in its
             * <code>ColorSpace</code> and returns
             * @return the color and alpha components in a <code>float</code> array.
             */
            Color.prototype.getComponents = function (compArray) {
                if (this.fvalue == null)
                    return this.getRGBComponents(compArray);
                var f;
                var n = this.fvalue.length;
                if (compArray == null) {
                    f = new Array(n + 1);
                }
                else {
                    f = compArray;
                }
                for (var i = 0; i < n; i++) {
                    f[i] = this.fvalue[i];
                }
                f[n] = this.falpha;
                return f;
            };
            /**
             * Returns a <code>float</code> array containing only the color components
             * of the <code>Color</code>, in the <code>ColorSpace</code> of the
             * <code>Color</code>. If <code>compArray</code> is <code>null</code>, an
             * array with length equal to the number of components in the associated
             * <code>ColorSpace</code> is created for the return value. Otherwise,
             * <code>compArray</code> must have at least this length and it is filled in
             * with the components and returned.
             *
             * @param compArray
             * an array that this method fills with the color components of
             * this <code>Color</code> in its <code>ColorSpace</code> and
             * returns
             * @return the color components in a <code>float</code> array.
             */
            Color.prototype.getColorComponents = function (compArray) {
                if (this.fvalue == null)
                    return this.getRGBColorComponents(compArray);
                var f;
                var n = this.fvalue.length;
                if (compArray == null) {
                    f = new Array(n);
                }
                else {
                    f = compArray;
                }
                for (var i = 0; i < n; i++) {
                    f[i] = this.fvalue[i];
                }
                return f;
            };
            /**
             * Returns the transparency mode for this <code>Color</code>. This is
             * required to implement the <code>Paint</code> interface.
             *
             * @return this <code>Color</code> object's transparency mode.
             * @see Paint
             * @see Transparency
             * @see #createContext
             */
            Color.prototype.getTransparency = function () {
                var alpha = this.getAlpha();
                if (alpha === 255) {
                    return java.awt.Transparency.OPAQUE;
                }
                else if (alpha === 0) {
                    return java.awt.Transparency.BITMASK;
                }
                else {
                    return java.awt.Transparency.TRANSLUCENT;
                }
            };
            Color.prototype.toHTML = function () {
                var sb = new java.lang.StringBuilder();
                sb.append("#");
                var s = javaemul.internal.IntegerHelper.toHexString(this.getRed());
                if (s.length === 1) {
                    sb.append("0");
                }
                sb.append(s);
                s = javaemul.internal.IntegerHelper.toHexString(this.getGreen());
                if (s.length === 1) {
                    sb.append("0");
                }
                sb.append(s);
                s = javaemul.internal.IntegerHelper.toHexString(this.getBlue());
                if (s.length === 1) {
                    sb.append("0");
                }
                sb.append(s);
                return sb.toString();
            };
            Color.serialVersionUID = 118526816881161077;
            Color.FACTOR = 0.7;
            return Color;
        }());
        awt.Color = Color;
        Color["__class"] = "java.awt.Color";
        Color["__interfaces"] = ["java.awt.Paint", "java.io.Serializable"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var Component = (function () {
            function Component() {
                this.preferredSize = new java.awt.Dimension();
                this.minimumSize = new java.awt.Dimension();
                this.mouseWheelListeners = [];
                this.mouseListeners = [];
                this.enabled = false;
                this.valid = false;
                this.visible = false;
            }
            Component.prototype.bindHTML = function (htmlElement) {
                if (this.htmlElement != null) {
                    if (htmlElement.tagName === this.htmlElement.tagName) {
                        var nodes = (new Array());
                        for (var index121 = 0; index121 < this.htmlElement.childNodes.length; index121++) {
                            var n = this.htmlElement.childNodes[index121];
                            {
                                nodes.push(n);
                            }
                        }
                        for (var index122 = 0; index122 < nodes.length; index122++) {
                            var n = nodes[index122];
                            {
                                this.htmlElement.removeChild(n);
                                htmlElement.appendChild(n);
                            }
                        }
                        this.htmlElement = htmlElement;
                        this.initHTML();
                    }
                    else {
                        throw new Error("already bound (incompatible node types): " + htmlElement.tagName + " != " + this.htmlElement.tagName);
                    }
                }
                else {
                    this.htmlElement = htmlElement;
                    this.initHTML();
                }
            };
            Component.prototype.getHTMLElement = function () {
                if (this.htmlElement == null) {
                    this.initHTML();
                }
                return this.htmlElement;
            };
            Component.prototype.initHTML = function () {
                if (this.htmlElement == null) {
                    this.createHTML();
                }
                this.htmlElement.id = "cmp" + Component.CURRENT_ID++;
                if (this.background != null) {
                    this.htmlElement.style.backgroundColor = this.background.toHTML();
                }
                if (this.width != null) {
                    this.htmlElement.style.width = this.width + "px";
                }
                else {
                    this.htmlElement.style.width = "auto";
                }
                if (this.height != null) {
                    this.htmlElement.style.height = this.height + "px";
                }
                else {
                    this.htmlElement.style.height = "auto";
                }
            };
            Component.prototype.getLocationOnScreen = function () {
                return new java.awt.Point(this.getX(), this.getY());
            };
            Component.prototype.getBounds = function () {
                return new java.awt.Rectangle(this.getX(), this.getY(), this.getWidth(), this.getHeight());
            };
            Component.prototype.getWidth = function () {
                return (this.htmlElement.offsetWidth | 0);
            };
            Component.prototype.getHeight = function () {
                return (this.htmlElement.offsetHeight | 0);
            };
            Component.prototype.getX = function () {
                return (this.htmlElement.offsetLeft | 0);
            };
            Component.prototype.getY = function () {
                return (this.htmlElement.offsetTop | 0);
            };
            Component.prototype.setSize = function (width, height) {
                var _this = this;
                if (((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        _this.width = width;
                        _this.height = height;
                        if (_this.htmlElement != null) {
                            _this.htmlElement.style.width = width + "px";
                            _this.htmlElement.style.height = height + "px";
                        }
                    })();
                }
                else if (((width != null && width instanceof java.awt.Dimension) || width === null) && height === undefined) {
                    return this.setSize$java_awt_Dimension(width);
                }
                else
                    throw new Error('invalid overload');
            };
            Component.prototype.setSize$java_awt_Dimension = function (d) {
                this.setSize(d.width, d.height);
            };
            Component.prototype.getPropertyChangeListeners = function (propertyName) {
                var _this = this;
                if (((typeof propertyName === 'string') || propertyName === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        if (_this.changeSupport == null) {
                            return new Array(0);
                        }
                        return _this.changeSupport.getPropertyChangeListeners(propertyName);
                    })();
                }
                else if (propertyName === undefined) {
                    return this.getPropertyChangeListeners$();
                }
                else
                    throw new Error('invalid overload');
            };
            Component.prototype.addPropertyChangeListener$java_beans_PropertyChangeListener = function (listener) {
                if (listener == null) {
                    return;
                }
                if (this.changeSupport == null) {
                    this.changeSupport = new java.beans.PropertyChangeSupport(this);
                }
                this.changeSupport.addPropertyChangeListener(listener);
            };
            Component.prototype.removePropertyChangeListener$java_beans_PropertyChangeListener = function (listener) {
                if (listener == null || this.changeSupport == null) {
                    return;
                }
                this.changeSupport.removePropertyChangeListener(listener);
            };
            Component.prototype.getPropertyChangeListeners$ = function () {
                if (this.changeSupport == null) {
                    return new Array(0);
                }
                return this.changeSupport.getPropertyChangeListeners();
            };
            Component.prototype.addPropertyChangeListener = function (propertyName, listener) {
                var _this = this;
                if (((typeof propertyName === 'string') || propertyName === null) && ((listener != null && (listener["__interfaces"] != null && listener["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0 || listener.constructor != null && listener.constructor["__interfaces"] != null && listener.constructor["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0)) || listener === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        if (listener == null) {
                            return;
                        }
                        if (_this.changeSupport == null) {
                            _this.changeSupport = new java.beans.PropertyChangeSupport(_this);
                        }
                        _this.changeSupport.addPropertyChangeListener(propertyName, listener);
                    })();
                }
                else if (((propertyName != null && (propertyName["__interfaces"] != null && propertyName["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0 || propertyName.constructor != null && propertyName.constructor["__interfaces"] != null && propertyName.constructor["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0)) || propertyName === null) && listener === undefined) {
                    return this.addPropertyChangeListener$java_beans_PropertyChangeListener(propertyName);
                }
                else
                    throw new Error('invalid overload');
            };
            Component.prototype.removePropertyChangeListener = function (propertyName, listener) {
                var _this = this;
                if (((typeof propertyName === 'string') || propertyName === null) && ((listener != null && (listener["__interfaces"] != null && listener["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0 || listener.constructor != null && listener.constructor["__interfaces"] != null && listener.constructor["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0)) || listener === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        if (listener == null || _this.changeSupport == null) {
                            return;
                        }
                        _this.changeSupport.removePropertyChangeListener(propertyName, listener);
                    })();
                }
                else if (((propertyName != null && (propertyName["__interfaces"] != null && propertyName["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0 || propertyName.constructor != null && propertyName.constructor["__interfaces"] != null && propertyName.constructor["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0)) || propertyName === null) && listener === undefined) {
                    return this.removePropertyChangeListener$java_beans_PropertyChangeListener(propertyName);
                }
                else
                    throw new Error('invalid overload');
            };
            Component.prototype.firePropertyChange = function (propertyName, oldValue, newValue) {
                var changeSupport;
                changeSupport = this.changeSupport;
                if (changeSupport == null || (oldValue != null && newValue != null && (oldValue === newValue))) {
                    return;
                }
                changeSupport.firePropertyChange(propertyName, oldValue, newValue);
            };
            Component.prototype.isEnabled = function () {
                return this.enabled;
            };
            Component.prototype.setEnabled = function (enabled) {
                this.enabled = enabled;
            };
            Component.prototype.getBackground = function () {
                return this.background;
            };
            Component.prototype.setBackground = function (background) {
                this.background = background;
                if (this.htmlElement != null) {
                    this.htmlElement.style.backgroundColor = background.toHTML();
                }
            };
            Component.prototype.getForeground = function () {
                return this.foreground;
            };
            Component.prototype.setForeground = function (foreground) {
                this.foreground = foreground;
                if (this.htmlElement != null) {
                    this.htmlElement.style.color = foreground.toHTML();
                }
            };
            Component.prototype.getFont = function () {
                return this.font;
            };
            Component.prototype.setFont = function (font) {
                this.font = font;
                if (this.htmlElement != null) {
                    this.htmlElement.style.font = font.toHTML();
                }
            };
            Component.prototype.isVisible = function () {
                return this.visible;
            };
            Component.prototype.setVisible = function (visible) {
                this.visible = visible;
                if (this.htmlElement != null) {
                    this.htmlElement.style.visibility = visible ? "visible" : "hidden";
                }
            };
            Component.prototype.getName = function () {
                return this.name;
            };
            Component.prototype.setName = function (name) {
                this.name = name;
            };
            Component.prototype.paramString = function () {
                var thisName = this.getName();
                var str = (thisName != null ? thisName : "") + "," + this.getX() + "," + this.getY() + "," + this.getWidth() + "x" + this.getHeight();
                if (!this.isValid()) {
                    str += ",invalid";
                }
                if (!this.visible) {
                    str += ",hidden";
                }
                if (!this.enabled) {
                    str += ",disabled";
                }
                return str;
            };
            Component.prototype.isValid = function () {
                return this.valid;
            };
            Component.prototype.setValid = function (valid) {
                this.valid = valid;
            };
            Component.prototype.validate = function () {
            };
            Component.prototype.paint = function (g) {
            };
            Component.prototype.update = function (g) {
                this.paint(g);
            };
            Component.prototype.paintAll = function (g) {
                this.paint(g);
            };
            Component.prototype.getGraphics = function () {
                return null;
            };
            Component.prototype.doPaintInternal = function () {
                var g = this.getGraphics();
                if (g != null) {
                    this.paint(g);
                }
            };
            Component.prototype.getPreferredSize = function () {
                return this.preferredSize;
            };
            Component.prototype.setPreferredSize = function (preferredSize) {
                this.preferredSize = preferredSize;
            };
            Component.prototype.getIgnoreRepaint = function () {
                return false;
            };
            Component.prototype.setIgnoreRepaint = function (ignoreRepaint) {
            };
            Component.prototype.getParent = function () {
                return this.parent;
            };
            Component.prototype.getSize = function () {
                return new java.awt.Dimension(this.width, this.height);
            };
            Component.prototype.revalidate = function () {
                if (this.getHTMLElement() != null) {
                    this.initHTML();
                }
            };
            Component.prototype.invalidate = function () {
            };
            Component.prototype.repaint = function () {
                this.paint(this.getGraphics());
            };
            Component.prototype.addFocusListener = function (l) {
            };
            Component.prototype.getMinimumSize = function () {
                return this.minimumSize;
            };
            Component.prototype.setMinimumSize = function (minimumSize) {
                this.minimumSize = minimumSize;
            };
            Component.prototype.setLocation = function (x, y) {
                var _this = this;
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        _this.x = x;
                        _this.y = y;
                    })();
                }
                else if (((x != null && x instanceof java.awt.Point) || x === null) && y === undefined) {
                    return this.setLocation$java_awt_Point(x);
                }
                else
                    throw new Error('invalid overload');
            };
            Component.prototype.setLocation$java_awt_Point = function (p) {
                this.x = p.x;
                this.y = p.y;
            };
            Component.prototype.getCursor = function () {
                return this.cursor;
            };
            Component.prototype.setCursor = function (cursor) {
                this.cursor = cursor;
            };
            Component.prototype.addMouseWheelListener = function (l) {
                if (l == null) {
                    return;
                }
                (this.mouseWheelListeners).push(l);
            };
            Component.prototype.removeMouseWheelListener = function (l) {
                if (l == null) {
                    return;
                }
                (this.mouseWheelListeners).splice((this.mouseWheelListeners).indexOf(l), 1);
            };
            Component.prototype.getMouseWheelListeners = function () {
                return this.mouseWheelListeners;
            };
            Component.prototype.addMouseListener = function (l) {
                if (l == null) {
                    return;
                }
                (this.mouseListeners).push(l);
            };
            Component.prototype.removeMouseListener = function (l) {
                if (l == null) {
                    return;
                }
                (this.mouseListeners).splice((this.mouseListeners).indexOf(l), 1);
            };
            Component.prototype.getMouseListeners = function () {
                return this.mouseListeners;
            };
            Component.prototype.requestFocus = function () {
            };
            Component.TOP_ALIGNMENT = 0.0;
            Component.CENTER_ALIGNMENT = 0.5;
            Component.BOTTOM_ALIGNMENT = 1.0;
            Component.LEFT_ALIGNMENT = 0.0;
            Component.RIGHT_ALIGNMENT = 1.0;
            Component.CURRENT_ID = 0;
            return Component;
        }());
        awt.Component = Component;
        Component["__class"] = "java.awt.Component";
        Component["__interfaces"] = ["java.awt.HTMLComponent"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        /**
         * A class to encapsulate the bitmap representation of the mouse cursor.
         *
         * @see Component#setCursor
         * @author Amy Fowler
         */
        var Cursor = (function () {
            /**
             * Creates a new custom cursor object with the specified name.
             * <p>
             * Note: this constructor should only be used by AWT implementations as part
             * of their support for custom cursors. Applications should use
             * Toolkit.createCustomCursor().
             *
             * @param name
             * the user-visible name of the cursor.
             * @see java.awt.Toolkit#createCustomCursor
             */
            function Cursor(name) {
                var _this = this;
                /**
                 * The chosen cursor type initially set to the <code>DEFAULT_CURSOR</code>.
                 *
                 * @serial
                 * @see #getType()
                 */
                this.type = Cursor.DEFAULT_CURSOR;
                if (((typeof name === 'string') || name === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    this.type = Cursor.DEFAULT_CURSOR;
                    (function () {
                        _this.type = Cursor.CUSTOM_CURSOR;
                        _this.name = name;
                    })();
                }
                else if (((typeof name === 'number') || name === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    var type_1 = __args[0];
                    this.type = Cursor.DEFAULT_CURSOR;
                    (function () {
                        if (type_1 < Cursor.DEFAULT_CURSOR || type_1 > Cursor.MOVE_CURSOR) {
                            throw new java.lang.IllegalArgumentException("illegal cursor type");
                        }
                        _this.type = type_1;
                        _this.name = java.awt.Toolkit.getProperty(Cursor.cursorProperties_$LI$()[type_1][0], Cursor.cursorProperties_$LI$()[type_1][1]);
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            Cursor.predefined_$LI$ = function () { if (Cursor.predefined == null)
                Cursor.predefined = new Array(14); return Cursor.predefined; };
            ;
            Cursor.predefinedPrivate_$LI$ = function () { if (Cursor.predefinedPrivate == null)
                Cursor.predefinedPrivate = new Array(14); return Cursor.predefinedPrivate; };
            ;
            Cursor.cursorProperties_$LI$ = function () { if (Cursor.cursorProperties == null)
                Cursor.cursorProperties = [["AWT.DefaultCursor", "Default Cursor"], ["AWT.CrosshairCursor", "Crosshair Cursor"], ["AWT.TextCursor", "Text Cursor"], ["AWT.WaitCursor", "Wait Cursor"], ["AWT.SWResizeCursor", "Southwest Resize Cursor"], ["AWT.SEResizeCursor", "Southeast Resize Cursor"], ["AWT.NWResizeCursor", "Northwest Resize Cursor"], ["AWT.NEResizeCursor", "Northeast Resize Cursor"], ["AWT.NResizeCursor", "North Resize Cursor"], ["AWT.SResizeCursor", "South Resize Cursor"], ["AWT.WResizeCursor", "West Resize Cursor"], ["AWT.EResizeCursor", "East Resize Cursor"], ["AWT.HandCursor", "Hand Cursor"], ["AWT.MoveCursor", "Move Cursor"]]; return Cursor.cursorProperties; };
            ;
            /**
             * Returns a cursor object with the specified predefined type.
             *
             * @param type
             * the type of predefined cursor
             * @return the specified predefined cursor
             * @throws IllegalArgumentException
             * if the specified cursor type is invalid
             */
            Cursor.getPredefinedCursor = function (type) {
                if (type < Cursor.DEFAULT_CURSOR || type > Cursor.MOVE_CURSOR) {
                    throw new java.lang.IllegalArgumentException("illegal cursor type");
                }
                var c = Cursor.predefinedPrivate_$LI$()[type];
                if (c == null) {
                    Cursor.predefinedPrivate_$LI$()[type] = c = new Cursor(type);
                }
                if (Cursor.predefined_$LI$()[type] == null) {
                    Cursor.predefined_$LI$()[type] = c;
                }
                return c;
            };
            /**
             * Returns a system-specific custom cursor object matching the specified
             * name. Cursor names are, for example: "Invalid.16x16"
             *
             * @param name
             * a string describing the desired system-specific custom cursor
             * @return the system specific custom cursor named
             * @exception HeadlessException
             * if <code>GraphicsEnvironment.isHeadless</code> returns
             * true
             */
            Cursor.getSystemCustomCursor = function (name) {
                return null;
            };
            /**
             * Return the system default cursor.
             */
            Cursor.getDefaultCursor = function () {
                return Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR);
            };
            /**
             * Returns the type for this cursor.
             */
            Cursor.prototype.getType = function () {
                return this.type;
            };
            /**
             * Returns the name of this cursor.
             *
             * @return a localized description of this cursor.
             * @since 1.2
             */
            Cursor.prototype.getName = function () {
                return this.name;
            };
            /**
             * Returns a string representation of this cursor.
             *
             * @return a string representation of this cursor.
             * @since 1.2
             */
            Cursor.prototype.toString = function () {
                return (function (c) { return c["__class"] ? c["__class"] : c.name; })(this.constructor) + "[" + this.getName() + "]";
            };
            /**
             * The default cursor type (gets set if no cursor is defined).
             */
            Cursor.DEFAULT_CURSOR = 0;
            /**
             * The crosshair cursor type.
             */
            Cursor.CROSSHAIR_CURSOR = 1;
            /**
             * The text cursor type.
             */
            Cursor.TEXT_CURSOR = 2;
            /**
             * The wait cursor type.
             */
            Cursor.WAIT_CURSOR = 3;
            /**
             * The south-west-resize cursor type.
             */
            Cursor.SW_RESIZE_CURSOR = 4;
            /**
             * The south-east-resize cursor type.
             */
            Cursor.SE_RESIZE_CURSOR = 5;
            /**
             * The north-west-resize cursor type.
             */
            Cursor.NW_RESIZE_CURSOR = 6;
            /**
             * The north-east-resize cursor type.
             */
            Cursor.NE_RESIZE_CURSOR = 7;
            /**
             * The north-resize cursor type.
             */
            Cursor.N_RESIZE_CURSOR = 8;
            /**
             * The south-resize cursor type.
             */
            Cursor.S_RESIZE_CURSOR = 9;
            /**
             * The west-resize cursor type.
             */
            Cursor.W_RESIZE_CURSOR = 10;
            /**
             * The east-resize cursor type.
             */
            Cursor.E_RESIZE_CURSOR = 11;
            /**
             * The hand cursor type.
             */
            Cursor.HAND_CURSOR = 12;
            /**
             * The move cursor type.
             */
            Cursor.MOVE_CURSOR = 13;
            /**
             * The type associated with all custom cursors.
             */
            Cursor.CUSTOM_CURSOR = -1;
            Cursor.serialVersionUID = 8028237497568985504;
            return Cursor;
        }());
        awt.Cursor = Cursor;
        Cursor["__class"] = "java.awt.Cursor";
        Cursor["__interfaces"] = ["java.io.Serializable"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var event;
        (function (event) {
            /**
             * An abstract adapter class for receiving component events.
             * The methods in this class are empty. This class exists as
             * convenience for creating listener objects.
             * <P>
             * Extend this class to create a <code>ComponentEvent</code> listener
             * and override the methods for the events of interest. (If you implement the
             * <code>ComponentListener</code> interface, you have to define all of
             * the methods in it. This abstract class defines null methods for them
             * all, so you can only have to define methods for events you care about.)
             * <P>
             * Create a listener object using your class and then register it with a
             * component using the component's <code>addComponentListener</code>
             * method. When the component's size, location, or visibility
             * changes, the relevant method in the listener object is invoked,
             * and the <code>ComponentEvent</code> is passed to it.
             *
             * @see ComponentEvent
             * @see ComponentListener
             * @see <a href="http://docs.oracle.com/javase/tutorial/uiswing/events/componentlistener.html">Tutorial: Writing a Component Listener</a>
             *
             * @author Carl Quinn
             * @since 1.1
             */
            var ComponentAdapter = (function () {
                function ComponentAdapter() {
                }
                /**
                 * Invoked when the component's size changes.
                 */
                ComponentAdapter.prototype.componentResized = function (e) {
                };
                /**
                 * Invoked when the component's position changes.
                 */
                ComponentAdapter.prototype.componentMoved = function (e) {
                };
                /**
                 * Invoked when the component has been made visible.
                 */
                ComponentAdapter.prototype.componentShown = function (e) {
                };
                /**
                 * Invoked when the component has been made invisible.
                 */
                ComponentAdapter.prototype.componentHidden = function (e) {
                };
                return ComponentAdapter;
            }());
            event.ComponentAdapter = ComponentAdapter;
            ComponentAdapter["__class"] = "java.awt.event.ComponentAdapter";
            ComponentAdapter["__interfaces"] = ["java.util.EventListener", "java.awt.event.ComponentListener"];
        })(event = awt.event || (awt.event = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var event;
        (function (event) {
            /**
             * An abstract adapter class for receiving container events.
             * The methods in this class are empty. This class exists as
             * convenience for creating listener objects.
             * <P>
             * Extend this class to create a <code>ContainerEvent</code> listener
             * and override the methods for the events of interest. (If you implement the
             * <code>ContainerListener</code> interface, you have to define all of
             * the methods in it. This abstract class defines null methods for them
             * all, so you can only have to define methods for events you care about.)
             * <P>
             * Create a listener object using the extended class and then register it with
             * a component using the component's <code>addContainerListener</code>
             * method. When the container's contents change because a component has
             * been added or removed, the relevant method in the listener object is invoked,
             * and the <code>ContainerEvent</code> is passed to it.
             *
             * @see ContainerEvent
             * @see ContainerListener
             * @see <a href="http://docs.oracle.com/javase/tutorial/uiswing/events/containerlistener.html">Tutorial: Writing a Container Listener</a>
             *
             * @author Amy Fowler
             * @since 1.1
             */
            var ContainerAdapter = (function () {
                function ContainerAdapter() {
                }
                /**
                 * Invoked when a component has been added to the container.
                 */
                ContainerAdapter.prototype.componentAdded = function (e) {
                };
                /**
                 * Invoked when a component has been removed from the container.
                 */
                ContainerAdapter.prototype.componentRemoved = function (e) {
                };
                return ContainerAdapter;
            }());
            event.ContainerAdapter = ContainerAdapter;
            ContainerAdapter["__class"] = "java.awt.event.ContainerAdapter";
            ContainerAdapter["__interfaces"] = ["java.util.EventListener", "java.awt.event.ContainerListener"];
        })(event = awt.event || (awt.event = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var event;
        (function (event) {
            /**
             * An abstract adapter class for receiving mouse events.
             * The methods in this class are empty. This class exists as
             * convenience for creating listener objects.
             * <P>
             * Mouse events let you track when a mouse is pressed, released, clicked,
             * moved, dragged, when it enters a component, when it exits and
             * when a mouse wheel is moved.
             * <P>
             * Extend this class to create a {@code MouseEvent}
             * (including drag and motion events) or/and {@code MouseWheelEvent}
             * listener and override the methods for the events of interest. (If you implement the
             * {@code MouseListener},
             * {@code MouseMotionListener}
             * interface, you have to define all of
             * the methods in it. This abstract class defines null methods for them
             * all, so you can only have to define methods for events you care about.)
             * <P>
             * Create a listener object using the extended class and then register it with
             * a component using the component's {@code addMouseListener}
             * {@code addMouseMotionListener}, {@code addMouseWheelListener}
             * methods.
             * The relevant method in the listener object is invoked  and the {@code MouseEvent}
             * or {@code MouseWheelEvent}  is passed to it in following cases:
             * <ul>
             * <li>when a mouse button is pressed, released, or clicked (pressed and  released)
             * <li>when the mouse cursor enters or exits the component
             * <li>when the mouse wheel rotated, or mouse moved or dragged
             * </ul>
             *
             * @author Carl Quinn
             * @author Andrei Dmitriev
             *
             * @see MouseEvent
             * @see MouseWheelEvent
             * @see MouseListener
             * @see MouseMotionListener
             * @see MouseWheelListener
             * @see <a href="http://docs.oracle.com/javase/tutorial/uiswing/events/mouselistener.html">Tutorial: Writing a Mouse Listener</a>
             *
             * @since 1.1
             */
            var MouseAdapter = (function () {
                function MouseAdapter() {
                }
                /**
                 * {@inheritDoc}
                 */
                MouseAdapter.prototype.mouseClicked = function (e) {
                };
                /**
                 * {@inheritDoc}
                 */
                MouseAdapter.prototype.mousePressed = function (e) {
                };
                /**
                 * {@inheritDoc}
                 */
                MouseAdapter.prototype.mouseReleased = function (e) {
                };
                /**
                 * {@inheritDoc}
                 */
                MouseAdapter.prototype.mouseEntered = function (e) {
                };
                /**
                 * {@inheritDoc}
                 */
                MouseAdapter.prototype.mouseExited = function (e) {
                };
                /**
                 * {@inheritDoc}
                 * @since 1.6
                 */
                MouseAdapter.prototype.mouseWheelMoved = function (e) {
                };
                /**
                 * {@inheritDoc}
                 * @since 1.6
                 */
                MouseAdapter.prototype.mouseDragged = function (e) {
                };
                /**
                 * {@inheritDoc}
                 * @since 1.6
                 */
                MouseAdapter.prototype.mouseMoved = function (e) {
                };
                return MouseAdapter;
            }());
            event.MouseAdapter = MouseAdapter;
            MouseAdapter["__class"] = "java.awt.event.MouseAdapter";
            MouseAdapter["__interfaces"] = ["java.util.EventListener", "java.awt.event.MouseMotionListener", "java.awt.event.MouseWheelListener", "java.awt.event.MouseListener"];
        })(event = awt.event || (awt.event = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var event;
        (function (event) {
            /**
             * An abstract adapter class for receiving mouse motion events.
             * The methods in this class are empty. This class exists as
             * convenience for creating listener objects.
             * <P>
             * Mouse motion events occur when a mouse is moved or dragged.
             * (Many such events will be generated in a normal program.
             * To track clicks and other mouse events, use the MouseAdapter.)
             * <P>
             * Extend this class to create a <code>MouseEvent</code> listener
             * and override the methods for the events of interest. (If you implement the
             * <code>MouseMotionListener</code> interface, you have to define all of
             * the methods in it. This abstract class defines null methods for them
             * all, so you can only have to define methods for events you care about.)
             * <P>
             * Create a listener object using the extended class and then register it with
             * a component using the component's <code>addMouseMotionListener</code>
             * method. When the mouse is moved or dragged, the relevant method in the
             * listener object is invoked and the <code>MouseEvent</code> is passed to it.
             *
             * @author Amy Fowler
             *
             * @see MouseEvent
             * @see MouseMotionListener
             * @see <a href="http://docs.oracle.com/javase/tutorial/uiswing/events/mousemotionlistener.html">Tutorial: Writing a Mouse Motion Listener</a>
             *
             * @since 1.1
             */
            var MouseMotionAdapter = (function () {
                function MouseMotionAdapter() {
                }
                /**
                 * Invoked when a mouse button is pressed on a component and then
                 * dragged.  Mouse drag events will continue to be delivered to
                 * the component where the first originated until the mouse button is
                 * released (regardless of whether the mouse position is within the
                 * bounds of the component).
                 */
                MouseMotionAdapter.prototype.mouseDragged = function (e) {
                };
                /**
                 * Invoked when the mouse button has been moved on a component
                 * (with no buttons no down).
                 */
                MouseMotionAdapter.prototype.mouseMoved = function (e) {
                };
                return MouseMotionAdapter;
            }());
            event.MouseMotionAdapter = MouseMotionAdapter;
            MouseMotionAdapter["__class"] = "java.awt.event.MouseMotionAdapter";
            MouseMotionAdapter["__interfaces"] = ["java.util.EventListener", "java.awt.event.MouseMotionListener"];
        })(event = awt.event || (awt.event = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var event;
        (function (event) {
            /**
             * An abstract adapter class for receiving window events.
             * The methods in this class are empty. This class exists as
             * convenience for creating listener objects.
             * <P>
             * Extend this class to create a <code>WindowEvent</code> listener
             * and override the methods for the events of interest. (If you implement the
             * <code>WindowListener</code> interface, you have to define all of
             * the methods in it. This abstract class defines null methods for them
             * all, so you can only have to define methods for events you care about.)
             * <P>
             * Create a listener object using the extended class and then register it with
             * a Window using the window's <code>addWindowListener</code>
             * method. When the window's status changes by virtue of being opened,
             * closed, activated or deactivated, iconified or deiconified,
             * the relevant method in the listener
             * object is invoked, and the <code>WindowEvent</code> is passed to it.
             *
             * @see WindowEvent
             * @see WindowListener
             * @see <a href="http://docs.oracle.com/javase/tutorial/uiswing/events/windowlistener.html">Tutorial: Writing a Window Listener</a>
             *
             * @author Carl Quinn
             * @author Amy Fowler
             * @author David Mendenhall
             * @since 1.1
             */
            var WindowAdapter = (function () {
                function WindowAdapter() {
                }
                /**
                 * Invoked when a window has been opened.
                 */
                WindowAdapter.prototype.windowOpened = function (e) {
                };
                /**
                 * Invoked when a window is in the process of being closed.
                 * The close operation can be overridden at this point.
                 */
                WindowAdapter.prototype.windowClosing = function (e) {
                };
                /**
                 * Invoked when a window has been closed.
                 */
                WindowAdapter.prototype.windowClosed = function (e) {
                };
                /**
                 * Invoked when a window is iconified.
                 */
                WindowAdapter.prototype.windowIconified = function (e) {
                };
                /**
                 * Invoked when a window is de-iconified.
                 */
                WindowAdapter.prototype.windowDeiconified = function (e) {
                };
                /**
                 * Invoked when a window is activated.
                 */
                WindowAdapter.prototype.windowActivated = function (e) {
                };
                /**
                 * Invoked when a window is de-activated.
                 */
                WindowAdapter.prototype.windowDeactivated = function (e) {
                };
                /**
                 * Invoked when a window state is changed.
                 * @since 1.4
                 */
                WindowAdapter.prototype.windowStateChanged = function (e) {
                };
                /**
                 * Invoked when the Window is set to be the focused Window, which means
                 * that the Window, or one of its subcomponents, will receive keyboard
                 * events.
                 *
                 * @since 1.4
                 */
                WindowAdapter.prototype.windowGainedFocus = function (e) {
                };
                /**
                 * Invoked when the Window is no longer the focused Window, which means
                 * that keyboard events will no longer be delivered to the Window or any of
                 * its subcomponents.
                 *
                 * @since 1.4
                 */
                WindowAdapter.prototype.windowLostFocus = function (e) {
                };
                return WindowAdapter;
            }());
            event.WindowAdapter = WindowAdapter;
            WindowAdapter["__class"] = "java.awt.event.WindowAdapter";
            WindowAdapter["__interfaces"] = ["java.util.EventListener", "java.awt.event.WindowListener", "java.awt.event.WindowFocusListener", "java.awt.event.WindowStateListener"];
        })(event = awt.event || (awt.event = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var Event = (function () {
            function Event(target, when, id, x, y, key, modifiers, arg) {
                var _this = this;
                this.consumed = false;
                if (((target != null) || target === null) && ((typeof when === 'number') || when === null) && ((typeof id === 'number') || id === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof key === 'number') || key === null) && ((typeof modifiers === 'number') || modifiers === null) && ((arg != null) || arg === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    this.consumed = false;
                    this.data = 0;
                    this.when = 0;
                    this.id = 0;
                    this.x = 0;
                    this.y = 0;
                    this.key = 0;
                    this.modifiers = 0;
                    this.clickCount = 0;
                    (function () {
                        _this.target = target;
                        _this.when = when;
                        _this.id = id;
                        _this.x = x;
                        _this.y = y;
                        _this.key = key;
                        _this.modifiers = modifiers;
                        _this.arg = arg;
                        _this.data = 0;
                        _this.clickCount = 0;
                        switch ((id)) {
                            case Event.ACTION_EVENT_$LI$():
                            case Event.WINDOW_DESTROY_$LI$():
                            case Event.WINDOW_ICONIFY_$LI$():
                            case Event.WINDOW_DEICONIFY_$LI$():
                            case Event.WINDOW_MOVED_$LI$():
                            case Event.SCROLL_LINE_UP_$LI$():
                            case Event.SCROLL_LINE_DOWN_$LI$():
                            case Event.SCROLL_PAGE_UP_$LI$():
                            case Event.SCROLL_PAGE_DOWN_$LI$():
                            case Event.SCROLL_ABSOLUTE_$LI$():
                            case Event.SCROLL_BEGIN_$LI$():
                            case Event.SCROLL_END_$LI$():
                            case Event.LIST_SELECT_$LI$():
                            case Event.LIST_DESELECT_$LI$():
                                _this.consumed = true;
                                break;
                            default:
                        }
                    })();
                }
                else if (((target != null) || target === null) && ((typeof when === 'number') || when === null) && ((typeof id === 'number') || id === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof key === 'number') || key === null) && ((typeof modifiers === 'number') || modifiers === null) && arg === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_6 = Array.prototype.slice.call(arguments);
                        var arg_1 = null;
                        this.consumed = false;
                        this.data = 0;
                        this.when = 0;
                        this.id = 0;
                        this.x = 0;
                        this.y = 0;
                        this.key = 0;
                        this.modifiers = 0;
                        this.clickCount = 0;
                        (function () {
                            _this.target = target;
                            _this.when = when;
                            _this.id = id;
                            _this.x = x;
                            _this.y = y;
                            _this.key = key;
                            _this.modifiers = modifiers;
                            _this.arg = arg_1;
                            _this.data = 0;
                            _this.clickCount = 0;
                            switch ((id)) {
                                case Event.ACTION_EVENT_$LI$():
                                case Event.WINDOW_DESTROY_$LI$():
                                case Event.WINDOW_ICONIFY_$LI$():
                                case Event.WINDOW_DEICONIFY_$LI$():
                                case Event.WINDOW_MOVED_$LI$():
                                case Event.SCROLL_LINE_UP_$LI$():
                                case Event.SCROLL_LINE_DOWN_$LI$():
                                case Event.SCROLL_PAGE_UP_$LI$():
                                case Event.SCROLL_PAGE_DOWN_$LI$():
                                case Event.SCROLL_ABSOLUTE_$LI$():
                                case Event.SCROLL_BEGIN_$LI$():
                                case Event.SCROLL_END_$LI$():
                                case Event.LIST_SELECT_$LI$():
                                case Event.LIST_DESELECT_$LI$():
                                    _this.consumed = true;
                                    break;
                                default:
                            }
                        })();
                    }
                }
                else if (((target != null) || target === null) && ((typeof when === 'number') || when === null) && ((id != null) || id === null) && x === undefined && y === undefined && key === undefined && modifiers === undefined && arg === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var id_2 = __args[1];
                    var arg_2 = __args[2];
                    {
                        var __args_7 = Array.prototype.slice.call(arguments);
                        var when_1 = 0;
                        var x_1 = 0;
                        var y_1 = 0;
                        var key_1 = 0;
                        var modifiers_1 = 0;
                        this.consumed = false;
                        this.data = 0;
                        this.when = 0;
                        this.id = 0;
                        this.x = 0;
                        this.y = 0;
                        this.key = 0;
                        this.modifiers = 0;
                        this.clickCount = 0;
                        (function () {
                            _this.target = target;
                            _this.when = when_1;
                            _this.id = id_2;
                            _this.x = x_1;
                            _this.y = y_1;
                            _this.key = key_1;
                            _this.modifiers = modifiers_1;
                            _this.arg = arg_2;
                            _this.data = 0;
                            _this.clickCount = 0;
                            switch ((id_2)) {
                                case Event.ACTION_EVENT_$LI$():
                                case Event.WINDOW_DESTROY_$LI$():
                                case Event.WINDOW_ICONIFY_$LI$():
                                case Event.WINDOW_DEICONIFY_$LI$():
                                case Event.WINDOW_MOVED_$LI$():
                                case Event.SCROLL_LINE_UP_$LI$():
                                case Event.SCROLL_LINE_DOWN_$LI$():
                                case Event.SCROLL_PAGE_UP_$LI$():
                                case Event.SCROLL_PAGE_DOWN_$LI$():
                                case Event.SCROLL_ABSOLUTE_$LI$():
                                case Event.SCROLL_BEGIN_$LI$():
                                case Event.SCROLL_END_$LI$():
                                case Event.LIST_SELECT_$LI$():
                                case Event.LIST_DESELECT_$LI$():
                                    _this.consumed = true;
                                    break;
                                default:
                            }
                        })();
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            Event.SHIFT_MASK_$LI$ = function () { if (Event.SHIFT_MASK == null)
                Event.SHIFT_MASK = 1 << 0; return Event.SHIFT_MASK; };
            ;
            Event.CTRL_MASK_$LI$ = function () { if (Event.CTRL_MASK == null)
                Event.CTRL_MASK = 1 << 1; return Event.CTRL_MASK; };
            ;
            Event.META_MASK_$LI$ = function () { if (Event.META_MASK == null)
                Event.META_MASK = 1 << 2; return Event.META_MASK; };
            ;
            Event.ALT_MASK_$LI$ = function () { if (Event.ALT_MASK == null)
                Event.ALT_MASK = 1 << 3; return Event.ALT_MASK; };
            ;
            Event.WINDOW_DESTROY_$LI$ = function () { if (Event.WINDOW_DESTROY == null)
                Event.WINDOW_DESTROY = 1 + Event.WINDOW_EVENT; return Event.WINDOW_DESTROY; };
            ;
            Event.WINDOW_EXPOSE_$LI$ = function () { if (Event.WINDOW_EXPOSE == null)
                Event.WINDOW_EXPOSE = 2 + Event.WINDOW_EVENT; return Event.WINDOW_EXPOSE; };
            ;
            Event.WINDOW_ICONIFY_$LI$ = function () { if (Event.WINDOW_ICONIFY == null)
                Event.WINDOW_ICONIFY = 3 + Event.WINDOW_EVENT; return Event.WINDOW_ICONIFY; };
            ;
            Event.WINDOW_DEICONIFY_$LI$ = function () { if (Event.WINDOW_DEICONIFY == null)
                Event.WINDOW_DEICONIFY = 4 + Event.WINDOW_EVENT; return Event.WINDOW_DEICONIFY; };
            ;
            Event.WINDOW_MOVED_$LI$ = function () { if (Event.WINDOW_MOVED == null)
                Event.WINDOW_MOVED = 5 + Event.WINDOW_EVENT; return Event.WINDOW_MOVED; };
            ;
            Event.KEY_PRESS_$LI$ = function () { if (Event.KEY_PRESS == null)
                Event.KEY_PRESS = 1 + Event.KEY_EVENT; return Event.KEY_PRESS; };
            ;
            Event.KEY_RELEASE_$LI$ = function () { if (Event.KEY_RELEASE == null)
                Event.KEY_RELEASE = 2 + Event.KEY_EVENT; return Event.KEY_RELEASE; };
            ;
            Event.KEY_ACTION_$LI$ = function () { if (Event.KEY_ACTION == null)
                Event.KEY_ACTION = 3 + Event.KEY_EVENT; return Event.KEY_ACTION; };
            ;
            Event.KEY_ACTION_RELEASE_$LI$ = function () { if (Event.KEY_ACTION_RELEASE == null)
                Event.KEY_ACTION_RELEASE = 4 + Event.KEY_EVENT; return Event.KEY_ACTION_RELEASE; };
            ;
            Event.MOUSE_DOWN_$LI$ = function () { if (Event.MOUSE_DOWN == null)
                Event.MOUSE_DOWN = 1 + Event.MOUSE_EVENT; return Event.MOUSE_DOWN; };
            ;
            Event.MOUSE_UP_$LI$ = function () { if (Event.MOUSE_UP == null)
                Event.MOUSE_UP = 2 + Event.MOUSE_EVENT; return Event.MOUSE_UP; };
            ;
            Event.MOUSE_MOVE_$LI$ = function () { if (Event.MOUSE_MOVE == null)
                Event.MOUSE_MOVE = 3 + Event.MOUSE_EVENT; return Event.MOUSE_MOVE; };
            ;
            Event.MOUSE_ENTER_$LI$ = function () { if (Event.MOUSE_ENTER == null)
                Event.MOUSE_ENTER = 4 + Event.MOUSE_EVENT; return Event.MOUSE_ENTER; };
            ;
            Event.MOUSE_EXIT_$LI$ = function () { if (Event.MOUSE_EXIT == null)
                Event.MOUSE_EXIT = 5 + Event.MOUSE_EVENT; return Event.MOUSE_EXIT; };
            ;
            Event.MOUSE_DRAG_$LI$ = function () { if (Event.MOUSE_DRAG == null)
                Event.MOUSE_DRAG = 6 + Event.MOUSE_EVENT; return Event.MOUSE_DRAG; };
            ;
            Event.SCROLL_LINE_UP_$LI$ = function () { if (Event.SCROLL_LINE_UP == null)
                Event.SCROLL_LINE_UP = 1 + Event.SCROLL_EVENT; return Event.SCROLL_LINE_UP; };
            ;
            Event.SCROLL_LINE_DOWN_$LI$ = function () { if (Event.SCROLL_LINE_DOWN == null)
                Event.SCROLL_LINE_DOWN = 2 + Event.SCROLL_EVENT; return Event.SCROLL_LINE_DOWN; };
            ;
            Event.SCROLL_PAGE_UP_$LI$ = function () { if (Event.SCROLL_PAGE_UP == null)
                Event.SCROLL_PAGE_UP = 3 + Event.SCROLL_EVENT; return Event.SCROLL_PAGE_UP; };
            ;
            Event.SCROLL_PAGE_DOWN_$LI$ = function () { if (Event.SCROLL_PAGE_DOWN == null)
                Event.SCROLL_PAGE_DOWN = 4 + Event.SCROLL_EVENT; return Event.SCROLL_PAGE_DOWN; };
            ;
            Event.SCROLL_ABSOLUTE_$LI$ = function () { if (Event.SCROLL_ABSOLUTE == null)
                Event.SCROLL_ABSOLUTE = 5 + Event.SCROLL_EVENT; return Event.SCROLL_ABSOLUTE; };
            ;
            Event.SCROLL_BEGIN_$LI$ = function () { if (Event.SCROLL_BEGIN == null)
                Event.SCROLL_BEGIN = 6 + Event.SCROLL_EVENT; return Event.SCROLL_BEGIN; };
            ;
            Event.SCROLL_END_$LI$ = function () { if (Event.SCROLL_END == null)
                Event.SCROLL_END = 7 + Event.SCROLL_EVENT; return Event.SCROLL_END; };
            ;
            Event.LIST_SELECT_$LI$ = function () { if (Event.LIST_SELECT == null)
                Event.LIST_SELECT = 1 + Event.LIST_EVENT; return Event.LIST_SELECT; };
            ;
            Event.LIST_DESELECT_$LI$ = function () { if (Event.LIST_DESELECT == null)
                Event.LIST_DESELECT = 2 + Event.LIST_EVENT; return Event.LIST_DESELECT; };
            ;
            Event.ACTION_EVENT_$LI$ = function () { if (Event.ACTION_EVENT == null)
                Event.ACTION_EVENT = 1 + Event.MISC_EVENT; return Event.ACTION_EVENT; };
            ;
            Event.LOAD_FILE_$LI$ = function () { if (Event.LOAD_FILE == null)
                Event.LOAD_FILE = 2 + Event.MISC_EVENT; return Event.LOAD_FILE; };
            ;
            Event.SAVE_FILE_$LI$ = function () { if (Event.SAVE_FILE == null)
                Event.SAVE_FILE = 3 + Event.MISC_EVENT; return Event.SAVE_FILE; };
            ;
            Event.GOT_FOCUS_$LI$ = function () { if (Event.GOT_FOCUS == null)
                Event.GOT_FOCUS = 4 + Event.MISC_EVENT; return Event.GOT_FOCUS; };
            ;
            Event.LOST_FOCUS_$LI$ = function () { if (Event.LOST_FOCUS == null)
                Event.LOST_FOCUS = 5 + Event.MISC_EVENT; return Event.LOST_FOCUS; };
            ;
            Event.prototype.translate = function (dx, dy) {
                this.x += dx;
                this.y += dy;
            };
            Event.prototype.shiftDown = function () {
                return (this.modifiers & Event.SHIFT_MASK_$LI$()) !== 0;
            };
            Event.prototype.controlDown = function () {
                return (this.modifiers & Event.CTRL_MASK_$LI$()) !== 0;
            };
            Event.prototype.metaDown = function () {
                return (this.modifiers & Event.META_MASK_$LI$()) !== 0;
            };
            Event.prototype.consume = function () {
                switch ((this.id)) {
                    case Event.KEY_PRESS_$LI$():
                    case Event.KEY_RELEASE_$LI$():
                    case Event.KEY_ACTION_$LI$():
                    case Event.KEY_ACTION_RELEASE_$LI$():
                        this.consumed = true;
                        break;
                    default:
                }
            };
            Event.prototype.isConsumed = function () {
                return this.consumed;
            };
            Event.prototype.paramString = function () {
                var str = "id=" + this.id + ",x=" + this.x + ",y=" + this.y;
                if (this.key !== 0) {
                    str += ",key=" + this.key;
                }
                if (this.shiftDown()) {
                    str += ",shift";
                }
                if (this.controlDown()) {
                    str += ",control";
                }
                if (this.metaDown()) {
                    str += ",meta";
                }
                if (this.target != null) {
                    str += ",target=" + this.target;
                }
                if (this.arg != null) {
                    str += ",arg=" + this.arg;
                }
                return str;
            };
            Event.prototype.toString = function () {
                return (function (c) { return c["__class"] ? c["__class"] : c.name; })(this.constructor) + "[" + this.paramString() + "]";
            };
            Event.HOME = 1000;
            Event.END = 1001;
            Event.PGUP = 1002;
            Event.PGDN = 1003;
            Event.UP = 1004;
            Event.DOWN = 1005;
            Event.LEFT = 1006;
            Event.RIGHT = 1007;
            Event.F1 = 1008;
            Event.F2 = 1009;
            Event.F3 = 1010;
            Event.F4 = 1011;
            Event.F5 = 1012;
            Event.F6 = 1013;
            Event.F7 = 1014;
            Event.F8 = 1015;
            Event.F9 = 1016;
            Event.F10 = 1017;
            Event.F11 = 1018;
            Event.F12 = 1019;
            Event.PRINT_SCREEN = 1020;
            Event.SCROLL_LOCK = 1021;
            Event.CAPS_LOCK = 1022;
            Event.NUM_LOCK = 1023;
            Event.PAUSE = 1024;
            Event.INSERT = 1025;
            Event.ENTER = ('\n').charCodeAt(0);
            Event.BACK_SPACE = ('\b').charCodeAt(0);
            Event.TAB = ('\t').charCodeAt(0);
            Event.ESCAPE = 27;
            Event.DELETE = 127;
            Event.WINDOW_EVENT = 200;
            Event.KEY_EVENT = 400;
            Event.MOUSE_EVENT = 500;
            Event.SCROLL_EVENT = 600;
            Event.LIST_EVENT = 700;
            Event.MISC_EVENT = 1000;
            return Event;
        }());
        awt.Event = Event;
        Event["__class"] = "java.awt.Event";
        Event["__interfaces"] = ["java.io.Serializable"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var FlowLayout = (function () {
            function FlowLayout(align, hgap, vgap) {
                if (align === void 0) { align = FlowLayout.CENTER; }
                if (hgap === void 0) { hgap = 5; }
                if (vgap === void 0) { vgap = 5; }
                this.created = false;
                this.align = 0;
                this.hgap = 0;
                this.vgap = 0;
                this.alignOnBaseline = false;
                this.hgap = hgap;
                this.vgap = vgap;
                this.setAlignment(align);
            }
            FlowLayout.prototype.getAlignment = function () {
                return this.align;
            };
            FlowLayout.prototype.setAlignment = function (align) {
                this.align = align;
            };
            FlowLayout.prototype.addLayoutComponent = function (name, component) {
                if (((typeof name === 'string') || name === null) && ((component != null && component instanceof java.awt.Component) || component === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            };
            FlowLayout.prototype.removeLayoutComponent = function (component) {
            };
            FlowLayout.prototype.layoutContainer = function (parent) {
                if (!this.created) {
                    this.parent = parent;
                    this.created = true;
                }
            };
            FlowLayout.prototype.onComponentAdded = function (parent, component, position) {
                var element = component.getHTMLElement();
                switch ((this.align)) {
                    case FlowLayout.CENTER:
                    case FlowLayout.LEFT:
                    case FlowLayout.LEADING:
                        element.style.display = "inline-block";
                        element.style.marginRight = this.hgap + "px";
                        element.style.marginBottom = this.vgap + "px";
                        element.style.verticalAlign = "top";
                        break;
                    case FlowLayout.RIGHT:
                    case FlowLayout.TRAILING:
                        element.style.cssFloat = "right";
                        element.style.marginLeft = this.hgap + "px";
                        element.style.marginBottom = this.vgap + "px";
                        break;
                }
                if ((component != null && component instanceof java.awt.Container) && (component.getLayout() != null && component.getLayout() instanceof java.awt.GridLayout)) {
                    component.getLayout().table.style.height = "auto";
                }
                parent.getHTMLElement().appendChild(element);
            };
            FlowLayout.prototype.getParent = function () {
                return this.parent;
            };
            FlowLayout.prototype.setParent = function (parent) {
                this.parent = parent;
            };
            FlowLayout.prototype.getHgap = function () {
                return this.hgap;
            };
            FlowLayout.prototype.setHgap = function (hgap) {
                this.hgap = hgap;
            };
            FlowLayout.prototype.getVgap = function () {
                return this.vgap;
            };
            FlowLayout.prototype.setVgap = function (vgap) {
                this.vgap = vgap;
            };
            FlowLayout.LEFT = 0;
            FlowLayout.CENTER = 1;
            FlowLayout.RIGHT = 2;
            FlowLayout.LEADING = 3;
            FlowLayout.TRAILING = 4;
            return FlowLayout;
        }());
        awt.FlowLayout = FlowLayout;
        FlowLayout["__class"] = "java.awt.FlowLayout";
        FlowLayout["__interfaces"] = ["java.awt.LayoutManager"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var Font = (function () {
            function Font(name, style, sizePts) {
                var _this = this;
                if (((typeof name === 'string') || name === null) && ((typeof style === 'number') || style === null) && ((typeof sizePts === 'number') || sizePts === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    this.style = 0;
                    this.size = 0;
                    this.pointSize = 0;
                    this.hash = 0;
                    (function () {
                        _this.name = (name != null) ? name : "Default";
                        _this.style = (style & ~3) === 0 ? style : 0;
                        _this.size = ((sizePts + 0.5) | 0);
                        _this.pointSize = sizePts;
                    })();
                }
                else if (((name != null && name instanceof java.awt.Font) || name === null) && style === undefined && sizePts === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var font_1 = __args[0];
                    this.style = 0;
                    this.size = 0;
                    this.pointSize = 0;
                    this.hash = 0;
                    (function () {
                        _this.name = font_1.name;
                        _this.style = font_1.style;
                        _this.size = font_1.size;
                        _this.pointSize = font_1.pointSize;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            Font.prototype.toHTML = function () {
                return this.style + " " + this.size + "px " + this.name;
            };
            Font.prototype.getFamily = function () {
                return this.name;
            };
            Font.prototype.getName = function () {
                return this.name;
            };
            Font.prototype.getFontName = function () {
                return this.name;
            };
            Font.prototype.getStyle = function () {
                return this.style;
            };
            Font.prototype.getSize = function () {
                return this.size;
            };
            Font.prototype.getSize2D = function () {
                return this.pointSize;
            };
            Font.prototype.isPlain = function () {
                return this.style === 0;
            };
            Font.prototype.isBold = function () {
                return (this.style & Font.BOLD) !== 0;
            };
            Font.prototype.isItalic = function () {
                return (this.style & Font.ITALIC) !== 0;
            };
            Font.decode = function (str) {
                var fontName = str;
                var styleName = "";
                var fontSize = 12;
                var fontStyle = Font.PLAIN;
                if (str == null) {
                    return new Font(Font.DIALOG, fontStyle, fontSize);
                }
                var lastHyphen = str.lastIndexOf('-');
                var lastSpace = str.lastIndexOf(' ');
                var sepChar = (lastHyphen > lastSpace) ? '-' : ' ';
                var sizeIndex = str.lastIndexOf(sepChar);
                var styleIndex = str.lastIndexOf(sepChar, sizeIndex - 1);
                var strlen = str.length;
                if (sizeIndex > 0 && sizeIndex + 1 < strlen) {
                    try {
                        fontSize = (javaemul.internal.IntegerHelper.valueOf(str.substring(sizeIndex + 1)) | 0);
                        if (fontSize <= 0) {
                            fontSize = 12;
                        }
                    }
                    catch (e) {
                        styleIndex = sizeIndex;
                        sizeIndex = strlen;
                        if (str.charAt(sizeIndex - 1) === sepChar) {
                            sizeIndex--;
                        }
                    }
                    ;
                }
                if (styleIndex >= 0 && styleIndex + 1 < strlen) {
                    styleName = str.substring(styleIndex + 1, sizeIndex);
                    styleName = styleName.toLowerCase();
                    if ((styleName === "bolditalic")) {
                        fontStyle = Font.BOLD | Font.ITALIC;
                    }
                    else if ((styleName === "italic")) {
                        fontStyle = Font.ITALIC;
                    }
                    else if ((styleName === "bold")) {
                        fontStyle = Font.BOLD;
                    }
                    else if ((styleName === "plain")) {
                        fontStyle = Font.PLAIN;
                    }
                    else {
                        styleIndex = sizeIndex;
                        if (str.charAt(styleIndex - 1) === sepChar) {
                            styleIndex--;
                        }
                    }
                    fontName = str.substring(0, styleIndex);
                }
                else {
                    var fontEnd = strlen;
                    if (styleIndex > 0) {
                        fontEnd = styleIndex;
                    }
                    else if (sizeIndex > 0) {
                        fontEnd = sizeIndex;
                    }
                    if (fontEnd > 0 && str.charAt(fontEnd - 1) === sepChar) {
                        fontEnd--;
                    }
                    fontName = str.substring(0, fontEnd);
                }
                return new Font(fontName, fontStyle, fontSize);
            };
            Font.getFont = function (nm, font) {
                if (font === void 0) { font = null; }
                var str = null;
                try {
                    str = java.lang.System.getProperty(nm);
                }
                catch (e) {
                }
                ;
                if (str == null) {
                    return font;
                }
                return Font.decode(str);
            };
            Font.prototype.hashCode = function () {
                if (this.hash === 0) {
                    this.hash = this.name.toString() ^ this.style ^ this.size;
                }
                return this.hash;
            };
            Font.prototype.equals = function (obj) {
                if (obj === this) {
                    return true;
                }
                if (obj != null) {
                    try {
                        var font = obj;
                        if (this.size === font.size && this.style === font.style && this.pointSize === font.pointSize && (this.name === font.name)) {
                            return true;
                        }
                    }
                    catch (e) {
                    }
                    ;
                }
                return false;
            };
            /**
             * Converts this <code>Font</code> object to a <code>String</code>
             * representation.
             *
             * @return a <code>String</code> representation of this <code>Font</code>
             * object.
             * @since JDK1.0
             */
            Font.prototype.toString = function () {
                var strStyle;
                if (this.isBold()) {
                    strStyle = this.isItalic() ? "bolditalic" : "bold";
                }
                else {
                    strStyle = this.isItalic() ? "italic" : "plain";
                }
                return (function (c) { return c["__class"] ? c["__class"] : c.name; })(this.constructor) + "[family=" + this.getFamily() + ",name=" + this.name + ",style=" + strStyle + ",size=" + this.size + "]";
            };
            /**
             * A String constant for the canonical family name of the logical font
             * "Dialog". It is useful in Font construction to provide compile-time
             * verification of the name.
             *
             * @since 1.6
             */
            Font.DIALOG = "Dialog";
            /**
             * A String constant for the canonical family name of the logical font
             * "DialogInput". It is useful in Font construction to provide compile-time
             * verification of the name.
             *
             * @since 1.6
             */
            Font.DIALOG_INPUT = "DialogInput";
            /**
             * A String constant for the canonical family name of the logical font
             * "SansSerif". It is useful in Font construction to provide compile-time
             * verification of the name.
             *
             * @since 1.6
             */
            Font.SANS_SERIF = "SansSerif";
            /**
             * A String constant for the canonical family name of the logical font
             * "Serif". It is useful in Font construction to provide compile-time
             * verification of the name.
             *
             * @since 1.6
             */
            Font.SERIF = "Serif";
            /**
             * A String constant for the canonical family name of the logical font
             * "Monospaced". It is useful in Font construction to provide compile-time
             * verification of the name.
             *
             * @since 1.6
             */
            Font.MONOSPACED = "Monospaced";
            /**
             * The plain style constant.
             */
            Font.PLAIN = 0;
            /**
             * The bold style constant. This can be combined with the other style
             * constants (except PLAIN) for mixed styles.
             */
            Font.BOLD = 1;
            /**
             * The italicized style constant. This can be combined with the other style
             * constants (except PLAIN) for mixed styles.
             */
            Font.ITALIC = 2;
            /**
             * The baseline used in most Roman scripts when laying out text.
             */
            Font.ROMAN_BASELINE = 0;
            /**
             * The baseline used in ideographic scripts like Chinese, Japanese, and
             * Korean when laying out text.
             */
            Font.CENTER_BASELINE = 1;
            /**
             * The baseline used in Devanigiri and similar scripts when laying out text.
             */
            Font.HANGING_BASELINE = 2;
            /**
             * Identify a font resource of type TRUETYPE. Used to specify a TrueType
             * font resource to the {@link #createFont} method. The TrueType format was
             * extended to become the OpenType format, which adds support for fonts with
             * Postscript outlines, this tag therefore references these fonts, as well
             * as those with TrueType outlines.
             *
             * @since 1.3
             */
            Font.TRUETYPE_FONT = 0;
            /**
             * Identify a font resource of type TYPE1. Used to specify a Type1 font
             * resource to the {@link #createFont} method.
             *
             * @since 1.5
             */
            Font.TYPE1_FONT = 1;
            Font.serialVersionUID = -4206021311591459213;
            /**
             * A flag to layoutGlyphVector indicating that text is left-to-right as
             * determined by Bidi analysis.
             */
            Font.LAYOUT_LEFT_TO_RIGHT = 0;
            /**
             * A flag to layoutGlyphVector indicating that text is right-to-left as
             * determined by Bidi analysis.
             */
            Font.LAYOUT_RIGHT_TO_LEFT = 1;
            /**
             * A flag to layoutGlyphVector indicating that text in the char array before
             * the indicated start should not be examined.
             */
            Font.LAYOUT_NO_START_CONTEXT = 2;
            /**
             * A flag to layoutGlyphVector indicating that text in the char array after
             * the indicated limit should not be examined.
             */
            Font.LAYOUT_NO_LIMIT_CONTEXT = 4;
            return Font;
        }());
        awt.Font = Font;
        Font["__class"] = "java.awt.Font";
        Font["__interfaces"] = ["java.io.Serializable"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>AffineTransform</code> class represents a 2D affine transform
             * that performs a linear mapping from 2D coordinates to other 2D
             * coordinates that preserves the "straightness" and
             * "parallelness" of lines.  Affine transformations can be constructed
             * using sequences of translations, scales, flips, rotations, and shears.
             * <p>
             * Such a coordinate transformation can be represented by a 3 row by
             * 3 column matrix with an implied last row of [ 0 0 1 ].  This matrix
             * transforms source coordinates {@code (x,y)} into
             * destination coordinates {@code (x',y')} by considering
             * them to be a column vector and multiplying the coordinate vector
             * by the matrix according to the following process:
             * <pre>
             * [ x']   [  m00  m01  m02  ] [ x ]   [ m00x + m01y + m02 ]
             * [ y'] = [  m10  m11  m12  ] [ y ] = [ m10x + m11y + m12 ]
             * [ 1 ]   [   0    0    1   ] [ 1 ]   [         1         ]
             * </pre>
             * <h3><a name="quadrantapproximation">Handling 90-Degree Rotations</a></h3>
             * <p>
             * In some variations of the <code>rotate</code> methods in the
             * <code>AffineTransform</code> class, a double-precision argument
             * specifies the angle of rotation in radians.
             * These methods have special handling for rotations of approximately
             * 90 degrees (including multiples such as 180, 270, and 360 degrees),
             * so that the common case of quadrant rotation is handled more
             * efficiently.
             * This special handling can cause angles very close to multiples of
             * 90 degrees to be treated as if they were exact multiples of
             * 90 degrees.
             * For small multiples of 90 degrees the range of angles treated
             * as a quadrant rotation is approximately 0.00000121 degrees wide.
             * This section explains why such special care is needed and how
             * it is implemented.
             * <p>
             * Since 90 degrees is represented as <code>PI/2</code> in radians,
             * and since PI is a transcendental (and therefore irrational) number,
             * it is not possible to exactly represent a multiple of 90 degrees as
             * an exact double precision value measured in radians.
             * As a result it is theoretically impossible to describe quadrant
             * rotations (90, 180, 270 or 360 degrees) using these values.
             * Double precision floating point values can get very close to
             * non-zero multiples of <code>PI/2</code> but never close enough
             * for the sine or cosine to be exactly 0.0, 1.0 or -1.0.
             * The implementations of <code>Math.sin()</code> and
             * <code>Math.cos()</code> correspondingly never return 0.0
             * for any case other than <code>Math.sin(0.0)</code>.
             * These same implementations do, however, return exactly 1.0 and
             * -1.0 for some range of numbers around each multiple of 90
             * degrees since the correct answer is so close to 1.0 or -1.0 that
             * the double precision significand cannot represent the difference
             * as accurately as it can for numbers that are near 0.0.
             * <p>
             * The net result of these issues is that if the
             * <code>Math.sin()</code> and <code>Math.cos()</code> methods
             * are used to directly generate the values for the matrix modifications
             * during these radian-based rotation operations then the resulting
             * transform is never strictly classifiable as a quadrant rotation
             * even for a simple case like <code>rotate(Math.PI/2.0)</code>,
             * due to minor variations in the matrix caused by the non-0.0 values
             * obtained for the sine and cosine.
             * If these transforms are not classified as quadrant rotations then
             * subsequent code which attempts to optimize further operations based
             * upon the type of the transform will be relegated to its most general
             * implementation.
             * <p>
             * Because quadrant rotations are fairly common,
             * this class should handle these cases reasonably quickly, both in
             * applying the rotations to the transform and in applying the resulting
             * transform to the coordinates.
             * To facilitate this optimal handling, the methods which take an angle
             * of rotation measured in radians attempt to detect angles that are
             * intended to be quadrant rotations and treat them as such.
             * These methods therefore treat an angle <em>theta</em> as a quadrant
             * rotation if either <code>Math.sin(<em>theta</em>)</code> or
             * <code>Math.cos(<em>theta</em>)</code> returns exactly 1.0 or -1.0.
             * As a rule of thumb, this property holds true for a range of
             * approximately 0.0000000211 radians (or 0.00000121 degrees) around
             * small multiples of <code>Math.PI/2.0</code>.
             *
             * @author Jim Graham
             * @since 1.2
             */
            var AffineTransform = (function () {
                function AffineTransform(m00, m10, m01, m11, m02, m12, state) {
                    var _this = this;
                    if (((typeof m00 === 'number') || m00 === null) && ((typeof m10 === 'number') || m10 === null) && ((typeof m01 === 'number') || m01 === null) && ((typeof m11 === 'number') || m11 === null) && ((typeof m02 === 'number') || m02 === null) && ((typeof m12 === 'number') || m12 === null) && ((typeof state === 'number') || state === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        this.m00 = 0;
                        this.m10 = 0;
                        this.m01 = 0;
                        this.m11 = 0;
                        this.m02 = 0;
                        this.m12 = 0;
                        this.state = 0;
                        this.type = 0;
                        (function () {
                            _this.m00 = m00;
                            _this.m10 = m10;
                            _this.m01 = m01;
                            _this.m11 = m11;
                            _this.m02 = m02;
                            _this.m12 = m12;
                            _this.state = state;
                            _this.type = AffineTransform.TYPE_UNKNOWN;
                        })();
                    }
                    else if (((typeof m00 === 'number') || m00 === null) && ((typeof m10 === 'number') || m10 === null) && ((typeof m01 === 'number') || m01 === null) && ((typeof m11 === 'number') || m11 === null) && ((typeof m02 === 'number') || m02 === null) && ((typeof m12 === 'number') || m12 === null) && state === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        this.m00 = 0;
                        this.m10 = 0;
                        this.m01 = 0;
                        this.m11 = 0;
                        this.m02 = 0;
                        this.m12 = 0;
                        this.state = 0;
                        this.type = 0;
                        (function () {
                            _this.m00 = m00;
                            _this.m10 = m10;
                            _this.m01 = m01;
                            _this.m11 = m11;
                            _this.m02 = m02;
                            _this.m12 = m12;
                            _this.updateState();
                        })();
                    }
                    else if (((typeof m00 === 'number') || m00 === null) && ((typeof m10 === 'number') || m10 === null) && ((typeof m01 === 'number') || m01 === null) && ((typeof m11 === 'number') || m11 === null) && ((typeof m02 === 'number') || m02 === null) && ((typeof m12 === 'number') || m12 === null) && state === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        this.m00 = 0;
                        this.m10 = 0;
                        this.m01 = 0;
                        this.m11 = 0;
                        this.m02 = 0;
                        this.m12 = 0;
                        this.state = 0;
                        this.type = 0;
                        (function () {
                            _this.m00 = m00;
                            _this.m10 = m10;
                            _this.m01 = m01;
                            _this.m11 = m11;
                            _this.m02 = m02;
                            _this.m12 = m12;
                            _this.updateState();
                        })();
                    }
                    else if (((m00 != null && m00 instanceof java.awt.geom.AffineTransform) || m00 === null) && m10 === undefined && m01 === undefined && m11 === undefined && m02 === undefined && m12 === undefined && state === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        var Tx_1 = __args[0];
                        this.m00 = 0;
                        this.m10 = 0;
                        this.m01 = 0;
                        this.m11 = 0;
                        this.m02 = 0;
                        this.m12 = 0;
                        this.state = 0;
                        this.type = 0;
                        (function () {
                            _this.m00 = Tx_1.m00;
                            _this.m10 = Tx_1.m10;
                            _this.m01 = Tx_1.m01;
                            _this.m11 = Tx_1.m11;
                            _this.m02 = Tx_1.m02;
                            _this.m12 = Tx_1.m12;
                            _this.state = Tx_1.state;
                            _this.type = Tx_1.type;
                        })();
                    }
                    else if (((m00 != null && m00 instanceof Array) || m00 === null) && m10 === undefined && m01 === undefined && m11 === undefined && m02 === undefined && m12 === undefined && state === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        var flatmatrix_1 = __args[0];
                        this.m00 = 0;
                        this.m10 = 0;
                        this.m01 = 0;
                        this.m11 = 0;
                        this.m02 = 0;
                        this.m12 = 0;
                        this.state = 0;
                        this.type = 0;
                        (function () {
                            _this.m00 = flatmatrix_1[0];
                            _this.m10 = flatmatrix_1[1];
                            _this.m01 = flatmatrix_1[2];
                            _this.m11 = flatmatrix_1[3];
                            if (flatmatrix_1.length > 5) {
                                _this.m02 = flatmatrix_1[4];
                                _this.m12 = flatmatrix_1[5];
                            }
                            _this.updateState();
                        })();
                    }
                    else if (((m00 != null && m00 instanceof Array) || m00 === null) && m10 === undefined && m01 === undefined && m11 === undefined && m02 === undefined && m12 === undefined && state === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        var flatmatrix_2 = __args[0];
                        this.m00 = 0;
                        this.m10 = 0;
                        this.m01 = 0;
                        this.m11 = 0;
                        this.m02 = 0;
                        this.m12 = 0;
                        this.state = 0;
                        this.type = 0;
                        (function () {
                            _this.m00 = flatmatrix_2[0];
                            _this.m10 = flatmatrix_2[1];
                            _this.m01 = flatmatrix_2[2];
                            _this.m11 = flatmatrix_2[3];
                            if (flatmatrix_2.length > 5) {
                                _this.m02 = flatmatrix_2[4];
                                _this.m12 = flatmatrix_2[5];
                            }
                            _this.updateState();
                        })();
                    }
                    else if (m00 === undefined && m10 === undefined && m01 === undefined && m11 === undefined && m02 === undefined && m12 === undefined && state === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        this.m00 = 0;
                        this.m10 = 0;
                        this.m01 = 0;
                        this.m11 = 0;
                        this.m02 = 0;
                        this.m12 = 0;
                        this.state = 0;
                        this.type = 0;
                        (function () {
                            _this.m00 = _this.m11 = 1.0;
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                AffineTransform.TYPE_MASK_SCALE_$LI$ = function () { if (AffineTransform.TYPE_MASK_SCALE == null)
                    AffineTransform.TYPE_MASK_SCALE = (AffineTransform.TYPE_UNIFORM_SCALE | AffineTransform.TYPE_GENERAL_SCALE); return AffineTransform.TYPE_MASK_SCALE; };
                ;
                AffineTransform.TYPE_MASK_ROTATION_$LI$ = function () { if (AffineTransform.TYPE_MASK_ROTATION == null)
                    AffineTransform.TYPE_MASK_ROTATION = (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_GENERAL_ROTATION); return AffineTransform.TYPE_MASK_ROTATION; };
                ;
                AffineTransform.HI_IDENTITY_$LI$ = function () { if (AffineTransform.HI_IDENTITY == null)
                    AffineTransform.HI_IDENTITY = AffineTransform.APPLY_IDENTITY << AffineTransform.HI_SHIFT; return AffineTransform.HI_IDENTITY; };
                ;
                AffineTransform.HI_TRANSLATE_$LI$ = function () { if (AffineTransform.HI_TRANSLATE == null)
                    AffineTransform.HI_TRANSLATE = AffineTransform.APPLY_TRANSLATE << AffineTransform.HI_SHIFT; return AffineTransform.HI_TRANSLATE; };
                ;
                AffineTransform.HI_SCALE_$LI$ = function () { if (AffineTransform.HI_SCALE == null)
                    AffineTransform.HI_SCALE = AffineTransform.APPLY_SCALE << AffineTransform.HI_SHIFT; return AffineTransform.HI_SCALE; };
                ;
                AffineTransform.HI_SHEAR_$LI$ = function () { if (AffineTransform.HI_SHEAR == null)
                    AffineTransform.HI_SHEAR = AffineTransform.APPLY_SHEAR << AffineTransform.HI_SHIFT; return AffineTransform.HI_SHEAR; };
                ;
                /**
                 * Returns a transform representing a translation transformation.
                 * The matrix representing the returned transform is:
                 * <pre>
                 * [   1    0    tx  ]
                 * [   0    1    ty  ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param tx the distance by which coordinates are translated in the
                 * X axis direction
                 * @param ty the distance by which coordinates are translated in the
                 * Y axis direction
                 * @return an <code>AffineTransform</code> object that represents a
                 * translation transformation, created with the specified vector.
                 * @since 1.2
                 */
                AffineTransform.getTranslateInstance = function (tx, ty) {
                    var Tx = new AffineTransform();
                    Tx.setToTranslation(tx, ty);
                    return Tx;
                };
                /**
                 * Returns a transform representing a rotation transformation.
                 * The matrix representing the returned transform is:
                 * <pre>
                 * [   cos(theta)    -sin(theta)    0   ]
                 * [   sin(theta)     cos(theta)    0   ]
                 * [       0              0         1   ]
                 * </pre>
                 * Rotating by a positive angle theta rotates points on the positive
                 * X axis toward the positive Y axis.
                 * Note also the discussion of
                 * <a href="#quadrantapproximation">Handling 90-Degree Rotations</a>
                 * above.
                 * @param theta the angle of rotation measured in radians
                 * @return an <code>AffineTransform</code> object that is a rotation
                 * transformation, created with the specified angle of rotation.
                 * @since 1.2
                 */
                AffineTransform.getRotateInstance$double = function (theta) {
                    var Tx = new AffineTransform();
                    Tx.setToRotation(theta);
                    return Tx;
                };
                /**
                 * Returns a transform that rotates coordinates around an anchor point.
                 * This operation is equivalent to translating the coordinates so
                 * that the anchor point is at the origin (S1), then rotating them
                 * about the new origin (S2), and finally translating so that the
                 * intermediate origin is restored to the coordinates of the original
                 * anchor point (S3).
                 * <p>
                 * This operation is equivalent to the following sequence of calls:
                 * <pre>
                 * AffineTransform Tx = new AffineTransform();
                 * Tx.translate(anchorx, anchory);    // S3: final translation
                 * Tx.rotate(theta);                  // S2: rotate around anchor
                 * Tx.translate(-anchorx, -anchory);  // S1: translate anchor to origin
                 * </pre>
                 * The matrix representing the returned transform is:
                 * <pre>
                 * [   cos(theta)    -sin(theta)    x-x*cos+y*sin  ]
                 * [   sin(theta)     cos(theta)    y-x*sin-y*cos  ]
                 * [       0              0               1        ]
                 * </pre>
                 * Rotating by a positive angle theta rotates points on the positive
                 * X axis toward the positive Y axis.
                 * Note also the discussion of
                 * <a href="#quadrantapproximation">Handling 90-Degree Rotations</a>
                 * above.
                 *
                 * @param theta the angle of rotation measured in radians
                 * @param anchorx the X coordinate of the rotation anchor point
                 * @param anchory the Y coordinate of the rotation anchor point
                 * @return an <code>AffineTransform</code> object that rotates
                 * coordinates around the specified point by the specified angle of
                 * rotation.
                 * @since 1.2
                 */
                AffineTransform.getRotateInstance$double$double$double = function (theta, anchorx, anchory) {
                    var Tx = new AffineTransform();
                    Tx.setToRotation(theta, anchorx, anchory);
                    return Tx;
                };
                /**
                 * Returns a transform that rotates coordinates according to
                 * a rotation vector.
                 * All coordinates rotate about the origin by the same amount.
                 * The amount of rotation is such that coordinates along the former
                 * positive X axis will subsequently align with the vector pointing
                 * from the origin to the specified vector coordinates.
                 * If both <code>vecx</code> and <code>vecy</code> are 0.0,
                 * an identity transform is returned.
                 * This operation is equivalent to calling:
                 * <pre>
                 * AffineTransform.getRotateInstance(Math.atan2(vecy, vecx));
                 * </pre>
                 *
                 * @param vecx the X coordinate of the rotation vector
                 * @param vecy the Y coordinate of the rotation vector
                 * @return an <code>AffineTransform</code> object that rotates
                 * coordinates according to the specified rotation vector.
                 * @since 1.6
                 */
                AffineTransform.getRotateInstance$double$double = function (vecx, vecy) {
                    var Tx = new AffineTransform();
                    Tx.setToRotation(vecx, vecy);
                    return Tx;
                };
                /**
                 * Returns a transform that rotates coordinates around an anchor
                 * point according to a rotation vector.
                 * All coordinates rotate about the specified anchor coordinates
                 * by the same amount.
                 * The amount of rotation is such that coordinates along the former
                 * positive X axis will subsequently align with the vector pointing
                 * from the origin to the specified vector coordinates.
                 * If both <code>vecx</code> and <code>vecy</code> are 0.0,
                 * an identity transform is returned.
                 * This operation is equivalent to calling:
                 * <pre>
                 * AffineTransform.getRotateInstance(Math.atan2(vecy, vecx),
                 * anchorx, anchory);
                 * </pre>
                 *
                 * @param vecx the X coordinate of the rotation vector
                 * @param vecy the Y coordinate of the rotation vector
                 * @param anchorx the X coordinate of the rotation anchor point
                 * @param anchory the Y coordinate of the rotation anchor point
                 * @return an <code>AffineTransform</code> object that rotates
                 * coordinates around the specified point according to the
                 * specified rotation vector.
                 * @since 1.6
                 */
                AffineTransform.getRotateInstance = function (vecx, vecy, anchorx, anchory) {
                    if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && ((typeof anchorx === 'number') || anchorx === null) && ((typeof anchory === 'number') || anchory === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            var Tx = new AffineTransform();
                            Tx.setToRotation(vecx, vecy, anchorx, anchory);
                            return Tx;
                        })();
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && ((typeof anchorx === 'number') || anchorx === null) && anchory === undefined) {
                        return java.awt.geom.AffineTransform.getRotateInstance$double$double$double(vecx, vecy, anchorx);
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && anchorx === undefined && anchory === undefined) {
                        return java.awt.geom.AffineTransform.getRotateInstance$double$double(vecx, vecy);
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && vecy === undefined && anchorx === undefined && anchory === undefined) {
                        return java.awt.geom.AffineTransform.getRotateInstance$double(vecx);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns a transform that rotates coordinates by the specified
                 * number of quadrants.
                 * This operation is equivalent to calling:
                 * <pre>
                 * AffineTransform.getRotateInstance(numquadrants * Math.PI / 2.0);
                 * </pre>
                 * Rotating by a positive number of quadrants rotates points on
                 * the positive X axis toward the positive Y axis.
                 * @param numquadrants the number of 90 degree arcs to rotate by
                 * @return an <code>AffineTransform</code> object that rotates
                 * coordinates by the specified number of quadrants.
                 * @since 1.6
                 */
                AffineTransform.getQuadrantRotateInstance$int = function (numquadrants) {
                    var Tx = new AffineTransform();
                    Tx.setToQuadrantRotation(numquadrants);
                    return Tx;
                };
                /**
                 * Returns a transform that rotates coordinates by the specified
                 * number of quadrants around the specified anchor point.
                 * This operation is equivalent to calling:
                 * <pre>
                 * AffineTransform.getRotateInstance(numquadrants * Math.PI / 2.0,
                 * anchorx, anchory);
                 * </pre>
                 * Rotating by a positive number of quadrants rotates points on
                 * the positive X axis toward the positive Y axis.
                 *
                 * @param numquadrants the number of 90 degree arcs to rotate by
                 * @param anchorx the X coordinate of the rotation anchor point
                 * @param anchory the Y coordinate of the rotation anchor point
                 * @return an <code>AffineTransform</code> object that rotates
                 * coordinates by the specified number of quadrants around the
                 * specified anchor point.
                 * @since 1.6
                 */
                AffineTransform.getQuadrantRotateInstance = function (numquadrants, anchorx, anchory) {
                    if (((typeof numquadrants === 'number') || numquadrants === null) && ((typeof anchorx === 'number') || anchorx === null) && ((typeof anchory === 'number') || anchory === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            var Tx = new AffineTransform();
                            Tx.setToQuadrantRotation(numquadrants, anchorx, anchory);
                            return Tx;
                        })();
                    }
                    else if (((typeof numquadrants === 'number') || numquadrants === null) && anchorx === undefined && anchory === undefined) {
                        return java.awt.geom.AffineTransform.getQuadrantRotateInstance$int(numquadrants);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns a transform representing a scaling transformation.
                 * The matrix representing the returned transform is:
                 * <pre>
                 * [   sx   0    0   ]
                 * [   0    sy   0   ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param sx the factor by which coordinates are scaled along the
                 * X axis direction
                 * @param sy the factor by which coordinates are scaled along the
                 * Y axis direction
                 * @return an <code>AffineTransform</code> object that scales
                 * coordinates by the specified factors.
                 * @since 1.2
                 */
                AffineTransform.getScaleInstance = function (sx, sy) {
                    var Tx = new AffineTransform();
                    Tx.setToScale(sx, sy);
                    return Tx;
                };
                /**
                 * Returns a transform representing a shearing transformation.
                 * The matrix representing the returned transform is:
                 * <pre>
                 * [   1   shx   0   ]
                 * [  shy   1    0   ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param shx the multiplier by which coordinates are shifted in the
                 * direction of the positive X axis as a factor of their Y coordinate
                 * @param shy the multiplier by which coordinates are shifted in the
                 * direction of the positive Y axis as a factor of their X coordinate
                 * @return an <code>AffineTransform</code> object that shears
                 * coordinates by the specified multipliers.
                 * @since 1.2
                 */
                AffineTransform.getShearInstance = function (shx, shy) {
                    var Tx = new AffineTransform();
                    Tx.setToShear(shx, shy);
                    return Tx;
                };
                /**
                 * Retrieves the flag bits describing the conversion properties of
                 * this transform.
                 * The return value is either one of the constants TYPE_IDENTITY
                 * or TYPE_GENERAL_TRANSFORM, or a combination of the
                 * appropriate flag bits.
                 * A valid combination of flag bits is an exclusive OR operation
                 * that can combine
                 * the TYPE_TRANSLATION flag bit
                 * in addition to either of the
                 * TYPE_UNIFORM_SCALE or TYPE_GENERAL_SCALE flag bits
                 * as well as either of the
                 * TYPE_QUADRANT_ROTATION or TYPE_GENERAL_ROTATION flag bits.
                 * @return the OR combination of any of the indicated flags that
                 * apply to this transform
                 * @see #TYPE_IDENTITY
                 * @see #TYPE_TRANSLATION
                 * @see #TYPE_UNIFORM_SCALE
                 * @see #TYPE_GENERAL_SCALE
                 * @see #TYPE_QUADRANT_ROTATION
                 * @see #TYPE_GENERAL_ROTATION
                 * @see #TYPE_GENERAL_TRANSFORM
                 * @since 1.2
                 */
                AffineTransform.prototype.getType = function () {
                    if (this.type === AffineTransform.TYPE_UNKNOWN) {
                        this.calculateType();
                    }
                    return this.type;
                };
                /**
                 * This is the utility function to calculate the flag bits when
                 * they have not been cached.
                 * @see #getType
                 */
                AffineTransform.prototype.calculateType = function () {
                    var ret = AffineTransform.TYPE_IDENTITY;
                    var sgn0;
                    var sgn1;
                    var M0;
                    var M1;
                    var M2;
                    var M3;
                    this.updateState();
                    switch ((this.state)) {
                        default:
                            this.stateError();
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            ret = AffineTransform.TYPE_TRANSLATION;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            if ((M0 = this.m00) * (M2 = this.m01) + (M3 = this.m10) * (M1 = this.m11) !== 0) {
                                this.type = AffineTransform.TYPE_GENERAL_TRANSFORM;
                                return;
                            }
                            sgn0 = (M0 >= 0.0);
                            sgn1 = (M1 >= 0.0);
                            if (sgn0 === sgn1) {
                                if (M0 !== M1 || M2 !== -M3) {
                                    ret |= (AffineTransform.TYPE_GENERAL_ROTATION | AffineTransform.TYPE_GENERAL_SCALE);
                                }
                                else if (M0 * M1 - M2 * M3 !== 1.0) {
                                    ret |= (AffineTransform.TYPE_GENERAL_ROTATION | AffineTransform.TYPE_UNIFORM_SCALE);
                                }
                                else {
                                    ret |= AffineTransform.TYPE_GENERAL_ROTATION;
                                }
                            }
                            else {
                                if (M0 !== -M1 || M2 !== M3) {
                                    ret |= (AffineTransform.TYPE_GENERAL_ROTATION | AffineTransform.TYPE_FLIP | AffineTransform.TYPE_GENERAL_SCALE);
                                }
                                else if (M0 * M1 - M2 * M3 !== 1.0) {
                                    ret |= (AffineTransform.TYPE_GENERAL_ROTATION | AffineTransform.TYPE_FLIP | AffineTransform.TYPE_UNIFORM_SCALE);
                                }
                                else {
                                    ret |= (AffineTransform.TYPE_GENERAL_ROTATION | AffineTransform.TYPE_FLIP);
                                }
                            }
                            break;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            ret = AffineTransform.TYPE_TRANSLATION;
                        case (AffineTransform.APPLY_SHEAR):
                            sgn0 = ((M0 = this.m01) >= 0.0);
                            sgn1 = ((M1 = this.m10) >= 0.0);
                            if (sgn0 !== sgn1) {
                                if (M0 !== -M1) {
                                    ret |= (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_GENERAL_SCALE);
                                }
                                else if (M0 !== 1.0 && M0 !== -1.0) {
                                    ret |= (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_UNIFORM_SCALE);
                                }
                                else {
                                    ret |= AffineTransform.TYPE_QUADRANT_ROTATION;
                                }
                            }
                            else {
                                if (M0 === M1) {
                                    ret |= (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_FLIP | AffineTransform.TYPE_UNIFORM_SCALE);
                                }
                                else {
                                    ret |= (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_FLIP | AffineTransform.TYPE_GENERAL_SCALE);
                                }
                            }
                            break;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            ret = AffineTransform.TYPE_TRANSLATION;
                        case (AffineTransform.APPLY_SCALE):
                            sgn0 = ((M0 = this.m00) >= 0.0);
                            sgn1 = ((M1 = this.m11) >= 0.0);
                            if (sgn0 === sgn1) {
                                if (sgn0) {
                                    if (M0 === M1) {
                                        ret |= AffineTransform.TYPE_UNIFORM_SCALE;
                                    }
                                    else {
                                        ret |= AffineTransform.TYPE_GENERAL_SCALE;
                                    }
                                }
                                else {
                                    if (M0 !== M1) {
                                        ret |= (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_GENERAL_SCALE);
                                    }
                                    else if (M0 !== -1.0) {
                                        ret |= (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_UNIFORM_SCALE);
                                    }
                                    else {
                                        ret |= AffineTransform.TYPE_QUADRANT_ROTATION;
                                    }
                                }
                            }
                            else {
                                if (M0 === -M1) {
                                    if (M0 === 1.0 || M0 === -1.0) {
                                        ret |= AffineTransform.TYPE_FLIP;
                                    }
                                    else {
                                        ret |= (AffineTransform.TYPE_FLIP | AffineTransform.TYPE_UNIFORM_SCALE);
                                    }
                                }
                                else {
                                    ret |= (AffineTransform.TYPE_FLIP | AffineTransform.TYPE_GENERAL_SCALE);
                                }
                            }
                            break;
                        case (AffineTransform.APPLY_TRANSLATE):
                            ret = AffineTransform.TYPE_TRANSLATION;
                            break;
                        case (AffineTransform.APPLY_IDENTITY):
                            break;
                    }
                    this.type = ret;
                };
                /**
                 * Returns the determinant of the matrix representation of the transform.
                 * The determinant is useful both to determine if the transform can
                 * be inverted and to get a single value representing the
                 * combined X and Y scaling of the transform.
                 * <p>
                 * If the determinant is non-zero, then this transform is
                 * invertible and the various methods that depend on the inverse
                 * transform do not need to throw a
                 * {@link NoninvertibleTransformException}.
                 * If the determinant is zero then this transform can not be
                 * inverted since the transform maps all input coordinates onto
                 * a line or a point.
                 * If the determinant is near enough to zero then inverse transform
                 * operations might not carry enough precision to produce meaningful
                 * results.
                 * <p>
                 * If this transform represents a uniform scale, as indicated by
                 * the <code>getType</code> method then the determinant also
                 * represents the square of the uniform scale factor by which all of
                 * the points are expanded from or contracted towards the origin.
                 * If this transform represents a non-uniform scale or more general
                 * transform then the determinant is not likely to represent a
                 * value useful for any purpose other than determining if inverse
                 * transforms are possible.
                 * <p>
                 * Mathematically, the determinant is calculated using the formula:
                 * <pre>
                 * |  m00  m01  m02  |
                 * |  m10  m11  m12  |  =  m00 * m11 - m01 * m10
                 * |   0    0    1   |
                 * </pre>
                 *
                 * @return the determinant of the matrix used to transform the
                 * coordinates.
                 * @see #getType
                 * @see #createInverse
                 * @see #inverseTransform
                 * @see #TYPE_UNIFORM_SCALE
                 * @since 1.2
                 */
                AffineTransform.prototype.getDeterminant = function () {
                    switch ((this.state)) {
                        default:
                            this.stateError();
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            return this.m00 * this.m11 - this.m01 * this.m10;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR):
                            return -(this.m01 * this.m10);
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SCALE):
                            return this.m00 * this.m11;
                        case (AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_IDENTITY):
                            return 1.0;
                    }
                };
                /**
                 * Manually recalculates the state of the transform when the matrix
                 * changes too much to predict the effects on the state.
                 * The following table specifies what the various settings of the
                 * state field say about the values of the corresponding matrix
                 * element fields.
                 * Note that the rules governing the SCALE fields are slightly
                 * different depending on whether the SHEAR flag is also set.
                 * <pre>
                 * SCALE            SHEAR          TRANSLATE
                 * m00/m11          m01/m10          m02/m12
                 *
                 * IDENTITY             1.0              0.0              0.0
                 * TRANSLATE (TR)       1.0              0.0          not both 0.0
                 * SCALE (SC)       not both 1.0         0.0              0.0
                 * TR | SC          not both 1.0         0.0          not both 0.0
                 * SHEAR (SH)           0.0          not both 0.0         0.0
                 * TR | SH              0.0          not both 0.0     not both 0.0
                 * SC | SH          not both 0.0     not both 0.0         0.0
                 * TR | SC | SH     not both 0.0     not both 0.0     not both 0.0
                 * </pre>
                 */
                AffineTransform.prototype.updateState = function () {
                    if (this.m01 === 0.0 && this.m10 === 0.0) {
                        if (this.m00 === 1.0 && this.m11 === 1.0) {
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = AffineTransform.APPLY_IDENTITY;
                                this.type = AffineTransform.TYPE_IDENTITY;
                            }
                            else {
                                this.state = AffineTransform.APPLY_TRANSLATE;
                                this.type = AffineTransform.TYPE_TRANSLATION;
                            }
                        }
                        else {
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = AffineTransform.APPLY_SCALE;
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                            else {
                                this.state = (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE);
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                        }
                    }
                    else {
                        if (this.m00 === 0.0 && this.m11 === 0.0) {
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = AffineTransform.APPLY_SHEAR;
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                            else {
                                this.state = (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE);
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                        }
                        else {
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE);
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                            else {
                                this.state = (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE);
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                        }
                    }
                };
                AffineTransform.prototype.stateError = function () {
                    throw new java.lang.InternalError("missing case in transform state switch");
                };
                /**
                 * Retrieves the 6 specifiable values in the 3x3 affine transformation
                 * matrix and places them into an array of double precisions values.
                 * The values are stored in the array as
                 * {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;m02&nbsp;m12&nbsp;}.
                 * An array of 4 doubles can also be specified, in which case only the
                 * first four elements representing the non-transform
                 * parts of the array are retrieved and the values are stored into
                 * the array as {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;}
                 * @param flatmatrix the double array used to store the returned
                 * values.
                 * @see #getScaleX
                 * @see #getScaleY
                 * @see #getShearX
                 * @see #getShearY
                 * @see #getTranslateX
                 * @see #getTranslateY
                 * @since 1.2
                 */
                AffineTransform.prototype.getMatrix = function (flatmatrix) {
                    flatmatrix[0] = this.m00;
                    flatmatrix[1] = this.m10;
                    flatmatrix[2] = this.m01;
                    flatmatrix[3] = this.m11;
                    if (flatmatrix.length > 5) {
                        flatmatrix[4] = this.m02;
                        flatmatrix[5] = this.m12;
                    }
                };
                /**
                 * Returns the X coordinate scaling element (m00) of the 3x3
                 * affine transformation matrix.
                 * @return a double value that is the X coordinate of the scaling
                 * element of the affine transformation matrix.
                 * @see #getMatrix
                 * @since 1.2
                 */
                AffineTransform.prototype.getScaleX = function () {
                    return this.m00;
                };
                /**
                 * Returns the Y coordinate scaling element (m11) of the 3x3
                 * affine transformation matrix.
                 * @return a double value that is the Y coordinate of the scaling
                 * element of the affine transformation matrix.
                 * @see #getMatrix
                 * @since 1.2
                 */
                AffineTransform.prototype.getScaleY = function () {
                    return this.m11;
                };
                /**
                 * Returns the X coordinate shearing element (m01) of the 3x3
                 * affine transformation matrix.
                 * @return a double value that is the X coordinate of the shearing
                 * element of the affine transformation matrix.
                 * @see #getMatrix
                 * @since 1.2
                 */
                AffineTransform.prototype.getShearX = function () {
                    return this.m01;
                };
                /**
                 * Returns the Y coordinate shearing element (m10) of the 3x3
                 * affine transformation matrix.
                 * @return a double value that is the Y coordinate of the shearing
                 * element of the affine transformation matrix.
                 * @see #getMatrix
                 * @since 1.2
                 */
                AffineTransform.prototype.getShearY = function () {
                    return this.m10;
                };
                /**
                 * Returns the X coordinate of the translation element (m02) of the
                 * 3x3 affine transformation matrix.
                 * @return a double value that is the X coordinate of the translation
                 * element of the affine transformation matrix.
                 * @see #getMatrix
                 * @since 1.2
                 */
                AffineTransform.prototype.getTranslateX = function () {
                    return this.m02;
                };
                /**
                 * Returns the Y coordinate of the translation element (m12) of the
                 * 3x3 affine transformation matrix.
                 * @return a double value that is the Y coordinate of the translation
                 * element of the affine transformation matrix.
                 * @see #getMatrix
                 * @since 1.2
                 */
                AffineTransform.prototype.getTranslateY = function () {
                    return this.m12;
                };
                /**
                 * Concatenates this transform with a translation transformation.
                 * This is equivalent to calling concatenate(T), where T is an
                 * <code>AffineTransform</code> represented by the following matrix:
                 * <pre>
                 * [   1    0    tx  ]
                 * [   0    1    ty  ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param tx the distance by which coordinates are translated in the
                 * X axis direction
                 * @param ty the distance by which coordinates are translated in the
                 * Y axis direction
                 * @since 1.2
                 */
                AffineTransform.prototype.translate = function (tx, ty) {
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            this.m02 = tx * this.m00 + ty * this.m01 + this.m02;
                            this.m12 = tx * this.m10 + ty * this.m11 + this.m12;
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE;
                                if (this.type !== AffineTransform.TYPE_UNKNOWN) {
                                    this.type -= AffineTransform.TYPE_TRANSLATION;
                                }
                            }
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            this.m02 = tx * this.m00 + ty * this.m01;
                            this.m12 = tx * this.m10 + ty * this.m11;
                            if (this.m02 !== 0.0 || this.m12 !== 0.0) {
                                this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE;
                                this.type |= AffineTransform.TYPE_TRANSLATION;
                            }
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            this.m02 = ty * this.m01 + this.m02;
                            this.m12 = tx * this.m10 + this.m12;
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = AffineTransform.APPLY_SHEAR;
                                if (this.type !== AffineTransform.TYPE_UNKNOWN) {
                                    this.type -= AffineTransform.TYPE_TRANSLATION;
                                }
                            }
                            return;
                        case (AffineTransform.APPLY_SHEAR):
                            this.m02 = ty * this.m01;
                            this.m12 = tx * this.m10;
                            if (this.m02 !== 0.0 || this.m12 !== 0.0) {
                                this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE;
                                this.type |= AffineTransform.TYPE_TRANSLATION;
                            }
                            return;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            this.m02 = tx * this.m00 + this.m02;
                            this.m12 = ty * this.m11 + this.m12;
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = AffineTransform.APPLY_SCALE;
                                if (this.type !== AffineTransform.TYPE_UNKNOWN) {
                                    this.type -= AffineTransform.TYPE_TRANSLATION;
                                }
                            }
                            return;
                        case (AffineTransform.APPLY_SCALE):
                            this.m02 = tx * this.m00;
                            this.m12 = ty * this.m11;
                            if (this.m02 !== 0.0 || this.m12 !== 0.0) {
                                this.state = AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE;
                                this.type |= AffineTransform.TYPE_TRANSLATION;
                            }
                            return;
                        case (AffineTransform.APPLY_TRANSLATE):
                            this.m02 = tx + this.m02;
                            this.m12 = ty + this.m12;
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = AffineTransform.APPLY_IDENTITY;
                                this.type = AffineTransform.TYPE_IDENTITY;
                            }
                            return;
                        case (AffineTransform.APPLY_IDENTITY):
                            this.m02 = tx;
                            this.m12 = ty;
                            if (tx !== 0.0 || ty !== 0.0) {
                                this.state = AffineTransform.APPLY_TRANSLATE;
                                this.type = AffineTransform.TYPE_TRANSLATION;
                            }
                            return;
                    }
                };
                AffineTransform.rot90conversion_$LI$ = function () { if (AffineTransform.rot90conversion == null)
                    AffineTransform.rot90conversion = [AffineTransform.APPLY_SHEAR, AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE, AffineTransform.APPLY_SHEAR, AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE, AffineTransform.APPLY_SCALE, AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE, AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE, AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE]; return AffineTransform.rot90conversion; };
                ;
                AffineTransform.prototype.rotate90 = function () {
                    var M0 = this.m00;
                    this.m00 = this.m01;
                    this.m01 = -M0;
                    M0 = this.m10;
                    this.m10 = this.m11;
                    this.m11 = -M0;
                    var state = AffineTransform.rot90conversion_$LI$()[this.state];
                    if ((state & (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE)) === AffineTransform.APPLY_SCALE && this.m00 === 1.0 && this.m11 === 1.0) {
                        state -= AffineTransform.APPLY_SCALE;
                    }
                    this.state = state;
                    this.type = AffineTransform.TYPE_UNKNOWN;
                };
                AffineTransform.prototype.rotate180 = function () {
                    this.m00 = -this.m00;
                    this.m11 = -this.m11;
                    var state = this.state;
                    if ((state & (AffineTransform.APPLY_SHEAR)) !== 0) {
                        this.m01 = -this.m01;
                        this.m10 = -this.m10;
                    }
                    else {
                        if (this.m00 === 1.0 && this.m11 === 1.0) {
                            this.state = state & ~AffineTransform.APPLY_SCALE;
                        }
                        else {
                            this.state = state | AffineTransform.APPLY_SCALE;
                        }
                    }
                    this.type = AffineTransform.TYPE_UNKNOWN;
                };
                AffineTransform.prototype.rotate270 = function () {
                    var M0 = this.m00;
                    this.m00 = -this.m01;
                    this.m01 = M0;
                    M0 = this.m10;
                    this.m10 = -this.m11;
                    this.m11 = M0;
                    var state = AffineTransform.rot90conversion_$LI$()[this.state];
                    if ((state & (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE)) === AffineTransform.APPLY_SCALE && this.m00 === 1.0 && this.m11 === 1.0) {
                        state -= AffineTransform.APPLY_SCALE;
                    }
                    this.state = state;
                    this.type = AffineTransform.TYPE_UNKNOWN;
                };
                /**
                 * Concatenates this transform with a rotation transformation.
                 * This is equivalent to calling concatenate(R), where R is an
                 * <code>AffineTransform</code> represented by the following matrix:
                 * <pre>
                 * [   cos(theta)    -sin(theta)    0   ]
                 * [   sin(theta)     cos(theta)    0   ]
                 * [       0              0         1   ]
                 * </pre>
                 * Rotating by a positive angle theta rotates points on the positive
                 * X axis toward the positive Y axis.
                 * Note also the discussion of
                 * <a href="#quadrantapproximation">Handling 90-Degree Rotations</a>
                 * above.
                 * @param theta the angle of rotation measured in radians
                 * @since 1.2
                 */
                AffineTransform.prototype.rotate$double = function (theta) {
                    var sin = Math.sin(theta);
                    if (sin === 1.0) {
                        this.rotate90();
                    }
                    else if (sin === -1.0) {
                        this.rotate270();
                    }
                    else {
                        var cos = Math.cos(theta);
                        if (cos === -1.0) {
                            this.rotate180();
                        }
                        else if (cos !== 1.0) {
                            var M0 = void 0;
                            var M1 = void 0;
                            M0 = this.m00;
                            M1 = this.m01;
                            this.m00 = cos * M0 + sin * M1;
                            this.m01 = -sin * M0 + cos * M1;
                            M0 = this.m10;
                            M1 = this.m11;
                            this.m10 = cos * M0 + sin * M1;
                            this.m11 = -sin * M0 + cos * M1;
                            this.updateState();
                        }
                    }
                };
                /**
                 * Concatenates this transform with a transform that rotates
                 * coordinates around an anchor point.
                 * This operation is equivalent to translating the coordinates so
                 * that the anchor point is at the origin (S1), then rotating them
                 * about the new origin (S2), and finally translating so that the
                 * intermediate origin is restored to the coordinates of the original
                 * anchor point (S3).
                 * <p>
                 * This operation is equivalent to the following sequence of calls:
                 * <pre>
                 * translate(anchorx, anchory);      // S3: final translation
                 * rotate(theta);                    // S2: rotate around anchor
                 * translate(-anchorx, -anchory);    // S1: translate anchor to origin
                 * </pre>
                 * Rotating by a positive angle theta rotates points on the positive
                 * X axis toward the positive Y axis.
                 * Note also the discussion of
                 * <a href="#quadrantapproximation">Handling 90-Degree Rotations</a>
                 * above.
                 *
                 * @param theta the angle of rotation measured in radians
                 * @param anchorx the X coordinate of the rotation anchor point
                 * @param anchory the Y coordinate of the rotation anchor point
                 * @since 1.2
                 */
                AffineTransform.prototype.rotate$double$double$double = function (theta, anchorx, anchory) {
                    this.translate(anchorx, anchory);
                    this.rotate(theta);
                    this.translate(-anchorx, -anchory);
                };
                /**
                 * Concatenates this transform with a transform that rotates
                 * coordinates according to a rotation vector.
                 * All coordinates rotate about the origin by the same amount.
                 * The amount of rotation is such that coordinates along the former
                 * positive X axis will subsequently align with the vector pointing
                 * from the origin to the specified vector coordinates.
                 * If both <code>vecx</code> and <code>vecy</code> are 0.0,
                 * no additional rotation is added to this transform.
                 * This operation is equivalent to calling:
                 * <pre>
                 * rotate(Math.atan2(vecy, vecx));
                 * </pre>
                 *
                 * @param vecx the X coordinate of the rotation vector
                 * @param vecy the Y coordinate of the rotation vector
                 * @since 1.6
                 */
                AffineTransform.prototype.rotate$double$double = function (vecx, vecy) {
                    if (vecy === 0.0) {
                        if (vecx < 0.0) {
                            this.rotate180();
                        }
                    }
                    else if (vecx === 0.0) {
                        if (vecy > 0.0) {
                            this.rotate90();
                        }
                        else {
                            this.rotate270();
                        }
                    }
                    else {
                        var len = Math.sqrt(vecx * vecx + vecy * vecy);
                        var sin = vecy / len;
                        var cos = vecx / len;
                        var M0 = void 0;
                        var M1 = void 0;
                        M0 = this.m00;
                        M1 = this.m01;
                        this.m00 = cos * M0 + sin * M1;
                        this.m01 = -sin * M0 + cos * M1;
                        M0 = this.m10;
                        M1 = this.m11;
                        this.m10 = cos * M0 + sin * M1;
                        this.m11 = -sin * M0 + cos * M1;
                        this.updateState();
                    }
                };
                /**
                 * Concatenates this transform with a transform that rotates
                 * coordinates around an anchor point according to a rotation
                 * vector.
                 * All coordinates rotate about the specified anchor coordinates
                 * by the same amount.
                 * The amount of rotation is such that coordinates along the former
                 * positive X axis will subsequently align with the vector pointing
                 * from the origin to the specified vector coordinates.
                 * If both <code>vecx</code> and <code>vecy</code> are 0.0,
                 * the transform is not modified in any way.
                 * This method is equivalent to calling:
                 * <pre>
                 * rotate(Math.atan2(vecy, vecx), anchorx, anchory);
                 * </pre>
                 *
                 * @param vecx the X coordinate of the rotation vector
                 * @param vecy the Y coordinate of the rotation vector
                 * @param anchorx the X coordinate of the rotation anchor point
                 * @param anchory the Y coordinate of the rotation anchor point
                 * @since 1.6
                 */
                AffineTransform.prototype.rotate = function (vecx, vecy, anchorx, anchory) {
                    var _this = this;
                    if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && ((typeof anchorx === 'number') || anchorx === null) && ((typeof anchory === 'number') || anchory === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            _this.translate(anchorx, anchory);
                            _this.rotate(vecx, vecy);
                            _this.translate(-anchorx, -anchory);
                        })();
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && ((typeof anchorx === 'number') || anchorx === null) && anchory === undefined) {
                        return this.rotate$double$double$double(vecx, vecy, anchorx);
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && anchorx === undefined && anchory === undefined) {
                        return this.rotate$double$double(vecx, vecy);
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && vecy === undefined && anchorx === undefined && anchory === undefined) {
                        return this.rotate$double(vecx);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Concatenates this transform with a transform that rotates
                 * coordinates by the specified number of quadrants.
                 * This is equivalent to calling:
                 * <pre>
                 * rotate(numquadrants * Math.PI / 2.0);
                 * </pre>
                 * Rotating by a positive number of quadrants rotates points on
                 * the positive X axis toward the positive Y axis.
                 * @param numquadrants the number of 90 degree arcs to rotate by
                 * @since 1.6
                 */
                AffineTransform.prototype.quadrantRotate$int = function (numquadrants) {
                    switch ((numquadrants & 3)) {
                        case 0:
                            break;
                        case 1:
                            this.rotate90();
                            break;
                        case 2:
                            this.rotate180();
                            break;
                        case 3:
                            this.rotate270();
                            break;
                    }
                };
                /**
                 * Concatenates this transform with a transform that rotates
                 * coordinates by the specified number of quadrants around
                 * the specified anchor point.
                 * This method is equivalent to calling:
                 * <pre>
                 * rotate(numquadrants * Math.PI / 2.0, anchorx, anchory);
                 * </pre>
                 * Rotating by a positive number of quadrants rotates points on
                 * the positive X axis toward the positive Y axis.
                 *
                 * @param numquadrants the number of 90 degree arcs to rotate by
                 * @param anchorx the X coordinate of the rotation anchor point
                 * @param anchory the Y coordinate of the rotation anchor point
                 * @since 1.6
                 */
                AffineTransform.prototype.quadrantRotate = function (numquadrants, anchorx, anchory) {
                    var _this = this;
                    if (((typeof numquadrants === 'number') || numquadrants === null) && ((typeof anchorx === 'number') || anchorx === null) && ((typeof anchory === 'number') || anchory === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            switch ((numquadrants & 3)) {
                                case 0:
                                    return;
                                case 1:
                                    _this.m02 += anchorx * (_this.m00 - _this.m01) + anchory * (_this.m01 + _this.m00);
                                    _this.m12 += anchorx * (_this.m10 - _this.m11) + anchory * (_this.m11 + _this.m10);
                                    _this.rotate90();
                                    break;
                                case 2:
                                    _this.m02 += anchorx * (_this.m00 + _this.m00) + anchory * (_this.m01 + _this.m01);
                                    _this.m12 += anchorx * (_this.m10 + _this.m10) + anchory * (_this.m11 + _this.m11);
                                    _this.rotate180();
                                    break;
                                case 3:
                                    _this.m02 += anchorx * (_this.m00 + _this.m01) + anchory * (_this.m01 - _this.m00);
                                    _this.m12 += anchorx * (_this.m10 + _this.m11) + anchory * (_this.m11 - _this.m10);
                                    _this.rotate270();
                                    break;
                            }
                            if (_this.m02 === 0.0 && _this.m12 === 0.0) {
                                _this.state &= ~AffineTransform.APPLY_TRANSLATE;
                            }
                            else {
                                _this.state |= AffineTransform.APPLY_TRANSLATE;
                            }
                        })();
                    }
                    else if (((typeof numquadrants === 'number') || numquadrants === null) && anchorx === undefined && anchory === undefined) {
                        return this.quadrantRotate$int(numquadrants);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Concatenates this transform with a scaling transformation.
                 * This is equivalent to calling concatenate(S), where S is an
                 * <code>AffineTransform</code> represented by the following matrix:
                 * <pre>
                 * [   sx   0    0   ]
                 * [   0    sy   0   ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param sx the factor by which coordinates are scaled along the
                 * X axis direction
                 * @param sy the factor by which coordinates are scaled along the
                 * Y axis direction
                 * @since 1.2
                 */
                AffineTransform.prototype.scale = function (sx, sy) {
                    var state = this.state;
                    switch ((state)) {
                        default:
                            this.stateError();
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            this.m00 *= sx;
                            this.m11 *= sy;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR):
                            this.m01 *= sy;
                            this.m10 *= sx;
                            if (this.m01 === 0 && this.m10 === 0) {
                                state &= AffineTransform.APPLY_TRANSLATE;
                                if (this.m00 === 1.0 && this.m11 === 1.0) {
                                    this.type = (state === AffineTransform.APPLY_IDENTITY ? AffineTransform.TYPE_IDENTITY : AffineTransform.TYPE_TRANSLATION);
                                }
                                else {
                                    state |= AffineTransform.APPLY_SCALE;
                                    this.type = AffineTransform.TYPE_UNKNOWN;
                                }
                                this.state = state;
                            }
                            return;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SCALE):
                            this.m00 *= sx;
                            this.m11 *= sy;
                            if (this.m00 === 1.0 && this.m11 === 1.0) {
                                this.state = (state &= AffineTransform.APPLY_TRANSLATE);
                                this.type = (state === AffineTransform.APPLY_IDENTITY ? AffineTransform.TYPE_IDENTITY : AffineTransform.TYPE_TRANSLATION);
                            }
                            else {
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                            return;
                        case (AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_IDENTITY):
                            this.m00 = sx;
                            this.m11 = sy;
                            if (sx !== 1.0 || sy !== 1.0) {
                                this.state = state | AffineTransform.APPLY_SCALE;
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                            return;
                    }
                };
                /**
                 * Concatenates this transform with a shearing transformation.
                 * This is equivalent to calling concatenate(SH), where SH is an
                 * <code>AffineTransform</code> represented by the following matrix:
                 * <pre>
                 * [   1   shx   0   ]
                 * [  shy   1    0   ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param shx the multiplier by which coordinates are shifted in the
                 * direction of the positive X axis as a factor of their Y coordinate
                 * @param shy the multiplier by which coordinates are shifted in the
                 * direction of the positive Y axis as a factor of their X coordinate
                 * @since 1.2
                 */
                AffineTransform.prototype.shear = function (shx, shy) {
                    var state = this.state;
                    switch ((state)) {
                        default:
                            this.stateError();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            var M0 = void 0;
                            var M1 = void 0;
                            M0 = this.m00;
                            M1 = this.m01;
                            this.m00 = M0 + M1 * shy;
                            this.m01 = M0 * shx + M1;
                            M0 = this.m10;
                            M1 = this.m11;
                            this.m10 = M0 + M1 * shy;
                            this.m11 = M0 * shx + M1;
                            this.updateState();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR):
                            this.m00 = this.m01 * shy;
                            this.m11 = this.m10 * shx;
                            if (this.m00 !== 0.0 || this.m11 !== 0.0) {
                                this.state = state | AffineTransform.APPLY_SCALE;
                            }
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SCALE):
                            this.m01 = this.m00 * shx;
                            this.m10 = this.m11 * shy;
                            if (this.m01 !== 0.0 || this.m10 !== 0.0) {
                                this.state = state | AffineTransform.APPLY_SHEAR;
                            }
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                        case (AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_IDENTITY):
                            this.m01 = shx;
                            this.m10 = shy;
                            if (this.m01 !== 0.0 || this.m10 !== 0.0) {
                                this.state = state | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_SHEAR;
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                            return;
                    }
                };
                /**
                 * Resets this transform to the Identity transform.
                 * @since 1.2
                 */
                AffineTransform.prototype.setToIdentity = function () {
                    this.m00 = this.m11 = 1.0;
                    this.m10 = this.m01 = this.m02 = this.m12 = 0.0;
                    this.state = AffineTransform.APPLY_IDENTITY;
                    this.type = AffineTransform.TYPE_IDENTITY;
                };
                /**
                 * Sets this transform to a translation transformation.
                 * The matrix representing this transform becomes:
                 * <pre>
                 * [   1    0    tx  ]
                 * [   0    1    ty  ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param tx the distance by which coordinates are translated in the
                 * X axis direction
                 * @param ty the distance by which coordinates are translated in the
                 * Y axis direction
                 * @since 1.2
                 */
                AffineTransform.prototype.setToTranslation = function (tx, ty) {
                    this.m00 = 1.0;
                    this.m10 = 0.0;
                    this.m01 = 0.0;
                    this.m11 = 1.0;
                    this.m02 = tx;
                    this.m12 = ty;
                    if (tx !== 0.0 || ty !== 0.0) {
                        this.state = AffineTransform.APPLY_TRANSLATE;
                        this.type = AffineTransform.TYPE_TRANSLATION;
                    }
                    else {
                        this.state = AffineTransform.APPLY_IDENTITY;
                        this.type = AffineTransform.TYPE_IDENTITY;
                    }
                };
                /**
                 * Sets this transform to a rotation transformation.
                 * The matrix representing this transform becomes:
                 * <pre>
                 * [   cos(theta)    -sin(theta)    0   ]
                 * [   sin(theta)     cos(theta)    0   ]
                 * [       0              0         1   ]
                 * </pre>
                 * Rotating by a positive angle theta rotates points on the positive
                 * X axis toward the positive Y axis.
                 * Note also the discussion of
                 * <a href="#quadrantapproximation">Handling 90-Degree Rotations</a>
                 * above.
                 * @param theta the angle of rotation measured in radians
                 * @since 1.2
                 */
                AffineTransform.prototype.setToRotation$double = function (theta) {
                    var sin = Math.sin(theta);
                    var cos;
                    if (sin === 1.0 || sin === -1.0) {
                        cos = 0.0;
                        this.state = AffineTransform.APPLY_SHEAR;
                        this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                    }
                    else {
                        cos = Math.cos(theta);
                        if (cos === -1.0) {
                            sin = 0.0;
                            this.state = AffineTransform.APPLY_SCALE;
                            this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                        }
                        else if (cos === 1.0) {
                            sin = 0.0;
                            this.state = AffineTransform.APPLY_IDENTITY;
                            this.type = AffineTransform.TYPE_IDENTITY;
                        }
                        else {
                            this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE;
                            this.type = AffineTransform.TYPE_GENERAL_ROTATION;
                        }
                    }
                    this.m00 = cos;
                    this.m10 = sin;
                    this.m01 = -sin;
                    this.m11 = cos;
                    this.m02 = 0.0;
                    this.m12 = 0.0;
                };
                /**
                 * Sets this transform to a translated rotation transformation.
                 * This operation is equivalent to translating the coordinates so
                 * that the anchor point is at the origin (S1), then rotating them
                 * about the new origin (S2), and finally translating so that the
                 * intermediate origin is restored to the coordinates of the original
                 * anchor point (S3).
                 * <p>
                 * This operation is equivalent to the following sequence of calls:
                 * <pre>
                 * setToTranslation(anchorx, anchory); // S3: final translation
                 * rotate(theta);                      // S2: rotate around anchor
                 * translate(-anchorx, -anchory);      // S1: translate anchor to origin
                 * </pre>
                 * The matrix representing this transform becomes:
                 * <pre>
                 * [   cos(theta)    -sin(theta)    x-x*cos+y*sin  ]
                 * [   sin(theta)     cos(theta)    y-x*sin-y*cos  ]
                 * [       0              0               1        ]
                 * </pre>
                 * Rotating by a positive angle theta rotates points on the positive
                 * X axis toward the positive Y axis.
                 * Note also the discussion of
                 * <a href="#quadrantapproximation">Handling 90-Degree Rotations</a>
                 * above.
                 *
                 * @param theta the angle of rotation measured in radians
                 * @param anchorx the X coordinate of the rotation anchor point
                 * @param anchory the Y coordinate of the rotation anchor point
                 * @since 1.2
                 */
                AffineTransform.prototype.setToRotation$double$double$double = function (theta, anchorx, anchory) {
                    this.setToRotation(theta);
                    var sin = this.m10;
                    var oneMinusCos = 1.0 - this.m00;
                    this.m02 = anchorx * oneMinusCos + anchory * sin;
                    this.m12 = anchory * oneMinusCos - anchorx * sin;
                    if (this.m02 !== 0.0 || this.m12 !== 0.0) {
                        this.state |= AffineTransform.APPLY_TRANSLATE;
                        this.type |= AffineTransform.TYPE_TRANSLATION;
                    }
                };
                /**
                 * Sets this transform to a rotation transformation that rotates
                 * coordinates according to a rotation vector.
                 * All coordinates rotate about the origin by the same amount.
                 * The amount of rotation is such that coordinates along the former
                 * positive X axis will subsequently align with the vector pointing
                 * from the origin to the specified vector coordinates.
                 * If both <code>vecx</code> and <code>vecy</code> are 0.0,
                 * the transform is set to an identity transform.
                 * This operation is equivalent to calling:
                 * <pre>
                 * setToRotation(Math.atan2(vecy, vecx));
                 * </pre>
                 *
                 * @param vecx the X coordinate of the rotation vector
                 * @param vecy the Y coordinate of the rotation vector
                 * @since 1.6
                 */
                AffineTransform.prototype.setToRotation$double$double = function (vecx, vecy) {
                    var sin;
                    var cos;
                    if (vecy === 0) {
                        sin = 0.0;
                        if (vecx < 0.0) {
                            cos = -1.0;
                            this.state = AffineTransform.APPLY_SCALE;
                            this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                        }
                        else {
                            cos = 1.0;
                            this.state = AffineTransform.APPLY_IDENTITY;
                            this.type = AffineTransform.TYPE_IDENTITY;
                        }
                    }
                    else if (vecx === 0) {
                        cos = 0.0;
                        sin = (vecy > 0.0) ? 1.0 : -1.0;
                        this.state = AffineTransform.APPLY_SHEAR;
                        this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                    }
                    else {
                        var len = Math.sqrt(vecx * vecx + vecy * vecy);
                        cos = vecx / len;
                        sin = vecy / len;
                        this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE;
                        this.type = AffineTransform.TYPE_GENERAL_ROTATION;
                    }
                    this.m00 = cos;
                    this.m10 = sin;
                    this.m01 = -sin;
                    this.m11 = cos;
                    this.m02 = 0.0;
                    this.m12 = 0.0;
                };
                /**
                 * Sets this transform to a rotation transformation that rotates
                 * coordinates around an anchor point according to a rotation
                 * vector.
                 * All coordinates rotate about the specified anchor coordinates
                 * by the same amount.
                 * The amount of rotation is such that coordinates along the former
                 * positive X axis will subsequently align with the vector pointing
                 * from the origin to the specified vector coordinates.
                 * If both <code>vecx</code> and <code>vecy</code> are 0.0,
                 * the transform is set to an identity transform.
                 * This operation is equivalent to calling:
                 * <pre>
                 * setToTranslation(Math.atan2(vecy, vecx), anchorx, anchory);
                 * </pre>
                 *
                 * @param vecx the X coordinate of the rotation vector
                 * @param vecy the Y coordinate of the rotation vector
                 * @param anchorx the X coordinate of the rotation anchor point
                 * @param anchory the Y coordinate of the rotation anchor point
                 * @since 1.6
                 */
                AffineTransform.prototype.setToRotation = function (vecx, vecy, anchorx, anchory) {
                    var _this = this;
                    if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && ((typeof anchorx === 'number') || anchorx === null) && ((typeof anchory === 'number') || anchory === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            _this.setToRotation(vecx, vecy);
                            var sin = _this.m10;
                            var oneMinusCos = 1.0 - _this.m00;
                            _this.m02 = anchorx * oneMinusCos + anchory * sin;
                            _this.m12 = anchory * oneMinusCos - anchorx * sin;
                            if (_this.m02 !== 0.0 || _this.m12 !== 0.0) {
                                _this.state |= AffineTransform.APPLY_TRANSLATE;
                                _this.type |= AffineTransform.TYPE_TRANSLATION;
                            }
                        })();
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && ((typeof anchorx === 'number') || anchorx === null) && anchory === undefined) {
                        return this.setToRotation$double$double$double(vecx, vecy, anchorx);
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && anchorx === undefined && anchory === undefined) {
                        return this.setToRotation$double$double(vecx, vecy);
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && vecy === undefined && anchorx === undefined && anchory === undefined) {
                        return this.setToRotation$double(vecx);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets this transform to a rotation transformation that rotates
                 * coordinates by the specified number of quadrants.
                 * This operation is equivalent to calling:
                 * <pre>
                 * setToRotation(numquadrants * Math.PI / 2.0);
                 * </pre>
                 * Rotating by a positive number of quadrants rotates points on
                 * the positive X axis toward the positive Y axis.
                 * @param numquadrants the number of 90 degree arcs to rotate by
                 * @since 1.6
                 */
                AffineTransform.prototype.setToQuadrantRotation$int = function (numquadrants) {
                    switch ((numquadrants & 3)) {
                        case 0:
                            this.m00 = 1.0;
                            this.m10 = 0.0;
                            this.m01 = 0.0;
                            this.m11 = 1.0;
                            this.m02 = 0.0;
                            this.m12 = 0.0;
                            this.state = AffineTransform.APPLY_IDENTITY;
                            this.type = AffineTransform.TYPE_IDENTITY;
                            break;
                        case 1:
                            this.m00 = 0.0;
                            this.m10 = 1.0;
                            this.m01 = -1.0;
                            this.m11 = 0.0;
                            this.m02 = 0.0;
                            this.m12 = 0.0;
                            this.state = AffineTransform.APPLY_SHEAR;
                            this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                            break;
                        case 2:
                            this.m00 = -1.0;
                            this.m10 = 0.0;
                            this.m01 = 0.0;
                            this.m11 = -1.0;
                            this.m02 = 0.0;
                            this.m12 = 0.0;
                            this.state = AffineTransform.APPLY_SCALE;
                            this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                            break;
                        case 3:
                            this.m00 = 0.0;
                            this.m10 = -1.0;
                            this.m01 = 1.0;
                            this.m11 = 0.0;
                            this.m02 = 0.0;
                            this.m12 = 0.0;
                            this.state = AffineTransform.APPLY_SHEAR;
                            this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                            break;
                    }
                };
                /**
                 * Sets this transform to a translated rotation transformation
                 * that rotates coordinates by the specified number of quadrants
                 * around the specified anchor point.
                 * This operation is equivalent to calling:
                 * <pre>
                 * setToRotation(numquadrants * Math.PI / 2.0, anchorx, anchory);
                 * </pre>
                 * Rotating by a positive number of quadrants rotates points on
                 * the positive X axis toward the positive Y axis.
                 *
                 * @param numquadrants the number of 90 degree arcs to rotate by
                 * @param anchorx the X coordinate of the rotation anchor point
                 * @param anchory the Y coordinate of the rotation anchor point
                 * @since 1.6
                 */
                AffineTransform.prototype.setToQuadrantRotation = function (numquadrants, anchorx, anchory) {
                    var _this = this;
                    if (((typeof numquadrants === 'number') || numquadrants === null) && ((typeof anchorx === 'number') || anchorx === null) && ((typeof anchory === 'number') || anchory === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            switch ((numquadrants & 3)) {
                                case 0:
                                    _this.m00 = 1.0;
                                    _this.m10 = 0.0;
                                    _this.m01 = 0.0;
                                    _this.m11 = 1.0;
                                    _this.m02 = 0.0;
                                    _this.m12 = 0.0;
                                    _this.state = AffineTransform.APPLY_IDENTITY;
                                    _this.type = AffineTransform.TYPE_IDENTITY;
                                    break;
                                case 1:
                                    _this.m00 = 0.0;
                                    _this.m10 = 1.0;
                                    _this.m01 = -1.0;
                                    _this.m11 = 0.0;
                                    _this.m02 = anchorx + anchory;
                                    _this.m12 = anchory - anchorx;
                                    if (_this.m02 === 0.0 && _this.m12 === 0.0) {
                                        _this.state = AffineTransform.APPLY_SHEAR;
                                        _this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                                    }
                                    else {
                                        _this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE;
                                        _this.type = AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_TRANSLATION;
                                    }
                                    break;
                                case 2:
                                    _this.m00 = -1.0;
                                    _this.m10 = 0.0;
                                    _this.m01 = 0.0;
                                    _this.m11 = -1.0;
                                    _this.m02 = anchorx + anchorx;
                                    _this.m12 = anchory + anchory;
                                    if (_this.m02 === 0.0 && _this.m12 === 0.0) {
                                        _this.state = AffineTransform.APPLY_SCALE;
                                        _this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                                    }
                                    else {
                                        _this.state = AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE;
                                        _this.type = AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_TRANSLATION;
                                    }
                                    break;
                                case 3:
                                    _this.m00 = 0.0;
                                    _this.m10 = -1.0;
                                    _this.m01 = 1.0;
                                    _this.m11 = 0.0;
                                    _this.m02 = anchorx - anchory;
                                    _this.m12 = anchory + anchorx;
                                    if (_this.m02 === 0.0 && _this.m12 === 0.0) {
                                        _this.state = AffineTransform.APPLY_SHEAR;
                                        _this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                                    }
                                    else {
                                        _this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE;
                                        _this.type = AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_TRANSLATION;
                                    }
                                    break;
                            }
                        })();
                    }
                    else if (((typeof numquadrants === 'number') || numquadrants === null) && anchorx === undefined && anchory === undefined) {
                        return this.setToQuadrantRotation$int(numquadrants);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets this transform to a scaling transformation.
                 * The matrix representing this transform becomes:
                 * <pre>
                 * [   sx   0    0   ]
                 * [   0    sy   0   ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param sx the factor by which coordinates are scaled along the
                 * X axis direction
                 * @param sy the factor by which coordinates are scaled along the
                 * Y axis direction
                 * @since 1.2
                 */
                AffineTransform.prototype.setToScale = function (sx, sy) {
                    this.m00 = sx;
                    this.m10 = 0.0;
                    this.m01 = 0.0;
                    this.m11 = sy;
                    this.m02 = 0.0;
                    this.m12 = 0.0;
                    if (sx !== 1.0 || sy !== 1.0) {
                        this.state = AffineTransform.APPLY_SCALE;
                        this.type = AffineTransform.TYPE_UNKNOWN;
                    }
                    else {
                        this.state = AffineTransform.APPLY_IDENTITY;
                        this.type = AffineTransform.TYPE_IDENTITY;
                    }
                };
                /**
                 * Sets this transform to a shearing transformation.
                 * The matrix representing this transform becomes:
                 * <pre>
                 * [   1   shx   0   ]
                 * [  shy   1    0   ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param shx the multiplier by which coordinates are shifted in the
                 * direction of the positive X axis as a factor of their Y coordinate
                 * @param shy the multiplier by which coordinates are shifted in the
                 * direction of the positive Y axis as a factor of their X coordinate
                 * @since 1.2
                 */
                AffineTransform.prototype.setToShear = function (shx, shy) {
                    this.m00 = 1.0;
                    this.m01 = shx;
                    this.m10 = shy;
                    this.m11 = 1.0;
                    this.m02 = 0.0;
                    this.m12 = 0.0;
                    if (shx !== 0.0 || shy !== 0.0) {
                        this.state = (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE);
                        this.type = AffineTransform.TYPE_UNKNOWN;
                    }
                    else {
                        this.state = AffineTransform.APPLY_IDENTITY;
                        this.type = AffineTransform.TYPE_IDENTITY;
                    }
                };
                /**
                 * Sets this transform to a copy of the transform in the specified
                 * <code>AffineTransform</code> object.
                 * @param Tx the <code>AffineTransform</code> object from which to
                 * copy the transform
                 * @since 1.2
                 */
                AffineTransform.prototype.setTransform$java_awt_geom_AffineTransform = function (Tx) {
                    this.m00 = Tx.m00;
                    this.m10 = Tx.m10;
                    this.m01 = Tx.m01;
                    this.m11 = Tx.m11;
                    this.m02 = Tx.m02;
                    this.m12 = Tx.m12;
                    this.state = Tx.state;
                    this.type = Tx.type;
                };
                /**
                 * Sets this transform to the matrix specified by the 6
                 * double precision values.
                 *
                 * @param m00 the X coordinate scaling element of the 3x3 matrix
                 * @param m10 the Y coordinate shearing element of the 3x3 matrix
                 * @param m01 the X coordinate shearing element of the 3x3 matrix
                 * @param m11 the Y coordinate scaling element of the 3x3 matrix
                 * @param m02 the X coordinate translation element of the 3x3 matrix
                 * @param m12 the Y coordinate translation element of the 3x3 matrix
                 * @since 1.2
                 */
                AffineTransform.prototype.setTransform = function (m00, m10, m01, m11, m02, m12) {
                    var _this = this;
                    if (((typeof m00 === 'number') || m00 === null) && ((typeof m10 === 'number') || m10 === null) && ((typeof m01 === 'number') || m01 === null) && ((typeof m11 === 'number') || m11 === null) && ((typeof m02 === 'number') || m02 === null) && ((typeof m12 === 'number') || m12 === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            _this.m00 = m00;
                            _this.m10 = m10;
                            _this.m01 = m01;
                            _this.m11 = m11;
                            _this.m02 = m02;
                            _this.m12 = m12;
                            _this.updateState();
                        })();
                    }
                    else if (((m00 != null && m00 instanceof java.awt.geom.AffineTransform) || m00 === null) && m10 === undefined && m01 === undefined && m11 === undefined && m02 === undefined && m12 === undefined) {
                        return this.setTransform$java_awt_geom_AffineTransform(m00);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Concatenates an <code>AffineTransform</code> <code>Tx</code> to
                 * this <code>AffineTransform</code> Cx in the most commonly useful
                 * way to provide a new user space
                 * that is mapped to the former user space by <code>Tx</code>.
                 * Cx is updated to perform the combined transformation.
                 * Transforming a point p by the updated transform Cx' is
                 * equivalent to first transforming p by <code>Tx</code> and then
                 * transforming the result by the original transform Cx like this:
                 * Cx'(p) = Cx(Tx(p))
                 * In matrix notation, if this transform Cx is
                 * represented by the matrix [this] and <code>Tx</code> is represented
                 * by the matrix [Tx] then this method does the following:
                 * <pre>
                 * [this] = [this] x [Tx]
                 * </pre>
                 * @param Tx the <code>AffineTransform</code> object to be
                 * concatenated with this <code>AffineTransform</code> object.
                 * @see #preConcatenate
                 * @since 1.2
                 */
                AffineTransform.prototype.concatenate = function (Tx) {
                    var M0;
                    var M1;
                    var T00;
                    var T01;
                    var T10;
                    var T11;
                    var T02;
                    var T12;
                    var mystate = this.state;
                    var txstate = Tx.state;
                    switch (((txstate << AffineTransform.HI_SHIFT) | mystate)) {
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_IDENTITY):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            return;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.HI_SCALE_$LI$() | AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_IDENTITY):
                            this.m01 = Tx.m01;
                            this.m10 = Tx.m10;
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_IDENTITY):
                            this.m00 = Tx.m00;
                            this.m11 = Tx.m11;
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_IDENTITY):
                            this.m02 = Tx.m02;
                            this.m12 = Tx.m12;
                            this.state = txstate;
                            this.type = Tx.type;
                            return;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_IDENTITY):
                            this.m01 = Tx.m01;
                            this.m10 = Tx.m10;
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_IDENTITY):
                            this.m00 = Tx.m00;
                            this.m11 = Tx.m11;
                            this.state = txstate;
                            this.type = Tx.type;
                            return;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_IDENTITY):
                            this.m02 = Tx.m02;
                            this.m12 = Tx.m12;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_IDENTITY):
                            this.m01 = Tx.m01;
                            this.m10 = Tx.m10;
                            this.m00 = this.m11 = 0.0;
                            this.state = txstate;
                            this.type = Tx.type;
                            return;
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_TRANSLATE):
                            this.translate(Tx.m02, Tx.m12);
                            return;
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_TRANSLATE):
                            this.scale(Tx.m00, Tx.m11);
                            return;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            T01 = Tx.m01;
                            T10 = Tx.m10;
                            M0 = this.m00;
                            this.m00 = this.m01 * T10;
                            this.m01 = M0 * T01;
                            M0 = this.m10;
                            this.m10 = this.m11 * T10;
                            this.m11 = M0 * T01;
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR):
                            this.m00 = this.m01 * Tx.m10;
                            this.m01 = 0.0;
                            this.m11 = this.m10 * Tx.m01;
                            this.m10 = 0.0;
                            this.state = mystate ^ (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE);
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SCALE):
                            this.m01 = this.m00 * Tx.m01;
                            this.m00 = 0.0;
                            this.m10 = this.m11 * Tx.m10;
                            this.m11 = 0.0;
                            this.state = mystate ^ (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE);
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_TRANSLATE):
                            this.m00 = 0.0;
                            this.m01 = Tx.m01;
                            this.m10 = Tx.m10;
                            this.m11 = 0.0;
                            this.state = AffineTransform.APPLY_TRANSLATE | AffineTransform.APPLY_SHEAR;
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                    }
                    T00 = Tx.m00;
                    T01 = Tx.m01;
                    T02 = Tx.m02;
                    T10 = Tx.m10;
                    T11 = Tx.m11;
                    T12 = Tx.m12;
                    switch ((mystate)) {
                        default:
                            this.stateError();
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            this.state = mystate | txstate;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M0 = this.m00;
                            M1 = this.m01;
                            this.m00 = T00 * M0 + T10 * M1;
                            this.m01 = T01 * M0 + T11 * M1;
                            this.m02 += T02 * M0 + T12 * M1;
                            M0 = this.m10;
                            M1 = this.m11;
                            this.m10 = T00 * M0 + T10 * M1;
                            this.m11 = T01 * M0 + T11 * M1;
                            this.m12 += T02 * M0 + T12 * M1;
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR):
                            M0 = this.m01;
                            this.m00 = T10 * M0;
                            this.m01 = T11 * M0;
                            this.m02 += T12 * M0;
                            M0 = this.m10;
                            this.m10 = T00 * M0;
                            this.m11 = T01 * M0;
                            this.m12 += T02 * M0;
                            break;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SCALE):
                            M0 = this.m00;
                            this.m00 = T00 * M0;
                            this.m01 = T01 * M0;
                            this.m02 += T02 * M0;
                            M0 = this.m11;
                            this.m10 = T10 * M0;
                            this.m11 = T11 * M0;
                            this.m12 += T12 * M0;
                            break;
                        case (AffineTransform.APPLY_TRANSLATE):
                            this.m00 = T00;
                            this.m01 = T01;
                            this.m02 += T02;
                            this.m10 = T10;
                            this.m11 = T11;
                            this.m12 += T12;
                            this.state = txstate | AffineTransform.APPLY_TRANSLATE;
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                    }
                    this.updateState();
                };
                /**
                 * Concatenates an <code>AffineTransform</code> <code>Tx</code> to
                 * this <code>AffineTransform</code> Cx
                 * in a less commonly used way such that <code>Tx</code> modifies the
                 * coordinate transformation relative to the absolute pixel
                 * space rather than relative to the existing user space.
                 * Cx is updated to perform the combined transformation.
                 * Transforming a point p by the updated transform Cx' is
                 * equivalent to first transforming p by the original transform
                 * Cx and then transforming the result by
                 * <code>Tx</code> like this:
                 * Cx'(p) = Tx(Cx(p))
                 * In matrix notation, if this transform Cx
                 * is represented by the matrix [this] and <code>Tx</code> is
                 * represented by the matrix [Tx] then this method does the
                 * following:
                 * <pre>
                 * [this] = [Tx] x [this]
                 * </pre>
                 * @param Tx the <code>AffineTransform</code> object to be
                 * concatenated with this <code>AffineTransform</code> object.
                 * @see #concatenate
                 * @since 1.2
                 */
                AffineTransform.prototype.preConcatenate = function (Tx) {
                    var M0;
                    var M1;
                    var T00;
                    var T01;
                    var T10;
                    var T11;
                    var T02;
                    var T12;
                    var mystate = this.state;
                    var txstate = Tx.state;
                    switch (((txstate << AffineTransform.HI_SHIFT) | mystate)) {
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_IDENTITY):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            return;
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_IDENTITY):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            this.m02 = Tx.m02;
                            this.m12 = Tx.m12;
                            this.state = mystate | AffineTransform.APPLY_TRANSLATE;
                            this.type |= AffineTransform.TYPE_TRANSLATION;
                            return;
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            this.m02 = this.m02 + Tx.m02;
                            this.m12 = this.m12 + Tx.m12;
                            return;
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_IDENTITY):
                            this.state = mystate | AffineTransform.APPLY_SCALE;
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SCALE):
                            T00 = Tx.m00;
                            T11 = Tx.m11;
                            if ((mystate & AffineTransform.APPLY_SHEAR) !== 0) {
                                this.m01 = this.m01 * T00;
                                this.m10 = this.m10 * T11;
                                if ((mystate & AffineTransform.APPLY_SCALE) !== 0) {
                                    this.m00 = this.m00 * T00;
                                    this.m11 = this.m11 * T11;
                                }
                            }
                            else {
                                this.m00 = this.m00 * T00;
                                this.m11 = this.m11 * T11;
                            }
                            if ((mystate & AffineTransform.APPLY_TRANSLATE) !== 0) {
                                this.m02 = this.m02 * T00;
                                this.m12 = this.m12 * T11;
                            }
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR):
                            mystate = mystate | AffineTransform.APPLY_SCALE;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_IDENTITY):
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SCALE):
                            this.state = mystate ^ AffineTransform.APPLY_SHEAR;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            T01 = Tx.m01;
                            T10 = Tx.m10;
                            M0 = this.m00;
                            this.m00 = this.m10 * T01;
                            this.m10 = M0 * T10;
                            M0 = this.m01;
                            this.m01 = this.m11 * T01;
                            this.m11 = M0 * T10;
                            M0 = this.m02;
                            this.m02 = this.m12 * T01;
                            this.m12 = M0 * T10;
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                    }
                    T00 = Tx.m00;
                    T01 = Tx.m01;
                    T02 = Tx.m02;
                    T10 = Tx.m10;
                    T11 = Tx.m11;
                    T12 = Tx.m12;
                    switch ((mystate)) {
                        default:
                            this.stateError();
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M0 = this.m02;
                            M1 = this.m12;
                            T02 += M0 * T00 + M1 * T01;
                            T12 += M0 * T10 + M1 * T11;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            this.m02 = T02;
                            this.m12 = T12;
                            M0 = this.m00;
                            M1 = this.m10;
                            this.m00 = M0 * T00 + M1 * T01;
                            this.m10 = M0 * T10 + M1 * T11;
                            M0 = this.m01;
                            M1 = this.m11;
                            this.m01 = M0 * T00 + M1 * T01;
                            this.m11 = M0 * T10 + M1 * T11;
                            break;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            M0 = this.m02;
                            M1 = this.m12;
                            T02 += M0 * T00 + M1 * T01;
                            T12 += M0 * T10 + M1 * T11;
                        case (AffineTransform.APPLY_SHEAR):
                            this.m02 = T02;
                            this.m12 = T12;
                            M0 = this.m10;
                            this.m00 = M0 * T01;
                            this.m10 = M0 * T11;
                            M0 = this.m01;
                            this.m01 = M0 * T00;
                            this.m11 = M0 * T10;
                            break;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M0 = this.m02;
                            M1 = this.m12;
                            T02 += M0 * T00 + M1 * T01;
                            T12 += M0 * T10 + M1 * T11;
                        case (AffineTransform.APPLY_SCALE):
                            this.m02 = T02;
                            this.m12 = T12;
                            M0 = this.m00;
                            this.m00 = M0 * T00;
                            this.m10 = M0 * T10;
                            M0 = this.m11;
                            this.m01 = M0 * T01;
                            this.m11 = M0 * T11;
                            break;
                        case (AffineTransform.APPLY_TRANSLATE):
                            M0 = this.m02;
                            M1 = this.m12;
                            T02 += M0 * T00 + M1 * T01;
                            T12 += M0 * T10 + M1 * T11;
                        case (AffineTransform.APPLY_IDENTITY):
                            this.m02 = T02;
                            this.m12 = T12;
                            this.m00 = T00;
                            this.m10 = T10;
                            this.m01 = T01;
                            this.m11 = T11;
                            this.state = mystate | txstate;
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                    }
                    this.updateState();
                };
                /**
                 * Returns an <code>AffineTransform</code> object representing the
                 * inverse transformation.
                 * The inverse transform Tx' of this transform Tx
                 * maps coordinates transformed by Tx back
                 * to their original coordinates.
                 * In other words, Tx'(Tx(p)) = p = Tx(Tx'(p)).
                 * <p>
                 * If this transform maps all coordinates onto a point or a line
                 * then it will not have an inverse, since coordinates that do
                 * not lie on the destination point or line will not have an inverse
                 * mapping.
                 * The <code>getDeterminant</code> method can be used to determine if this
                 * transform has no inverse, in which case an exception will be
                 * thrown if the <code>createInverse</code> method is called.
                 * @return a new <code>AffineTransform</code> object representing the
                 * inverse transformation.
                 * @see #getDeterminant
                 * @exception NoninvertibleTransformException
                 * if the matrix cannot be inverted.
                 * @since 1.2
                 */
                AffineTransform.prototype.createInverse = function () {
                    var det;
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return null;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            det = this.m00 * this.m11 - this.m01 * this.m10;
                            if (Math.abs(det) <= javaemul.internal.DoubleHelper.MIN_VALUE) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is " + det);
                            }
                            return new AffineTransform(this.m11 / det, -this.m10 / det, -this.m01 / det, this.m00 / det, (this.m01 * this.m12 - this.m11 * this.m02) / det, (this.m10 * this.m02 - this.m00 * this.m12) / det, (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE));
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            det = this.m00 * this.m11 - this.m01 * this.m10;
                            if (Math.abs(det) <= javaemul.internal.DoubleHelper.MIN_VALUE) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is " + det);
                            }
                            return new AffineTransform(this.m11 / det, -this.m10 / det, -this.m01 / det, this.m00 / det, 0.0, 0.0, (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE));
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            if (this.m01 === 0.0 || this.m10 === 0.0) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                            }
                            return new AffineTransform(0.0, 1.0 / this.m01, 1.0 / this.m10, 0.0, -this.m12 / this.m10, -this.m02 / this.m01, (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE));
                        case (AffineTransform.APPLY_SHEAR):
                            if (this.m01 === 0.0 || this.m10 === 0.0) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                            }
                            return new AffineTransform(0.0, 1.0 / this.m01, 1.0 / this.m10, 0.0, 0.0, 0.0, (AffineTransform.APPLY_SHEAR));
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            if (this.m00 === 0.0 || this.m11 === 0.0) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                            }
                            return new AffineTransform(1.0 / this.m00, 0.0, 0.0, 1.0 / this.m11, -this.m02 / this.m00, -this.m12 / this.m11, (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE));
                        case (AffineTransform.APPLY_SCALE):
                            if (this.m00 === 0.0 || this.m11 === 0.0) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                            }
                            return new AffineTransform(1.0 / this.m00, 0.0, 0.0, 1.0 / this.m11, 0.0, 0.0, (AffineTransform.APPLY_SCALE));
                        case (AffineTransform.APPLY_TRANSLATE):
                            return new AffineTransform(1.0, 0.0, 0.0, 1.0, -this.m02, -this.m12, (AffineTransform.APPLY_TRANSLATE));
                        case (AffineTransform.APPLY_IDENTITY):
                            return new AffineTransform();
                    }
                };
                /**
                 * Sets this transform to the inverse of itself.
                 * The inverse transform Tx' of this transform Tx
                 * maps coordinates transformed by Tx back
                 * to their original coordinates.
                 * In other words, Tx'(Tx(p)) = p = Tx(Tx'(p)).
                 * <p>
                 * If this transform maps all coordinates onto a point or a line
                 * then it will not have an inverse, since coordinates that do
                 * not lie on the destination point or line will not have an inverse
                 * mapping.
                 * The <code>getDeterminant</code> method can be used to determine if this
                 * transform has no inverse, in which case an exception will be
                 * thrown if the <code>invert</code> method is called.
                 * @see #getDeterminant
                 * @exception NoninvertibleTransformException
                 * if the matrix cannot be inverted.
                 * @since 1.6
                 */
                AffineTransform.prototype.invert = function () {
                    var M00;
                    var M01;
                    var M02;
                    var M10;
                    var M11;
                    var M12;
                    var det;
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M11 = this.m11;
                            M12 = this.m12;
                            det = M00 * M11 - M01 * M10;
                            if (Math.abs(det) <= javaemul.internal.DoubleHelper.MIN_VALUE) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is " + det);
                            }
                            this.m00 = M11 / det;
                            this.m10 = -M10 / det;
                            this.m01 = -M01 / det;
                            this.m11 = M00 / det;
                            this.m02 = (M01 * M12 - M11 * M02) / det;
                            this.m12 = (M10 * M02 - M00 * M12) / det;
                            break;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M10 = this.m10;
                            M11 = this.m11;
                            det = M00 * M11 - M01 * M10;
                            if (Math.abs(det) <= javaemul.internal.DoubleHelper.MIN_VALUE) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is " + det);
                            }
                            this.m00 = M11 / det;
                            this.m10 = -M10 / det;
                            this.m01 = -M01 / det;
                            this.m11 = M00 / det;
                            break;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M12 = this.m12;
                            if (M01 === 0.0 || M10 === 0.0) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                            }
                            this.m10 = 1.0 / M01;
                            this.m01 = 1.0 / M10;
                            this.m02 = -M12 / M10;
                            this.m12 = -M02 / M01;
                            break;
                        case (AffineTransform.APPLY_SHEAR):
                            M01 = this.m01;
                            M10 = this.m10;
                            if (M01 === 0.0 || M10 === 0.0) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                            }
                            this.m10 = 1.0 / M01;
                            this.m01 = 1.0 / M10;
                            break;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M02 = this.m02;
                            M11 = this.m11;
                            M12 = this.m12;
                            if (M00 === 0.0 || M11 === 0.0) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                            }
                            this.m00 = 1.0 / M00;
                            this.m11 = 1.0 / M11;
                            this.m02 = -M02 / M00;
                            this.m12 = -M12 / M11;
                            break;
                        case (AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M11 = this.m11;
                            if (M00 === 0.0 || M11 === 0.0) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                            }
                            this.m00 = 1.0 / M00;
                            this.m11 = 1.0 / M11;
                            break;
                        case (AffineTransform.APPLY_TRANSLATE):
                            this.m02 = -this.m02;
                            this.m12 = -this.m12;
                            break;
                        case (AffineTransform.APPLY_IDENTITY):
                            break;
                    }
                };
                /**
                 * Transforms the specified <code>ptSrc</code> and stores the result
                 * in <code>ptDst</code>.
                 * If <code>ptDst</code> is <code>null</code>, a new {@link Point2D}
                 * object is allocated and then the result of the transformation is
                 * stored in this object.
                 * In either case, <code>ptDst</code>, which contains the
                 * transformed point, is returned for convenience.
                 * If <code>ptSrc</code> and <code>ptDst</code> are the same
                 * object, the input point is correctly overwritten with
                 * the transformed point.
                 * @param ptSrc the specified <code>Point2D</code> to be transformed
                 * @param ptDst the specified <code>Point2D</code> that stores the
                 * result of transforming <code>ptSrc</code>
                 * @return the <code>ptDst</code> after transforming
                 * <code>ptSrc</code> and storing the result in <code>ptDst</code>.
                 * @since 1.2
                 */
                AffineTransform.prototype.transform$java_awt_geom_Point2D$java_awt_geom_Point2D = function (ptSrc, ptDst) {
                    if (ptDst == null) {
                        if (ptSrc != null && ptSrc instanceof java.awt.geom.Point2D.Double) {
                            ptDst = new java.awt.geom.Point2D.Double();
                        }
                        else {
                            ptDst = new java.awt.geom.Point2D.Float();
                        }
                    }
                    var x = ptSrc.getX();
                    var y = ptSrc.getY();
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return null;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            ptDst.setLocation(x * this.m00 + y * this.m01 + this.m02, x * this.m10 + y * this.m11 + this.m12);
                            return ptDst;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            ptDst.setLocation(x * this.m00 + y * this.m01, x * this.m10 + y * this.m11);
                            return ptDst;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            ptDst.setLocation(y * this.m01 + this.m02, x * this.m10 + this.m12);
                            return ptDst;
                        case (AffineTransform.APPLY_SHEAR):
                            ptDst.setLocation(y * this.m01, x * this.m10);
                            return ptDst;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            ptDst.setLocation(x * this.m00 + this.m02, y * this.m11 + this.m12);
                            return ptDst;
                        case (AffineTransform.APPLY_SCALE):
                            ptDst.setLocation(x * this.m00, y * this.m11);
                            return ptDst;
                        case (AffineTransform.APPLY_TRANSLATE):
                            ptDst.setLocation(x + this.m02, y + this.m12);
                            return ptDst;
                        case (AffineTransform.APPLY_IDENTITY):
                            ptDst.setLocation(x, y);
                            return ptDst;
                    }
                };
                /**
                 * Transforms an array of point objects by this transform.
                 * If any element of the <code>ptDst</code> array is
                 * <code>null</code>, a new <code>Point2D</code> object is allocated
                 * and stored into that element before storing the results of the
                 * transformation.
                 * <p>
                 * Note that this method does not take any precautions to
                 * avoid problems caused by storing results into <code>Point2D</code>
                 * objects that will be used as the source for calculations
                 * further down the source array.
                 * This method does guarantee that if a specified <code>Point2D</code>
                 * object is both the source and destination for the same single point
                 * transform operation then the results will not be stored until
                 * the calculations are complete to avoid storing the results on
                 * top of the operands.
                 * If, however, the destination <code>Point2D</code> object for one
                 * operation is the same object as the source <code>Point2D</code>
                 * object for another operation further down the source array then
                 * the original coordinates in that point are overwritten before
                 * they can be converted.
                 * @param ptSrc the array containing the source point objects
                 * @param ptDst the array into which the transform point objects are
                 * returned
                 * @param srcOff the offset to the first point object to be
                 * transformed in the source array
                 * @param dstOff the offset to the location of the first
                 * transformed point object that is stored in the destination array
                 * @param numPts the number of point objects to be transformed
                 * @since 1.2
                 */
                AffineTransform.prototype.transform = function (ptSrc, srcOff, ptDst, dstOff, numPts) {
                    var _this = this;
                    if (((ptSrc != null && ptSrc instanceof Array) || ptSrc === null) && ((typeof srcOff === 'number') || srcOff === null) && ((ptDst != null && ptDst instanceof Array) || ptDst === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            var state = _this.state;
                            while ((--numPts >= 0)) {
                                var src = ptSrc[srcOff++];
                                var x = src.getX();
                                var y = src.getY();
                                var dst = ptDst[dstOff++];
                                if (dst == null) {
                                    if (src != null && src instanceof java.awt.geom.Point2D.Double) {
                                        dst = new java.awt.geom.Point2D.Double();
                                    }
                                    else {
                                        dst = new java.awt.geom.Point2D.Float();
                                    }
                                    ptDst[dstOff - 1] = dst;
                                }
                                switch ((state)) {
                                    default:
                                        _this.stateError();
                                        return;
                                    case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                                        dst.setLocation(x * _this.m00 + y * _this.m01 + _this.m02, x * _this.m10 + y * _this.m11 + _this.m12);
                                        break;
                                    case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                                        dst.setLocation(x * _this.m00 + y * _this.m01, x * _this.m10 + y * _this.m11);
                                        break;
                                    case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                                        dst.setLocation(y * _this.m01 + _this.m02, x * _this.m10 + _this.m12);
                                        break;
                                    case (AffineTransform.APPLY_SHEAR):
                                        dst.setLocation(y * _this.m01, x * _this.m10);
                                        break;
                                    case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                                        dst.setLocation(x * _this.m00 + _this.m02, y * _this.m11 + _this.m12);
                                        break;
                                    case (AffineTransform.APPLY_SCALE):
                                        dst.setLocation(x * _this.m00, y * _this.m11);
                                        break;
                                    case (AffineTransform.APPLY_TRANSLATE):
                                        dst.setLocation(x + _this.m02, y + _this.m12);
                                        break;
                                    case (AffineTransform.APPLY_IDENTITY):
                                        dst.setLocation(x, y);
                                        break;
                                }
                            }
                            ;
                        })();
                    }
                    else if (((ptSrc != null && ptSrc instanceof Array) || ptSrc === null) && ((typeof srcOff === 'number') || srcOff === null) && ((ptDst != null && ptDst instanceof Array) || ptDst === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
                        return this.transform$float_A$int$float_A$int$int(ptSrc, srcOff, ptDst, dstOff, numPts);
                    }
                    else if (((ptSrc != null && ptSrc instanceof Array) || ptSrc === null) && ((typeof srcOff === 'number') || srcOff === null) && ((ptDst != null && ptDst instanceof Array) || ptDst === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
                        return this.transform$double_A$int$double_A$int$int(ptSrc, srcOff, ptDst, dstOff, numPts);
                    }
                    else if (((ptSrc != null && ptSrc instanceof Array) || ptSrc === null) && ((typeof srcOff === 'number') || srcOff === null) && ((ptDst != null && ptDst instanceof Array) || ptDst === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
                        return this.transform$float_A$int$double_A$int$int(ptSrc, srcOff, ptDst, dstOff, numPts);
                    }
                    else if (((ptSrc != null && ptSrc instanceof Array) || ptSrc === null) && ((typeof srcOff === 'number') || srcOff === null) && ((ptDst != null && ptDst instanceof Array) || ptDst === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
                        return this.transform$double_A$int$float_A$int$int(ptSrc, srcOff, ptDst, dstOff, numPts);
                    }
                    else if (((ptSrc != null && ptSrc instanceof java.awt.geom.Point2D) || ptSrc === null) && ((srcOff != null && srcOff instanceof java.awt.geom.Point2D) || srcOff === null) && ptDst === undefined && dstOff === undefined && numPts === undefined) {
                        return this.transform$java_awt_geom_Point2D$java_awt_geom_Point2D(ptSrc, srcOff);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Transforms an array of floating point coordinates by this transform.
                 * The two coordinate array sections can be exactly the same or
                 * can be overlapping sections of the same array without affecting the
                 * validity of the results.
                 * This method ensures that no source coordinates are overwritten by a
                 * previous operation before they can be transformed.
                 * The coordinates are stored in the arrays starting at the specified
                 * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
                 * @param srcPts the array containing the source point coordinates.
                 * Each point is stored as a pair of x,&nbsp;y coordinates.
                 * @param dstPts the array into which the transformed point coordinates
                 * are returned.  Each point is stored as a pair of x,&nbsp;y
                 * coordinates.
                 * @param srcOff the offset to the first point to be transformed
                 * in the source array
                 * @param dstOff the offset to the location of the first
                 * transformed point that is stored in the destination array
                 * @param numPts the number of points to be transformed
                 * @since 1.2
                 */
                AffineTransform.prototype.transform$float_A$int$float_A$int$int = function (srcPts, srcOff, dstPts, dstOff, numPts) {
                    var M00;
                    var M01;
                    var M02;
                    var M10;
                    var M11;
                    var M12;
                    if (dstPts === srcPts && dstOff > srcOff && dstOff < srcOff + numPts * 2) {
                        java.lang.System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                        srcOff = dstOff;
                    }
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M11 = this.m11;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                var y = srcPts[srcOff++];
                                dstPts[dstOff++] = (M00 * x + M01 * y + M02);
                                dstPts[dstOff++] = (M10 * x + M11 * y + M12);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M10 = this.m10;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                var y = srcPts[srcOff++];
                                dstPts[dstOff++] = (M00 * x + M01 * y);
                                dstPts[dstOff++] = (M10 * x + M11 * y);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                dstPts[dstOff++] = (M01 * srcPts[srcOff++] + M02);
                                dstPts[dstOff++] = (M10 * x + M12);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR):
                            M01 = this.m01;
                            M10 = this.m10;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                dstPts[dstOff++] = (M01 * srcPts[srcOff++]);
                                dstPts[dstOff++] = (M10 * x);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M02 = this.m02;
                            M11 = this.m11;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = (M00 * srcPts[srcOff++] + M02);
                                dstPts[dstOff++] = (M11 * srcPts[srcOff++] + M12);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = (M00 * srcPts[srcOff++]);
                                dstPts[dstOff++] = (M11 * srcPts[srcOff++]);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_TRANSLATE):
                            M02 = this.m02;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = (srcPts[srcOff++] + M02);
                                dstPts[dstOff++] = (srcPts[srcOff++] + M12);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_IDENTITY):
                            if (srcPts !== dstPts || srcOff !== dstOff) {
                                java.lang.System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                            }
                            return;
                    }
                };
                /**
                 * Transforms an array of double precision coordinates by this transform.
                 * The two coordinate array sections can be exactly the same or
                 * can be overlapping sections of the same array without affecting the
                 * validity of the results.
                 * This method ensures that no source coordinates are
                 * overwritten by a previous operation before they can be transformed.
                 * The coordinates are stored in the arrays starting at the indicated
                 * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
                 * @param srcPts the array containing the source point coordinates.
                 * Each point is stored as a pair of x,&nbsp;y coordinates.
                 * @param dstPts the array into which the transformed point
                 * coordinates are returned.  Each point is stored as a pair of
                 * x,&nbsp;y coordinates.
                 * @param srcOff the offset to the first point to be transformed
                 * in the source array
                 * @param dstOff the offset to the location of the first
                 * transformed point that is stored in the destination array
                 * @param numPts the number of point objects to be transformed
                 * @since 1.2
                 */
                AffineTransform.prototype.transform$double_A$int$double_A$int$int = function (srcPts, srcOff, dstPts, dstOff, numPts) {
                    var M00;
                    var M01;
                    var M02;
                    var M10;
                    var M11;
                    var M12;
                    if (dstPts === srcPts && dstOff > srcOff && dstOff < srcOff + numPts * 2) {
                        java.lang.System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                        srcOff = dstOff;
                    }
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M11 = this.m11;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                var y = srcPts[srcOff++];
                                dstPts[dstOff++] = M00 * x + M01 * y + M02;
                                dstPts[dstOff++] = M10 * x + M11 * y + M12;
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M10 = this.m10;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                var y = srcPts[srcOff++];
                                dstPts[dstOff++] = M00 * x + M01 * y;
                                dstPts[dstOff++] = M10 * x + M11 * y;
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                dstPts[dstOff++] = M01 * srcPts[srcOff++] + M02;
                                dstPts[dstOff++] = M10 * x + M12;
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR):
                            M01 = this.m01;
                            M10 = this.m10;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                dstPts[dstOff++] = M01 * srcPts[srcOff++];
                                dstPts[dstOff++] = M10 * x;
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M02 = this.m02;
                            M11 = this.m11;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = M00 * srcPts[srcOff++] + M02;
                                dstPts[dstOff++] = M11 * srcPts[srcOff++] + M12;
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = M00 * srcPts[srcOff++];
                                dstPts[dstOff++] = M11 * srcPts[srcOff++];
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_TRANSLATE):
                            M02 = this.m02;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = srcPts[srcOff++] + M02;
                                dstPts[dstOff++] = srcPts[srcOff++] + M12;
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_IDENTITY):
                            if (srcPts !== dstPts || srcOff !== dstOff) {
                                java.lang.System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                            }
                            return;
                    }
                };
                /**
                 * Transforms an array of floating point coordinates by this transform
                 * and stores the results into an array of doubles.
                 * The coordinates are stored in the arrays starting at the specified
                 * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
                 * @param srcPts the array containing the source point coordinates.
                 * Each point is stored as a pair of x,&nbsp;y coordinates.
                 * @param dstPts the array into which the transformed point coordinates
                 * are returned.  Each point is stored as a pair of x,&nbsp;y
                 * coordinates.
                 * @param srcOff the offset to the first point to be transformed
                 * in the source array
                 * @param dstOff the offset to the location of the first
                 * transformed point that is stored in the destination array
                 * @param numPts the number of points to be transformed
                 * @since 1.2
                 */
                AffineTransform.prototype.transform$float_A$int$double_A$int$int = function (srcPts, srcOff, dstPts, dstOff, numPts) {
                    var M00;
                    var M01;
                    var M02;
                    var M10;
                    var M11;
                    var M12;
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M11 = this.m11;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                var y = srcPts[srcOff++];
                                dstPts[dstOff++] = M00 * x + M01 * y + M02;
                                dstPts[dstOff++] = M10 * x + M11 * y + M12;
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M10 = this.m10;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                var y = srcPts[srcOff++];
                                dstPts[dstOff++] = M00 * x + M01 * y;
                                dstPts[dstOff++] = M10 * x + M11 * y;
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                dstPts[dstOff++] = M01 * srcPts[srcOff++] + M02;
                                dstPts[dstOff++] = M10 * x + M12;
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR):
                            M01 = this.m01;
                            M10 = this.m10;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                dstPts[dstOff++] = M01 * srcPts[srcOff++];
                                dstPts[dstOff++] = M10 * x;
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M02 = this.m02;
                            M11 = this.m11;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = M00 * srcPts[srcOff++] + M02;
                                dstPts[dstOff++] = M11 * srcPts[srcOff++] + M12;
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = M00 * srcPts[srcOff++];
                                dstPts[dstOff++] = M11 * srcPts[srcOff++];
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_TRANSLATE):
                            M02 = this.m02;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = srcPts[srcOff++] + M02;
                                dstPts[dstOff++] = srcPts[srcOff++] + M12;
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_IDENTITY):
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = srcPts[srcOff++];
                                dstPts[dstOff++] = srcPts[srcOff++];
                            }
                            ;
                            return;
                    }
                };
                /**
                 * Transforms an array of double precision coordinates by this transform
                 * and stores the results into an array of floats.
                 * The coordinates are stored in the arrays starting at the specified
                 * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
                 * @param srcPts the array containing the source point coordinates.
                 * Each point is stored as a pair of x,&nbsp;y coordinates.
                 * @param dstPts the array into which the transformed point
                 * coordinates are returned.  Each point is stored as a pair of
                 * x,&nbsp;y coordinates.
                 * @param srcOff the offset to the first point to be transformed
                 * in the source array
                 * @param dstOff the offset to the location of the first
                 * transformed point that is stored in the destination array
                 * @param numPts the number of point objects to be transformed
                 * @since 1.2
                 */
                AffineTransform.prototype.transform$double_A$int$float_A$int$int = function (srcPts, srcOff, dstPts, dstOff, numPts) {
                    var M00;
                    var M01;
                    var M02;
                    var M10;
                    var M11;
                    var M12;
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M11 = this.m11;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                var y = srcPts[srcOff++];
                                dstPts[dstOff++] = (M00 * x + M01 * y + M02);
                                dstPts[dstOff++] = (M10 * x + M11 * y + M12);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M10 = this.m10;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                var y = srcPts[srcOff++];
                                dstPts[dstOff++] = (M00 * x + M01 * y);
                                dstPts[dstOff++] = (M10 * x + M11 * y);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                dstPts[dstOff++] = (M01 * srcPts[srcOff++] + M02);
                                dstPts[dstOff++] = (M10 * x + M12);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR):
                            M01 = this.m01;
                            M10 = this.m10;
                            while ((--numPts >= 0)) {
                                var x = srcPts[srcOff++];
                                dstPts[dstOff++] = (M01 * srcPts[srcOff++]);
                                dstPts[dstOff++] = (M10 * x);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M02 = this.m02;
                            M11 = this.m11;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = (M00 * srcPts[srcOff++] + M02);
                                dstPts[dstOff++] = (M11 * srcPts[srcOff++] + M12);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = (M00 * srcPts[srcOff++]);
                                dstPts[dstOff++] = (M11 * srcPts[srcOff++]);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_TRANSLATE):
                            M02 = this.m02;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = (srcPts[srcOff++] + M02);
                                dstPts[dstOff++] = (srcPts[srcOff++] + M12);
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_IDENTITY):
                            while ((--numPts >= 0)) {
                                dstPts[dstOff++] = (srcPts[srcOff++]);
                                dstPts[dstOff++] = (srcPts[srcOff++]);
                            }
                            ;
                            return;
                    }
                };
                /**
                 * Inverse transforms the specified <code>ptSrc</code> and stores the
                 * result in <code>ptDst</code>.
                 * If <code>ptDst</code> is <code>null</code>, a new
                 * <code>Point2D</code> object is allocated and then the result of the
                 * transform is stored in this object.
                 * In either case, <code>ptDst</code>, which contains the transformed
                 * point, is returned for convenience.
                 * If <code>ptSrc</code> and <code>ptDst</code> are the same
                 * object, the input point is correctly overwritten with the
                 * transformed point.
                 * @param ptSrc the point to be inverse transformed
                 * @param ptDst the resulting transformed point
                 * @return <code>ptDst</code>, which contains the result of the
                 * inverse transform.
                 * @exception NoninvertibleTransformException  if the matrix cannot be
                 * inverted.
                 * @since 1.2
                 */
                AffineTransform.prototype.inverseTransform$java_awt_geom_Point2D$java_awt_geom_Point2D = function (ptSrc, ptDst) {
                    if (ptDst == null) {
                        if (ptSrc != null && ptSrc instanceof java.awt.geom.Point2D.Double) {
                            ptDst = new java.awt.geom.Point2D.Double();
                        }
                        else {
                            ptDst = new java.awt.geom.Point2D.Float();
                        }
                    }
                    var x = ptSrc.getX();
                    var y = ptSrc.getY();
                    switch ((this.state)) {
                        default:
                            this.stateError();
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            x -= this.m02;
                            y -= this.m12;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            var det = this.m00 * this.m11 - this.m01 * this.m10;
                            if (Math.abs(det) <= javaemul.internal.DoubleHelper.MIN_VALUE) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is " + det);
                            }
                            ptDst.setLocation((x * this.m11 - y * this.m01) / det, (y * this.m00 - x * this.m10) / det);
                            return ptDst;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            x -= this.m02;
                            y -= this.m12;
                        case (AffineTransform.APPLY_SHEAR):
                            if (this.m01 === 0.0 || this.m10 === 0.0) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                            }
                            ptDst.setLocation(y / this.m10, x / this.m01);
                            return ptDst;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            x -= this.m02;
                            y -= this.m12;
                        case (AffineTransform.APPLY_SCALE):
                            if (this.m00 === 0.0 || this.m11 === 0.0) {
                                throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                            }
                            ptDst.setLocation(x / this.m00, y / this.m11);
                            return ptDst;
                        case (AffineTransform.APPLY_TRANSLATE):
                            ptDst.setLocation(x - this.m02, y - this.m12);
                            return ptDst;
                        case (AffineTransform.APPLY_IDENTITY):
                            ptDst.setLocation(x, y);
                            return ptDst;
                    }
                };
                /**
                 * Inverse transforms an array of double precision coordinates by
                 * this transform.
                 * The two coordinate array sections can be exactly the same or
                 * can be overlapping sections of the same array without affecting the
                 * validity of the results.
                 * This method ensures that no source coordinates are
                 * overwritten by a previous operation before they can be transformed.
                 * The coordinates are stored in the arrays starting at the specified
                 * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
                 * @param srcPts the array containing the source point coordinates.
                 * Each point is stored as a pair of x,&nbsp;y coordinates.
                 * @param dstPts the array into which the transformed point
                 * coordinates are returned.  Each point is stored as a pair of
                 * x,&nbsp;y coordinates.
                 * @param srcOff the offset to the first point to be transformed
                 * in the source array
                 * @param dstOff the offset to the location of the first
                 * transformed point that is stored in the destination array
                 * @param numPts the number of point objects to be transformed
                 * @exception NoninvertibleTransformException  if the matrix cannot be
                 * inverted.
                 * @since 1.2
                 */
                AffineTransform.prototype.inverseTransform = function (srcPts, srcOff, dstPts, dstOff, numPts) {
                    var _this = this;
                    if (((srcPts != null && srcPts instanceof Array) || srcPts === null) && ((typeof srcOff === 'number') || srcOff === null) && ((dstPts != null && dstPts instanceof Array) || dstPts === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            var M00;
                            var M01;
                            var M02;
                            var M10;
                            var M11;
                            var M12;
                            var det;
                            if (dstPts === srcPts && dstOff > srcOff && dstOff < srcOff + numPts * 2) {
                                java.lang.System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                                srcOff = dstOff;
                            }
                            switch ((_this.state)) {
                                default:
                                    _this.stateError();
                                    return;
                                case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                                    M00 = _this.m00;
                                    M01 = _this.m01;
                                    M02 = _this.m02;
                                    M10 = _this.m10;
                                    M11 = _this.m11;
                                    M12 = _this.m12;
                                    det = M00 * M11 - M01 * M10;
                                    if (Math.abs(det) <= javaemul.internal.DoubleHelper.MIN_VALUE) {
                                        throw new java.awt.geom.NoninvertibleTransformException("Determinant is " + det);
                                    }
                                    while ((--numPts >= 0)) {
                                        var x = srcPts[srcOff++] - M02;
                                        var y = srcPts[srcOff++] - M12;
                                        dstPts[dstOff++] = (x * M11 - y * M01) / det;
                                        dstPts[dstOff++] = (y * M00 - x * M10) / det;
                                    }
                                    ;
                                    return;
                                case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                                    M00 = _this.m00;
                                    M01 = _this.m01;
                                    M10 = _this.m10;
                                    M11 = _this.m11;
                                    det = M00 * M11 - M01 * M10;
                                    if (Math.abs(det) <= javaemul.internal.DoubleHelper.MIN_VALUE) {
                                        throw new java.awt.geom.NoninvertibleTransformException("Determinant is " + det);
                                    }
                                    while ((--numPts >= 0)) {
                                        var x = srcPts[srcOff++];
                                        var y = srcPts[srcOff++];
                                        dstPts[dstOff++] = (x * M11 - y * M01) / det;
                                        dstPts[dstOff++] = (y * M00 - x * M10) / det;
                                    }
                                    ;
                                    return;
                                case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                                    M01 = _this.m01;
                                    M02 = _this.m02;
                                    M10 = _this.m10;
                                    M12 = _this.m12;
                                    if (M01 === 0.0 || M10 === 0.0) {
                                        throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                                    }
                                    while ((--numPts >= 0)) {
                                        var x = srcPts[srcOff++] - M02;
                                        dstPts[dstOff++] = (srcPts[srcOff++] - M12) / M10;
                                        dstPts[dstOff++] = x / M01;
                                    }
                                    ;
                                    return;
                                case (AffineTransform.APPLY_SHEAR):
                                    M01 = _this.m01;
                                    M10 = _this.m10;
                                    if (M01 === 0.0 || M10 === 0.0) {
                                        throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                                    }
                                    while ((--numPts >= 0)) {
                                        var x = srcPts[srcOff++];
                                        dstPts[dstOff++] = srcPts[srcOff++] / M10;
                                        dstPts[dstOff++] = x / M01;
                                    }
                                    ;
                                    return;
                                case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                                    M00 = _this.m00;
                                    M02 = _this.m02;
                                    M11 = _this.m11;
                                    M12 = _this.m12;
                                    if (M00 === 0.0 || M11 === 0.0) {
                                        throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                                    }
                                    while ((--numPts >= 0)) {
                                        dstPts[dstOff++] = (srcPts[srcOff++] - M02) / M00;
                                        dstPts[dstOff++] = (srcPts[srcOff++] - M12) / M11;
                                    }
                                    ;
                                    return;
                                case (AffineTransform.APPLY_SCALE):
                                    M00 = _this.m00;
                                    M11 = _this.m11;
                                    if (M00 === 0.0 || M11 === 0.0) {
                                        throw new java.awt.geom.NoninvertibleTransformException("Determinant is 0");
                                    }
                                    while ((--numPts >= 0)) {
                                        dstPts[dstOff++] = srcPts[srcOff++] / M00;
                                        dstPts[dstOff++] = srcPts[srcOff++] / M11;
                                    }
                                    ;
                                    return;
                                case (AffineTransform.APPLY_TRANSLATE):
                                    M02 = _this.m02;
                                    M12 = _this.m12;
                                    while ((--numPts >= 0)) {
                                        dstPts[dstOff++] = srcPts[srcOff++] - M02;
                                        dstPts[dstOff++] = srcPts[srcOff++] - M12;
                                    }
                                    ;
                                    return;
                                case (AffineTransform.APPLY_IDENTITY):
                                    if (srcPts !== dstPts || srcOff !== dstOff) {
                                        java.lang.System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                                    }
                                    return;
                            }
                        })();
                    }
                    else if (((srcPts != null && srcPts instanceof java.awt.geom.Point2D) || srcPts === null) && ((srcOff != null && srcOff instanceof java.awt.geom.Point2D) || srcOff === null) && dstPts === undefined && dstOff === undefined && numPts === undefined) {
                        return this.inverseTransform$java_awt_geom_Point2D$java_awt_geom_Point2D(srcPts, srcOff);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Transforms the relative distance vector specified by
                 * <code>ptSrc</code> and stores the result in <code>ptDst</code>.
                 * A relative distance vector is transformed without applying the
                 * translation components of the affine transformation matrix
                 * using the following equations:
                 * <pre>
                 * [  x' ]   [  m00  m01 (m02) ] [  x  ]   [ m00x + m01y ]
                 * [  y' ] = [  m10  m11 (m12) ] [  y  ] = [ m10x + m11y ]
                 * [ (1) ]   [  (0)  (0) ( 1 ) ] [ (1) ]   [     (1)     ]
                 * </pre>
                 * If <code>ptDst</code> is <code>null</code>, a new
                 * <code>Point2D</code> object is allocated and then the result of the
                 * transform is stored in this object.
                 * In either case, <code>ptDst</code>, which contains the
                 * transformed point, is returned for convenience.
                 * If <code>ptSrc</code> and <code>ptDst</code> are the same object,
                 * the input point is correctly overwritten with the transformed
                 * point.
                 * @param ptSrc the distance vector to be delta transformed
                 * @param ptDst the resulting transformed distance vector
                 * @return <code>ptDst</code>, which contains the result of the
                 * transformation.
                 * @since 1.2
                 */
                AffineTransform.prototype.deltaTransform$java_awt_geom_Point2D$java_awt_geom_Point2D = function (ptSrc, ptDst) {
                    if (ptDst == null) {
                        if (ptSrc != null && ptSrc instanceof java.awt.geom.Point2D.Double) {
                            ptDst = new java.awt.geom.Point2D.Double();
                        }
                        else {
                            ptDst = new java.awt.geom.Point2D.Float();
                        }
                    }
                    var x = ptSrc.getX();
                    var y = ptSrc.getY();
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return null;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            ptDst.setLocation(x * this.m00 + y * this.m01, x * this.m10 + y * this.m11);
                            return ptDst;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR):
                            ptDst.setLocation(y * this.m01, x * this.m10);
                            return ptDst;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SCALE):
                            ptDst.setLocation(x * this.m00, y * this.m11);
                            return ptDst;
                        case (AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_IDENTITY):
                            ptDst.setLocation(x, y);
                            return ptDst;
                    }
                };
                /**
                 * Transforms an array of relative distance vectors by this
                 * transform.
                 * A relative distance vector is transformed without applying the
                 * translation components of the affine transformation matrix
                 * using the following equations:
                 * <pre>
                 * [  x' ]   [  m00  m01 (m02) ] [  x  ]   [ m00x + m01y ]
                 * [  y' ] = [  m10  m11 (m12) ] [  y  ] = [ m10x + m11y ]
                 * [ (1) ]   [  (0)  (0) ( 1 ) ] [ (1) ]   [     (1)     ]
                 * </pre>
                 * The two coordinate array sections can be exactly the same or
                 * can be overlapping sections of the same array without affecting the
                 * validity of the results.
                 * This method ensures that no source coordinates are
                 * overwritten by a previous operation before they can be transformed.
                 * The coordinates are stored in the arrays starting at the indicated
                 * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
                 * @param srcPts the array containing the source distance vectors.
                 * Each vector is stored as a pair of relative x,&nbsp;y coordinates.
                 * @param dstPts the array into which the transformed distance vectors
                 * are returned.  Each vector is stored as a pair of relative
                 * x,&nbsp;y coordinates.
                 * @param srcOff the offset to the first vector to be transformed
                 * in the source array
                 * @param dstOff the offset to the location of the first
                 * transformed vector that is stored in the destination array
                 * @param numPts the number of vector coordinate pairs to be
                 * transformed
                 * @since 1.2
                 */
                AffineTransform.prototype.deltaTransform = function (srcPts, srcOff, dstPts, dstOff, numPts) {
                    var _this = this;
                    if (((srcPts != null && srcPts instanceof Array) || srcPts === null) && ((typeof srcOff === 'number') || srcOff === null) && ((dstPts != null && dstPts instanceof Array) || dstPts === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            var M00;
                            var M01;
                            var M10;
                            var M11;
                            if (dstPts === srcPts && dstOff > srcOff && dstOff < srcOff + numPts * 2) {
                                java.lang.System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                                srcOff = dstOff;
                            }
                            switch ((_this.state)) {
                                default:
                                    _this.stateError();
                                    return;
                                case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                                case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                                    M00 = _this.m00;
                                    M01 = _this.m01;
                                    M10 = _this.m10;
                                    M11 = _this.m11;
                                    while ((--numPts >= 0)) {
                                        var x = srcPts[srcOff++];
                                        var y = srcPts[srcOff++];
                                        dstPts[dstOff++] = x * M00 + y * M01;
                                        dstPts[dstOff++] = x * M10 + y * M11;
                                    }
                                    ;
                                    return;
                                case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                                case (AffineTransform.APPLY_SHEAR):
                                    M01 = _this.m01;
                                    M10 = _this.m10;
                                    while ((--numPts >= 0)) {
                                        var x = srcPts[srcOff++];
                                        dstPts[dstOff++] = srcPts[srcOff++] * M01;
                                        dstPts[dstOff++] = x * M10;
                                    }
                                    ;
                                    return;
                                case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                                case (AffineTransform.APPLY_SCALE):
                                    M00 = _this.m00;
                                    M11 = _this.m11;
                                    while ((--numPts >= 0)) {
                                        dstPts[dstOff++] = srcPts[srcOff++] * M00;
                                        dstPts[dstOff++] = srcPts[srcOff++] * M11;
                                    }
                                    ;
                                    return;
                                case (AffineTransform.APPLY_TRANSLATE):
                                case (AffineTransform.APPLY_IDENTITY):
                                    if (srcPts !== dstPts || srcOff !== dstOff) {
                                        java.lang.System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                                    }
                                    return;
                            }
                        })();
                    }
                    else if (((srcPts != null && srcPts instanceof java.awt.geom.Point2D) || srcPts === null) && ((srcOff != null && srcOff instanceof java.awt.geom.Point2D) || srcOff === null) && dstPts === undefined && dstOff === undefined && numPts === undefined) {
                        return this.deltaTransform$java_awt_geom_Point2D$java_awt_geom_Point2D(srcPts, srcOff);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns a new {@link Shape} object defined by the geometry of the
                 * specified <code>Shape</code> after it has been transformed by
                 * this transform.
                 * @param pSrc the specified <code>Shape</code> object to be
                 * transformed by this transform.
                 * @return a new <code>Shape</code> object that defines the geometry
                 * of the transformed <code>Shape</code>, or null if {@code pSrc} is null.
                 * @since 1.2
                 */
                AffineTransform.prototype.createTransformedShape = function (pSrc) {
                    if (pSrc == null) {
                        return null;
                    }
                    return new java.awt.geom.Path2D.Double(pSrc, this);
                };
                AffineTransform._matround = function (matval) {
                    return (function (d) { if (d === Number.NaN) {
                        return d;
                    }
                    else if (Number.POSITIVE_INFINITY === d || Number.NEGATIVE_INFINITY === d) {
                        return d;
                    }
                    else if (d == 0) {
                        return d;
                    }
                    else {
                        return Math.round(d);
                    } })(matval * 1.0E15) / 1.0E15;
                };
                /**
                 * Returns a <code>String</code> that represents the value of this
                 * {@link Object}.
                 * @return a <code>String</code> representing the value of this
                 * <code>Object</code>.
                 * @since 1.2
                 */
                AffineTransform.prototype.toString = function () {
                    return ("AffineTransform[[" + AffineTransform._matround(this.m00) + ", " + AffineTransform._matround(this.m01) + ", " + AffineTransform._matround(this.m02) + "], [" + AffineTransform._matround(this.m10) + ", " + AffineTransform._matround(this.m11) + ", " + AffineTransform._matround(this.m12) + "]]");
                };
                /**
                 * Returns <code>true</code> if this <code>AffineTransform</code> is
                 * an identity transform.
                 * @return <code>true</code> if this <code>AffineTransform</code> is
                 * an identity transform; <code>false</code> otherwise.
                 * @since 1.2
                 */
                AffineTransform.prototype.isIdentity = function () {
                    return (this.state === AffineTransform.APPLY_IDENTITY || (this.getType() === AffineTransform.TYPE_IDENTITY));
                };
                /**
                 * Returns a copy of this <code>AffineTransform</code> object.
                 * @return an <code>Object</code> that is a copy of this
                 * <code>AffineTransform</code> object.
                 * @since 1.2
                 */
                AffineTransform.prototype.clone = function () {
                    try {
                        return javaemul.internal.ObjectHelper.clone(this);
                    }
                    catch (e) {
                        throw new java.lang.InternalError(e);
                    }
                    ;
                };
                /**
                 * Returns the hashcode for this transform.
                 * @return      a hash code for this transform.
                 * @since 1.2
                 */
                AffineTransform.prototype.hashCode = function () {
                    var bits = javaemul.internal.DoubleHelper.doubleToLongBits(this.m00);
                    bits = bits * 31 + javaemul.internal.DoubleHelper.doubleToLongBits(this.m01);
                    bits = bits * 31 + javaemul.internal.DoubleHelper.doubleToLongBits(this.m02);
                    bits = bits * 31 + javaemul.internal.DoubleHelper.doubleToLongBits(this.m10);
                    bits = bits * 31 + javaemul.internal.DoubleHelper.doubleToLongBits(this.m11);
                    bits = bits * 31 + javaemul.internal.DoubleHelper.doubleToLongBits(this.m12);
                    return (((bits | 0)) ^ (((bits >> 32) | 0)));
                };
                /**
                 * Returns <code>true</code> if this <code>AffineTransform</code>
                 * represents the same affine coordinate transform as the specified
                 * argument.
                 * @param obj the <code>Object</code> to test for equality with this
                 * <code>AffineTransform</code>
                 * @return <code>true</code> if <code>obj</code> equals this
                 * <code>AffineTransform</code> object; <code>false</code> otherwise.
                 * @since 1.2
                 */
                AffineTransform.prototype.equals = function (obj) {
                    if (!(obj != null && obj instanceof java.awt.geom.AffineTransform)) {
                        return false;
                    }
                    var a = obj;
                    return ((this.m00 === a.m00) && (this.m01 === a.m01) && (this.m02 === a.m02) && (this.m10 === a.m10) && (this.m11 === a.m11) && (this.m12 === a.m12));
                };
                AffineTransform.TYPE_UNKNOWN = -1;
                /**
                 * This constant indicates that the transform defined by this object
                 * is an identity transform.
                 * An identity transform is one in which the output coordinates are
                 * always the same as the input coordinates.
                 * If this transform is anything other than the identity transform,
                 * the type will either be the constant GENERAL_TRANSFORM or a
                 * combination of the appropriate flag bits for the various coordinate
                 * conversions that this transform performs.
                 * @see #TYPE_TRANSLATION
                 * @see #TYPE_UNIFORM_SCALE
                 * @see #TYPE_GENERAL_SCALE
                 * @see #TYPE_FLIP
                 * @see #TYPE_QUADRANT_ROTATION
                 * @see #TYPE_GENERAL_ROTATION
                 * @see #TYPE_GENERAL_TRANSFORM
                 * @see #getType
                 * @since 1.2
                 */
                AffineTransform.TYPE_IDENTITY = 0;
                /**
                 * This flag bit indicates that the transform defined by this object
                 * performs a translation in addition to the conversions indicated
                 * by other flag bits.
                 * A translation moves the coordinates by a constant amount in x
                 * and y without changing the length or angle of vectors.
                 * @see #TYPE_IDENTITY
                 * @see #TYPE_UNIFORM_SCALE
                 * @see #TYPE_GENERAL_SCALE
                 * @see #TYPE_FLIP
                 * @see #TYPE_QUADRANT_ROTATION
                 * @see #TYPE_GENERAL_ROTATION
                 * @see #TYPE_GENERAL_TRANSFORM
                 * @see #getType
                 * @since 1.2
                 */
                AffineTransform.TYPE_TRANSLATION = 1;
                /**
                 * This flag bit indicates that the transform defined by this object
                 * performs a uniform scale in addition to the conversions indicated
                 * by other flag bits.
                 * A uniform scale multiplies the length of vectors by the same amount
                 * in both the x and y directions without changing the angle between
                 * vectors.
                 * This flag bit is mutually exclusive with the TYPE_GENERAL_SCALE flag.
                 * @see #TYPE_IDENTITY
                 * @see #TYPE_TRANSLATION
                 * @see #TYPE_GENERAL_SCALE
                 * @see #TYPE_FLIP
                 * @see #TYPE_QUADRANT_ROTATION
                 * @see #TYPE_GENERAL_ROTATION
                 * @see #TYPE_GENERAL_TRANSFORM
                 * @see #getType
                 * @since 1.2
                 */
                AffineTransform.TYPE_UNIFORM_SCALE = 2;
                /**
                 * This flag bit indicates that the transform defined by this object
                 * performs a general scale in addition to the conversions indicated
                 * by other flag bits.
                 * A general scale multiplies the length of vectors by different
                 * amounts in the x and y directions without changing the angle
                 * between perpendicular vectors.
                 * This flag bit is mutually exclusive with the TYPE_UNIFORM_SCALE flag.
                 * @see #TYPE_IDENTITY
                 * @see #TYPE_TRANSLATION
                 * @see #TYPE_UNIFORM_SCALE
                 * @see #TYPE_FLIP
                 * @see #TYPE_QUADRANT_ROTATION
                 * @see #TYPE_GENERAL_ROTATION
                 * @see #TYPE_GENERAL_TRANSFORM
                 * @see #getType
                 * @since 1.2
                 */
                AffineTransform.TYPE_GENERAL_SCALE = 4;
                /**
                 * This flag bit indicates that the transform defined by this object
                 * performs a mirror image flip about some axis which changes the
                 * normally right handed coordinate system into a left handed
                 * system in addition to the conversions indicated by other flag bits.
                 * A right handed coordinate system is one where the positive X
                 * axis rotates counterclockwise to overlay the positive Y axis
                 * similar to the direction that the fingers on your right hand
                 * curl when you stare end on at your thumb.
                 * A left handed coordinate system is one where the positive X
                 * axis rotates clockwise to overlay the positive Y axis similar
                 * to the direction that the fingers on your left hand curl.
                 * There is no mathematical way to determine the angle of the
                 * original flipping or mirroring transformation since all angles
                 * of flip are identical given an appropriate adjusting rotation.
                 * @see #TYPE_IDENTITY
                 * @see #TYPE_TRANSLATION
                 * @see #TYPE_UNIFORM_SCALE
                 * @see #TYPE_GENERAL_SCALE
                 * @see #TYPE_QUADRANT_ROTATION
                 * @see #TYPE_GENERAL_ROTATION
                 * @see #TYPE_GENERAL_TRANSFORM
                 * @see #getType
                 * @since 1.2
                 */
                AffineTransform.TYPE_FLIP = 64;
                /**
                 * This flag bit indicates that the transform defined by this object
                 * performs a quadrant rotation by some multiple of 90 degrees in
                 * addition to the conversions indicated by other flag bits.
                 * A rotation changes the angles of vectors by the same amount
                 * regardless of the original direction of the vector and without
                 * changing the length of the vector.
                 * This flag bit is mutually exclusive with the TYPE_GENERAL_ROTATION flag.
                 * @see #TYPE_IDENTITY
                 * @see #TYPE_TRANSLATION
                 * @see #TYPE_UNIFORM_SCALE
                 * @see #TYPE_GENERAL_SCALE
                 * @see #TYPE_FLIP
                 * @see #TYPE_GENERAL_ROTATION
                 * @see #TYPE_GENERAL_TRANSFORM
                 * @see #getType
                 * @since 1.2
                 */
                AffineTransform.TYPE_QUADRANT_ROTATION = 8;
                /**
                 * This flag bit indicates that the transform defined by this object
                 * performs a rotation by an arbitrary angle in addition to the
                 * conversions indicated by other flag bits.
                 * A rotation changes the angles of vectors by the same amount
                 * regardless of the original direction of the vector and without
                 * changing the length of the vector.
                 * This flag bit is mutually exclusive with the
                 * TYPE_QUADRANT_ROTATION flag.
                 * @see #TYPE_IDENTITY
                 * @see #TYPE_TRANSLATION
                 * @see #TYPE_UNIFORM_SCALE
                 * @see #TYPE_GENERAL_SCALE
                 * @see #TYPE_FLIP
                 * @see #TYPE_QUADRANT_ROTATION
                 * @see #TYPE_GENERAL_TRANSFORM
                 * @see #getType
                 * @since 1.2
                 */
                AffineTransform.TYPE_GENERAL_ROTATION = 16;
                /**
                 * This constant indicates that the transform defined by this object
                 * performs an arbitrary conversion of the input coordinates.
                 * If this transform can be classified by any of the above constants,
                 * the type will either be the constant TYPE_IDENTITY or a
                 * combination of the appropriate flag bits for the various coordinate
                 * conversions that this transform performs.
                 * @see #TYPE_IDENTITY
                 * @see #TYPE_TRANSLATION
                 * @see #TYPE_UNIFORM_SCALE
                 * @see #TYPE_GENERAL_SCALE
                 * @see #TYPE_FLIP
                 * @see #TYPE_QUADRANT_ROTATION
                 * @see #TYPE_GENERAL_ROTATION
                 * @see #getType
                 * @since 1.2
                 */
                AffineTransform.TYPE_GENERAL_TRANSFORM = 32;
                /**
                 * This constant is used for the internal state variable to indicate
                 * that no calculations need to be performed and that the source
                 * coordinates only need to be copied to their destinations to
                 * complete the transformation equation of this transform.
                 * @see #APPLY_TRANSLATE
                 * @see #APPLY_SCALE
                 * @see #APPLY_SHEAR
                 * @see #state
                 */
                AffineTransform.APPLY_IDENTITY = 0;
                /**
                 * This constant is used for the internal state variable to indicate
                 * that the translation components of the matrix (m02 and m12) need
                 * to be added to complete the transformation equation of this transform.
                 * @see #APPLY_IDENTITY
                 * @see #APPLY_SCALE
                 * @see #APPLY_SHEAR
                 * @see #state
                 */
                AffineTransform.APPLY_TRANSLATE = 1;
                /**
                 * This constant is used for the internal state variable to indicate
                 * that the scaling components of the matrix (m00 and m11) need
                 * to be factored in to complete the transformation equation of
                 * this transform.  If the APPLY_SHEAR bit is also set then it
                 * indicates that the scaling components are not both 0.0.  If the
                 * APPLY_SHEAR bit is not also set then it indicates that the
                 * scaling components are not both 1.0.  If neither the APPLY_SHEAR
                 * nor the APPLY_SCALE bits are set then the scaling components
                 * are both 1.0, which means that the x and y components contribute
                 * to the transformed coordinate, but they are not multiplied by
                 * any scaling factor.
                 * @see #APPLY_IDENTITY
                 * @see #APPLY_TRANSLATE
                 * @see #APPLY_SHEAR
                 * @see #state
                 */
                AffineTransform.APPLY_SCALE = 2;
                /**
                 * This constant is used for the internal state variable to indicate
                 * that the shearing components of the matrix (m01 and m10) need
                 * to be factored in to complete the transformation equation of this
                 * transform.  The presence of this bit in the state variable changes
                 * the interpretation of the APPLY_SCALE bit as indicated in its
                 * documentation.
                 * @see #APPLY_IDENTITY
                 * @see #APPLY_TRANSLATE
                 * @see #APPLY_SCALE
                 * @see #state
                 */
                AffineTransform.APPLY_SHEAR = 4;
                AffineTransform.HI_SHIFT = 3;
                AffineTransform.serialVersionUID = 1330973210523860834;
                return AffineTransform;
            }());
            geom.AffineTransform = AffineTransform;
            AffineTransform["__class"] = "java.awt.geom.AffineTransform";
            AffineTransform["__interfaces"] = ["java.lang.Cloneable", "java.io.Serializable"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * A utility class to iterate over the path segments of an arc through the
             * PathIterator interface.
             *
             * @author Jim Graham
             */
            var ArcIterator = (function () {
                function ArcIterator(a, at) {
                    this.x = 0;
                    this.y = 0;
                    this.w = 0;
                    this.h = 0;
                    this.angStRad = 0;
                    this.increment = 0;
                    this.cv = 0;
                    this.index = 0;
                    this.arcSegs = 0;
                    this.lineSegs = 0;
                    this.w = a.getWidth() / 2;
                    this.h = a.getHeight() / 2;
                    this.x = a.getX() + this.w;
                    this.y = a.getY() + this.h;
                    this.angStRad = -(function (x) { return x * Math.PI / 180; })(a.getAngleStart());
                    this.affine = at;
                    var ext = -a.getAngleExtent();
                    if (ext >= 360.0 || ext <= -360) {
                        this.arcSegs = 4;
                        this.increment = Math.PI / 2;
                        this.cv = 0.5522847498307933;
                        if (ext < 0) {
                            this.increment = -this.increment;
                            this.cv = -this.cv;
                        }
                    }
                    else {
                        this.arcSegs = (Math.ceil(Math.abs(ext) / 90.0) | 0);
                        this.increment = (function (x) { return x * Math.PI / 180; })(ext / this.arcSegs);
                        this.cv = ArcIterator.btan(this.increment);
                        if (this.cv === 0) {
                            this.arcSegs = 0;
                        }
                    }
                    switch ((a.getArcType())) {
                        case java.awt.geom.Arc2D.OPEN:
                            this.lineSegs = 0;
                            break;
                        case java.awt.geom.Arc2D.CHORD:
                            this.lineSegs = 1;
                            break;
                        case java.awt.geom.Arc2D.PIE:
                            this.lineSegs = 2;
                            break;
                    }
                    if (this.w < 0 || this.h < 0) {
                        this.arcSegs = this.lineSegs = -1;
                    }
                }
                /**
                 * Return the winding rule for determining the insideness of the path.
                 *
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 */
                ArcIterator.prototype.getWindingRule = function () {
                    return java.awt.geom.PathIterator.WIND_NON_ZERO;
                };
                /**
                 * Tests if there are more points to read.
                 *
                 * @return true if there are more points to read
                 */
                ArcIterator.prototype.isDone = function () {
                    return this.index > this.arcSegs + this.lineSegs;
                };
                /**
                 * Moves the iterator to the next segment of the path forwards along the
                 * primary direction of traversal as long as there are more points in that
                 * direction.
                 */
                ArcIterator.prototype.next = function () {
                    this.index++;
                };
                ArcIterator.btan = function (increment) {
                    increment /= 2.0;
                    return 4.0 / 3.0 * Math.sin(increment) / (1.0 + Math.cos(increment));
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of float x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                ArcIterator.prototype.currentSegment = function (coords) {
                    var _this = this;
                    if (((coords != null && coords instanceof Array) || coords === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (_this.isDone()) {
                                throw new java.util.NoSuchElementException("arc iterator out of bounds");
                            }
                            var angle = _this.angStRad;
                            if (_this.index === 0) {
                                coords[0] = (_this.x + Math.cos(angle) * _this.w);
                                coords[1] = (_this.y + Math.sin(angle) * _this.h);
                                if (_this.affine != null) {
                                    _this.affine.transform(coords, 0, coords, 0, 1);
                                }
                                return java.awt.geom.PathIterator.SEG_MOVETO;
                            }
                            if (_this.index > _this.arcSegs) {
                                if (_this.index === _this.arcSegs + _this.lineSegs) {
                                    return java.awt.geom.PathIterator.SEG_CLOSE;
                                }
                                coords[0] = _this.x;
                                coords[1] = _this.y;
                                if (_this.affine != null) {
                                    _this.affine.transform(coords, 0, coords, 0, 1);
                                }
                                return java.awt.geom.PathIterator.SEG_LINETO;
                            }
                            angle += _this.increment * (_this.index - 1);
                            var relx = Math.cos(angle);
                            var rely = Math.sin(angle);
                            coords[0] = (_this.x + (relx - _this.cv * rely) * _this.w);
                            coords[1] = (_this.y + (rely + _this.cv * relx) * _this.h);
                            angle += _this.increment;
                            relx = Math.cos(angle);
                            rely = Math.sin(angle);
                            coords[2] = (_this.x + (relx + _this.cv * rely) * _this.w);
                            coords[3] = (_this.y + (rely - _this.cv * relx) * _this.h);
                            coords[4] = (_this.x + relx * _this.w);
                            coords[5] = (_this.y + rely * _this.h);
                            if (_this.affine != null) {
                                _this.affine.transform(coords, 0, coords, 0, 3);
                            }
                            return java.awt.geom.PathIterator.SEG_CUBICTO;
                        })();
                    }
                    else if (((coords != null && coords instanceof Array) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A double array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of double x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                ArcIterator.prototype.currentSegment$double_A = function (coords) {
                    if (this.isDone()) {
                        throw new java.util.NoSuchElementException("arc iterator out of bounds");
                    }
                    var angle = this.angStRad;
                    if (this.index === 0) {
                        coords[0] = this.x + Math.cos(angle) * this.w;
                        coords[1] = this.y + Math.sin(angle) * this.h;
                        if (this.affine != null) {
                            this.affine.transform(coords, 0, coords, 0, 1);
                        }
                        return java.awt.geom.PathIterator.SEG_MOVETO;
                    }
                    if (this.index > this.arcSegs) {
                        if (this.index === this.arcSegs + this.lineSegs) {
                            return java.awt.geom.PathIterator.SEG_CLOSE;
                        }
                        coords[0] = this.x;
                        coords[1] = this.y;
                        if (this.affine != null) {
                            this.affine.transform(coords, 0, coords, 0, 1);
                        }
                        return java.awt.geom.PathIterator.SEG_LINETO;
                    }
                    angle += this.increment * (this.index - 1);
                    var relx = Math.cos(angle);
                    var rely = Math.sin(angle);
                    coords[0] = this.x + (relx - this.cv * rely) * this.w;
                    coords[1] = this.y + (rely + this.cv * relx) * this.h;
                    angle += this.increment;
                    relx = Math.cos(angle);
                    rely = Math.sin(angle);
                    coords[2] = this.x + (relx + this.cv * rely) * this.w;
                    coords[3] = this.y + (rely - this.cv * relx) * this.h;
                    coords[4] = this.x + relx * this.w;
                    coords[5] = this.y + rely * this.h;
                    if (this.affine != null) {
                        this.affine.transform(coords, 0, coords, 0, 3);
                    }
                    return java.awt.geom.PathIterator.SEG_CUBICTO;
                };
                return ArcIterator;
            }());
            geom.ArcIterator = ArcIterator;
            ArcIterator["__class"] = "java.awt.geom.ArcIterator";
            ArcIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * An <code>Area</code> object stores and manipulates a resolution-independent
             * description of an enclosed area of 2-dimensional space. <code>Area</code>
             * objects can be transformed and can perform various Constructive Area Geometry
             * (CAG) operations when combined with other <code>Area</code> objects. The CAG
             * operations include area {@link #add addition}, {@link #subtract subtraction},
             * {@link #intersect intersection}, and {@link #exclusiveOr exclusive or}. See
             * the linked method documentation for examples of the various operations.
             * <p>
             * The <code>Area</code> class implements the <code>Shape</code> interface and
             * provides full support for all of its hit-testing and path iteration
             * facilities, but an <code>Area</code> is more specific than a generalized path
             * in a number of ways:
             * <ul>
             * <li>Only closed paths and sub-paths are stored. <code>Area</code> objects
             * constructed from unclosed paths are implicitly closed during construction as
             * if those paths had been filled by the <code>Graphics2D.fill</code> method.
             * <li>The interiors of the individual stored sub-paths are all non-empty and
             * non-overlapping. Paths are decomposed during construction into separate
             * component non-overlapping parts, empty pieces of the path are discarded, and
             * then these non-empty and non-overlapping properties are maintained through
             * all subsequent CAG operations. Outlines of different component sub-paths may
             * touch each other, as long as they do not cross so that their enclosed areas
             * overlap.
             * <li>The geometry of the path describing the outline of the <code>Area</code>
             * resembles the path from which it was constructed only in that it describes
             * the same enclosed 2-dimensional area, but may use entirely different types
             * and ordering of the path segments to do so.
             * </ul>
             * Interesting issues which are not always obvious when using the
             * <code>Area</code> include:
             * <ul>
             * <li>Creating an <code>Area</code> from an unclosed (open) <code>Shape</code>
             * results in a closed outline in the <code>Area</code> object.
             * <li>Creating an <code>Area</code> from a <code>Shape</code> which encloses no
             * area (even when "closed") produces an empty <code>Area</code>. A common
             * example of this issue is that producing an <code>Area</code> from a line will
             * be empty since the line encloses no area. An empty <code>Area</code> will
             * iterate no geometry in its <code>PathIterator</code> objects.
             * <li>A self-intersecting <code>Shape</code> may be split into two (or more)
             * sub-paths each enclosing one of the non-intersecting portions of the original
             * path.
             * <li>An <code>Area</code> may take more path segments to describe the same
             * geometry even when the original outline is simple and obvious. The analysis
             * that the <code>Area</code> class must perform on the path may not reflect the
             * same concepts of "simple and obvious" as a human being perceives.
             * </ul>
             *
             * @since 1.2
             */
            var Area = (function () {
                /**
                 * The <code>Area</code> class creates an area geometry from the specified
                 * {@link Shape} object. The geometry is explicitly closed, if the
                 * <code>Shape</code> is not already closed. The fill rule (even-odd or
                 * winding) specified by the geometry of the <code>Shape</code> is used to
                 * determine the resulting enclosed area.
                 *
                 * @param s
                 * the <code>Shape</code> from which the area is constructed
                 * @throws NullPointerException
                 * if <code>s</code> is null
                 * @since 1.2
                 */
                function Area(s) {
                    var _this = this;
                    if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.Shape") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || s === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        (function () {
                            if (s != null && s instanceof java.awt.geom.Area) {
                                _this.curves = s.curves;
                            }
                            else {
                                _this.curves = Area.pathToCurves(s.getPathIterator(null));
                            }
                        })();
                    }
                    else if (s === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        (function () {
                            _this.curves = Area.EmptyCurves_$LI$();
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                Area.EmptyCurves_$LI$ = function () { if (Area.EmptyCurves == null)
                    Area.EmptyCurves = new java.util.Vector(); return Area.EmptyCurves; };
                ;
                Area.pathToCurves = function (pi) {
                    var curves = (new java.util.Vector());
                    var windingRule = pi.getWindingRule();
                    var coords = new Array(23);
                    var movx = 0;
                    var movy = 0;
                    var curx = 0;
                    var cury = 0;
                    var newx;
                    var newy;
                    while ((!pi.isDone())) {
                        switch ((pi.currentSegment(coords))) {
                            case java.awt.geom.PathIterator.SEG_MOVETO:
                                sun.awt.geom.Curve.insertLine(curves, curx, cury, movx, movy);
                                curx = movx = coords[0];
                                cury = movy = coords[1];
                                sun.awt.geom.Curve.insertMove(curves, movx, movy);
                                break;
                            case java.awt.geom.PathIterator.SEG_LINETO:
                                newx = coords[0];
                                newy = coords[1];
                                sun.awt.geom.Curve.insertLine(curves, curx, cury, newx, newy);
                                curx = newx;
                                cury = newy;
                                break;
                            case java.awt.geom.PathIterator.SEG_QUADTO:
                                newx = coords[2];
                                newy = coords[3];
                                sun.awt.geom.Curve.insertQuad(curves, curx, cury, coords);
                                curx = newx;
                                cury = newy;
                                break;
                            case java.awt.geom.PathIterator.SEG_CUBICTO:
                                newx = coords[4];
                                newy = coords[5];
                                sun.awt.geom.Curve.insertCubic(curves, curx, cury, coords);
                                curx = newx;
                                cury = newy;
                                break;
                            case java.awt.geom.PathIterator.SEG_CLOSE:
                                sun.awt.geom.Curve.insertLine(curves, curx, cury, movx, movy);
                                curx = movx;
                                cury = movy;
                                break;
                        }
                        pi.next();
                    }
                    ;
                    sun.awt.geom.Curve.insertLine(curves, curx, cury, movx, movy);
                    var operator;
                    if (windingRule === java.awt.geom.PathIterator.WIND_EVEN_ODD) {
                        operator = new sun.awt.geom.AreaOp.EOWindOp();
                    }
                    else {
                        operator = new sun.awt.geom.AreaOp.NZWindOp();
                    }
                    return operator.calculate(curves, Area.EmptyCurves_$LI$());
                };
                /**
                 * Adds the shape of the specified <code>Area</code> to the shape of this
                 * <code>Area</code>. The resulting shape of this <code>Area</code> will
                 * include the union of both shapes, or all areas that were contained in
                 * either this or the specified <code>Area</code>.
                 *
                 * <pre>
                 * // Example:
                 * Area a1 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 0,8]);
                 * Area a2 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 8,8]);
                 * a1.add(a2);
                 *
                 * a1(before)     +         a2         =     a1(after)
                 *
                 * ################     ################     ################
                 * ##############         ##############     ################
                 * ############             ############     ################
                 * ##########                 ##########     ################
                 * ########                     ########     ################
                 * ######                         ######     ######    ######
                 * ####                             ####     ####        ####
                 * ##                                 ##     ##            ##
                 * </pre>
                 *
                 * @param rhs
                 * the <code>Area</code> to be added to the current shape
                 * @throws NullPointerException
                 * if <code>rhs</code> is null
                 * @since 1.2
                 */
                Area.prototype.add = function (rhs) {
                    this.curves = new sun.awt.geom.AreaOp.AddOp().calculate(this.curves, rhs.curves);
                    this.invalidateBounds();
                };
                /**
                 * Subtracts the shape of the specified <code>Area</code> from the shape of
                 * this <code>Area</code>. The resulting shape of this <code>Area</code>
                 * will include areas that were contained only in this <code>Area</code> and
                 * not in the specified <code>Area</code>.
                 *
                 * <pre>
                 * // Example:
                 * Area a1 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 0,8]);
                 * Area a2 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 8,8]);
                 * a1.subtract(a2);
                 *
                 * a1(before)     -         a2         =     a1(after)
                 *
                 * ################     ################
                 * ##############         ##############     ##
                 * ############             ############     ####
                 * ##########                 ##########     ######
                 * ########                     ########     ########
                 * ######                         ######     ######
                 * ####                             ####     ####
                 * ##                                 ##     ##
                 * </pre>
                 *
                 * @param rhs
                 * the <code>Area</code> to be subtracted from the current shape
                 * @throws NullPointerException
                 * if <code>rhs</code> is null
                 * @since 1.2
                 */
                Area.prototype.subtract = function (rhs) {
                    this.curves = new sun.awt.geom.AreaOp.SubOp().calculate(this.curves, rhs.curves);
                    this.invalidateBounds();
                };
                /**
                 * Sets the shape of this <code>Area</code> to the intersection of its
                 * current shape and the shape of the specified <code>Area</code>. The
                 * resulting shape of this <code>Area</code> will include only areas that
                 * were contained in both this <code>Area</code> and also in the specified
                 * <code>Area</code>.
                 *
                 * <pre>
                 * // Example:
                 * Area a1 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 0,8]);
                 * Area a2 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 8,8]);
                 * a1.intersect(a2);
                 *
                 * a1(before)   intersect     a2         =     a1(after)
                 *
                 * ################     ################     ################
                 * ##############         ##############       ############
                 * ############             ############         ########
                 * ##########                 ##########           ####
                 * ########                     ########
                 * ######                         ######
                 * ####                             ####
                 * ##                                 ##
                 * </pre>
                 *
                 * @param rhs
                 * the <code>Area</code> to be intersected with this
                 * <code>Area</code>
                 * @throws NullPointerException
                 * if <code>rhs</code> is null
                 * @since 1.2
                 */
                Area.prototype.intersect = function (rhs) {
                    this.curves = new sun.awt.geom.AreaOp.IntOp().calculate(this.curves, rhs.curves);
                    this.invalidateBounds();
                };
                /**
                 * Sets the shape of this <code>Area</code> to be the combined area of its
                 * current shape and the shape of the specified <code>Area</code>, minus
                 * their intersection. The resulting shape of this <code>Area</code> will
                 * include only areas that were contained in either this <code>Area</code>
                 * or in the specified <code>Area</code>, but not in both.
                 *
                 * <pre>
                 * // Example:
                 * Area a1 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 0,8]);
                 * Area a2 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 8,8]);
                 * a1.exclusiveOr(a2);
                 *
                 * a1(before)    xor        a2         =     a1(after)
                 *
                 * ################     ################
                 * ##############         ##############     ##            ##
                 * ############             ############     ####        ####
                 * ##########                 ##########     ######    ######
                 * ########                     ########     ################
                 * ######                         ######     ######    ######
                 * ####                             ####     ####        ####
                 * ##                                 ##     ##            ##
                 * </pre>
                 *
                 * @param rhs
                 * the <code>Area</code> to be exclusive ORed with this
                 * <code>Area</code>.
                 * @throws NullPointerException
                 * if <code>rhs</code> is null
                 * @since 1.2
                 */
                Area.prototype.exclusiveOr = function (rhs) {
                    this.curves = new sun.awt.geom.AreaOp.XorOp().calculate(this.curves, rhs.curves);
                    this.invalidateBounds();
                };
                /**
                 * Removes all of the geometry from this <code>Area</code> and restores it
                 * to an empty area.
                 *
                 * @since 1.2
                 */
                Area.prototype.reset = function () {
                    this.curves = (new java.util.Vector());
                    this.invalidateBounds();
                };
                /**
                 * Tests whether this <code>Area</code> object encloses any area.
                 *
                 * @return <code>true</code> if this <code>Area</code> object represents an
                 * empty area; <code>false</code> otherwise.
                 * @since 1.2
                 */
                Area.prototype.isEmpty = function () {
                    return (this.curves.size() === 0);
                };
                /**
                 * Tests whether this <code>Area</code> consists entirely of straight edged
                 * polygonal geometry.
                 *
                 * @return <code>true</code> if the geometry of this <code>Area</code>
                 * consists entirely of line segments; <code>false</code> otherwise.
                 * @since 1.2
                 */
                Area.prototype.isPolygonal = function () {
                    var enum_ = this.curves.elements();
                    while ((enum_.hasMoreElements())) {
                        if (enum_.nextElement().getOrder() > 1) {
                            return false;
                        }
                    }
                    ;
                    return true;
                };
                /**
                 * Tests whether this <code>Area</code> is rectangular in shape.
                 *
                 * @return <code>true</code> if the geometry of this <code>Area</code> is
                 * rectangular in shape; <code>false</code> otherwise.
                 * @since 1.2
                 */
                Area.prototype.isRectangular = function () {
                    var size = this.curves.size();
                    if (size === 0) {
                        return true;
                    }
                    if (size > 3) {
                        return false;
                    }
                    var c1 = this.curves.get(1);
                    var c2 = this.curves.get(2);
                    if (c1.getOrder() !== 1 || c2.getOrder() !== 1) {
                        return false;
                    }
                    if (c1.getXTop() !== c1.getXBot() || c2.getXTop() !== c2.getXBot()) {
                        return false;
                    }
                    if (c1.getYTop() !== c2.getYTop() || c1.getYBot() !== c2.getYBot()) {
                        return false;
                    }
                    return true;
                };
                /**
                 * Tests whether this <code>Area</code> is comprised of a single closed
                 * subpath. This method returns <code>true</code> if the path contains 0 or
                 * 1 subpaths, or <code>false</code> if the path contains more than 1
                 * subpath. The subpaths are counted by the number of
                 * {@link PathIterator#SEG_MOVETO SEG_MOVETO} segments that appear in the
                 * path.
                 *
                 * @return <code>true</code> if the <code>Area</code> is comprised of a
                 * single basic geometry; <code>false</code> otherwise.
                 * @since 1.2
                 */
                Area.prototype.isSingular = function () {
                    if (this.curves.size() < 3) {
                        return true;
                    }
                    var enum_ = this.curves.elements();
                    enum_.nextElement();
                    while ((enum_.hasMoreElements())) {
                        if (enum_.nextElement().getOrder() === 0) {
                            return false;
                        }
                    }
                    ;
                    return true;
                };
                Area.prototype.invalidateBounds = function () {
                    this.cachedBounds = null;
                };
                Area.prototype.getCachedBounds = function () {
                    if (this.cachedBounds != null) {
                        return this.cachedBounds;
                    }
                    var r = new java.awt.geom.Rectangle2D.Double();
                    if (this.curves.size() > 0) {
                        var c = this.curves.get(0);
                        r.setRect(c.getX0(), c.getY0(), 0, 0);
                        for (var i = 1; i < this.curves.size(); i++) {
                            this.curves.get(i).enlarge(r);
                        }
                    }
                    return (this.cachedBounds = r);
                };
                /**
                 * Returns a high precision bounding {@link Rectangle2D} that completely
                 * encloses this <code>Area</code>.
                 * <p>
                 * The Area class will attempt to return the tightest bounding box possible
                 * for the Shape. The bounding box will not be padded to include the control
                 * points of curves in the outline of the Shape, but should tightly fit the
                 * actual geometry of the outline itself.
                 *
                 * @return the bounding <code>Rectangle2D</code> for the <code>Area</code>.
                 * @since 1.2
                 */
                Area.prototype.getBounds2D = function () {
                    return this.getCachedBounds().getBounds2D();
                };
                /**
                 * Returns a bounding {@link Rectangle} that completely encloses this
                 * <code>Area</code>.
                 * <p>
                 * The Area class will attempt to return the tightest bounding box possible
                 * for the Shape. The bounding box will not be padded to include the control
                 * points of curves in the outline of the Shape, but should tightly fit the
                 * actual geometry of the outline itself. Since the returned object
                 * represents the bounding box with integers, the bounding box can only be
                 * as tight as the nearest integer coordinates that encompass the geometry
                 * of the Shape.
                 *
                 * @return the bounding <code>Rectangle</code> for the <code>Area</code>.
                 * @since 1.2
                 */
                Area.prototype.getBounds = function () {
                    return this.getCachedBounds().getBounds();
                };
                /**
                 * Returns an exact copy of this <code>Area</code> object.
                 *
                 * @return Created clone object
                 * @since 1.2
                 */
                Area.prototype.clone = function () {
                    return new Area(this);
                };
                /**
                 * Tests whether the geometries of the two <code>Area</code> objects are
                 * equal. This method will return false if the argument is null.
                 *
                 * @param other
                 * the <code>Area</code> to be compared to this <code>Area</code>
                 * @return <code>true</code> if the two geometries are equal;
                 * <code>false</code> otherwise.
                 * @since 1.2
                 */
                Area.prototype.equals = function (other) {
                    if (other === this) {
                        return true;
                    }
                    if (other == null) {
                        return false;
                    }
                    var c = new sun.awt.geom.AreaOp.XorOp().calculate(this.curves, other.curves);
                    return c.isEmpty();
                };
                /**
                 * Transforms the geometry of this <code>Area</code> using the specified
                 * {@link AffineTransform}. The geometry is transformed in place, which
                 * permanently changes the enclosed area defined by this object.
                 *
                 * @param t
                 * the transformation used to transform the area
                 * @throws NullPointerException
                 * if <code>t</code> is null
                 * @since 1.2
                 */
                Area.prototype.transform = function (t) {
                    if (t == null) {
                        throw new java.lang.NullPointerException("transform must not be null");
                    }
                    this.curves = Area.pathToCurves(this.getPathIterator(t));
                    this.invalidateBounds();
                };
                /**
                 * Creates a new <code>Area</code> object that contains the same geometry as
                 * this <code>Area</code> transformed by the specified
                 * <code>AffineTransform</code>. This <code>Area</code> object is unchanged.
                 *
                 * @param t
                 * the specified <code>AffineTransform</code> used to transform
                 * the new <code>Area</code>
                 * @throws NullPointerException
                 * if <code>t</code> is null
                 * @return a new <code>Area</code> object representing the transformed
                 * geometry.
                 * @since 1.2
                 */
                Area.prototype.createTransformedArea = function (t) {
                    var a = new Area(this);
                    a.transform(t);
                    return a;
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Area.prototype.contains$double$double = function (x, y) {
                    if (!this.getCachedBounds().contains(x, y)) {
                        return false;
                    }
                    var enum_ = this.curves.elements();
                    var crossings = 0;
                    while ((enum_.hasMoreElements())) {
                        var c = enum_.nextElement();
                        crossings += c.crossingsFor(x, y);
                    }
                    ;
                    return ((crossings & 1) === 1);
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Area.prototype.contains$java_awt_geom_Point2D = function (p) {
                    return this.contains(p.getX(), p.getY());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Area.prototype.contains = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (w < 0 || h < 0) {
                                return false;
                            }
                            if (!_this.getCachedBounds().contains(x, y, w, h)) {
                                return false;
                            }
                            var c = sun.awt.geom.Crossings.findCrossings(_this.curves, x, y, x + w, y + h);
                            return (c != null && c.covers(y, y + h));
                        })();
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Area.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
                    return this.contains(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Area.prototype.intersects = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (w < 0 || h < 0) {
                                return false;
                            }
                            if (!_this.getCachedBounds().intersects(x, y, w, h)) {
                                return false;
                            }
                            var c = sun.awt.geom.Crossings.findCrossings(_this.curves, x, y, x + w, y + h);
                            return (c == null || !c.isEmpty());
                        })();
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Area.prototype.intersects$java_awt_geom_Rectangle2D = function (r) {
                    return this.intersects(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * Creates a {@link PathIterator} for the outline of this <code>Area</code>
                 * object. This <code>Area</code> object is unchanged.
                 *
                 * @param at
                 * an optional <code>AffineTransform</code> to be applied to the
                 * coordinates as they are returned in the iteration, or
                 * <code>null</code> if untransformed coordinates are desired
                 * @return the <code>PathIterator</code> object that returns the geometry of
                 * the outline of this <code>Area</code>, one segment at a time.
                 * @since 1.2
                 */
                Area.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                    return new java.awt.geom.AreaIterator(this.curves, at);
                };
                /**
                 * Creates a <code>PathIterator</code> for the flattened outline of this
                 * <code>Area</code> object. Only uncurved path segments represented by the
                 * SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types are returned by the
                 * iterator. This <code>Area</code> object is unchanged.
                 *
                 * @param at
                 * an optional <code>AffineTransform</code> to be applied to the
                 * coordinates as they are returned in the iteration, or
                 * <code>null</code> if untransformed coordinates are desired
                 * @param flatness
                 * the maximum amount that the control points for a given curve
                 * can vary from colinear before a subdivided curve is replaced
                 * by a straight line connecting the end points
                 * @return the <code>PathIterator</code> object that returns the geometry of
                 * the outline of this <code>Area</code>, one segment at a time.
                 * @since 1.2
                 */
                Area.prototype.getPathIterator = function (at, flatness) {
                    var _this = this;
                    if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            return new java.awt.geom.FlatteningPathIterator(_this.getPathIterator(at), flatness);
                        })();
                    }
                    else if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && flatness === undefined) {
                        return this.getPathIterator$java_awt_geom_AffineTransform(at);
                    }
                    else
                        throw new Error('invalid overload');
                };
                return Area;
            }());
            geom.Area = Area;
            Area["__class"] = "java.awt.geom.Area";
            Area["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
            var AreaIterator = (function () {
                function AreaIterator(curves, at) {
                    this.index = 0;
                    this.curves = curves;
                    this.transform = at;
                    if (curves.size() >= 1) {
                        this.thiscurve = curves.get(0);
                    }
                }
                AreaIterator.prototype.getWindingRule = function () {
                    return java.awt.geom.PathIterator.WIND_NON_ZERO;
                };
                AreaIterator.prototype.isDone = function () {
                    return (this.prevcurve == null && this.thiscurve == null);
                };
                AreaIterator.prototype.next = function () {
                    if (this.prevcurve != null) {
                        this.prevcurve = null;
                    }
                    else {
                        this.prevcurve = this.thiscurve;
                        this.index++;
                        if (this.index < this.curves.size()) {
                            this.thiscurve = this.curves.get(this.index);
                            if (this.thiscurve.getOrder() !== 0 && this.prevcurve.getX1() === this.thiscurve.getX0() && this.prevcurve.getY1() === this.thiscurve.getY0()) {
                                this.prevcurve = null;
                            }
                        }
                        else {
                            this.thiscurve = null;
                        }
                    }
                };
                AreaIterator.prototype.currentSegment = function (coords) {
                    var _this = this;
                    if (((coords != null && coords instanceof Array) || coords === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            var dcoords = new Array(6);
                            var segtype = _this.currentSegment(dcoords);
                            var numpoints = (segtype === java.awt.geom.PathIterator.SEG_CLOSE ? 0 : (segtype === java.awt.geom.PathIterator.SEG_QUADTO ? 2 : (segtype === java.awt.geom.PathIterator.SEG_CUBICTO ? 3 : 1)));
                            for (var i = 0; i < numpoints * 2; i++) {
                                coords[i] = dcoords[i];
                            }
                            return segtype;
                        })();
                    }
                    else if (((coords != null && coords instanceof Array) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                AreaIterator.prototype.currentSegment$double_A = function (coords) {
                    var segtype;
                    var numpoints;
                    if (this.prevcurve != null) {
                        if (this.thiscurve == null || this.thiscurve.getOrder() === 0) {
                            return java.awt.geom.PathIterator.SEG_CLOSE;
                        }
                        coords[0] = this.thiscurve.getX0();
                        coords[1] = this.thiscurve.getY0();
                        segtype = java.awt.geom.PathIterator.SEG_LINETO;
                        numpoints = 1;
                    }
                    else if (this.thiscurve == null) {
                        throw new java.util.NoSuchElementException("area iterator out of bounds");
                    }
                    else {
                        segtype = this.thiscurve.getSegment(coords);
                        numpoints = this.thiscurve.getOrder();
                        if (numpoints === 0) {
                            numpoints = 1;
                        }
                    }
                    if (this.transform != null) {
                        this.transform.transform(coords, 0, coords, 0, numpoints);
                    }
                    return segtype;
                };
                return AreaIterator;
            }());
            geom.AreaIterator = AreaIterator;
            AreaIterator["__class"] = "java.awt.geom.AreaIterator";
            AreaIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>CubicCurve2D</code> class defines a cubic parametric curve segment
             * in {@code (x,y)} coordinate space.
             * <p>
             * This class is only the abstract superclass for all objects which store a 2D
             * cubic curve segment. The actual storage representation of the coordinates is
             * left to the subclass.
             *
             * @author Jim Graham
             * @since 1.2
             */
            var CubicCurve2D = (function () {
                /**
                 * This is an abstract class that cannot be instantiated directly.
                 * Type-specific implementation subclasses are available for instantiation
                 * and provide a number of formats for storing the information necessary to
                 * satisfy the various accessor methods below.
                 *
                 * @see java.awt.geom.CubicCurve2D.Float
                 * @see java.awt.geom.CubicCurve2D.Double
                 * @since 1.2
                 */
                function CubicCurve2D() {
                }
                /**
                 * Sets the location of the end points and control points of this curve
                 * to the specified {@code float} coordinates.
                 *
                 * @param x1
                 * the X coordinate used to set the start point of this
                 * {@code CubicCurve2D}
                 * @param y1
                 * the Y coordinate used to set the start point of this
                 * {@code CubicCurve2D}
                 * @param ctrlx1
                 * the X coordinate used to set the first control point of
                 * this {@code CubicCurve2D}
                 * @param ctrly1
                 * the Y coordinate used to set the first control point of
                 * this {@code CubicCurve2D}
                 * @param ctrlx2
                 * the X coordinate used to set the second control point of
                 * this {@code CubicCurve2D}
                 * @param ctrly2
                 * the Y coordinate used to set the second control point of
                 * this {@code CubicCurve2D}
                 * @param x2
                 * the X coordinate used to set the end point of this
                 * {@code CubicCurve2D}
                 * @param y2
                 * the Y coordinate used to set the end point of this
                 * {@code CubicCurve2D}
                 * @since 1.2
                 */
                CubicCurve2D.prototype.setCurve = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return this.setCurve$double$double$double$double$double$double$double$double(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && ((ctrlx1 != null && ctrlx1 instanceof java.awt.geom.Point2D) || ctrlx1 === null) && ((ctrly1 != null && ctrly1 instanceof java.awt.geom.Point2D) || ctrly1 === null) && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                        return this.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1, ctrlx1, ctrly1);
                    }
                    else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                        return this.setCurve$double_A$int(x1, y1);
                    }
                    else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                        return this.setCurve$java_awt_geom_Point2D_A$int(x1, y1);
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.CubicCurve2D) || x1 === null) && y1 === undefined && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                        return this.setCurve$java_awt_geom_CubicCurve2D(x1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the location of the end points and control points of this curve to
                 * the specified double coordinates.
                 *
                 * @param x1
                 * the X coordinate used to set the start point of this
                 * {@code CubicCurve2D}
                 * @param y1
                 * the Y coordinate used to set the start point of this
                 * {@code CubicCurve2D}
                 * @param ctrlx1
                 * the X coordinate used to set the first control point of this
                 * {@code CubicCurve2D}
                 * @param ctrly1
                 * the Y coordinate used to set the first control point of this
                 * {@code CubicCurve2D}
                 * @param ctrlx2
                 * the X coordinate used to set the second control point of this
                 * {@code CubicCurve2D}
                 * @param ctrly2
                 * the Y coordinate used to set the second control point of this
                 * {@code CubicCurve2D}
                 * @param x2
                 * the X coordinate used to set the end point of this
                 * {@code CubicCurve2D}
                 * @param y2
                 * the Y coordinate used to set the end point of this
                 * {@code CubicCurve2D}
                 * @since 1.2
                 */
                CubicCurve2D.prototype.setCurve$double$double$double$double$double$double$double$double = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets the location of the end points and control points of this curve to
                 * the double coordinates at the specified offset in the specified array.
                 *
                 * @param coords
                 * a double array containing coordinates
                 * @param offset
                 * the index of <code>coords</code> from which to begin setting
                 * the end points and control points of this curve to the
                 * coordinates contained in <code>coords</code>
                 * @since 1.2
                 */
                CubicCurve2D.prototype.setCurve$double_A$int = function (coords, offset) {
                    this.setCurve(coords[offset + 0], coords[offset + 1], coords[offset + 2], coords[offset + 3], coords[offset + 4], coords[offset + 5], coords[offset + 6], coords[offset + 7]);
                };
                /**
                 * Sets the location of the end points and control points of this curve to
                 * the specified <code>Point2D</code> coordinates.
                 *
                 * @param p1
                 * the first specified <code>Point2D</code> used to set the start
                 * point of this curve
                 * @param cp1
                 * the second specified <code>Point2D</code> used to set the
                 * first control point of this curve
                 * @param cp2
                 * the third specified <code>Point2D</code> used to set the
                 * second control point of this curve
                 * @param p2
                 * the fourth specified <code>Point2D</code> used to set the end
                 * point of this curve
                 * @since 1.2
                 */
                CubicCurve2D.prototype.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D = function (p1, cp1, cp2, p2) {
                    this.setCurve(p1.getX(), p1.getY(), cp1.getX(), cp1.getY(), cp2.getX(), cp2.getY(), p2.getX(), p2.getY());
                };
                /**
                 * Sets the location of the end points and control points of this curve to
                 * the coordinates of the <code>Point2D</code> objects at the specified
                 * offset in the specified array.
                 *
                 * @param pts
                 * an array of <code>Point2D</code> objects
                 * @param offset
                 * the index of <code>pts</code> from which to begin setting the
                 * end points and control points of this curve to the points
                 * contained in <code>pts</code>
                 * @since 1.2
                 */
                CubicCurve2D.prototype.setCurve$java_awt_geom_Point2D_A$int = function (pts, offset) {
                    this.setCurve(pts[offset + 0].getX(), pts[offset + 0].getY(), pts[offset + 1].getX(), pts[offset + 1].getY(), pts[offset + 2].getX(), pts[offset + 2].getY(), pts[offset + 3].getX(), pts[offset + 3].getY());
                };
                /**
                 * Sets the location of the end points and control points of this curve to
                 * the same as those in the specified <code>CubicCurve2D</code>.
                 *
                 * @param c
                 * the specified <code>CubicCurve2D</code>
                 * @since 1.2
                 */
                CubicCurve2D.prototype.setCurve$java_awt_geom_CubicCurve2D = function (c) {
                    this.setCurve(c.getX1(), c.getY1(), c.getCtrlX1(), c.getCtrlY1(), c.getCtrlX2(), c.getCtrlY2(), c.getX2(), c.getY2());
                };
                /**
                 * Returns the square of the flatness of the cubic curve specified by the
                 * indicated control points. The flatness is the maximum distance of a
                 * control point from the line connecting the end points.
                 *
                 * @param x1
                 * the X coordinate that specifies the start point of a
                 * {@code CubicCurve2D}
                 * @param y1
                 * the Y coordinate that specifies the start point of a
                 * {@code CubicCurve2D}
                 * @param ctrlx1
                 * the X coordinate that specifies the first control point of a
                 * {@code CubicCurve2D}
                 * @param ctrly1
                 * the Y coordinate that specifies the first control point of a
                 * {@code CubicCurve2D}
                 * @param ctrlx2
                 * the X coordinate that specifies the second control point of a
                 * {@code CubicCurve2D}
                 * @param ctrly2
                 * the Y coordinate that specifies the second control point of a
                 * {@code CubicCurve2D}
                 * @param x2
                 * the X coordinate that specifies the end point of a
                 * {@code CubicCurve2D}
                 * @param y2
                 * the Y coordinate that specifies the end point of a
                 * {@code CubicCurve2D}
                 * @return the square of the flatness of the {@code CubicCurve2D}
                 * represented by the specified coordinates.
                 * @since 1.2
                 */
                CubicCurve2D.getFlatnessSq = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            return Math.max(java.awt.geom.Line2D.ptSegDistSq(x1, y1, x2, y2, ctrlx1, ctrly1), java.awt.geom.Line2D.ptSegDistSq(x1, y1, x2, y2, ctrlx2, ctrly2));
                        })();
                    }
                    else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                        return java.awt.geom.CubicCurve2D.getFlatnessSq$double_A$int(x1, y1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the flatness of the cubic curve specified by the indicated
                 * control points. The flatness is the maximum distance of a control point
                 * from the line connecting the end points.
                 *
                 * @param x1
                 * the X coordinate that specifies the start point of a
                 * {@code CubicCurve2D}
                 * @param y1
                 * the Y coordinate that specifies the start point of a
                 * {@code CubicCurve2D}
                 * @param ctrlx1
                 * the X coordinate that specifies the first control point of a
                 * {@code CubicCurve2D}
                 * @param ctrly1
                 * the Y coordinate that specifies the first control point of a
                 * {@code CubicCurve2D}
                 * @param ctrlx2
                 * the X coordinate that specifies the second control point of a
                 * {@code CubicCurve2D}
                 * @param ctrly2
                 * the Y coordinate that specifies the second control point of a
                 * {@code CubicCurve2D}
                 * @param x2
                 * the X coordinate that specifies the end point of a
                 * {@code CubicCurve2D}
                 * @param y2
                 * the Y coordinate that specifies the end point of a
                 * {@code CubicCurve2D}
                 * @return the flatness of the {@code CubicCurve2D} represented by the
                 * specified coordinates.
                 * @since 1.2
                 */
                CubicCurve2D.getFlatness = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            return Math.sqrt(CubicCurve2D.getFlatnessSq(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2));
                        })();
                    }
                    else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                        return java.awt.geom.CubicCurve2D.getFlatness$double_A$int(x1, y1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the square of the flatness of the cubic curve specified by the
                 * control points stored in the indicated array at the indicated index. The
                 * flatness is the maximum distance of a control point from the line
                 * connecting the end points.
                 *
                 * @param coords
                 * an array containing coordinates
                 * @param offset
                 * the index of <code>coords</code> from which to begin getting
                 * the end points and control points of the curve
                 * @return the square of the flatness of the <code>CubicCurve2D</code>
                 * specified by the coordinates in <code>coords</code> at the
                 * specified offset.
                 * @since 1.2
                 */
                CubicCurve2D.getFlatnessSq$double_A$int = function (coords, offset) {
                    return CubicCurve2D.getFlatnessSq(coords[offset + 0], coords[offset + 1], coords[offset + 2], coords[offset + 3], coords[offset + 4], coords[offset + 5], coords[offset + 6], coords[offset + 7]);
                };
                /**
                 * Returns the flatness of the cubic curve specified by the control points
                 * stored in the indicated array at the indicated index. The flatness is the
                 * maximum distance of a control point from the line connecting the end
                 * points.
                 *
                 * @param coords
                 * an array containing coordinates
                 * @param offset
                 * the index of <code>coords</code> from which to begin getting
                 * the end points and control points of the curve
                 * @return the flatness of the <code>CubicCurve2D</code> specified by the
                 * coordinates in <code>coords</code> at the specified offset.
                 * @since 1.2
                 */
                CubicCurve2D.getFlatness$double_A$int = function (coords, offset) {
                    return CubicCurve2D.getFlatness(coords[offset + 0], coords[offset + 1], coords[offset + 2], coords[offset + 3], coords[offset + 4], coords[offset + 5], coords[offset + 6], coords[offset + 7]);
                };
                /**
                 * Returns the square of the flatness of this curve. The flatness is the
                 * maximum distance of a control point from the line connecting the end
                 * points.
                 *
                 * @return the square of the flatness of this curve.
                 * @since 1.2
                 */
                CubicCurve2D.prototype.getFlatnessSq = function () {
                    return CubicCurve2D.getFlatnessSq(this.getX1(), this.getY1(), this.getCtrlX1(), this.getCtrlY1(), this.getCtrlX2(), this.getCtrlY2(), this.getX2(), this.getY2());
                };
                /**
                 * Returns the flatness of this curve. The flatness is the maximum distance
                 * of a control point from the line connecting the end points.
                 *
                 * @return the flatness of this curve.
                 * @since 1.2
                 */
                CubicCurve2D.prototype.getFlatness = function () {
                    return CubicCurve2D.getFlatness(this.getX1(), this.getY1(), this.getCtrlX1(), this.getCtrlY1(), this.getCtrlX2(), this.getCtrlY2(), this.getX2(), this.getY2());
                };
                /**
                 * Subdivides this cubic curve and stores the resulting two subdivided
                 * curves into the left and right curve parameters. Either or both of the
                 * left and right objects may be the same as this object or null.
                 *
                 * @param left
                 * the cubic curve object for storing for the left or first half
                 * of the subdivided curve
                 * @param right
                 * the cubic curve object for storing for the right or second
                 * half of the subdivided curve
                 * @since 1.2
                 */
                CubicCurve2D.prototype.subdivide = function (left, right) {
                    CubicCurve2D.subdivide(this, left, right);
                };
                /**
                 * Subdivides the cubic curve specified by the <code>src</code> parameter
                 * and stores the resulting two subdivided curves into the <code>left</code>
                 * and <code>right</code> curve parameters. Either or both of the
                 * <code>left</code> and <code>right</code> objects may be the same as the
                 * <code>src</code> object or <code>null</code>.
                 *
                 * @param src
                 * the cubic curve to be subdivided
                 * @param left
                 * the cubic curve object for storing the left or first half of
                 * the subdivided curve
                 * @param right
                 * the cubic curve object for storing the right or second half of
                 * the subdivided curve
                 * @since 1.2
                 */
                CubicCurve2D.subdivide$java_awt_geom_CubicCurve2D$java_awt_geom_CubicCurve2D$java_awt_geom_CubicCurve2D = function (src, left, right) {
                    var x1 = src.getX1();
                    var y1 = src.getY1();
                    var ctrlx1 = src.getCtrlX1();
                    var ctrly1 = src.getCtrlY1();
                    var ctrlx2 = src.getCtrlX2();
                    var ctrly2 = src.getCtrlY2();
                    var x2 = src.getX2();
                    var y2 = src.getY2();
                    var centerx = (ctrlx1 + ctrlx2) / 2.0;
                    var centery = (ctrly1 + ctrly2) / 2.0;
                    ctrlx1 = (x1 + ctrlx1) / 2.0;
                    ctrly1 = (y1 + ctrly1) / 2.0;
                    ctrlx2 = (x2 + ctrlx2) / 2.0;
                    ctrly2 = (y2 + ctrly2) / 2.0;
                    var ctrlx12 = (ctrlx1 + centerx) / 2.0;
                    var ctrly12 = (ctrly1 + centery) / 2.0;
                    var ctrlx21 = (ctrlx2 + centerx) / 2.0;
                    var ctrly21 = (ctrly2 + centery) / 2.0;
                    centerx = (ctrlx12 + ctrlx21) / 2.0;
                    centery = (ctrly12 + ctrly21) / 2.0;
                    if (left != null) {
                        left.setCurve(x1, y1, ctrlx1, ctrly1, ctrlx12, ctrly12, centerx, centery);
                    }
                    if (right != null) {
                        right.setCurve(centerx, centery, ctrlx21, ctrly21, ctrlx2, ctrly2, x2, y2);
                    }
                };
                /**
                 * Subdivides the cubic curve specified by the coordinates stored in the
                 * <code>src</code> array at indices <code>srcoff</code> through (
                 * <code>srcoff</code>&nbsp;+&nbsp;7) and stores the resulting two
                 * subdivided curves into the two result arrays at the corresponding
                 * indices. Either or both of the <code>left</code> and <code>right</code>
                 * arrays may be <code>null</code> or a reference to the same array as the
                 * <code>src</code> array. Note that the last point in the first subdivided
                 * curve is the same as the first point in the second subdivided curve.
                 * Thus, it is possible to pass the same array for <code>left</code> and
                 * <code>right</code> and to use offsets, such as <code>rightoff</code>
                 * equals (<code>leftoff</code> + 6), in order to avoid allocating extra
                 * storage for this common point.
                 *
                 * @param src
                 * the array holding the coordinates for the source curve
                 * @param srcoff
                 * the offset into the array of the beginning of the the 6 source
                 * coordinates
                 * @param left
                 * the array for storing the coordinates for the first half of
                 * the subdivided curve
                 * @param leftoff
                 * the offset into the array of the beginning of the the 6 left
                 * coordinates
                 * @param right
                 * the array for storing the coordinates for the second half of
                 * the subdivided curve
                 * @param rightoff
                 * the offset into the array of the beginning of the the 6 right
                 * coordinates
                 * @since 1.2
                 */
                CubicCurve2D.subdivide = function (src, srcoff, left, leftoff, right, rightoff) {
                    if (((src != null && src instanceof Array) || src === null) && ((typeof srcoff === 'number') || srcoff === null) && ((left != null && left instanceof Array) || left === null) && ((typeof leftoff === 'number') || leftoff === null) && ((right != null && right instanceof Array) || right === null) && ((typeof rightoff === 'number') || rightoff === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            var x1 = src[srcoff + 0];
                            var y1 = src[srcoff + 1];
                            var ctrlx1 = src[srcoff + 2];
                            var ctrly1 = src[srcoff + 3];
                            var ctrlx2 = src[srcoff + 4];
                            var ctrly2 = src[srcoff + 5];
                            var x2 = src[srcoff + 6];
                            var y2 = src[srcoff + 7];
                            if (left != null) {
                                left[leftoff + 0] = x1;
                                left[leftoff + 1] = y1;
                            }
                            if (right != null) {
                                right[rightoff + 6] = x2;
                                right[rightoff + 7] = y2;
                            }
                            x1 = (x1 + ctrlx1) / 2.0;
                            y1 = (y1 + ctrly1) / 2.0;
                            x2 = (x2 + ctrlx2) / 2.0;
                            y2 = (y2 + ctrly2) / 2.0;
                            var centerx = (ctrlx1 + ctrlx2) / 2.0;
                            var centery = (ctrly1 + ctrly2) / 2.0;
                            ctrlx1 = (x1 + centerx) / 2.0;
                            ctrly1 = (y1 + centery) / 2.0;
                            ctrlx2 = (x2 + centerx) / 2.0;
                            ctrly2 = (y2 + centery) / 2.0;
                            centerx = (ctrlx1 + ctrlx2) / 2.0;
                            centery = (ctrly1 + ctrly2) / 2.0;
                            if (left != null) {
                                left[leftoff + 2] = x1;
                                left[leftoff + 3] = y1;
                                left[leftoff + 4] = ctrlx1;
                                left[leftoff + 5] = ctrly1;
                                left[leftoff + 6] = centerx;
                                left[leftoff + 7] = centery;
                            }
                            if (right != null) {
                                right[rightoff + 0] = centerx;
                                right[rightoff + 1] = centery;
                                right[rightoff + 2] = ctrlx2;
                                right[rightoff + 3] = ctrly2;
                                right[rightoff + 4] = x2;
                                right[rightoff + 5] = y2;
                            }
                        })();
                    }
                    else if (((src != null && src instanceof java.awt.geom.CubicCurve2D) || src === null) && ((srcoff != null && srcoff instanceof java.awt.geom.CubicCurve2D) || srcoff === null) && ((left != null && left instanceof java.awt.geom.CubicCurve2D) || left === null) && leftoff === undefined && right === undefined && rightoff === undefined) {
                        return java.awt.geom.CubicCurve2D.subdivide$java_awt_geom_CubicCurve2D$java_awt_geom_CubicCurve2D$java_awt_geom_CubicCurve2D(src, srcoff, left);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Solves the cubic whose coefficients are in the <code>eqn</code> array and
                 * places the non-complex roots back into the same array, returning the
                 * number of roots. The solved cubic is represented by the equation:
                 *
                 * <pre>
                 * eqn = {c, b, a, d}
                 * dx^3 + ax^2 + bx + c = 0
                 * </pre>
                 *
                 * A return value of -1 is used to distinguish a constant equation that
                 * might be always 0 or never 0 from an equation that has no zeroes.
                 *
                 * @param eqn
                 * an array containing coefficients for a cubic
                 * @return the number of roots, or -1 if the equation is a constant.
                 * @since 1.2
                 */
                CubicCurve2D.solveCubic$double_A = function (eqn) {
                    return CubicCurve2D.solveCubic(eqn, eqn);
                };
                /**
                 * Solve the cubic whose coefficients are in the <code>eqn</code> array and
                 * place the non-complex roots into the <code>res</code> array, returning
                 * the number of roots. The cubic solved is represented by the equation: eqn
                 * = {c, b, a, d} dx^3 + ax^2 + bx + c = 0 A return value of -1 is used to
                 * distinguish a constant equation, which may be always 0 or never 0, from
                 * an equation which has no zeroes.
                 *
                 * @param eqn
                 * the specified array of coefficients to use to solve the cubic
                 * equation
                 * @param res
                 * the array that contains the non-complex roots resulting from
                 * the solution of the cubic equation
                 * @return the number of roots, or -1 if the equation is a constant
                 * @since 1.3
                 */
                CubicCurve2D.solveCubic = function (eqn, res) {
                    if (((eqn != null && eqn instanceof Array) || eqn === null) && ((res != null && res instanceof Array) || res === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            var d = eqn[3];
                            if (d === 0) {
                                return java.awt.geom.QuadCurve2D.solveQuadratic(eqn, res);
                            }
                            var A = eqn[2] / d;
                            var B = eqn[1] / d;
                            var C = eqn[0] / d;
                            var sq_A = A * A;
                            var p = 1.0 / 3 * (-1.0 / 3 * sq_A + B);
                            var q = 1.0 / 2 * (2.0 / 27 * A * sq_A - 1.0 / 3 * A * B + C);
                            var cb_p = p * p * p;
                            var D = q * q + cb_p;
                            var sub = 1.0 / 3 * A;
                            var num;
                            if (D < 0) {
                                var phi = 1.0 / 3 * Math.acos(-q / Math.sqrt(-cb_p));
                                var t = 2 * Math.sqrt(-p);
                                if (res === eqn) {
                                    eqn = java.util.Arrays.copyOf(eqn, 4);
                                }
                                res[0] = (t * Math.cos(phi));
                                res[1] = (-t * Math.cos(phi + Math.PI / 3));
                                res[2] = (-t * Math.cos(phi - Math.PI / 3));
                                num = 3;
                                for (var i = 0; i < num; ++i) {
                                    res[i] -= sub;
                                }
                            }
                            else {
                                var sqrt_D = Math.sqrt(D);
                                var u = Math.pow(sqrt_D - q, 1 / 3);
                                var v = -Math.pow(sqrt_D + q, 1 / 3);
                                var uv = u + v;
                                num = 1;
                                var err = 1200000000 * javaemul.internal.MathHelper.ulp(Math.abs(uv) + Math.abs(sub));
                                if (CubicCurve2D.iszero(D, err) || CubicCurve2D.within(u, v, err)) {
                                    if (res === eqn) {
                                        eqn = java.util.Arrays.copyOf(eqn, 4);
                                    }
                                    res[1] = -(uv / 2) - sub;
                                    num = 2;
                                }
                                res[0] = uv - sub;
                            }
                            if (num > 1) {
                                num = CubicCurve2D.fixRoots(eqn, res, num);
                            }
                            if (num > 2 && (res[2] === res[1] || res[2] === res[0])) {
                                num--;
                            }
                            if (num > 1 && res[1] === res[0]) {
                                res[1] = res[--num];
                            }
                            return num;
                        })();
                    }
                    else if (((eqn != null && eqn instanceof Array) || eqn === null) && res === undefined) {
                        return java.awt.geom.CubicCurve2D.solveCubic$double_A(eqn);
                    }
                    else
                        throw new Error('invalid overload');
                };
                CubicCurve2D.fixRoots = function (eqn, res, num) {
                    var intervals = [eqn[1], 2 * eqn[2], 3 * eqn[3]];
                    var critCount = java.awt.geom.QuadCurve2D.solveQuadratic(intervals, intervals);
                    if (critCount === 2 && intervals[0] === intervals[1]) {
                        critCount--;
                    }
                    if (critCount === 2 && intervals[0] > intervals[1]) {
                        var tmp = intervals[0];
                        intervals[0] = intervals[1];
                        intervals[1] = tmp;
                    }
                    if (num === 3) {
                        var xe = CubicCurve2D.getRootUpperBound(eqn);
                        var x0 = -xe;
                        java.util.Arrays.sort(res, 0, num);
                        if (critCount === 2) {
                            res[0] = CubicCurve2D.refineRootWithHint(eqn, x0, intervals[0], res[0]);
                            res[1] = CubicCurve2D.refineRootWithHint(eqn, intervals[0], intervals[1], res[1]);
                            res[2] = CubicCurve2D.refineRootWithHint(eqn, intervals[1], xe, res[2]);
                            return 3;
                        }
                        else if (critCount === 1) {
                            var fxe = eqn[3];
                            var fx0 = -fxe;
                            var x1 = intervals[0];
                            var fx1 = CubicCurve2D.solveEqn(eqn, 3, x1);
                            if (CubicCurve2D.oppositeSigns(fx0, fx1)) {
                                res[0] = CubicCurve2D.bisectRootWithHint(eqn, x0, x1, res[0]);
                            }
                            else if (CubicCurve2D.oppositeSigns(fx1, fxe)) {
                                res[0] = CubicCurve2D.bisectRootWithHint(eqn, x1, xe, res[2]);
                            }
                            else {
                                res[0] = x1;
                            }
                        }
                        else if (critCount === 0) {
                            res[0] = CubicCurve2D.bisectRootWithHint(eqn, x0, xe, res[1]);
                        }
                    }
                    else if (num === 2 && critCount === 2) {
                        var goodRoot = res[0];
                        var badRoot = res[1];
                        var x1 = intervals[0];
                        var x2 = intervals[1];
                        var x = Math.abs(x1 - goodRoot) > Math.abs(x2 - goodRoot) ? x1 : x2;
                        var fx = CubicCurve2D.solveEqn(eqn, 3, x);
                        if (CubicCurve2D.iszero(fx, 10000000 * javaemul.internal.MathHelper.ulp(x))) {
                            var badRootVal = CubicCurve2D.solveEqn(eqn, 3, badRoot);
                            res[1] = Math.abs(badRootVal) < Math.abs(fx) ? badRoot : x;
                            return 2;
                        }
                    }
                    return 1;
                };
                CubicCurve2D.refineRootWithHint = function (eqn, min, max, t) {
                    if (!CubicCurve2D.inInterval(t, min, max)) {
                        return t;
                    }
                    var deriv = [eqn[1], 2 * eqn[2], 3 * eqn[3]];
                    var origt = t;
                    for (var i = 0; i < 3; i++) {
                        var slope = CubicCurve2D.solveEqn(deriv, 2, t);
                        var y = CubicCurve2D.solveEqn(eqn, 3, t);
                        var delta = -(y / slope);
                        var newt = t + delta;
                        if (slope === 0 || y === 0 || t === newt) {
                            break;
                        }
                        t = newt;
                    }
                    if (CubicCurve2D.within(t, origt, 1000 * javaemul.internal.MathHelper.ulp(origt)) && CubicCurve2D.inInterval(t, min, max)) {
                        return t;
                    }
                    return origt;
                };
                CubicCurve2D.bisectRootWithHint = function (eqn, x0, xe, hint) {
                    var delta1 = Math.min(Math.abs(hint - x0) / 64, 0.0625);
                    var delta2 = Math.min(Math.abs(hint - xe) / 64, 0.0625);
                    var x02 = hint - delta1;
                    var xe2 = hint + delta2;
                    var fx02 = CubicCurve2D.solveEqn(eqn, 3, x02);
                    var fxe2 = CubicCurve2D.solveEqn(eqn, 3, xe2);
                    while ((CubicCurve2D.oppositeSigns(fx02, fxe2))) {
                        if (x02 >= xe2) {
                            return x02;
                        }
                        x0 = x02;
                        xe = xe2;
                        delta1 /= 64;
                        delta2 /= 64;
                        x02 = hint - delta1;
                        xe2 = hint + delta2;
                        fx02 = CubicCurve2D.solveEqn(eqn, 3, x02);
                        fxe2 = CubicCurve2D.solveEqn(eqn, 3, xe2);
                    }
                    ;
                    if (fx02 === 0) {
                        return x02;
                    }
                    if (fxe2 === 0) {
                        return xe2;
                    }
                    return CubicCurve2D.bisectRoot(eqn, x0, xe);
                };
                CubicCurve2D.bisectRoot = function (eqn, x0, xe) {
                    var fx0 = CubicCurve2D.solveEqn(eqn, 3, x0);
                    var m = x0 + (xe - x0) / 2;
                    while ((m !== x0 && m !== xe)) {
                        var fm = CubicCurve2D.solveEqn(eqn, 3, m);
                        if (fm === 0) {
                            return m;
                        }
                        if (CubicCurve2D.oppositeSigns(fx0, fm)) {
                            xe = m;
                        }
                        else {
                            fx0 = fm;
                            x0 = m;
                        }
                        m = x0 + (xe - x0) / 2;
                    }
                    ;
                    return m;
                };
                CubicCurve2D.inInterval = function (t, min, max) {
                    return min <= t && t <= max;
                };
                CubicCurve2D.within = function (x, y, err) {
                    var d = y - x;
                    return (d <= err && d >= -err);
                };
                CubicCurve2D.iszero = function (x, err) {
                    return CubicCurve2D.within(x, 0, err);
                };
                CubicCurve2D.oppositeSigns = function (x1, x2) {
                    return (x1 < 0 && x2 > 0) || (x1 > 0 && x2 < 0);
                };
                CubicCurve2D.solveEqn = function (eqn, order, t) {
                    var v = eqn[order];
                    while ((--order >= 0)) {
                        v = v * t + eqn[order];
                    }
                    ;
                    return v;
                };
                CubicCurve2D.getRootUpperBound = function (eqn) {
                    var d = eqn[3];
                    var a = eqn[2];
                    var b = eqn[1];
                    var c = eqn[0];
                    var M = 1 + Math.max(Math.max(Math.abs(a), Math.abs(b)), Math.abs(c)) / Math.abs(d);
                    M += javaemul.internal.MathHelper.ulp(M) + 1;
                    return M;
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                CubicCurve2D.prototype.contains$double$double = function (x, y) {
                    if (!(x * 0.0 + y * 0.0 === 0.0)) {
                        return false;
                    }
                    var x1 = this.getX1();
                    var y1 = this.getY1();
                    var x2 = this.getX2();
                    var y2 = this.getY2();
                    var crossings = (sun.awt.geom.Curve.pointCrossingsForLine(x, y, x1, y1, x2, y2) + sun.awt.geom.Curve.pointCrossingsForCubic(x, y, x1, y1, this.getCtrlX1(), this.getCtrlY1(), this.getCtrlX2(), this.getCtrlY2(), x2, y2, 0));
                    return ((crossings & 1) === 1);
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                CubicCurve2D.prototype.contains$java_awt_geom_Point2D = function (p) {
                    return this.contains(p.getX(), p.getY());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                CubicCurve2D.prototype.intersects = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (w <= 0 || h <= 0) {
                                return false;
                            }
                            var numCrossings = _this.rectCrossings(x, y, w, h);
                            return numCrossings !== 0;
                        })();
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                CubicCurve2D.prototype.intersects$java_awt_geom_Rectangle2D = function (r) {
                    return this.intersects(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                CubicCurve2D.prototype.contains = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (w <= 0 || h <= 0) {
                                return false;
                            }
                            var numCrossings = _this.rectCrossings(x, y, w, h);
                            return !(numCrossings === 0 || numCrossings === sun.awt.geom.Curve.RECT_INTERSECTS);
                        })();
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                CubicCurve2D.prototype.rectCrossings = function (x, y, w, h) {
                    var crossings = 0;
                    if (!(this.getX1() === this.getX2() && this.getY1() === this.getY2())) {
                        crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, x, y, x + w, y + h, this.getX1(), this.getY1(), this.getX2(), this.getY2());
                        if (crossings === sun.awt.geom.Curve.RECT_INTERSECTS) {
                            return crossings;
                        }
                    }
                    return sun.awt.geom.Curve.rectCrossingsForCubic(crossings, x, y, x + w, y + h, this.getX2(), this.getY2(), this.getCtrlX2(), this.getCtrlY2(), this.getCtrlX1(), this.getCtrlY1(), this.getX1(), this.getY1(), 0);
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                CubicCurve2D.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
                    return this.contains(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                CubicCurve2D.prototype.getBounds = function () {
                    return this.getBounds2D().getBounds();
                };
                /**
                 * Returns an iteration object that defines the boundary of the shape. The
                 * iterator for this class is not multi-threaded safe, which means that this
                 * <code>CubicCurve2D</code> class does not guarantee that modifications to
                 * the geometry of this <code>CubicCurve2D</code> object do not affect any
                 * iterations of that geometry that are already in process.
                 *
                 * @param at
                 * an optional <code>AffineTransform</code> to be applied to the
                 * coordinates as they are returned in the iteration, or
                 * <code>null</code> if untransformed coordinates are desired
                 * @return the <code>PathIterator</code> object that returns the geometry of
                 * the outline of this <code>CubicCurve2D</code>, one segment at a
                 * time.
                 * @since 1.2
                 */
                CubicCurve2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                    return new java.awt.geom.CubicIterator(this, at);
                };
                /**
                 * Return an iteration object that defines the boundary of the flattened
                 * shape. The iterator for this class is not multi-threaded safe, which
                 * means that this <code>CubicCurve2D</code> class does not guarantee that
                 * modifications to the geometry of this <code>CubicCurve2D</code> object do
                 * not affect any iterations of that geometry that are already in process.
                 *
                 * @param at
                 * an optional <code>AffineTransform</code> to be applied to the
                 * coordinates as they are returned in the iteration, or
                 * <code>null</code> if untransformed coordinates are desired
                 * @param flatness
                 * the maximum amount that the control points for a given curve
                 * can vary from colinear before a subdivided curve is replaced
                 * by a straight line connecting the end points
                 * @return the <code>PathIterator</code> object that returns the geometry of
                 * the outline of this <code>CubicCurve2D</code>, one segment at a
                 * time.
                 * @since 1.2
                 */
                CubicCurve2D.prototype.getPathIterator = function (at, flatness) {
                    var _this = this;
                    if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            return new java.awt.geom.FlatteningPathIterator(_this.getPathIterator(at), flatness);
                        })();
                    }
                    else if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && flatness === undefined) {
                        return this.getPathIterator$java_awt_geom_AffineTransform(at);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Creates a new object of the same class as this object.
                 *
                 * @return a clone of this instance.
                 * @exception OutOfMemoryError
                 * if there is not enough memory.
                 * @see java.lang.Cloneable
                 * @since 1.2
                 */
                CubicCurve2D.prototype.clone = function () {
                    try {
                        return javaemul.internal.ObjectHelper.clone(this);
                    }
                    catch (e) {
                        throw new java.lang.InternalError(e);
                    }
                    ;
                };
                return CubicCurve2D;
            }());
            geom.CubicCurve2D = CubicCurve2D;
            CubicCurve2D["__class"] = "java.awt.geom.CubicCurve2D";
            CubicCurve2D["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
            var CubicCurve2D;
            (function (CubicCurve2D) {
                /**
                 * A cubic parametric curve segment specified with {@code float}
                 * coordinates.
                 *
                 * @since 1.2
                 */
                var Float = (function (_super) {
                    __extends(Float, _super);
                    /**
                     * Constructs and initializes a {@code CubicCurve2D} from the specified
                     * {@code float} coordinates.
                     *
                     * @param x1
                     * the X coordinate for the start point of the resulting
                     * {@code CubicCurve2D}
                     * @param y1
                     * the Y coordinate for the start point of the resulting
                     * {@code CubicCurve2D}
                     * @param ctrlx1
                     * the X coordinate for the first control point of the
                     * resulting {@code CubicCurve2D}
                     * @param ctrly1
                     * the Y coordinate for the first control point of the
                     * resulting {@code CubicCurve2D}
                     * @param ctrlx2
                     * the X coordinate for the second control point of the
                     * resulting {@code CubicCurve2D}
                     * @param ctrly2
                     * the Y coordinate for the second control point of the
                     * resulting {@code CubicCurve2D}
                     * @param x2
                     * the X coordinate for the end point of the resulting
                     * {@code CubicCurve2D}
                     * @param y2
                     * the Y coordinate for the end point of the resulting
                     * {@code CubicCurve2D}
                     * @since 1.2
                     */
                    function Float(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x1 = 0;
                            this.y1 = 0;
                            this.ctrlx1 = 0;
                            this.ctrly1 = 0;
                            this.ctrlx2 = 0;
                            this.ctrly2 = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                            (function () {
                                _this.setCurve(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
                            })();
                        }
                        else if (x1 === undefined && y1 === undefined && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x1 = 0;
                            this.y1 = 0;
                            this.ctrlx1 = 0;
                            this.ctrly1 = 0;
                            this.ctrlx2 = 0;
                            this.ctrly2 = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getX1 = function () {
                        return this.x1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getY1 = function () {
                        return this.y1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getP1 = function () {
                        return new java.awt.geom.Point2D.Float(this.x1, this.y1);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getCtrlX1 = function () {
                        return this.ctrlx1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getCtrlY1 = function () {
                        return this.ctrly1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getCtrlP1 = function () {
                        return new java.awt.geom.Point2D.Float(this.ctrlx1, this.ctrly1);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getCtrlX2 = function () {
                        return this.ctrlx2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getCtrlY2 = function () {
                        return this.ctrly2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getCtrlP2 = function () {
                        return new java.awt.geom.Point2D.Float(this.ctrlx2, this.ctrly2);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getX2 = function () {
                        return this.x2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getY2 = function () {
                        return this.y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getP2 = function () {
                        return new java.awt.geom.Point2D.Float(this.x2, this.y2);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.setCurve$double$double$double$double$double$double$double$double = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                        this.x1 = x1;
                        this.y1 = y1;
                        this.ctrlx1 = ctrlx1;
                        this.ctrly1 = ctrly1;
                        this.ctrlx2 = ctrlx2;
                        this.ctrly2 = ctrly2;
                        this.x2 = x2;
                        this.y2 = y2;
                    };
                    /**
                     * Sets the location of the end points and control points of this curve
                     * to the specified {@code float} coordinates.
                     *
                     * @param x1
                     * the X coordinate used to set the start point of this
                     * {@code CubicCurve2D}
                     * @param y1
                     * the Y coordinate used to set the start point of this
                     * {@code CubicCurve2D}
                     * @param ctrlx1
                     * the X coordinate used to set the first control point of
                     * this {@code CubicCurve2D}
                     * @param ctrly1
                     * the Y coordinate used to set the first control point of
                     * this {@code CubicCurve2D}
                     * @param ctrlx2
                     * the X coordinate used to set the second control point of
                     * this {@code CubicCurve2D}
                     * @param ctrly2
                     * the Y coordinate used to set the second control point of
                     * this {@code CubicCurve2D}
                     * @param x2
                     * the X coordinate used to set the end point of this
                     * {@code CubicCurve2D}
                     * @param y2
                     * the Y coordinate used to set the end point of this
                     * {@code CubicCurve2D}
                     * @since 1.2
                     */
                    Float.prototype.setCurve = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            return (function () {
                                _this.x1 = x1;
                                _this.y1 = y1;
                                _this.ctrlx1 = ctrlx1;
                                _this.ctrly1 = ctrly1;
                                _this.ctrlx2 = ctrlx2;
                                _this.ctrly2 = ctrly2;
                                _this.x2 = x2;
                                _this.y2 = y2;
                            })();
                        }
                        else if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.setCurve$double$double$double$double$double$double$double$double(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && ((ctrlx1 != null && ctrlx1 instanceof java.awt.geom.Point2D) || ctrlx1 === null) && ((ctrly1 != null && ctrly1 instanceof java.awt.geom.Point2D) || ctrly1 === null) && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1, ctrlx1, ctrly1);
                        }
                        else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$double_A$int(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_Point2D_A$int(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.CubicCurve2D) || x1 === null) && y1 === undefined && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_CubicCurve2D(x1);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getBounds2D = function () {
                        var left = Math.min(Math.min(this.x1, this.x2), Math.min(this.ctrlx1, this.ctrlx2));
                        var top = Math.min(Math.min(this.y1, this.y2), Math.min(this.ctrly1, this.ctrly2));
                        var right = Math.max(Math.max(this.x1, this.x2), Math.max(this.ctrlx1, this.ctrlx2));
                        var bottom = Math.max(Math.max(this.y1, this.y2), Math.max(this.ctrly1, this.ctrly2));
                        return new java.awt.geom.Rectangle2D.Float(left, top, right - left, bottom - top);
                    };
                    Float.serialVersionUID = -1272015596714244385;
                    return Float;
                }(java.awt.geom.CubicCurve2D));
                CubicCurve2D.Float = Float;
                Float["__class"] = "java.awt.geom.CubicCurve2D.Float";
                Float["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
                /**
                 * A cubic parametric curve segment specified with {@code double}
                 * coordinates.
                 *
                 * @since 1.2
                 */
                var Double = (function (_super) {
                    __extends(Double, _super);
                    /**
                     * Constructs and initializes a {@code CubicCurve2D} from the specified
                     * {@code double} coordinates.
                     *
                     * @param x1
                     * the X coordinate for the start point of the resulting
                     * {@code CubicCurve2D}
                     * @param y1
                     * the Y coordinate for the start point of the resulting
                     * {@code CubicCurve2D}
                     * @param ctrlx1
                     * the X coordinate for the first control point of the
                     * resulting {@code CubicCurve2D}
                     * @param ctrly1
                     * the Y coordinate for the first control point of the
                     * resulting {@code CubicCurve2D}
                     * @param ctrlx2
                     * the X coordinate for the second control point of the
                     * resulting {@code CubicCurve2D}
                     * @param ctrly2
                     * the Y coordinate for the second control point of the
                     * resulting {@code CubicCurve2D}
                     * @param x2
                     * the X coordinate for the end point of the resulting
                     * {@code CubicCurve2D}
                     * @param y2
                     * the Y coordinate for the end point of the resulting
                     * {@code CubicCurve2D}
                     * @since 1.2
                     */
                    function Double(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x1 = 0;
                            this.y1 = 0;
                            this.ctrlx1 = 0;
                            this.ctrly1 = 0;
                            this.ctrlx2 = 0;
                            this.ctrly2 = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                            (function () {
                                _this.setCurve(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
                            })();
                        }
                        else if (x1 === undefined && y1 === undefined && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x1 = 0;
                            this.y1 = 0;
                            this.ctrlx1 = 0;
                            this.ctrly1 = 0;
                            this.ctrlx2 = 0;
                            this.ctrly2 = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getX1 = function () {
                        return this.x1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getY1 = function () {
                        return this.y1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getP1 = function () {
                        return new java.awt.geom.Point2D.Double(this.x1, this.y1);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getCtrlX1 = function () {
                        return this.ctrlx1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getCtrlY1 = function () {
                        return this.ctrly1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getCtrlP1 = function () {
                        return new java.awt.geom.Point2D.Double(this.ctrlx1, this.ctrly1);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getCtrlX2 = function () {
                        return this.ctrlx2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getCtrlY2 = function () {
                        return this.ctrly2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getCtrlP2 = function () {
                        return new java.awt.geom.Point2D.Double(this.ctrlx2, this.ctrly2);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getX2 = function () {
                        return this.x2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getY2 = function () {
                        return this.y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getP2 = function () {
                        return new java.awt.geom.Point2D.Double(this.x2, this.y2);
                    };
                    /**
                     * Sets the location of the end points and control points of this curve
                     * to the specified {@code float} coordinates.
                     *
                     * @param x1
                     * the X coordinate used to set the start point of this
                     * {@code CubicCurve2D}
                     * @param y1
                     * the Y coordinate used to set the start point of this
                     * {@code CubicCurve2D}
                     * @param ctrlx1
                     * the X coordinate used to set the first control point of
                     * this {@code CubicCurve2D}
                     * @param ctrly1
                     * the Y coordinate used to set the first control point of
                     * this {@code CubicCurve2D}
                     * @param ctrlx2
                     * the X coordinate used to set the second control point of
                     * this {@code CubicCurve2D}
                     * @param ctrly2
                     * the Y coordinate used to set the second control point of
                     * this {@code CubicCurve2D}
                     * @param x2
                     * the X coordinate used to set the end point of this
                     * {@code CubicCurve2D}
                     * @param y2
                     * the Y coordinate used to set the end point of this
                     * {@code CubicCurve2D}
                     * @since 1.2
                     */
                    Double.prototype.setCurve = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.setCurve$double$double$double$double$double$double$double$double(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && ((ctrlx1 != null && ctrlx1 instanceof java.awt.geom.Point2D) || ctrlx1 === null) && ((ctrly1 != null && ctrly1 instanceof java.awt.geom.Point2D) || ctrly1 === null) && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1, ctrlx1, ctrly1);
                        }
                        else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$double_A$int(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_Point2D_A$int(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.CubicCurve2D) || x1 === null) && y1 === undefined && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_CubicCurve2D(x1);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.setCurve$double$double$double$double$double$double$double$double = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                        this.x1 = x1;
                        this.y1 = y1;
                        this.ctrlx1 = ctrlx1;
                        this.ctrly1 = ctrly1;
                        this.ctrlx2 = ctrlx2;
                        this.ctrly2 = ctrly2;
                        this.x2 = x2;
                        this.y2 = y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getBounds2D = function () {
                        var left = Math.min(Math.min(this.x1, this.x2), Math.min(this.ctrlx1, this.ctrlx2));
                        var top = Math.min(Math.min(this.y1, this.y2), Math.min(this.ctrly1, this.ctrly2));
                        var right = Math.max(Math.max(this.x1, this.x2), Math.max(this.ctrlx1, this.ctrlx2));
                        var bottom = Math.max(Math.max(this.y1, this.y2), Math.max(this.ctrly1, this.ctrly2));
                        return new java.awt.geom.Rectangle2D.Double(left, top, right - left, bottom - top);
                    };
                    Double.serialVersionUID = -4202960122839707295;
                    return Double;
                }(java.awt.geom.CubicCurve2D));
                CubicCurve2D.Double = Double;
                Double["__class"] = "java.awt.geom.CubicCurve2D.Double";
                Double["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
            })(CubicCurve2D = geom.CubicCurve2D || (geom.CubicCurve2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * A utility class to iterate over the path segments of a cubic curve segment
             * through the PathIterator interface.
             *
             * @author Jim Graham
             */
            var CubicIterator = (function () {
                function CubicIterator(q, at) {
                    this.index = 0;
                    this.cubic = q;
                    this.affine = at;
                }
                /**
                 * Return the winding rule for determining the insideness of the path.
                 *
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 */
                CubicIterator.prototype.getWindingRule = function () {
                    return java.awt.geom.PathIterator.WIND_NON_ZERO;
                };
                /**
                 * Tests if there are more points to read.
                 *
                 * @return true if there are more points to read
                 */
                CubicIterator.prototype.isDone = function () {
                    return (this.index > 1);
                };
                /**
                 * Moves the iterator to the next segment of the path forwards along the
                 * primary direction of traversal as long as there are more points in that
                 * direction.
                 */
                CubicIterator.prototype.next = function () {
                    this.index++;
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of float x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                CubicIterator.prototype.currentSegment = function (coords) {
                    var _this = this;
                    if (((coords != null && coords instanceof Array) || coords === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (_this.isDone()) {
                                throw new java.util.NoSuchElementException("cubic iterator iterator out of bounds");
                            }
                            var type;
                            if (_this.index === 0) {
                                coords[0] = _this.cubic.getX1();
                                coords[1] = _this.cubic.getY1();
                                type = java.awt.geom.PathIterator.SEG_MOVETO;
                            }
                            else {
                                coords[0] = _this.cubic.getCtrlX1();
                                coords[1] = _this.cubic.getCtrlY1();
                                coords[2] = _this.cubic.getCtrlX2();
                                coords[3] = _this.cubic.getCtrlY2();
                                coords[4] = _this.cubic.getX2();
                                coords[5] = _this.cubic.getY2();
                                type = java.awt.geom.PathIterator.SEG_CUBICTO;
                            }
                            if (_this.affine != null) {
                                _this.affine.transform(coords, 0, coords, 0, _this.index === 0 ? 1 : 3);
                            }
                            return type;
                        })();
                    }
                    else if (((coords != null && coords instanceof Array) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A double array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of double x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                CubicIterator.prototype.currentSegment$double_A = function (coords) {
                    if (this.isDone()) {
                        throw new java.util.NoSuchElementException("cubic iterator iterator out of bounds");
                    }
                    var type;
                    if (this.index === 0) {
                        coords[0] = this.cubic.getX1();
                        coords[1] = this.cubic.getY1();
                        type = java.awt.geom.PathIterator.SEG_MOVETO;
                    }
                    else {
                        coords[0] = this.cubic.getCtrlX1();
                        coords[1] = this.cubic.getCtrlY1();
                        coords[2] = this.cubic.getCtrlX2();
                        coords[3] = this.cubic.getCtrlY2();
                        coords[4] = this.cubic.getX2();
                        coords[5] = this.cubic.getY2();
                        type = java.awt.geom.PathIterator.SEG_CUBICTO;
                    }
                    if (this.affine != null) {
                        this.affine.transform(coords, 0, coords, 0, this.index === 0 ? 1 : 3);
                    }
                    return type;
                };
                return CubicIterator;
            }());
            geom.CubicIterator = CubicIterator;
            CubicIterator["__class"] = "java.awt.geom.CubicIterator";
            CubicIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>Dimension2D</code> class is to encapsulate a width and a height
             * dimension.
             * <p>
             * This class is only the abstract superclass for all objects that store a 2D
             * dimension. The actual storage representation of the sizes is left to the
             * subclass.
             *
             * @author Jim Graham
             * @since 1.2
             */
            var Dimension2D = (function () {
                /**
                 * This is an abstract class that cannot be instantiated directly.
                 * Type-specific implementation subclasses are available for instantiation
                 * and provide a number of formats for storing the information necessary to
                 * satisfy the various accessor methods below.
                 *
                 * @see java.awt.Dimension
                 * @since 1.2
                 */
                function Dimension2D() {
                }
                Dimension2D.prototype.setSize = function (width, height) {
                    if (((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null)) {
                        return this.setSize$double$double(width, height);
                    }
                    else if (((width != null && width instanceof java.awt.geom.Dimension2D) || width === null) && height === undefined) {
                        return this.setSize$java_awt_geom_Dimension2D(width);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the size of this <code>Dimension</code> object to the specified
                 * width and height. This method is included for completeness, to parallel
                 * the {@link java.awt.Component#getSize getSize} method of
                 * {@link java.awt.Component}.
                 *
                 * @param width
                 * the new width for the <code>Dimension</code> object
                 * @param height
                 * the new height for the <code>Dimension</code> object
                 * @since 1.2
                 */
                Dimension2D.prototype.setSize$double$double = function (width, height) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets the size of this <code>Dimension2D</code> object to match the
                 * specified size. This method is included for completeness, to parallel the
                 * <code>getSize</code> method of <code>Component</code>.
                 *
                 * @param d
                 * the new size for the <code>Dimension2D</code> object
                 * @since 1.2
                 */
                Dimension2D.prototype.setSize$java_awt_geom_Dimension2D = function (d) {
                    this.setSize(d.getWidth(), d.getHeight());
                };
                /**
                 * Creates a new object of the same class as this object.
                 *
                 * @return a clone of this instance.
                 * @exception OutOfMemoryError
                 * if there is not enough memory.
                 * @see java.lang.Cloneable
                 * @since 1.2
                 */
                Dimension2D.prototype.clone = function () {
                    try {
                        return javaemul.internal.ObjectHelper.clone(this);
                    }
                    catch (e) {
                        throw new java.lang.InternalError(e);
                    }
                    ;
                };
                return Dimension2D;
            }());
            geom.Dimension2D = Dimension2D;
            Dimension2D["__class"] = "java.awt.geom.Dimension2D";
            Dimension2D["__interfaces"] = ["java.lang.Cloneable"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * A utility class to iterate over the path segments of an ellipse through the
             * PathIterator interface.
             *
             * @author Jim Graham
             */
            var EllipseIterator = (function () {
                function EllipseIterator(e, at) {
                    this.x = 0;
                    this.y = 0;
                    this.w = 0;
                    this.h = 0;
                    this.index = 0;
                    this.x = e.getX();
                    this.y = e.getY();
                    this.w = e.getWidth();
                    this.h = e.getHeight();
                    this.affine = at;
                    if (this.w < 0 || this.h < 0) {
                        this.index = 6;
                    }
                }
                /**
                 * Return the winding rule for determining the insideness of the path.
                 *
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 */
                EllipseIterator.prototype.getWindingRule = function () {
                    return java.awt.geom.PathIterator.WIND_NON_ZERO;
                };
                /**
                 * Tests if there are more points to read.
                 *
                 * @return true if there are more points to read
                 */
                EllipseIterator.prototype.isDone = function () {
                    return this.index > 5;
                };
                /**
                 * Moves the iterator to the next segment of the path forwards along the
                 * primary direction of traversal as long as there are more points in that
                 * direction.
                 */
                EllipseIterator.prototype.next = function () {
                    this.index++;
                };
                EllipseIterator.pcv_$LI$ = function () { if (EllipseIterator.pcv == null)
                    EllipseIterator.pcv = 0.5 + EllipseIterator.CtrlVal * 0.5; return EllipseIterator.pcv; };
                ;
                EllipseIterator.ncv_$LI$ = function () { if (EllipseIterator.ncv == null)
                    EllipseIterator.ncv = 0.5 - EllipseIterator.CtrlVal * 0.5; return EllipseIterator.ncv; };
                ;
                EllipseIterator.ctrlpts_$LI$ = function () { if (EllipseIterator.ctrlpts == null)
                    EllipseIterator.ctrlpts = [[1.0, EllipseIterator.pcv_$LI$(), EllipseIterator.pcv_$LI$(), 1.0, 0.5, 1.0], [EllipseIterator.ncv_$LI$(), 1.0, 0.0, EllipseIterator.pcv_$LI$(), 0.0, 0.5], [0.0, EllipseIterator.ncv_$LI$(), EllipseIterator.ncv_$LI$(), 0.0, 0.5, 0.0], [EllipseIterator.pcv_$LI$(), 0.0, 1.0, EllipseIterator.ncv_$LI$(), 1.0, 0.5]]; return EllipseIterator.ctrlpts; };
                ;
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of float x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                EllipseIterator.prototype.currentSegment = function (coords) {
                    var _this = this;
                    if (((coords != null && coords instanceof Array) || coords === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (_this.isDone()) {
                                throw new java.util.NoSuchElementException("ellipse iterator out of bounds");
                            }
                            if (_this.index === 5) {
                                return java.awt.geom.PathIterator.SEG_CLOSE;
                            }
                            if (_this.index === 0) {
                                var ctrls_1 = EllipseIterator.ctrlpts_$LI$()[3];
                                coords[0] = (_this.x + ctrls_1[4] * _this.w);
                                coords[1] = (_this.y + ctrls_1[5] * _this.h);
                                if (_this.affine != null) {
                                    _this.affine.transform(coords, 0, coords, 0, 1);
                                }
                                return java.awt.geom.PathIterator.SEG_MOVETO;
                            }
                            var ctrls = EllipseIterator.ctrlpts_$LI$()[_this.index - 1];
                            coords[0] = (_this.x + ctrls[0] * _this.w);
                            coords[1] = (_this.y + ctrls[1] * _this.h);
                            coords[2] = (_this.x + ctrls[2] * _this.w);
                            coords[3] = (_this.y + ctrls[3] * _this.h);
                            coords[4] = (_this.x + ctrls[4] * _this.w);
                            coords[5] = (_this.y + ctrls[5] * _this.h);
                            if (_this.affine != null) {
                                _this.affine.transform(coords, 0, coords, 0, 3);
                            }
                            return java.awt.geom.PathIterator.SEG_CUBICTO;
                        })();
                    }
                    else if (((coords != null && coords instanceof Array) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A double array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of double x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                EllipseIterator.prototype.currentSegment$double_A = function (coords) {
                    if (this.isDone()) {
                        throw new java.util.NoSuchElementException("ellipse iterator out of bounds");
                    }
                    if (this.index === 5) {
                        return java.awt.geom.PathIterator.SEG_CLOSE;
                    }
                    if (this.index === 0) {
                        var ctrls_2 = EllipseIterator.ctrlpts_$LI$()[3];
                        coords[0] = this.x + ctrls_2[4] * this.w;
                        coords[1] = this.y + ctrls_2[5] * this.h;
                        if (this.affine != null) {
                            this.affine.transform(coords, 0, coords, 0, 1);
                        }
                        return java.awt.geom.PathIterator.SEG_MOVETO;
                    }
                    var ctrls = EllipseIterator.ctrlpts_$LI$()[this.index - 1];
                    coords[0] = this.x + ctrls[0] * this.w;
                    coords[1] = this.y + ctrls[1] * this.h;
                    coords[2] = this.x + ctrls[2] * this.w;
                    coords[3] = this.y + ctrls[3] * this.h;
                    coords[4] = this.x + ctrls[4] * this.w;
                    coords[5] = this.y + ctrls[5] * this.h;
                    if (this.affine != null) {
                        this.affine.transform(coords, 0, coords, 0, 3);
                    }
                    return java.awt.geom.PathIterator.SEG_CUBICTO;
                };
                EllipseIterator.CtrlVal = 0.5522847498307933;
                return EllipseIterator;
            }());
            geom.EllipseIterator = EllipseIterator;
            EllipseIterator["__class"] = "java.awt.geom.EllipseIterator";
            EllipseIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>FlatteningPathIterator</code> class returns a flattened view of
             * another {@link PathIterator} object. Other {@link java.awt.Shape Shape}
             * classes can use this class to provide flattening behavior for their paths
             * without having to perform the interpolation calculations themselves.
             *
             * @author Jim Graham
             */
            var FlatteningPathIterator = (function () {
                /**
                 * Constructs a new <code>FlatteningPathIterator</code> object that flattens
                 * a path as it iterates over it. The <code>limit</code> parameter allows
                 * you to control the maximum number of recursive subdivisions that the
                 * iterator can make before it assumes that the curve is flat enough without
                 * measuring against the <code>flatness</code> parameter. The flattened
                 * iteration therefore never generates more than a maximum of
                 * <code>(2^limit)</code> line segments per curve.
                 *
                 * @param src
                 * the original unflattened path being iterated over
                 * @param flatness
                 * the maximum allowable distance between the control points and
                 * the flattened curve
                 * @param limit
                 * the maximum number of recursive subdivisions allowed for any
                 * curved segment
                 * @exception IllegalArgumentException
                 * if <code>flatness</code> or <code>limit</code> is less
                 * than zero
                 */
                function FlatteningPathIterator(src, flatness, limit) {
                    if (limit === void 0) { limit = 10; }
                    this.hold = new Array(14);
                    this.squareflat = 0;
                    this.limit = 0;
                    this.curx = 0;
                    this.cury = 0;
                    this.movx = 0;
                    this.movy = 0;
                    this.holdType = 0;
                    this.holdEnd = 0;
                    this.holdIndex = 0;
                    this.levelIndex = 0;
                    this.done = false;
                    if (flatness < 0.0) {
                        throw new java.lang.IllegalArgumentException("flatness must be >= 0");
                    }
                    if (limit < 0) {
                        throw new java.lang.IllegalArgumentException("limit must be >= 0");
                    }
                    this.src = src;
                    this.squareflat = flatness * flatness;
                    this.limit = limit;
                    this.levels = new Array(limit + 1);
                    this.next(false);
                }
                /**
                 * Returns the flatness of this iterator.
                 *
                 * @return the flatness of this <code>FlatteningPathIterator</code>.
                 */
                FlatteningPathIterator.prototype.getFlatness = function () {
                    return Math.sqrt(this.squareflat);
                };
                /**
                 * Returns the recursion limit of this iterator.
                 *
                 * @return the recursion limit of this <code>FlatteningPathIterator</code>.
                 */
                FlatteningPathIterator.prototype.getRecursionLimit = function () {
                    return this.limit;
                };
                /**
                 * Returns the winding rule for determining the interior of the path.
                 *
                 * @return the winding rule of the original unflattened path being iterated
                 * over.
                 * @see PathIterator#WIND_EVEN_ODD
                 * @see PathIterator#WIND_NON_ZERO
                 */
                FlatteningPathIterator.prototype.getWindingRule = function () {
                    return this.src.getWindingRule();
                };
                /**
                 * Tests if the iteration is complete.
                 *
                 * @return <code>true</code> if all the segments have been read;
                 * <code>false</code> otherwise.
                 */
                FlatteningPathIterator.prototype.isDone = function () {
                    return this.done;
                };
                FlatteningPathIterator.prototype.ensureHoldCapacity = function (want) {
                    if (this.holdIndex - want < 0) {
                        var have = this.hold.length - this.holdIndex;
                        var newsize = this.hold.length + FlatteningPathIterator.GROW_SIZE;
                        var newhold = new Array(newsize);
                        java.lang.System.arraycopy(this.hold, this.holdIndex, newhold, this.holdIndex + FlatteningPathIterator.GROW_SIZE, have);
                        this.hold = newhold;
                        this.holdIndex += FlatteningPathIterator.GROW_SIZE;
                        this.holdEnd += FlatteningPathIterator.GROW_SIZE;
                    }
                };
                /**
                 * Moves the iterator to the next segment of the path forwards along the
                 * primary direction of traversal as long as there are more points in that
                 * direction.
                 */
                FlatteningPathIterator.prototype.next$ = function () {
                    this.next(true);
                };
                FlatteningPathIterator.prototype.next = function (doNext) {
                    var _this = this;
                    if (((typeof doNext === 'boolean') || doNext === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            var level;
                            if (_this.holdIndex >= _this.holdEnd) {
                                if (doNext) {
                                    _this.src.next();
                                }
                                if (_this.src.isDone()) {
                                    _this.done = true;
                                    return;
                                }
                                _this.holdType = _this.src.currentSegment(_this.hold);
                                _this.levelIndex = 0;
                                _this.levels[0] = 0;
                            }
                            switch ((_this.holdType)) {
                                case java.awt.geom.PathIterator.SEG_MOVETO:
                                case java.awt.geom.PathIterator.SEG_LINETO:
                                    _this.curx = _this.hold[0];
                                    _this.cury = _this.hold[1];
                                    if (_this.holdType === java.awt.geom.PathIterator.SEG_MOVETO) {
                                        _this.movx = _this.curx;
                                        _this.movy = _this.cury;
                                    }
                                    _this.holdIndex = 0;
                                    _this.holdEnd = 0;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CLOSE:
                                    _this.curx = _this.movx;
                                    _this.cury = _this.movy;
                                    _this.holdIndex = 0;
                                    _this.holdEnd = 0;
                                    break;
                                case java.awt.geom.PathIterator.SEG_QUADTO:
                                    if (_this.holdIndex >= _this.holdEnd) {
                                        _this.holdIndex = _this.hold.length - 6;
                                        _this.holdEnd = _this.hold.length - 2;
                                        _this.hold[_this.holdIndex + 0] = _this.curx;
                                        _this.hold[_this.holdIndex + 1] = _this.cury;
                                        _this.hold[_this.holdIndex + 2] = _this.hold[0];
                                        _this.hold[_this.holdIndex + 3] = _this.hold[1];
                                        _this.hold[_this.holdIndex + 4] = _this.curx = _this.hold[2];
                                        _this.hold[_this.holdIndex + 5] = _this.cury = _this.hold[3];
                                    }
                                    level = _this.levels[_this.levelIndex];
                                    while ((level < _this.limit)) {
                                        if (java.awt.geom.QuadCurve2D.getFlatnessSq(_this.hold, _this.holdIndex) < _this.squareflat) {
                                            break;
                                        }
                                        _this.ensureHoldCapacity(4);
                                        java.awt.geom.QuadCurve2D.subdivide(_this.hold, _this.holdIndex, _this.hold, _this.holdIndex - 4, _this.hold, _this.holdIndex);
                                        _this.holdIndex -= 4;
                                        level++;
                                        _this.levels[_this.levelIndex] = level;
                                        _this.levelIndex++;
                                        _this.levels[_this.levelIndex] = level;
                                    }
                                    ;
                                    _this.holdIndex += 4;
                                    _this.levelIndex--;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CUBICTO:
                                    if (_this.holdIndex >= _this.holdEnd) {
                                        _this.holdIndex = _this.hold.length - 8;
                                        _this.holdEnd = _this.hold.length - 2;
                                        _this.hold[_this.holdIndex + 0] = _this.curx;
                                        _this.hold[_this.holdIndex + 1] = _this.cury;
                                        _this.hold[_this.holdIndex + 2] = _this.hold[0];
                                        _this.hold[_this.holdIndex + 3] = _this.hold[1];
                                        _this.hold[_this.holdIndex + 4] = _this.hold[2];
                                        _this.hold[_this.holdIndex + 5] = _this.hold[3];
                                        _this.hold[_this.holdIndex + 6] = _this.curx = _this.hold[4];
                                        _this.hold[_this.holdIndex + 7] = _this.cury = _this.hold[5];
                                    }
                                    level = _this.levels[_this.levelIndex];
                                    while ((level < _this.limit)) {
                                        if (java.awt.geom.CubicCurve2D.getFlatnessSq(_this.hold, _this.holdIndex) < _this.squareflat) {
                                            break;
                                        }
                                        _this.ensureHoldCapacity(6);
                                        java.awt.geom.CubicCurve2D.subdivide(_this.hold, _this.holdIndex, _this.hold, _this.holdIndex - 6, _this.hold, _this.holdIndex);
                                        _this.holdIndex -= 6;
                                        level++;
                                        _this.levels[_this.levelIndex] = level;
                                        _this.levelIndex++;
                                        _this.levels[_this.levelIndex] = level;
                                    }
                                    ;
                                    _this.holdIndex += 6;
                                    _this.levelIndex--;
                                    break;
                            }
                        })();
                    }
                    else if (doNext === undefined) {
                        return this.next$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, or SEG_CLOSE. A float array of length 6 must be passed in and
                 * can be used to store the coordinates of the point(s). Each point is
                 * stored as a pair of float x,y coordinates. SEG_MOVETO and SEG_LINETO
                 * types return one point, and SEG_CLOSE does not return any points.
                 *
                 * @param coords
                 * an array that holds the data returned from this method
                 * @return the path segment type of the current path segment.
                 * @exception NoSuchElementException
                 * if there are no more elements in the flattening path to be
                 * returned.
                 * @see PathIterator#SEG_MOVETO
                 * @see PathIterator#SEG_LINETO
                 * @see PathIterator#SEG_CLOSE
                 */
                FlatteningPathIterator.prototype.currentSegment = function (coords) {
                    var _this = this;
                    if (((coords != null && coords instanceof Array) || coords === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (_this.isDone()) {
                                throw new java.util.NoSuchElementException("flattening iterator out of bounds");
                            }
                            var type = _this.holdType;
                            if (type !== java.awt.geom.PathIterator.SEG_CLOSE) {
                                coords[0] = _this.hold[_this.holdIndex + 0];
                                coords[1] = _this.hold[_this.holdIndex + 1];
                                if (type !== java.awt.geom.PathIterator.SEG_MOVETO) {
                                    type = java.awt.geom.PathIterator.SEG_LINETO;
                                }
                            }
                            return type;
                        })();
                    }
                    else if (((coords != null && coords instanceof Array) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, or SEG_CLOSE. A double array of length 6 must be passed in
                 * and can be used to store the coordinates of the point(s). Each point is
                 * stored as a pair of double x,y coordinates. SEG_MOVETO and SEG_LINETO
                 * types return one point, and SEG_CLOSE does not return any points.
                 *
                 * @param coords
                 * an array that holds the data returned from this method
                 * @return the path segment type of the current path segment.
                 * @exception NoSuchElementException
                 * if there are no more elements in the flattening path to be
                 * returned.
                 * @see PathIterator#SEG_MOVETO
                 * @see PathIterator#SEG_LINETO
                 * @see PathIterator#SEG_CLOSE
                 */
                FlatteningPathIterator.prototype.currentSegment$double_A = function (coords) {
                    if (this.isDone()) {
                        throw new java.util.NoSuchElementException("flattening iterator out of bounds");
                    }
                    var type = this.holdType;
                    if (type !== java.awt.geom.PathIterator.SEG_CLOSE) {
                        coords[0] = this.hold[this.holdIndex + 0];
                        coords[1] = this.hold[this.holdIndex + 1];
                        if (type !== java.awt.geom.PathIterator.SEG_MOVETO) {
                            type = java.awt.geom.PathIterator.SEG_LINETO;
                        }
                    }
                    return type;
                };
                FlatteningPathIterator.GROW_SIZE = 24;
                return FlatteningPathIterator;
            }());
            geom.FlatteningPathIterator = FlatteningPathIterator;
            FlatteningPathIterator["__class"] = "java.awt.geom.FlatteningPathIterator";
            FlatteningPathIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>IllegalPathStateException</code> represents an
             * exception that is thrown if an operation is performed on a path
             * that is in an illegal state with respect to the particular
             * operation being performed, such as appending a path segment
             * to a {@link GeneralPath} without an initial moveto.
             */
            var IllegalPathStateException = (function (_super) {
                __extends(IllegalPathStateException, _super);
                /**
                 * Constructs an <code>IllegalPathStateException</code> with the
                 * specified detail message.
                 * @param   s   the detail message
                 * @since   1.2
                 */
                function IllegalPathStateException(s) {
                    if (((typeof s === 'string') || s === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        _super.call(this, s);
                        this.message = s;
                    }
                    else if (s === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        _super.call(this);
                    }
                    else
                        throw new Error('invalid overload');
                }
                return IllegalPathStateException;
            }(Error));
            geom.IllegalPathStateException = IllegalPathStateException;
            IllegalPathStateException["__class"] = "java.awt.geom.IllegalPathStateException";
            IllegalPathStateException["__interfaces"] = ["java.io.Serializable"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * This <code>Line2D</code> represents a line segment in {@code (x,y)}
             * coordinate space. This class, like all of the Java 2D API, uses a default
             * coordinate system called <i>user space</i> in which the y-axis values
             * increase downward and x-axis values increase to the right. For more
             * information on the user space coordinate system, see the <a href=
             * "http://docs.oracle.com/javase/1.3/docs/guide/2d/spec/j2d-intro.fm2.html#61857">
             * Coordinate Systems</a> section of the Java 2D Programmer's Guide.
             * <p>
             * This class is only the abstract superclass for all objects that store a 2D
             * line segment. The actual storage representation of the coordinates is left to
             * the subclass.
             *
             * @author Jim Graham
             * @since 1.2
             */
            var Line2D = (function () {
                /**
                 * This is an abstract class that cannot be instantiated directly.
                 * Type-specific implementation subclasses are available for instantiation
                 * and provide a number of formats for storing the information necessary to
                 * satisfy the various accessory methods below.
                 *
                 * @see java.awt.geom.Line2D.Float
                 * @see java.awt.geom.Line2D.Double
                 * @since 1.2
                 */
                function Line2D() {
                }
                /**
                 * Sets the location of the end points of this <code>Line2D</code> to
                 * the specified float coordinates.
                 *
                 * @param x1
                 * the X coordinate of the start point
                 * @param y1
                 * the Y coordinate of the start point
                 * @param x2
                 * the X coordinate of the end point
                 * @param y2
                 * the Y coordinate of the end point
                 * @since 1.2
                 */
                Line2D.prototype.setLine = function (x1, y1, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return this.setLine$double$double$double$double(x1, y1, x2, y2);
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
                        return this.setLine$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1);
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.Line2D) || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
                        return this.setLine$java_awt_geom_Line2D(x1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the location of the end points of this <code>Line2D</code> to the
                 * specified double coordinates.
                 *
                 * @param x1
                 * the X coordinate of the start point
                 * @param y1
                 * the Y coordinate of the start point
                 * @param x2
                 * the X coordinate of the end point
                 * @param y2
                 * the Y coordinate of the end point
                 * @since 1.2
                 */
                Line2D.prototype.setLine$double$double$double$double = function (x1, y1, x2, y2) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets the location of the end points of this <code>Line2D</code> to the
                 * specified <code>Point2D</code> coordinates.
                 *
                 * @param p1
                 * the start <code>Point2D</code> of the line segment
                 * @param p2
                 * the end <code>Point2D</code> of the line segment
                 * @since 1.2
                 */
                Line2D.prototype.setLine$java_awt_geom_Point2D$java_awt_geom_Point2D = function (p1, p2) {
                    this.setLine(p1.getX(), p1.getY(), p2.getX(), p2.getY());
                };
                /**
                 * Sets the location of the end points of this <code>Line2D</code> to the
                 * same as those end points of the specified <code>Line2D</code>.
                 *
                 * @param l
                 * the specified <code>Line2D</code>
                 * @since 1.2
                 */
                Line2D.prototype.setLine$java_awt_geom_Line2D = function (l) {
                    this.setLine(l.getX1(), l.getY1(), l.getX2(), l.getY2());
                };
                /**
                 * Returns an indicator of where the specified point {@code (px,py)} lies
                 * with respect to the line segment from {@code (x1,y1)} to {@code (x2,y2)}.
                 * The return value can be either 1, -1, or 0 and indicates in which
                 * direction the specified line must pivot around its first end point,
                 * {@code (x1,y1)}, in order to point at the specified point {@code (px,py)}
                 * .
                 * <p>
                 * A return value of 1 indicates that the line segment must turn in the
                 * direction that takes the positive X axis towards the negative Y axis. In
                 * the default coordinate system used by Java 2D, this direction is
                 * counterclockwise.
                 * <p>
                 * A return value of -1 indicates that the line segment must turn in the
                 * direction that takes the positive X axis towards the positive Y axis. In
                 * the default coordinate system, this direction is clockwise.
                 * <p>
                 * A return value of 0 indicates that the point lies exactly on the line
                 * segment. Note that an indicator value of 0 is rare and not useful for
                 * determining collinearity because of floating point rounding issues.
                 * <p>
                 * If the point is colinear with the line segment, but not between the end
                 * points, then the value will be -1 if the point lies
                 * "beyond {@code (x1,y1)}" or 1 if the point lies "beyond {@code (x2,y2)}".
                 *
                 * @param x1
                 * the X coordinate of the start point of the specified line
                 * segment
                 * @param y1
                 * the Y coordinate of the start point of the specified line
                 * segment
                 * @param x2
                 * the X coordinate of the end point of the specified line
                 * segment
                 * @param y2
                 * the Y coordinate of the end point of the specified line
                 * segment
                 * @param px
                 * the X coordinate of the specified point to be compared with
                 * the specified line segment
                 * @param py
                 * the Y coordinate of the specified point to be compared with
                 * the specified line segment
                 * @return an integer that indicates the position of the third specified
                 * coordinates with respect to the line segment formed by the first
                 * two specified coordinates.
                 * @since 1.2
                 */
                Line2D.relativeCCW = function (x1, y1, x2, y2, px, py) {
                    x2 -= x1;
                    y2 -= y1;
                    px -= x1;
                    py -= y1;
                    var ccw = px * y2 - py * x2;
                    if (ccw === 0.0) {
                        ccw = px * x2 + py * y2;
                        if (ccw > 0.0) {
                            px -= x2;
                            py -= y2;
                            ccw = px * x2 + py * y2;
                            if (ccw < 0.0) {
                                ccw = 0.0;
                            }
                        }
                    }
                    return (ccw < 0.0) ? -1 : ((ccw > 0.0) ? 1 : 0);
                };
                /**
                 * Returns an indicator of where the specified point {@code (px,py)} lies
                 * with respect to this line segment. See the method comments of
                 * {@link #relativeCCW(double, double, double, double, double, double)} to
                 * interpret the return value.
                 *
                 * @param px
                 * the X coordinate of the specified point to be compared with
                 * this <code>Line2D</code>
                 * @param py
                 * the Y coordinate of the specified point to be compared with
                 * this <code>Line2D</code>
                 * @return an integer that indicates the position of the specified
                 * coordinates with respect to this <code>Line2D</code>
                 * @see #relativeCCW(double, double, double, double, double, double)
                 * @since 1.2
                 */
                Line2D.prototype.relativeCCW = function (px, py) {
                    var _this = this;
                    if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            return Line2D.relativeCCW(_this.getX1(), _this.getY1(), _this.getX2(), _this.getY2(), px, py);
                        })();
                    }
                    else if (((px != null && px instanceof java.awt.geom.Point2D) || px === null) && py === undefined) {
                        return this.relativeCCW$java_awt_geom_Point2D(px);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns an indicator of where the specified <code>Point2D</code> lies
                 * with respect to this line segment. See the method comments of
                 * {@link #relativeCCW(double, double, double, double, double, double)} to
                 * interpret the return value.
                 *
                 * @param p
                 * the specified <code>Point2D</code> to be compared with this
                 * <code>Line2D</code>
                 * @return an integer that indicates the position of the specified
                 * <code>Point2D</code> with respect to this <code>Line2D</code>
                 * @see #relativeCCW(double, double, double, double, double, double)
                 * @since 1.2
                 */
                Line2D.prototype.relativeCCW$java_awt_geom_Point2D = function (p) {
                    return Line2D.relativeCCW(this.getX1(), this.getY1(), this.getX2(), this.getY2(), p.getX(), p.getY());
                };
                /**
                 * Tests if the line segment from {@code (x1,y1)} to {@code (x2,y2)}
                 * intersects the line segment from {@code (x3,y3)} to {@code (x4,y4)}.
                 *
                 * @param x1
                 * the X coordinate of the start point of the first specified
                 * line segment
                 * @param y1
                 * the Y coordinate of the start point of the first specified
                 * line segment
                 * @param x2
                 * the X coordinate of the end point of the first specified line
                 * segment
                 * @param y2
                 * the Y coordinate of the end point of the first specified line
                 * segment
                 * @param x3
                 * the X coordinate of the start point of the second specified
                 * line segment
                 * @param y3
                 * the Y coordinate of the start point of the second specified
                 * line segment
                 * @param x4
                 * the X coordinate of the end point of the second specified line
                 * segment
                 * @param y4
                 * the Y coordinate of the end point of the second specified line
                 * segment
                 * @return <code>true</code> if the first specified line segment and the
                 * second specified line segment intersect each other;
                 * <code>false</code> otherwise.
                 * @since 1.2
                 */
                Line2D.linesIntersect = function (x1, y1, x2, y2, x3, y3, x4, y4) {
                    return ((Line2D.relativeCCW(x1, y1, x2, y2, x3, y3) * Line2D.relativeCCW(x1, y1, x2, y2, x4, y4) <= 0) && (Line2D.relativeCCW(x3, y3, x4, y4, x1, y1) * Line2D.relativeCCW(x3, y3, x4, y4, x2, y2) <= 0));
                };
                /**
                 * Tests if the line segment from {@code (x1,y1)} to {@code (x2,y2)}
                 * intersects this line segment.
                 *
                 * @param x1
                 * the X coordinate of the start point of the specified line
                 * segment
                 * @param y1
                 * the Y coordinate of the start point of the specified line
                 * segment
                 * @param x2
                 * the X coordinate of the end point of the specified line
                 * segment
                 * @param y2
                 * the Y coordinate of the end point of the specified line
                 * segment
                 * @return {@code <true>} if this line segment and the specified line
                 * segment intersect each other; <code>false</code> otherwise.
                 * @since 1.2
                 */
                Line2D.prototype.intersectsLine = function (x1, y1, x2, y2) {
                    var _this = this;
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            return Line2D.linesIntersect(x1, y1, x2, y2, _this.getX1(), _this.getY1(), _this.getX2(), _this.getY2());
                        })();
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.Line2D) || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
                        return this.intersectsLine$java_awt_geom_Line2D(x1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Tests if the specified line segment intersects this line segment.
                 *
                 * @param l
                 * the specified <code>Line2D</code>
                 * @return <code>true</code> if this line segment and the specified line
                 * segment intersect each other; <code>false</code> otherwise.
                 * @since 1.2
                 */
                Line2D.prototype.intersectsLine$java_awt_geom_Line2D = function (l) {
                    return Line2D.linesIntersect(l.getX1(), l.getY1(), l.getX2(), l.getY2(), this.getX1(), this.getY1(), this.getX2(), this.getY2());
                };
                /**
                 * Returns the square of the distance from a point to a line segment. The
                 * distance measured is the distance between the specified point and the
                 * closest point between the specified end points. If the specified point
                 * intersects the line segment in between the end points, this method
                 * returns 0.0.
                 *
                 * @param x1
                 * the X coordinate of the start point of the specified line
                 * segment
                 * @param y1
                 * the Y coordinate of the start point of the specified line
                 * segment
                 * @param x2
                 * the X coordinate of the end point of the specified line
                 * segment
                 * @param y2
                 * the Y coordinate of the end point of the specified line
                 * segment
                 * @param px
                 * the X coordinate of the specified point being measured against
                 * the specified line segment
                 * @param py
                 * the Y coordinate of the specified point being measured against
                 * the specified line segment
                 * @return a double value that is the square of the distance from the
                 * specified point to the specified line segment.
                 * @see #ptLineDistSq(double, double, double, double, double, double)
                 * @since 1.2
                 */
                Line2D.ptSegDistSq = function (x1, y1, x2, y2, px, py) {
                    x2 -= x1;
                    y2 -= y1;
                    px -= x1;
                    py -= y1;
                    var dotprod = px * x2 + py * y2;
                    var projlenSq;
                    if (dotprod <= 0.0) {
                        projlenSq = 0.0;
                    }
                    else {
                        px = x2 - px;
                        py = y2 - py;
                        dotprod = px * x2 + py * y2;
                        if (dotprod <= 0.0) {
                            projlenSq = 0.0;
                        }
                        else {
                            projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);
                        }
                    }
                    var lenSq = px * px + py * py - projlenSq;
                    if (lenSq < 0) {
                        lenSq = 0;
                    }
                    return lenSq;
                };
                /**
                 * Returns the distance from a point to a line segment. The distance
                 * measured is the distance between the specified point and the closest
                 * point between the specified end points. If the specified point intersects
                 * the line segment in between the end points, this method returns 0.0.
                 *
                 * @param x1
                 * the X coordinate of the start point of the specified line
                 * segment
                 * @param y1
                 * the Y coordinate of the start point of the specified line
                 * segment
                 * @param x2
                 * the X coordinate of the end point of the specified line
                 * segment
                 * @param y2
                 * the Y coordinate of the end point of the specified line
                 * segment
                 * @param px
                 * the X coordinate of the specified point being measured against
                 * the specified line segment
                 * @param py
                 * the Y coordinate of the specified point being measured against
                 * the specified line segment
                 * @return a double value that is the distance from the specified point to
                 * the specified line segment.
                 * @see #ptLineDist(double, double, double, double, double, double)
                 * @since 1.2
                 */
                Line2D.ptSegDist = function (x1, y1, x2, y2, px, py) {
                    return Math.sqrt(Line2D.ptSegDistSq(x1, y1, x2, y2, px, py));
                };
                /**
                 * Returns the square of the distance from a point to this line segment. The
                 * distance measured is the distance between the specified point and the
                 * closest point between the current line's end points. If the specified
                 * point intersects the line segment in between the end points, this method
                 * returns 0.0.
                 *
                 * @param px
                 * the X coordinate of the specified point being measured against
                 * this line segment
                 * @param py
                 * the Y coordinate of the specified point being measured against
                 * this line segment
                 * @return a double value that is the square of the distance from the
                 * specified point to the current line segment.
                 * @see #ptLineDistSq(double, double)
                 * @since 1.2
                 */
                Line2D.prototype.ptSegDistSq = function (px, py) {
                    var _this = this;
                    if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            return Line2D.ptSegDistSq(_this.getX1(), _this.getY1(), _this.getX2(), _this.getY2(), px, py);
                        })();
                    }
                    else if (((px != null && px instanceof java.awt.geom.Point2D) || px === null) && py === undefined) {
                        return this.ptSegDistSq$java_awt_geom_Point2D(px);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the square of the distance from a <code>Point2D</code> to this
                 * line segment. The distance measured is the distance between the specified
                 * point and the closest point between the current line's end points. If the
                 * specified point intersects the line segment in between the end points,
                 * this method returns 0.0.
                 *
                 * @param pt
                 * the specified <code>Point2D</code> being measured against this
                 * line segment.
                 * @return a double value that is the square of the distance from the
                 * specified <code>Point2D</code> to the current line segment.
                 * @see #ptLineDistSq(Point2D)
                 * @since 1.2
                 */
                Line2D.prototype.ptSegDistSq$java_awt_geom_Point2D = function (pt) {
                    return Line2D.ptSegDistSq(this.getX1(), this.getY1(), this.getX2(), this.getY2(), pt.getX(), pt.getY());
                };
                /**
                 * Returns the distance from a point to this line segment. The distance
                 * measured is the distance between the specified point and the closest
                 * point between the current line's end points. If the specified point
                 * intersects the line segment in between the end points, this method
                 * returns 0.0.
                 *
                 * @param px
                 * the X coordinate of the specified point being measured against
                 * this line segment
                 * @param py
                 * the Y coordinate of the specified point being measured against
                 * this line segment
                 * @return a double value that is the distance from the specified point to
                 * the current line segment.
                 * @see #ptLineDist(double, double)
                 * @since 1.2
                 */
                Line2D.prototype.ptSegDist = function (px, py) {
                    var _this = this;
                    if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            return Line2D.ptSegDist(_this.getX1(), _this.getY1(), _this.getX2(), _this.getY2(), px, py);
                        })();
                    }
                    else if (((px != null && px instanceof java.awt.geom.Point2D) || px === null) && py === undefined) {
                        return this.ptSegDist$java_awt_geom_Point2D(px);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the distance from a <code>Point2D</code> to this line segment.
                 * The distance measured is the distance between the specified point and the
                 * closest point between the current line's end points. If the specified
                 * point intersects the line segment in between the end points, this method
                 * returns 0.0.
                 *
                 * @param pt
                 * the specified <code>Point2D</code> being measured against this
                 * line segment
                 * @return a double value that is the distance from the specified
                 * <code>Point2D</code> to the current line segment.
                 * @see #ptLineDist(Point2D)
                 * @since 1.2
                 */
                Line2D.prototype.ptSegDist$java_awt_geom_Point2D = function (pt) {
                    return Line2D.ptSegDist(this.getX1(), this.getY1(), this.getX2(), this.getY2(), pt.getX(), pt.getY());
                };
                /**
                 * Returns the square of the distance from a point to a line. The distance
                 * measured is the distance between the specified point and the closest
                 * point on the infinitely-extended line defined by the specified
                 * coordinates. If the specified point intersects the line, this method
                 * returns 0.0.
                 *
                 * @param x1
                 * the X coordinate of the start point of the specified line
                 * @param y1
                 * the Y coordinate of the start point of the specified line
                 * @param x2
                 * the X coordinate of the end point of the specified line
                 * @param y2
                 * the Y coordinate of the end point of the specified line
                 * @param px
                 * the X coordinate of the specified point being measured against
                 * the specified line
                 * @param py
                 * the Y coordinate of the specified point being measured against
                 * the specified line
                 * @return a double value that is the square of the distance from the
                 * specified point to the specified line.
                 * @see #ptSegDistSq(double, double, double, double, double, double)
                 * @since 1.2
                 */
                Line2D.ptLineDistSq = function (x1, y1, x2, y2, px, py) {
                    x2 -= x1;
                    y2 -= y1;
                    px -= x1;
                    py -= y1;
                    var dotprod = px * x2 + py * y2;
                    var projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);
                    var lenSq = px * px + py * py - projlenSq;
                    if (lenSq < 0) {
                        lenSq = 0;
                    }
                    return lenSq;
                };
                /**
                 * Returns the distance from a point to a line. The distance measured is the
                 * distance between the specified point and the closest point on the
                 * infinitely-extended line defined by the specified coordinates. If the
                 * specified point intersects the line, this method returns 0.0.
                 *
                 * @param x1
                 * the X coordinate of the start point of the specified line
                 * @param y1
                 * the Y coordinate of the start point of the specified line
                 * @param x2
                 * the X coordinate of the end point of the specified line
                 * @param y2
                 * the Y coordinate of the end point of the specified line
                 * @param px
                 * the X coordinate of the specified point being measured against
                 * the specified line
                 * @param py
                 * the Y coordinate of the specified point being measured against
                 * the specified line
                 * @return a double value that is the distance from the specified point to
                 * the specified line.
                 * @see #ptSegDist(double, double, double, double, double, double)
                 * @since 1.2
                 */
                Line2D.ptLineDist = function (x1, y1, x2, y2, px, py) {
                    return Math.sqrt(Line2D.ptLineDistSq(x1, y1, x2, y2, px, py));
                };
                /**
                 * Returns the square of the distance from a point to this line. The
                 * distance measured is the distance between the specified point and the
                 * closest point on the infinitely-extended line defined by this
                 * <code>Line2D</code>. If the specified point intersects the line, this
                 * method returns 0.0.
                 *
                 * @param px
                 * the X coordinate of the specified point being measured against
                 * this line
                 * @param py
                 * the Y coordinate of the specified point being measured against
                 * this line
                 * @return a double value that is the square of the distance from a
                 * specified point to the current line.
                 * @see #ptSegDistSq(double, double)
                 * @since 1.2
                 */
                Line2D.prototype.ptLineDistSq = function (px, py) {
                    var _this = this;
                    if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            return Line2D.ptLineDistSq(_this.getX1(), _this.getY1(), _this.getX2(), _this.getY2(), px, py);
                        })();
                    }
                    else if (((px != null && px instanceof java.awt.geom.Point2D) || px === null) && py === undefined) {
                        return this.ptLineDistSq$java_awt_geom_Point2D(px);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the square of the distance from a specified <code>Point2D</code>
                 * to this line. The distance measured is the distance between the specified
                 * point and the closest point on the infinitely-extended line defined by
                 * this <code>Line2D</code>. If the specified point intersects the line,
                 * this method returns 0.0.
                 *
                 * @param pt
                 * the specified <code>Point2D</code> being measured against this
                 * line
                 * @return a double value that is the square of the distance from a
                 * specified <code>Point2D</code> to the current line.
                 * @see #ptSegDistSq(Point2D)
                 * @since 1.2
                 */
                Line2D.prototype.ptLineDistSq$java_awt_geom_Point2D = function (pt) {
                    return Line2D.ptLineDistSq(this.getX1(), this.getY1(), this.getX2(), this.getY2(), pt.getX(), pt.getY());
                };
                /**
                 * Returns the distance from a point to this line. The distance measured is
                 * the distance between the specified point and the closest point on the
                 * infinitely-extended line defined by this <code>Line2D</code>. If the
                 * specified point intersects the line, this method returns 0.0.
                 *
                 * @param px
                 * the X coordinate of the specified point being measured against
                 * this line
                 * @param py
                 * the Y coordinate of the specified point being measured against
                 * this line
                 * @return a double value that is the distance from a specified point to the
                 * current line.
                 * @see #ptSegDist(double, double)
                 * @since 1.2
                 */
                Line2D.prototype.ptLineDist = function (px, py) {
                    var _this = this;
                    if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            return Line2D.ptLineDist(_this.getX1(), _this.getY1(), _this.getX2(), _this.getY2(), px, py);
                        })();
                    }
                    else if (((px != null && px instanceof java.awt.geom.Point2D) || px === null) && py === undefined) {
                        return this.ptLineDist$java_awt_geom_Point2D(px);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the distance from a <code>Point2D</code> to this line. The
                 * distance measured is the distance between the specified point and the
                 * closest point on the infinitely-extended line defined by this
                 * <code>Line2D</code>. If the specified point intersects the line, this
                 * method returns 0.0.
                 *
                 * @param pt
                 * the specified <code>Point2D</code> being measured
                 * @return a double value that is the distance from a specified
                 * <code>Point2D</code> to the current line.
                 * @see #ptSegDist(Point2D)
                 * @since 1.2
                 */
                Line2D.prototype.ptLineDist$java_awt_geom_Point2D = function (pt) {
                    return Line2D.ptLineDist(this.getX1(), this.getY1(), this.getX2(), this.getY2(), pt.getX(), pt.getY());
                };
                /**
                 * Tests if a specified coordinate is inside the boundary of this
                 * <code>Line2D</code>. This method is required to implement the
                 * {@link Shape} interface, but in the case of <code>Line2D</code> objects
                 * it always returns <code>false</code> since a line contains no area.
                 *
                 * @param x
                 * the X coordinate of the specified point to be tested
                 * @param y
                 * the Y coordinate of the specified point to be tested
                 * @return <code>false</code> because a <code>Line2D</code> contains no
                 * area.
                 * @since 1.2
                 */
                Line2D.prototype.contains$double$double = function (x, y) {
                    return false;
                };
                /**
                 * Tests if a given <code>Point2D</code> is inside the boundary of this
                 * <code>Line2D</code>. This method is required to implement the
                 * {@link Shape} interface, but in the case of <code>Line2D</code> objects
                 * it always returns <code>false</code> since a line contains no area.
                 *
                 * @param p
                 * the specified <code>Point2D</code> to be tested
                 * @return <code>false</code> because a <code>Line2D</code> contains no
                 * area.
                 * @since 1.2
                 */
                Line2D.prototype.contains$java_awt_geom_Point2D = function (p) {
                    return false;
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Line2D.prototype.intersects = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            return _this.intersects(new java.awt.geom.Rectangle2D.Double(x, y, w, h));
                        })();
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Line2D.prototype.intersects$java_awt_geom_Rectangle2D = function (r) {
                    return r.intersectsLine(this.getX1(), this.getY1(), this.getX2(), this.getY2());
                };
                /**
                 * Tests if the interior of this <code>Line2D</code> entirely contains the
                 * specified set of rectangular coordinates. This method is required to
                 * implement the <code>Shape</code> interface, but in the case of
                 * <code>Line2D</code> objects it always returns false since a line contains
                 * no area.
                 *
                 * @param x
                 * the X coordinate of the upper-left corner of the specified
                 * rectangular area
                 * @param y
                 * the Y coordinate of the upper-left corner of the specified
                 * rectangular area
                 * @param w
                 * the width of the specified rectangular area
                 * @param h
                 * the height of the specified rectangular area
                 * @return <code>false</code> because a <code>Line2D</code> contains no
                 * area.
                 * @since 1.2
                 */
                Line2D.prototype.contains = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            return false;
                        })();
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Tests if the interior of this <code>Line2D</code> entirely contains the
                 * specified <code>Rectangle2D</code>. This method is required to implement
                 * the <code>Shape</code> interface, but in the case of <code>Line2D</code>
                 * objects it always returns <code>false</code> since a line contains no
                 * area.
                 *
                 * @param r
                 * the specified <code>Rectangle2D</code> to be tested
                 * @return <code>false</code> because a <code>Line2D</code> contains no
                 * area.
                 * @since 1.2
                 */
                Line2D.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
                    return false;
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Line2D.prototype.getBounds = function () {
                    return this.getBounds2D().getBounds();
                };
                /**
                 * Returns an iteration object that defines the boundary of this
                 * <code>Line2D</code>. The iterator for this class is not multi-threaded
                 * safe, which means that this <code>Line2D</code> class does not guarantee
                 * that modifications to the geometry of this <code>Line2D</code> object do
                 * not affect any iterations of that geometry that are already in process.
                 *
                 * @param at
                 * the specified {@link AffineTransform}
                 * @return a {@link PathIterator} that defines the boundary of this
                 * <code>Line2D</code>.
                 * @since 1.2
                 */
                Line2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                    return new java.awt.geom.LineIterator(this, at);
                };
                /**
                 * Returns an iteration object that defines the boundary of this flattened
                 * <code>Line2D</code>. The iterator for this class is not multi-threaded
                 * safe, which means that this <code>Line2D</code> class does not guarantee
                 * that modifications to the geometry of this <code>Line2D</code> object do
                 * not affect any iterations of that geometry that are already in process.
                 *
                 * @param at
                 * the specified <code>AffineTransform</code>
                 * @param flatness
                 * the maximum amount that the control points for a given curve
                 * can vary from colinear before a subdivided curve is replaced
                 * by a straight line connecting the end points. Since a
                 * <code>Line2D</code> object is always flat, this parameter is
                 * ignored.
                 * @return a <code>PathIterator</code> that defines the boundary of the
                 * flattened <code>Line2D</code>
                 * @since 1.2
                 */
                Line2D.prototype.getPathIterator = function (at, flatness) {
                    var _this = this;
                    if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            return new java.awt.geom.LineIterator(_this, at);
                        })();
                    }
                    else if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && flatness === undefined) {
                        return this.getPathIterator$java_awt_geom_AffineTransform(at);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Creates a new object of the same class as this object.
                 *
                 * @return a clone of this instance.
                 * @exception OutOfMemoryError
                 * if there is not enough memory.
                 * @see java.lang.Cloneable
                 * @since 1.2
                 */
                Line2D.prototype.clone = function () {
                    try {
                        return javaemul.internal.ObjectHelper.clone(this);
                    }
                    catch (e) {
                        throw new java.lang.InternalError(e);
                    }
                    ;
                };
                return Line2D;
            }());
            geom.Line2D = Line2D;
            Line2D["__class"] = "java.awt.geom.Line2D";
            Line2D["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
            var Line2D;
            (function (Line2D) {
                /**
                 * A line segment specified with float coordinates.
                 *
                 * @since 1.2
                 */
                var Float = (function (_super) {
                    __extends(Float, _super);
                    /**
                     * Constructs and initializes a Line from the specified coordinates.
                     *
                     * @param x1
                     * the X coordinate of the start point
                     * @param y1
                     * the Y coordinate of the start point
                     * @param x2
                     * the X coordinate of the end point
                     * @param y2
                     * the Y coordinate of the end point
                     * @since 1.2
                     */
                    function Float(x1, y1, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x1 = 0;
                            this.y1 = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                            (function () {
                                _this.setLine(x1, y1, x2, y2);
                            })();
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            var p1_1 = __args[0];
                            var p2_1 = __args[1];
                            _super.call(this);
                            this.x1 = 0;
                            this.y1 = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                            (function () {
                                _this.setLine(p1_1, p2_1);
                            })();
                        }
                        else if (x1 === undefined && y1 === undefined && x2 === undefined && y2 === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x1 = 0;
                            this.y1 = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getX1 = function () {
                        return this.x1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getY1 = function () {
                        return this.y1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getP1 = function () {
                        return new java.awt.geom.Point2D.Float(this.x1, this.y1);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getX2 = function () {
                        return this.x2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getY2 = function () {
                        return this.y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getP2 = function () {
                        return new java.awt.geom.Point2D.Float(this.x2, this.y2);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.setLine$double$double$double$double = function (x1, y1, x2, y2) {
                        this.x1 = x1;
                        this.y1 = y1;
                        this.x2 = x2;
                        this.y2 = y2;
                    };
                    /**
                     * Sets the location of the end points of this <code>Line2D</code> to
                     * the specified float coordinates.
                     *
                     * @param x1
                     * the X coordinate of the start point
                     * @param y1
                     * the Y coordinate of the start point
                     * @param x2
                     * the X coordinate of the end point
                     * @param y2
                     * the Y coordinate of the end point
                     * @since 1.2
                     */
                    Float.prototype.setLine = function (x1, y1, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            return (function () {
                                _this.x1 = x1;
                                _this.y1 = y1;
                                _this.x2 = x2;
                                _this.y2 = y2;
                            })();
                        }
                        else if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.setLine$double$double$double$double(x1, y1, x2, y2);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
                            return this.setLine$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Line2D) || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setLine$java_awt_geom_Line2D(x1);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getBounds2D = function () {
                        var x;
                        var y;
                        var w;
                        var h;
                        if (this.x1 < this.x2) {
                            x = this.x1;
                            w = this.x2 - this.x1;
                        }
                        else {
                            x = this.x2;
                            w = this.x1 - this.x2;
                        }
                        if (this.y1 < this.y2) {
                            y = this.y1;
                            h = this.y2 - this.y1;
                        }
                        else {
                            y = this.y2;
                            h = this.y1 - this.y2;
                        }
                        return new java.awt.geom.Rectangle2D.Float(x, y, w, h);
                    };
                    Float.serialVersionUID = 6161772511649436349;
                    return Float;
                }(java.awt.geom.Line2D));
                Line2D.Float = Float;
                Float["__class"] = "java.awt.geom.Line2D.Float";
                Float["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
                /**
                 * A line segment specified with double coordinates.
                 *
                 * @since 1.2
                 */
                var Double = (function (_super) {
                    __extends(Double, _super);
                    /**
                     * Constructs and initializes a <code>Line2D</code> from the specified
                     * coordinates.
                     *
                     * @param x1
                     * the X coordinate of the start point
                     * @param y1
                     * the Y coordinate of the start point
                     * @param x2
                     * the X coordinate of the end point
                     * @param y2
                     * the Y coordinate of the end point
                     * @since 1.2
                     */
                    function Double(x1, y1, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x1 = 0;
                            this.y1 = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                            (function () {
                                _this.setLine(x1, y1, x2, y2);
                            })();
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            var p1_2 = __args[0];
                            var p2_2 = __args[1];
                            _super.call(this);
                            this.x1 = 0;
                            this.y1 = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                            (function () {
                                _this.setLine(p1_2, p2_2);
                            })();
                        }
                        else if (x1 === undefined && y1 === undefined && x2 === undefined && y2 === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x1 = 0;
                            this.y1 = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getX1 = function () {
                        return this.x1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getY1 = function () {
                        return this.y1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getP1 = function () {
                        return new java.awt.geom.Point2D.Double(this.x1, this.y1);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getX2 = function () {
                        return this.x2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getY2 = function () {
                        return this.y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getP2 = function () {
                        return new java.awt.geom.Point2D.Double(this.x2, this.y2);
                    };
                    /**
                     * Sets the location of the end points of this <code>Line2D</code> to
                     * the specified float coordinates.
                     *
                     * @param x1
                     * the X coordinate of the start point
                     * @param y1
                     * the Y coordinate of the start point
                     * @param x2
                     * the X coordinate of the end point
                     * @param y2
                     * the Y coordinate of the end point
                     * @since 1.2
                     */
                    Double.prototype.setLine = function (x1, y1, x2, y2) {
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.setLine$double$double$double$double(x1, y1, x2, y2);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
                            return this.setLine$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Line2D) || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setLine$java_awt_geom_Line2D(x1);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.setLine$double$double$double$double = function (x1, y1, x2, y2) {
                        this.x1 = x1;
                        this.y1 = y1;
                        this.x2 = x2;
                        this.y2 = y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getBounds2D = function () {
                        var x;
                        var y;
                        var w;
                        var h;
                        if (this.x1 < this.x2) {
                            x = this.x1;
                            w = this.x2 - this.x1;
                        }
                        else {
                            x = this.x2;
                            w = this.x1 - this.x2;
                        }
                        if (this.y1 < this.y2) {
                            y = this.y1;
                            h = this.y2 - this.y1;
                        }
                        else {
                            y = this.y2;
                            h = this.y1 - this.y2;
                        }
                        return new java.awt.geom.Rectangle2D.Double(x, y, w, h);
                    };
                    Double.serialVersionUID = 7979627399746467499;
                    return Double;
                }(java.awt.geom.Line2D));
                Line2D.Double = Double;
                Double["__class"] = "java.awt.geom.Line2D.Double";
                Double["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
            })(Line2D = geom.Line2D || (geom.Line2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * A utility class to iterate over the path segments of a line segment through
             * the PathIterator interface.
             *
             * @author Jim Graham
             */
            var LineIterator = (function () {
                function LineIterator(l, at) {
                    this.index = 0;
                    this.line = l;
                    this.affine = at;
                }
                /**
                 * Return the winding rule for determining the insideness of the path.
                 *
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 */
                LineIterator.prototype.getWindingRule = function () {
                    return java.awt.geom.PathIterator.WIND_NON_ZERO;
                };
                /**
                 * Tests if there are more points to read.
                 *
                 * @return true if there are more points to read
                 */
                LineIterator.prototype.isDone = function () {
                    return (this.index > 1);
                };
                LineIterator.prototype.next = function (doNext) {
                    if (doNext === undefined) {
                        return this.next$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Moves the iterator to the next segment of the path forwards along the
                 * primary direction of traversal as long as there are more points in that
                 * direction.
                 */
                LineIterator.prototype.next$ = function () {
                    this.index++;
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of float x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                LineIterator.prototype.currentSegment = function (coords) {
                    var _this = this;
                    if (((coords != null && coords instanceof Array) || coords === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (_this.isDone()) {
                                throw new java.util.NoSuchElementException("line iterator out of bounds");
                            }
                            var type;
                            if (_this.index === 0) {
                                coords[0] = _this.line.getX1();
                                coords[1] = _this.line.getY1();
                                type = java.awt.geom.PathIterator.SEG_MOVETO;
                            }
                            else {
                                coords[0] = _this.line.getX2();
                                coords[1] = _this.line.getY2();
                                type = java.awt.geom.PathIterator.SEG_LINETO;
                            }
                            if (_this.affine != null) {
                                _this.affine.transform(coords, 0, coords, 0, 1);
                            }
                            return type;
                        })();
                    }
                    else if (((coords != null && coords instanceof Array) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A double array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of double x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                LineIterator.prototype.currentSegment$double_A = function (coords) {
                    if (this.isDone()) {
                        throw new java.util.NoSuchElementException("line iterator out of bounds");
                    }
                    var type;
                    if (this.index === 0) {
                        coords[0] = this.line.getX1();
                        coords[1] = this.line.getY1();
                        type = java.awt.geom.PathIterator.SEG_MOVETO;
                    }
                    else {
                        coords[0] = this.line.getX2();
                        coords[1] = this.line.getY2();
                        type = java.awt.geom.PathIterator.SEG_LINETO;
                    }
                    if (this.affine != null) {
                        this.affine.transform(coords, 0, coords, 0, 1);
                    }
                    return type;
                };
                return LineIterator;
            }());
            geom.LineIterator = LineIterator;
            LineIterator["__class"] = "java.awt.geom.LineIterator";
            LineIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>NoninvertibleTransformException</code> class represents an
             * exception that is thrown if an operation is performed requiring the inverse
             * of an {@link AffineTransform} object but the <code>AffineTransform</code> is
             * in a non-invertible state.
             */
            var NoninvertibleTransformException = (function (_super) {
                __extends(NoninvertibleTransformException, _super);
                /**
                 * Constructs an instance of <code>NoninvertibleTransformException</code>
                 * with the specified detail message.
                 *
                 * @param s
                 * the detail message
                 * @since 1.2
                 */
                function NoninvertibleTransformException(s) {
                    _super.call(this, s);
                    this.message = s;
                }
                return NoninvertibleTransformException;
            }(java.lang.Exception));
            geom.NoninvertibleTransformException = NoninvertibleTransformException;
            NoninvertibleTransformException["__class"] = "java.awt.geom.NoninvertibleTransformException";
            NoninvertibleTransformException["__interfaces"] = ["java.io.Serializable"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var PathIterator;
            (function (PathIterator) {
                /**
                 * The winding rule constant for specifying an even-odd rule for determining
                 * the interior of a path. The even-odd rule specifies that a point lies
                 * inside the path if a ray drawn in any direction from that point to
                 * infinity is crossed by path segments an odd number of times.
                 */
                PathIterator.WIND_EVEN_ODD = 0;
                /**
                 * The winding rule constant for specifying a non-zero rule for determining
                 * the interior of a path. The non-zero rule specifies that a point lies
                 * inside the path if a ray drawn in any direction from that point to
                 * infinity is crossed by path segments a different number of times in the
                 * counter-clockwise direction than the clockwise direction.
                 */
                PathIterator.WIND_NON_ZERO = 1;
                /**
                 * The segment type constant for a point that specifies the starting
                 * location for a new subpath.
                 */
                PathIterator.SEG_MOVETO = 0;
                /**
                 * The segment type constant for a point that specifies the end point of a
                 * line to be drawn from the most recently specified point.
                 */
                PathIterator.SEG_LINETO = 1;
                /**
                 * The segment type constant for the pair of points that specify a quadratic
                 * parametric curve to be drawn from the most recently specified point. The
                 * curve is interpolated by solving the parametric control equation in the
                 * range <code>(t=[0..1])</code> using the most recently specified (current)
                 * point (CP), the first control point (P1), and the final interpolated
                 * control point (P2). The parametric control equation for this curve is:
                 *
                 * <pre>
                 * P(t) = B(2,0)*CP + B(2,1)*P1 + B(2,2)*P2
                 * 0 &lt;= t &lt;= 1
                 *
                 * B(n,m) = mth coefficient of nth degree Bernstein polynomial
                 * = C(n,m) * t^(m) * (1 - t)^(n-m)
                 * C(n,m) = Combinations of n things, taken m at a time
                 * = n! / (m! * (n-m)!)
                 * </pre>
                 */
                PathIterator.SEG_QUADTO = 2;
                /**
                 * The segment type constant for the set of 3 points that specify a cubic
                 * parametric curve to be drawn from the most recently specified point. The
                 * curve is interpolated by solving the parametric control equation in the
                 * range <code>(t=[0..1])</code> using the most recently specified (current)
                 * point (CP), the first control point (P1), the second control point (P2),
                 * and the final interpolated control point (P3). The parametric control
                 * equation for this curve is:
                 *
                 * <pre>
                 * P(t) = B(3,0)*CP + B(3,1)*P1 + B(3,2)*P2 + B(3,3)*P3
                 * 0 &lt;= t &lt;= 1
                 *
                 * B(n,m) = mth coefficient of nth degree Bernstein polynomial
                 * = C(n,m) * t^(m) * (1 - t)^(n-m)
                 * C(n,m) = Combinations of n things, taken m at a time
                 * = n! / (m! * (n-m)!)
                 * </pre>
                 *
                 * This form of curve is commonly known as a B&eacute;zier curve.
                 */
                PathIterator.SEG_CUBICTO = 3;
                /**
                 * The segment type constant that specifies that the preceding subpath
                 * should be closed by appending a line segment back to the point
                 * corresponding to the most recent SEG_MOVETO.
                 */
                PathIterator.SEG_CLOSE = 4;
            })(PathIterator = geom.PathIterator || (geom.PathIterator = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>Point2D</code> class defines a point representing a location in
             * {@code (x,y)} coordinate space.
             * <p>
             * This class is only the abstract superclass for all objects that store a 2D
             * coordinate. The actual storage representation of the coordinates is left to
             * the subclass.
             *
             * @author Jim Graham
             * @since 1.2
             */
            var Point2D = (function () {
                /**
                 * This is an abstract class that cannot be instantiated directly.
                 * Type-specific implementation subclasses are available for instantiation
                 * and provide a number of formats for storing the information necessary to
                 * satisfy the various accessor methods below.
                 *
                 * @see java.awt.geom.Point2D.Float
                 * @see java.awt.geom.Point2D.Double
                 * @see java.awt.Point
                 * @since 1.2
                 */
                function Point2D() {
                }
                Point2D.prototype.setLocation = function (x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.setLocation$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined) {
                        return this.setLocation$java_awt_geom_Point2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the location of this <code>Point2D</code> to the specified
                 * <code>double</code> coordinates.
                 *
                 * @param x
                 * the new X coordinate of this {@code Point2D}
                 * @param y
                 * the new Y coordinate of this {@code Point2D}
                 * @since 1.2
                 */
                Point2D.prototype.setLocation$double$double = function (x, y) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets the location of this <code>Point2D</code> to the same coordinates as
                 * the specified <code>Point2D</code> object.
                 *
                 * @param p
                 * the specified <code>Point2D</code> to which to set this
                 * <code>Point2D</code>
                 * @since 1.2
                 */
                Point2D.prototype.setLocation$java_awt_geom_Point2D = function (p) {
                    this.setLocation(p.getX(), p.getY());
                };
                /**
                 * Returns the square of the distance between two points.
                 *
                 * @param x1
                 * the X coordinate of the first specified point
                 * @param y1
                 * the Y coordinate of the first specified point
                 * @param x2
                 * the X coordinate of the second specified point
                 * @param y2
                 * the Y coordinate of the second specified point
                 * @return the square of the distance between the two sets of specified
                 * coordinates.
                 * @since 1.2
                 */
                Point2D.distanceSq = function (x1, y1, x2, y2) {
                    x1 -= x2;
                    y1 -= y2;
                    return (x1 * x1 + y1 * y1);
                };
                /**
                 * Returns the distance between two points.
                 *
                 * @param x1
                 * the X coordinate of the first specified point
                 * @param y1
                 * the Y coordinate of the first specified point
                 * @param x2
                 * the X coordinate of the second specified point
                 * @param y2
                 * the Y coordinate of the second specified point
                 * @return the distance between the two sets of specified coordinates.
                 * @since 1.2
                 */
                Point2D.distance = function (x1, y1, x2, y2) {
                    x1 -= x2;
                    y1 -= y2;
                    return Math.sqrt(x1 * x1 + y1 * y1);
                };
                /**
                 * Returns the square of the distance from this <code>Point2D</code> to a
                 * specified point.
                 *
                 * @param px
                 * the X coordinate of the specified point to be measured against
                 * this <code>Point2D</code>
                 * @param py
                 * the Y coordinate of the specified point to be measured against
                 * this <code>Point2D</code>
                 * @return the square of the distance between this <code>Point2D</code> and
                 * the specified point.
                 * @since 1.2
                 */
                Point2D.prototype.distanceSq = function (px, py) {
                    var _this = this;
                    if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            px -= _this.getX();
                            py -= _this.getY();
                            return (px * px + py * py);
                        })();
                    }
                    else if (((px != null && px instanceof java.awt.geom.Point2D) || px === null) && py === undefined) {
                        return this.distanceSq$java_awt_geom_Point2D(px);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the square of the distance from this <code>Point2D</code> to a
                 * specified <code>Point2D</code>.
                 *
                 * @param pt
                 * the specified point to be measured against this
                 * <code>Point2D</code>
                 * @return the square of the distance between this <code>Point2D</code> to a
                 * specified <code>Point2D</code>.
                 * @since 1.2
                 */
                Point2D.prototype.distanceSq$java_awt_geom_Point2D = function (pt) {
                    var px = pt.getX() - this.getX();
                    var py = pt.getY() - this.getY();
                    return (px * px + py * py);
                };
                /**
                 * Returns the distance from this <code>Point2D</code> to a specified point.
                 *
                 * @param px
                 * the X coordinate of the specified point to be measured against
                 * this <code>Point2D</code>
                 * @param py
                 * the Y coordinate of the specified point to be measured against
                 * this <code>Point2D</code>
                 * @return the distance between this <code>Point2D</code> and a specified
                 * point.
                 * @since 1.2
                 */
                Point2D.prototype.distance = function (px, py) {
                    var _this = this;
                    if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            px -= _this.getX();
                            py -= _this.getY();
                            return Math.sqrt(px * px + py * py);
                        })();
                    }
                    else if (((px != null && px instanceof java.awt.geom.Point2D) || px === null) && py === undefined) {
                        return this.distance$java_awt_geom_Point2D(px);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the distance from this <code>Point2D</code> to a specified
                 * <code>Point2D</code>.
                 *
                 * @param pt
                 * the specified point to be measured against this
                 * <code>Point2D</code>
                 * @return the distance between this <code>Point2D</code> and the specified
                 * <code>Point2D</code>.
                 * @since 1.2
                 */
                Point2D.prototype.distance$java_awt_geom_Point2D = function (pt) {
                    var px = pt.getX() - this.getX();
                    var py = pt.getY() - this.getY();
                    return Math.sqrt(px * px + py * py);
                };
                /**
                 * Creates a new object of the same class and with the same contents as this
                 * object.
                 *
                 * @return a clone of this instance.
                 * @exception OutOfMemoryError
                 * if there is not enough memory.
                 * @see java.lang.Cloneable
                 * @since 1.2
                 */
                Point2D.prototype.clone = function () {
                    try {
                        return javaemul.internal.ObjectHelper.clone(this);
                    }
                    catch (e) {
                        throw new java.lang.InternalError(e);
                    }
                    ;
                };
                /**
                 * Returns the hashcode for this <code>Point2D</code>.
                 *
                 * @return a hash code for this <code>Point2D</code>.
                 */
                Point2D.prototype.hashCode = function () {
                    var bits = javaemul.internal.DoubleHelper.doubleToLongBits(this.getX());
                    bits ^= javaemul.internal.DoubleHelper.doubleToLongBits(this.getY()) * 31;
                    return (((bits | 0)) ^ (((bits >> 32) | 0)));
                };
                /**
                 * Determines whether or not two points are equal. Two instances of
                 * <code>Point2D</code> are equal if the values of their <code>x</code> and
                 * <code>y</code> member fields, representing their position in the
                 * coordinate space, are the same.
                 *
                 * @param obj
                 * an object to be compared with this <code>Point2D</code>
                 * @return <code>true</code> if the object to be compared is an instance of
                 * <code>Point2D</code> and has the same values; <code>false</code>
                 * otherwise.
                 * @since 1.2
                 */
                Point2D.prototype.equals = function (obj) {
                    if (obj != null && obj instanceof java.awt.geom.Point2D) {
                        var p2d = obj;
                        return (this.getX() === p2d.getX()) && (this.getY() === p2d.getY());
                    }
                    return (this === obj);
                };
                return Point2D;
            }());
            geom.Point2D = Point2D;
            Point2D["__class"] = "java.awt.geom.Point2D";
            Point2D["__interfaces"] = ["java.lang.Cloneable"];
            var Point2D;
            (function (Point2D) {
                /**
                 * The <code>Float</code> class defines a point specified in float
                 * precision.
                 *
                 * @since 1.2
                 */
                var Float = (function (_super) {
                    __extends(Float, _super);
                    /**
                     * Constructs and initializes a <code>Point2D</code> with the specified
                     * coordinates.
                     *
                     * @param x
                     * the X coordinate of the newly constructed
                     * <code>Point2D</code>
                     * @param y
                     * the Y coordinate of the newly constructed
                     * <code>Point2D</code>
                     * @since 1.2
                     */
                    function Float(x, y) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x = 0;
                            this.y = 0;
                            (function () {
                                _this.x = x;
                                _this.y = y;
                            })();
                        }
                        else if (x === undefined && y === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x = 0;
                            this.y = 0;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.setLocation$double$double = function (x, y) {
                        this.x = x;
                        this.y = y;
                    };
                    /**
                     * Sets the location of this <code>Point2D</code> to the specified
                     * <code>float</code> coordinates.
                     *
                     * @param x
                     * the new X coordinate of this {@code Point2D}
                     * @param y
                     * the new Y coordinate of this {@code Point2D}
                     * @since 1.2
                     */
                    Float.prototype.setLocation = function (x, y) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            return (function () {
                                _this.x = x;
                                _this.y = y;
                            })();
                        }
                        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return this.setLocation$double$double(x, y);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined) {
                            return this.setLocation$java_awt_geom_Point2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * Returns a <code>String</code> that represents the value of this
                     * <code>Point2D</code>.
                     *
                     * @return a string representation of this <code>Point2D</code>.
                     * @since 1.2
                     */
                    Float.prototype.toString = function () {
                        return "Point2D.Float[" + this.x + ", " + this.y + "]";
                    };
                    Float.serialVersionUID = -2870572449815403710;
                    return Float;
                }(java.awt.geom.Point2D));
                Point2D.Float = Float;
                Float["__class"] = "java.awt.geom.Point2D.Float";
                Float["__interfaces"] = ["java.lang.Cloneable", "java.io.Serializable"];
                /**
                 * The <code>Double</code> class defines a point specified in
                 * <code>double</code> precision.
                 *
                 * @since 1.2
                 */
                var Double = (function (_super) {
                    __extends(Double, _super);
                    /**
                     * Constructs and initializes a <code>Point2D</code> with the specified
                     * coordinates.
                     *
                     * @param x
                     * the X coordinate of the newly constructed
                     * <code>Point2D</code>
                     * @param y
                     * the Y coordinate of the newly constructed
                     * <code>Point2D</code>
                     * @since 1.2
                     */
                    function Double(x, y) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x = 0;
                            this.y = 0;
                            (function () {
                                _this.x = x;
                                _this.y = y;
                            })();
                        }
                        else if (x === undefined && y === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x = 0;
                            this.y = 0;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * Sets the location of this <code>Point2D</code> to the specified
                     * <code>float</code> coordinates.
                     *
                     * @param x
                     * the new X coordinate of this {@code Point2D}
                     * @param y
                     * the new Y coordinate of this {@code Point2D}
                     * @since 1.2
                     */
                    Double.prototype.setLocation = function (x, y) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return this.setLocation$double$double(x, y);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined) {
                            return this.setLocation$java_awt_geom_Point2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.setLocation$double$double = function (x, y) {
                        this.x = x;
                        this.y = y;
                    };
                    /**
                     * Returns a <code>String</code> that represents the value of this
                     * <code>Point2D</code>.
                     *
                     * @return a string representation of this <code>Point2D</code>.
                     * @since 1.2
                     */
                    Double.prototype.toString = function () {
                        return "Point2D.Double[" + this.x + ", " + this.y + "]";
                    };
                    Double.serialVersionUID = 6150783262733311327;
                    return Double;
                }(java.awt.geom.Point2D));
                Point2D.Double = Double;
                Double["__class"] = "java.awt.geom.Point2D.Double";
                Double["__interfaces"] = ["java.lang.Cloneable", "java.io.Serializable"];
            })(Point2D = geom.Point2D || (geom.Point2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>QuadCurve2D</code> class defines a quadratic parametric curve
             * segment in {@code (x,y)} coordinate space.
             * <p>
             * This class is only the abstract superclass for all objects that store a 2D
             * quadratic curve segment. The actual storage representation of the coordinates
             * is left to the subclass.
             *
             * @author Jim Graham
             * @since 1.2
             */
            var QuadCurve2D = (function () {
                /**
                 * This is an abstract class that cannot be instantiated directly.
                 * Type-specific implementation subclasses are available for instantiation
                 * and provide a number of formats for storing the information necessary to
                 * satisfy the various accessor methods below.
                 *
                 * @see java.awt.geom.QuadCurve2D.Float
                 * @see java.awt.geom.QuadCurve2D.Double
                 * @since 1.2
                 */
                function QuadCurve2D() {
                }
                /**
                 * Sets the location of the end points and control point of this curve
                 * to the specified {@code float} coordinates.
                 *
                 * @param x1
                 * the X coordinate of the start point
                 * @param y1
                 * the Y coordinate of the start point
                 * @param ctrlx
                 * the X coordinate of the control point
                 * @param ctrly
                 * the Y coordinate of the control point
                 * @param x2
                 * the X coordinate of the end point
                 * @param y2
                 * the Y coordinate of the end point
                 * @since 1.2
                 */
                QuadCurve2D.prototype.setCurve = function (x1, y1, ctrlx, ctrly, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return this.setCurve$double$double$double$double$double$double(x1, y1, ctrlx, ctrly, x2, y2);
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && ((ctrlx != null && ctrlx instanceof java.awt.geom.Point2D) || ctrlx === null) && ctrly === undefined && x2 === undefined && y2 === undefined) {
                        return this.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1, ctrlx);
                    }
                    else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                        return this.setCurve$double_A$int(x1, y1);
                    }
                    else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                        return this.setCurve$java_awt_geom_Point2D_A$int(x1, y1);
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.QuadCurve2D) || x1 === null) && y1 === undefined && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                        return this.setCurve$java_awt_geom_QuadCurve2D(x1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the location of the end points and control point of this curve to
                 * the specified <code>double</code> coordinates.
                 *
                 * @param x1
                 * the X coordinate of the start point
                 * @param y1
                 * the Y coordinate of the start point
                 * @param ctrlx
                 * the X coordinate of the control point
                 * @param ctrly
                 * the Y coordinate of the control point
                 * @param x2
                 * the X coordinate of the end point
                 * @param y2
                 * the Y coordinate of the end point
                 * @since 1.2
                 */
                QuadCurve2D.prototype.setCurve$double$double$double$double$double$double = function (x1, y1, ctrlx, ctrly, x2, y2) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets the location of the end points and control points of this
                 * <code>QuadCurve2D</code> to the <code>double</code> coordinates at the
                 * specified offset in the specified array.
                 *
                 * @param coords
                 * the array containing coordinate values
                 * @param offset
                 * the index into the array from which to start getting the
                 * coordinate values and assigning them to this
                 * <code>QuadCurve2D</code>
                 * @since 1.2
                 */
                QuadCurve2D.prototype.setCurve$double_A$int = function (coords, offset) {
                    this.setCurve(coords[offset + 0], coords[offset + 1], coords[offset + 2], coords[offset + 3], coords[offset + 4], coords[offset + 5]);
                };
                /**
                 * Sets the location of the end points and control point of this
                 * <code>QuadCurve2D</code> to the specified <code>Point2D</code>
                 * coordinates.
                 *
                 * @param p1
                 * the start point
                 * @param cp
                 * the control point
                 * @param p2
                 * the end point
                 * @since 1.2
                 */
                QuadCurve2D.prototype.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D = function (p1, cp, p2) {
                    this.setCurve(p1.getX(), p1.getY(), cp.getX(), cp.getY(), p2.getX(), p2.getY());
                };
                /**
                 * Sets the location of the end points and control points of this
                 * <code>QuadCurve2D</code> to the coordinates of the <code>Point2D</code>
                 * objects at the specified offset in the specified array.
                 *
                 * @param pts
                 * an array containing <code>Point2D</code> that define
                 * coordinate values
                 * @param offset
                 * the index into <code>pts</code> from which to start getting
                 * the coordinate values and assigning them to this
                 * <code>QuadCurve2D</code>
                 * @since 1.2
                 */
                QuadCurve2D.prototype.setCurve$java_awt_geom_Point2D_A$int = function (pts, offset) {
                    this.setCurve(pts[offset + 0].getX(), pts[offset + 0].getY(), pts[offset + 1].getX(), pts[offset + 1].getY(), pts[offset + 2].getX(), pts[offset + 2].getY());
                };
                /**
                 * Sets the location of the end points and control point of this
                 * <code>QuadCurve2D</code> to the same as those in the specified
                 * <code>QuadCurve2D</code>.
                 *
                 * @param c
                 * the specified <code>QuadCurve2D</code>
                 * @since 1.2
                 */
                QuadCurve2D.prototype.setCurve$java_awt_geom_QuadCurve2D = function (c) {
                    this.setCurve(c.getX1(), c.getY1(), c.getCtrlX(), c.getCtrlY(), c.getX2(), c.getY2());
                };
                /**
                 * Returns the square of the flatness, or maximum distance of a control
                 * point from the line connecting the end points, of the quadratic curve
                 * specified by the indicated control points.
                 *
                 * @param x1
                 * the X coordinate of the start point
                 * @param y1
                 * the Y coordinate of the start point
                 * @param ctrlx
                 * the X coordinate of the control point
                 * @param ctrly
                 * the Y coordinate of the control point
                 * @param x2
                 * the X coordinate of the end point
                 * @param y2
                 * the Y coordinate of the end point
                 * @return the square of the flatness of the quadratic curve defined by the
                 * specified coordinates.
                 * @since 1.2
                 */
                QuadCurve2D.getFlatnessSq = function (x1, y1, ctrlx, ctrly, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            return java.awt.geom.Line2D.ptSegDistSq(x1, y1, x2, y2, ctrlx, ctrly);
                        })();
                    }
                    else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                        return java.awt.geom.QuadCurve2D.getFlatnessSq$double_A$int(x1, y1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the flatness, or maximum distance of a control point from the
                 * line connecting the end points, of the quadratic curve specified by the
                 * indicated control points.
                 *
                 * @param x1
                 * the X coordinate of the start point
                 * @param y1
                 * the Y coordinate of the start point
                 * @param ctrlx
                 * the X coordinate of the control point
                 * @param ctrly
                 * the Y coordinate of the control point
                 * @param x2
                 * the X coordinate of the end point
                 * @param y2
                 * the Y coordinate of the end point
                 * @return the flatness of the quadratic curve defined by the specified
                 * coordinates.
                 * @since 1.2
                 */
                QuadCurve2D.getFlatness = function (x1, y1, ctrlx, ctrly, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            return java.awt.geom.Line2D.ptSegDist(x1, y1, x2, y2, ctrlx, ctrly);
                        })();
                    }
                    else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                        return java.awt.geom.QuadCurve2D.getFlatness$double_A$int(x1, y1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the square of the flatness, or maximum distance of a control
                 * point from the line connecting the end points, of the quadratic curve
                 * specified by the control points stored in the indicated array at the
                 * indicated index.
                 *
                 * @param coords
                 * an array containing coordinate values
                 * @param offset
                 * the index into <code>coords</code> from which to to start
                 * getting the values from the array
                 * @return the flatness of the quadratic curve that is defined by the values
                 * in the specified array at the specified index.
                 * @since 1.2
                 */
                QuadCurve2D.getFlatnessSq$double_A$int = function (coords, offset) {
                    return java.awt.geom.Line2D.ptSegDistSq(coords[offset + 0], coords[offset + 1], coords[offset + 4], coords[offset + 5], coords[offset + 2], coords[offset + 3]);
                };
                /**
                 * Returns the flatness, or maximum distance of a control point from the
                 * line connecting the end points, of the quadratic curve specified by the
                 * control points stored in the indicated array at the indicated index.
                 *
                 * @param coords
                 * an array containing coordinate values
                 * @param offset
                 * the index into <code>coords</code> from which to start getting
                 * the coordinate values
                 * @return the flatness of a quadratic curve defined by the specified array
                 * at the specified offset.
                 * @since 1.2
                 */
                QuadCurve2D.getFlatness$double_A$int = function (coords, offset) {
                    return java.awt.geom.Line2D.ptSegDist(coords[offset + 0], coords[offset + 1], coords[offset + 4], coords[offset + 5], coords[offset + 2], coords[offset + 3]);
                };
                /**
                 * Returns the square of the flatness, or maximum distance of a control
                 * point from the line connecting the end points, of this
                 * <code>QuadCurve2D</code>.
                 *
                 * @return the square of the flatness of this <code>QuadCurve2D</code>.
                 * @since 1.2
                 */
                QuadCurve2D.prototype.getFlatnessSq = function () {
                    return java.awt.geom.Line2D.ptSegDistSq(this.getX1(), this.getY1(), this.getX2(), this.getY2(), this.getCtrlX(), this.getCtrlY());
                };
                /**
                 * Returns the flatness, or maximum distance of a control point from the
                 * line connecting the end points, of this <code>QuadCurve2D</code>.
                 *
                 * @return the flatness of this <code>QuadCurve2D</code>.
                 * @since 1.2
                 */
                QuadCurve2D.prototype.getFlatness = function () {
                    return java.awt.geom.Line2D.ptSegDist(this.getX1(), this.getY1(), this.getX2(), this.getY2(), this.getCtrlX(), this.getCtrlY());
                };
                /**
                 * Subdivides this <code>QuadCurve2D</code> and stores the resulting two
                 * subdivided curves into the <code>left</code> and <code>right</code> curve
                 * parameters. Either or both of the <code>left</code> and
                 * <code>right</code> objects can be the same as this
                 * <code>QuadCurve2D</code> or <code>null</code>.
                 *
                 * @param left
                 * the <code>QuadCurve2D</code> object for storing the left or
                 * first half of the subdivided curve
                 * @param right
                 * the <code>QuadCurve2D</code> object for storing the right or
                 * second half of the subdivided curve
                 * @since 1.2
                 */
                QuadCurve2D.prototype.subdivide = function (left, right) {
                    QuadCurve2D.subdivide(this, left, right);
                };
                /**
                 * Subdivides the quadratic curve specified by the <code>src</code>
                 * parameter and stores the resulting two subdivided curves into the
                 * <code>left</code> and <code>right</code> curve parameters. Either or both
                 * of the <code>left</code> and <code>right</code> objects can be the same
                 * as the <code>src</code> object or <code>null</code>.
                 *
                 * @param src
                 * the quadratic curve to be subdivided
                 * @param left
                 * the <code>QuadCurve2D</code> object for storing the left or
                 * first half of the subdivided curve
                 * @param right
                 * the <code>QuadCurve2D</code> object for storing the right or
                 * second half of the subdivided curve
                 * @since 1.2
                 */
                QuadCurve2D.subdivide$java_awt_geom_QuadCurve2D$java_awt_geom_QuadCurve2D$java_awt_geom_QuadCurve2D = function (src, left, right) {
                    var x1 = src.getX1();
                    var y1 = src.getY1();
                    var ctrlx = src.getCtrlX();
                    var ctrly = src.getCtrlY();
                    var x2 = src.getX2();
                    var y2 = src.getY2();
                    var ctrlx1 = (x1 + ctrlx) / 2.0;
                    var ctrly1 = (y1 + ctrly) / 2.0;
                    var ctrlx2 = (x2 + ctrlx) / 2.0;
                    var ctrly2 = (y2 + ctrly) / 2.0;
                    ctrlx = (ctrlx1 + ctrlx2) / 2.0;
                    ctrly = (ctrly1 + ctrly2) / 2.0;
                    if (left != null) {
                        left.setCurve(x1, y1, ctrlx1, ctrly1, ctrlx, ctrly);
                    }
                    if (right != null) {
                        right.setCurve(ctrlx, ctrly, ctrlx2, ctrly2, x2, y2);
                    }
                };
                /**
                 * Subdivides the quadratic curve specified by the coordinates stored in the
                 * <code>src</code> array at indices <code>srcoff</code> through
                 * <code>srcoff</code>&nbsp;+&nbsp;5 and stores the resulting two subdivided
                 * curves into the two result arrays at the corresponding indices. Either or
                 * both of the <code>left</code> and <code>right</code> arrays can be
                 * <code>null</code> or a reference to the same array and offset as the
                 * <code>src</code> array. Note that the last point in the first subdivided
                 * curve is the same as the first point in the second subdivided curve.
                 * Thus, it is possible to pass the same array for <code>left</code> and
                 * <code>right</code> and to use offsets such that <code>rightoff</code>
                 * equals <code>leftoff</code> + 4 in order to avoid allocating extra
                 * storage for this common point.
                 *
                 * @param src
                 * the array holding the coordinates for the source curve
                 * @param srcoff
                 * the offset into the array of the beginning of the the 6 source
                 * coordinates
                 * @param left
                 * the array for storing the coordinates for the first half of
                 * the subdivided curve
                 * @param leftoff
                 * the offset into the array of the beginning of the the 6 left
                 * coordinates
                 * @param right
                 * the array for storing the coordinates for the second half of
                 * the subdivided curve
                 * @param rightoff
                 * the offset into the array of the beginning of the the 6 right
                 * coordinates
                 * @since 1.2
                 */
                QuadCurve2D.subdivide = function (src, srcoff, left, leftoff, right, rightoff) {
                    if (((src != null && src instanceof Array) || src === null) && ((typeof srcoff === 'number') || srcoff === null) && ((left != null && left instanceof Array) || left === null) && ((typeof leftoff === 'number') || leftoff === null) && ((right != null && right instanceof Array) || right === null) && ((typeof rightoff === 'number') || rightoff === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            var x1 = src[srcoff + 0];
                            var y1 = src[srcoff + 1];
                            var ctrlx = src[srcoff + 2];
                            var ctrly = src[srcoff + 3];
                            var x2 = src[srcoff + 4];
                            var y2 = src[srcoff + 5];
                            if (left != null) {
                                left[leftoff + 0] = x1;
                                left[leftoff + 1] = y1;
                            }
                            if (right != null) {
                                right[rightoff + 4] = x2;
                                right[rightoff + 5] = y2;
                            }
                            x1 = (x1 + ctrlx) / 2.0;
                            y1 = (y1 + ctrly) / 2.0;
                            x2 = (x2 + ctrlx) / 2.0;
                            y2 = (y2 + ctrly) / 2.0;
                            ctrlx = (x1 + x2) / 2.0;
                            ctrly = (y1 + y2) / 2.0;
                            if (left != null) {
                                left[leftoff + 2] = x1;
                                left[leftoff + 3] = y1;
                                left[leftoff + 4] = ctrlx;
                                left[leftoff + 5] = ctrly;
                            }
                            if (right != null) {
                                right[rightoff + 0] = ctrlx;
                                right[rightoff + 1] = ctrly;
                                right[rightoff + 2] = x2;
                                right[rightoff + 3] = y2;
                            }
                        })();
                    }
                    else if (((src != null && src instanceof java.awt.geom.QuadCurve2D) || src === null) && ((srcoff != null && srcoff instanceof java.awt.geom.QuadCurve2D) || srcoff === null) && ((left != null && left instanceof java.awt.geom.QuadCurve2D) || left === null) && leftoff === undefined && right === undefined && rightoff === undefined) {
                        return java.awt.geom.QuadCurve2D.subdivide$java_awt_geom_QuadCurve2D$java_awt_geom_QuadCurve2D$java_awt_geom_QuadCurve2D(src, srcoff, left);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Solves the quadratic whose coefficients are in the <code>eqn</code> array
                 * and places the non-complex roots back into the same array, returning the
                 * number of roots. The quadratic solved is represented by the equation:
                 *
                 * <pre>
                 * eqn = {C, B, A};
                 * ax^2 + bx + c = 0
                 * </pre>
                 *
                 * A return value of <code>-1</code> is used to distinguish a constant
                 * equation, which might be always 0 or never 0, from an equation that has
                 * no zeroes.
                 *
                 * @param eqn
                 * the array that contains the quadratic coefficients
                 * @return the number of roots, or <code>-1</code> if the equation is a
                 * constant
                 * @since 1.2
                 */
                QuadCurve2D.solveQuadratic$double_A = function (eqn) {
                    return QuadCurve2D.solveQuadratic(eqn, eqn);
                };
                /**
                 * Solves the quadratic whose coefficients are in the <code>eqn</code> array
                 * and places the non-complex roots into the <code>res</code> array,
                 * returning the number of roots. The quadratic solved is represented by the
                 * equation:
                 *
                 * <pre>
                 * eqn = {C, B, A};
                 * ax^2 + bx + c = 0
                 * </pre>
                 *
                 * A return value of <code>-1</code> is used to distinguish a constant
                 * equation, which might be always 0 or never 0, from an equation that has
                 * no zeroes.
                 *
                 * @param eqn
                 * the specified array of coefficients to use to solve the
                 * quadratic equation
                 * @param res
                 * the array that contains the non-complex roots resulting from
                 * the solution of the quadratic equation
                 * @return the number of roots, or <code>-1</code> if the equation is a
                 * constant.
                 * @since 1.3
                 */
                QuadCurve2D.solveQuadratic = function (eqn, res) {
                    if (((eqn != null && eqn instanceof Array) || eqn === null) && ((res != null && res instanceof Array) || res === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            var a = eqn[2];
                            var b = eqn[1];
                            var c = eqn[0];
                            var roots = 0;
                            if (a === 0.0) {
                                if (b === 0.0) {
                                    return -1;
                                }
                                res[roots++] = -c / b;
                            }
                            else {
                                var d = b * b - 4.0 * a * c;
                                if (d < 0.0) {
                                    return 0;
                                }
                                d = Math.sqrt(d);
                                if (b < 0.0) {
                                    d = -d;
                                }
                                var q = (b + d) / -2.0;
                                res[roots++] = q / a;
                                if (q !== 0.0) {
                                    res[roots++] = c / q;
                                }
                            }
                            return roots;
                        })();
                    }
                    else if (((eqn != null && eqn instanceof Array) || eqn === null) && res === undefined) {
                        return java.awt.geom.QuadCurve2D.solveQuadratic$double_A(eqn);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                QuadCurve2D.prototype.contains$double$double = function (x, y) {
                    var x1 = this.getX1();
                    var y1 = this.getY1();
                    var xc = this.getCtrlX();
                    var yc = this.getCtrlY();
                    var x2 = this.getX2();
                    var y2 = this.getY2();
                    var kx = x1 - 2 * xc + x2;
                    var ky = y1 - 2 * yc + y2;
                    var dx = x - x1;
                    var dy = y - y1;
                    var dxl = x2 - x1;
                    var dyl = y2 - y1;
                    var t0 = (dx * ky - dy * kx) / (dxl * ky - dyl * kx);
                    if (t0 < 0 || t0 > 1 || t0 !== t0) {
                        return false;
                    }
                    var xb = kx * t0 * t0 + 2 * (xc - x1) * t0 + x1;
                    var yb = ky * t0 * t0 + 2 * (yc - y1) * t0 + y1;
                    var xl = dxl * t0 + x1;
                    var yl = dyl * t0 + y1;
                    return (x >= xb && x < xl) || (x >= xl && x < xb) || (y >= yb && y < yl) || (y >= yl && y < yb);
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                QuadCurve2D.prototype.contains$java_awt_geom_Point2D = function (p) {
                    return this.contains(p.getX(), p.getY());
                };
                /**
                 * Fill an array with the coefficients of the parametric equation in t,
                 * ready for solving against val with solveQuadratic. We currently have: val
                 * = Py(t) = C1*(1-t)^2 + 2*CP*t*(1-t) + C2*t^2 = C1 - 2*C1*t + C1*t^2 +
                 * 2*CP*t - 2*CP*t^2 + C2*t^2 = C1 + (2*CP - 2*C1)*t + (C1 - 2*CP + C2)*t^2
                 * 0 = (C1 - val) + (2*CP - 2*C1)*t + (C1 - 2*CP + C2)*t^2 0 = C + Bt + At^2
                 * C = C1 - val B = 2*CP - 2*C1 A = C1 - 2*CP + C2
                 */
                QuadCurve2D.fillEqn = function (eqn, val, c1, cp, c2) {
                    eqn[0] = c1 - val;
                    eqn[1] = cp + cp - c1 - c1;
                    eqn[2] = c1 - cp - cp + c2;
                    return;
                };
                /**
                 * Evaluate the t values in the first num slots of the vals[] array and
                 * place the evaluated values back into the same array. Only evaluate t
                 * values that are within the range &lt;0, 1&gt;, including the 0 and 1 ends
                 * of the range iff the include0 or include1 booleans are true. If an
                 * "inflection" equation is handed in, then any points which represent a
                 * point of inflection for that quadratic equation are also ignored.
                 */
                QuadCurve2D.evalQuadratic = function (vals, num, include0, include1, inflect, c1, ctrl, c2) {
                    var j = 0;
                    for (var i = 0; i < num; i++) {
                        var t = vals[i];
                        if ((include0 ? t >= 0 : t > 0) && (include1 ? t <= 1 : t < 1) && (inflect == null || inflect[1] + 2 * inflect[2] * t !== 0)) {
                            var u = 1 - t;
                            vals[j++] = c1 * u * u + 2 * ctrl * t * u + c2 * t * t;
                        }
                    }
                    return j;
                };
                /**
                 * Determine where coord lies with respect to the range from low to high. It
                 * is assumed that low &lt;= high. The return value is one of the 5 values
                 * BELOW, LOWEDGE, INSIDE, HIGHEDGE, or ABOVE.
                 */
                QuadCurve2D.getTag = function (coord, low, high) {
                    if (coord <= low) {
                        return (coord < low ? QuadCurve2D.BELOW : QuadCurve2D.LOWEDGE);
                    }
                    if (coord >= high) {
                        return (coord > high ? QuadCurve2D.ABOVE : QuadCurve2D.HIGHEDGE);
                    }
                    return QuadCurve2D.INSIDE;
                };
                /**
                 * Determine if the pttag represents a coordinate that is already in its
                 * test range, or is on the border with either of the two opttags
                 * representing another coordinate that is "towards the inside" of that test
                 * range. In other words, are either of the two "opt" points
                 * "drawing the pt inward"?
                 */
                QuadCurve2D.inwards = function (pttag, opt1tag, opt2tag) {
                    switch ((pttag)) {
                        case QuadCurve2D.BELOW:
                        case QuadCurve2D.ABOVE:
                        default:
                            return false;
                        case QuadCurve2D.LOWEDGE:
                            return (opt1tag >= QuadCurve2D.INSIDE || opt2tag >= QuadCurve2D.INSIDE);
                        case QuadCurve2D.INSIDE:
                            return true;
                        case QuadCurve2D.HIGHEDGE:
                            return (opt1tag <= QuadCurve2D.INSIDE || opt2tag <= QuadCurve2D.INSIDE);
                    }
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                QuadCurve2D.prototype.intersects = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (w <= 0 || h <= 0) {
                                return false;
                            }
                            var x1 = _this.getX1();
                            var y1 = _this.getY1();
                            var x1tag = QuadCurve2D.getTag(x1, x, x + w);
                            var y1tag = QuadCurve2D.getTag(y1, y, y + h);
                            if (x1tag === QuadCurve2D.INSIDE && y1tag === QuadCurve2D.INSIDE) {
                                return true;
                            }
                            var x2 = _this.getX2();
                            var y2 = _this.getY2();
                            var x2tag = QuadCurve2D.getTag(x2, x, x + w);
                            var y2tag = QuadCurve2D.getTag(y2, y, y + h);
                            if (x2tag === QuadCurve2D.INSIDE && y2tag === QuadCurve2D.INSIDE) {
                                return true;
                            }
                            var ctrlx = _this.getCtrlX();
                            var ctrly = _this.getCtrlY();
                            var ctrlxtag = QuadCurve2D.getTag(ctrlx, x, x + w);
                            var ctrlytag = QuadCurve2D.getTag(ctrly, y, y + h);
                            if (x1tag < QuadCurve2D.INSIDE && x2tag < QuadCurve2D.INSIDE && ctrlxtag < QuadCurve2D.INSIDE) {
                                return false;
                            }
                            if (y1tag < QuadCurve2D.INSIDE && y2tag < QuadCurve2D.INSIDE && ctrlytag < QuadCurve2D.INSIDE) {
                                return false;
                            }
                            if (x1tag > QuadCurve2D.INSIDE && x2tag > QuadCurve2D.INSIDE && ctrlxtag > QuadCurve2D.INSIDE) {
                                return false;
                            }
                            if (y1tag > QuadCurve2D.INSIDE && y2tag > QuadCurve2D.INSIDE && ctrlytag > QuadCurve2D.INSIDE) {
                                return false;
                            }
                            if (QuadCurve2D.inwards(x1tag, x2tag, ctrlxtag) && QuadCurve2D.inwards(y1tag, y2tag, ctrlytag)) {
                                return true;
                            }
                            if (QuadCurve2D.inwards(x2tag, x1tag, ctrlxtag) && QuadCurve2D.inwards(y2tag, y1tag, ctrlytag)) {
                                return true;
                            }
                            var xoverlap = (x1tag * x2tag <= 0);
                            var yoverlap = (y1tag * y2tag <= 0);
                            if (x1tag === QuadCurve2D.INSIDE && x2tag === QuadCurve2D.INSIDE && yoverlap) {
                                return true;
                            }
                            if (y1tag === QuadCurve2D.INSIDE && y2tag === QuadCurve2D.INSIDE && xoverlap) {
                                return true;
                            }
                            var eqn = new Array(3);
                            var res = new Array(3);
                            if (!yoverlap) {
                                QuadCurve2D.fillEqn(eqn, (y1tag < QuadCurve2D.INSIDE ? y : y + h), y1, ctrly, y2);
                                return (QuadCurve2D.solveQuadratic(eqn, res) === 2 && QuadCurve2D.evalQuadratic(res, 2, true, true, null, x1, ctrlx, x2) === 2 && QuadCurve2D.getTag(res[0], x, x + w) * QuadCurve2D.getTag(res[1], x, x + w) <= 0);
                            }
                            if (!xoverlap) {
                                QuadCurve2D.fillEqn(eqn, (x1tag < QuadCurve2D.INSIDE ? x : x + w), x1, ctrlx, x2);
                                return (QuadCurve2D.solveQuadratic(eqn, res) === 2 && QuadCurve2D.evalQuadratic(res, 2, true, true, null, y1, ctrly, y2) === 2 && QuadCurve2D.getTag(res[0], y, y + h) * QuadCurve2D.getTag(res[1], y, y + h) <= 0);
                            }
                            var dx = x2 - x1;
                            var dy = y2 - y1;
                            var k = y2 * x1 - x2 * y1;
                            var c1tag;
                            var c2tag;
                            if (y1tag === QuadCurve2D.INSIDE) {
                                c1tag = x1tag;
                            }
                            else {
                                c1tag = QuadCurve2D.getTag((k + dx * (y1tag < QuadCurve2D.INSIDE ? y : y + h)) / dy, x, x + w);
                            }
                            if (y2tag === QuadCurve2D.INSIDE) {
                                c2tag = x2tag;
                            }
                            else {
                                c2tag = QuadCurve2D.getTag((k + dx * (y2tag < QuadCurve2D.INSIDE ? y : y + h)) / dy, x, x + w);
                            }
                            if (c1tag * c2tag <= 0) {
                                return true;
                            }
                            c1tag = ((c1tag * x1tag <= 0) ? y1tag : y2tag);
                            QuadCurve2D.fillEqn(eqn, (c2tag < QuadCurve2D.INSIDE ? x : x + w), x1, ctrlx, x2);
                            var num = QuadCurve2D.solveQuadratic(eqn, res);
                            QuadCurve2D.evalQuadratic(res, num, true, true, null, y1, ctrly, y2);
                            c2tag = QuadCurve2D.getTag(res[0], y, y + h);
                            return (c1tag * c2tag <= 0);
                        })();
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                QuadCurve2D.prototype.intersects$java_awt_geom_Rectangle2D = function (r) {
                    return this.intersects(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                QuadCurve2D.prototype.contains = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (w <= 0 || h <= 0) {
                                return false;
                            }
                            return (_this.contains(x, y) && _this.contains(x + w, y) && _this.contains(x + w, y + h) && _this.contains(x, y + h));
                        })();
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                QuadCurve2D.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
                    return this.contains(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                QuadCurve2D.prototype.getBounds = function () {
                    return this.getBounds2D().getBounds();
                };
                /**
                 * Returns an iteration object that defines the boundary of the shape of
                 * this <code>QuadCurve2D</code>. The iterator for this class is not
                 * multi-threaded safe, which means that this <code>QuadCurve2D</code> class
                 * does not guarantee that modifications to the geometry of this
                 * <code>QuadCurve2D</code> object do not affect any iterations of that
                 * geometry that are already in process.
                 *
                 * @param at
                 * an optional {@link AffineTransform} to apply to the shape
                 * boundary
                 * @return a {@link PathIterator} object that defines the boundary of the
                 * shape.
                 * @since 1.2
                 */
                QuadCurve2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                    return new java.awt.geom.QuadIterator(this, at);
                };
                /**
                 * Returns an iteration object that defines the boundary of the flattened
                 * shape of this <code>QuadCurve2D</code>. The iterator for this class is
                 * not multi-threaded safe, which means that this <code>QuadCurve2D</code>
                 * class does not guarantee that modifications to the geometry of this
                 * <code>QuadCurve2D</code> object do not affect any iterations of that
                 * geometry that are already in process.
                 *
                 * @param at
                 * an optional <code>AffineTransform</code> to apply to the
                 * boundary of the shape
                 * @param flatness
                 * the maximum distance that the control points for a subdivided
                 * curve can be with respect to a line connecting the end points
                 * of this curve before this curve is replaced by a straight line
                 * connecting the end points.
                 * @return a <code>PathIterator</code> object that defines the flattened
                 * boundary of the shape.
                 * @since 1.2
                 */
                QuadCurve2D.prototype.getPathIterator = function (at, flatness) {
                    var _this = this;
                    if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            return new java.awt.geom.FlatteningPathIterator(_this.getPathIterator(at), flatness);
                        })();
                    }
                    else if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && flatness === undefined) {
                        return this.getPathIterator$java_awt_geom_AffineTransform(at);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Creates a new object of the same class and with the same contents as this
                 * object.
                 *
                 * @return a clone of this instance.
                 * @exception OutOfMemoryError
                 * if there is not enough memory.
                 * @see java.lang.Cloneable
                 * @since 1.2
                 */
                QuadCurve2D.prototype.clone = function () {
                    try {
                        return javaemul.internal.ObjectHelper.clone(this);
                    }
                    catch (e) {
                        throw new java.lang.InternalError(e);
                    }
                    ;
                };
                QuadCurve2D.BELOW = -2;
                QuadCurve2D.LOWEDGE = -1;
                QuadCurve2D.INSIDE = 0;
                QuadCurve2D.HIGHEDGE = 1;
                QuadCurve2D.ABOVE = 2;
                return QuadCurve2D;
            }());
            geom.QuadCurve2D = QuadCurve2D;
            QuadCurve2D["__class"] = "java.awt.geom.QuadCurve2D";
            QuadCurve2D["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
            var QuadCurve2D;
            (function (QuadCurve2D) {
                /**
                 * A quadratic parametric curve segment specified with {@code float}
                 * coordinates.
                 *
                 * @since 1.2
                 */
                var Float = (function (_super) {
                    __extends(Float, _super);
                    /**
                     * Constructs and initializes a <code>QuadCurve2D</code> from the
                     * specified {@code float} coordinates.
                     *
                     * @param x1
                     * the X coordinate of the start point
                     * @param y1
                     * the Y coordinate of the start point
                     * @param ctrlx
                     * the X coordinate of the control point
                     * @param ctrly
                     * the Y coordinate of the control point
                     * @param x2
                     * the X coordinate of the end point
                     * @param y2
                     * the Y coordinate of the end point
                     * @since 1.2
                     */
                    function Float(x1, y1, ctrlx, ctrly, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x1 = 0;
                            this.y1 = 0;
                            this.ctrlx = 0;
                            this.ctrly = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                            (function () {
                                _this.setCurve(x1, y1, ctrlx, ctrly, x2, y2);
                            })();
                        }
                        else if (x1 === undefined && y1 === undefined && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x1 = 0;
                            this.y1 = 0;
                            this.ctrlx = 0;
                            this.ctrly = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getX1 = function () {
                        return this.x1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getY1 = function () {
                        return this.y1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getP1 = function () {
                        return new java.awt.geom.Point2D.Float(this.x1, this.y1);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getCtrlX = function () {
                        return this.ctrlx;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getCtrlY = function () {
                        return this.ctrly;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getCtrlPt = function () {
                        return new java.awt.geom.Point2D.Float(this.ctrlx, this.ctrly);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getX2 = function () {
                        return this.x2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getY2 = function () {
                        return this.y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getP2 = function () {
                        return new java.awt.geom.Point2D.Float(this.x2, this.y2);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.setCurve$double$double$double$double$double$double = function (x1, y1, ctrlx, ctrly, x2, y2) {
                        this.x1 = x1;
                        this.y1 = y1;
                        this.ctrlx = ctrlx;
                        this.ctrly = ctrly;
                        this.x2 = x2;
                        this.y2 = y2;
                    };
                    /**
                     * Sets the location of the end points and control point of this curve
                     * to the specified {@code float} coordinates.
                     *
                     * @param x1
                     * the X coordinate of the start point
                     * @param y1
                     * the Y coordinate of the start point
                     * @param ctrlx
                     * the X coordinate of the control point
                     * @param ctrly
                     * the Y coordinate of the control point
                     * @param x2
                     * the X coordinate of the end point
                     * @param y2
                     * the Y coordinate of the end point
                     * @since 1.2
                     */
                    Float.prototype.setCurve = function (x1, y1, ctrlx, ctrly, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            return (function () {
                                _this.x1 = x1;
                                _this.y1 = y1;
                                _this.ctrlx = ctrlx;
                                _this.ctrly = ctrly;
                                _this.x2 = x2;
                                _this.y2 = y2;
                            })();
                        }
                        else if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.setCurve$double$double$double$double$double$double(x1, y1, ctrlx, ctrly, x2, y2);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && ((ctrlx != null && ctrlx instanceof java.awt.geom.Point2D) || ctrlx === null) && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1, ctrlx);
                        }
                        else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$double_A$int(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_Point2D_A$int(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.QuadCurve2D) || x1 === null) && y1 === undefined && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_QuadCurve2D(x1);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getBounds2D = function () {
                        var left = Math.min(Math.min(this.x1, this.x2), this.ctrlx);
                        var top = Math.min(Math.min(this.y1, this.y2), this.ctrly);
                        var right = Math.max(Math.max(this.x1, this.x2), this.ctrlx);
                        var bottom = Math.max(Math.max(this.y1, this.y2), this.ctrly);
                        return new java.awt.geom.Rectangle2D.Float(left, top, right - left, bottom - top);
                    };
                    Float.serialVersionUID = -8511188402130719609;
                    return Float;
                }(java.awt.geom.QuadCurve2D));
                QuadCurve2D.Float = Float;
                Float["__class"] = "java.awt.geom.QuadCurve2D.Float";
                Float["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
                /**
                 * A quadratic parametric curve segment specified with {@code double}
                 * coordinates.
                 *
                 * @since 1.2
                 */
                var Double = (function (_super) {
                    __extends(Double, _super);
                    /**
                     * Constructs and initializes a <code>QuadCurve2D</code> from the
                     * specified {@code double} coordinates.
                     *
                     * @param x1
                     * the X coordinate of the start point
                     * @param y1
                     * the Y coordinate of the start point
                     * @param ctrlx
                     * the X coordinate of the control point
                     * @param ctrly
                     * the Y coordinate of the control point
                     * @param x2
                     * the X coordinate of the end point
                     * @param y2
                     * the Y coordinate of the end point
                     * @since 1.2
                     */
                    function Double(x1, y1, ctrlx, ctrly, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x1 = 0;
                            this.y1 = 0;
                            this.ctrlx = 0;
                            this.ctrly = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                            (function () {
                                _this.setCurve(x1, y1, ctrlx, ctrly, x2, y2);
                            })();
                        }
                        else if (x1 === undefined && y1 === undefined && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x1 = 0;
                            this.y1 = 0;
                            this.ctrlx = 0;
                            this.ctrly = 0;
                            this.x2 = 0;
                            this.y2 = 0;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getX1 = function () {
                        return this.x1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getY1 = function () {
                        return this.y1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getP1 = function () {
                        return new java.awt.geom.Point2D.Double(this.x1, this.y1);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getCtrlX = function () {
                        return this.ctrlx;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getCtrlY = function () {
                        return this.ctrly;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getCtrlPt = function () {
                        return new java.awt.geom.Point2D.Double(this.ctrlx, this.ctrly);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getX2 = function () {
                        return this.x2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getY2 = function () {
                        return this.y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getP2 = function () {
                        return new java.awt.geom.Point2D.Double(this.x2, this.y2);
                    };
                    /**
                     * Sets the location of the end points and control point of this curve
                     * to the specified {@code float} coordinates.
                     *
                     * @param x1
                     * the X coordinate of the start point
                     * @param y1
                     * the Y coordinate of the start point
                     * @param ctrlx
                     * the X coordinate of the control point
                     * @param ctrly
                     * the Y coordinate of the control point
                     * @param x2
                     * the X coordinate of the end point
                     * @param y2
                     * the Y coordinate of the end point
                     * @since 1.2
                     */
                    Double.prototype.setCurve = function (x1, y1, ctrlx, ctrly, x2, y2) {
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.setCurve$double$double$double$double$double$double(x1, y1, ctrlx, ctrly, x2, y2);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && ((ctrlx != null && ctrlx instanceof java.awt.geom.Point2D) || ctrlx === null) && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1, ctrlx);
                        }
                        else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$double_A$int(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof Array) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_Point2D_A$int(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.QuadCurve2D) || x1 === null) && y1 === undefined && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_QuadCurve2D(x1);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.setCurve$double$double$double$double$double$double = function (x1, y1, ctrlx, ctrly, x2, y2) {
                        this.x1 = x1;
                        this.y1 = y1;
                        this.ctrlx = ctrlx;
                        this.ctrly = ctrly;
                        this.x2 = x2;
                        this.y2 = y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getBounds2D = function () {
                        var left = Math.min(Math.min(this.x1, this.x2), this.ctrlx);
                        var top = Math.min(Math.min(this.y1, this.y2), this.ctrly);
                        var right = Math.max(Math.max(this.x1, this.x2), this.ctrlx);
                        var bottom = Math.max(Math.max(this.y1, this.y2), this.ctrly);
                        return new java.awt.geom.Rectangle2D.Double(left, top, right - left, bottom - top);
                    };
                    Double.serialVersionUID = 4217149928428559721;
                    return Double;
                }(java.awt.geom.QuadCurve2D));
                QuadCurve2D.Double = Double;
                Double["__class"] = "java.awt.geom.QuadCurve2D.Double";
                Double["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
            })(QuadCurve2D = geom.QuadCurve2D || (geom.QuadCurve2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * A utility class to iterate over the path segments of a quadratic curve
             * segment through the PathIterator interface.
             *
             * @author Jim Graham
             */
            var QuadIterator = (function () {
                function QuadIterator(q, at) {
                    this.index = 0;
                    this.quad = q;
                    this.affine = at;
                }
                /**
                 * Return the winding rule for determining the insideness of the path.
                 *
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 */
                QuadIterator.prototype.getWindingRule = function () {
                    return java.awt.geom.PathIterator.WIND_NON_ZERO;
                };
                /**
                 * Tests if there are more points to read.
                 *
                 * @return true if there are more points to read
                 */
                QuadIterator.prototype.isDone = function () {
                    return (this.index > 1);
                };
                QuadIterator.prototype.next = function (doNext) {
                    if (doNext === undefined) {
                        return this.next$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Moves the iterator to the next segment of the path forwards along the
                 * primary direction of traversal as long as there are more points in that
                 * direction.
                 */
                QuadIterator.prototype.next$ = function () {
                    this.index++;
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of float x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                QuadIterator.prototype.currentSegment = function (coords) {
                    var _this = this;
                    if (((coords != null && coords instanceof Array) || coords === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (_this.isDone()) {
                                throw new java.util.NoSuchElementException("quad iterator iterator out of bounds");
                            }
                            var type;
                            if (_this.index === 0) {
                                coords[0] = _this.quad.getX1();
                                coords[1] = _this.quad.getY1();
                                type = java.awt.geom.PathIterator.SEG_MOVETO;
                            }
                            else {
                                coords[0] = _this.quad.getCtrlX();
                                coords[1] = _this.quad.getCtrlY();
                                coords[2] = _this.quad.getX2();
                                coords[3] = _this.quad.getY2();
                                type = java.awt.geom.PathIterator.SEG_QUADTO;
                            }
                            if (_this.affine != null) {
                                _this.affine.transform(coords, 0, coords, 0, _this.index === 0 ? 1 : 2);
                            }
                            return type;
                        })();
                    }
                    else if (((coords != null && coords instanceof Array) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A double array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of double x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                QuadIterator.prototype.currentSegment$double_A = function (coords) {
                    if (this.isDone()) {
                        throw new java.util.NoSuchElementException("quad iterator iterator out of bounds");
                    }
                    var type;
                    if (this.index === 0) {
                        coords[0] = this.quad.getX1();
                        coords[1] = this.quad.getY1();
                        type = java.awt.geom.PathIterator.SEG_MOVETO;
                    }
                    else {
                        coords[0] = this.quad.getCtrlX();
                        coords[1] = this.quad.getCtrlY();
                        coords[2] = this.quad.getX2();
                        coords[3] = this.quad.getY2();
                        type = java.awt.geom.PathIterator.SEG_QUADTO;
                    }
                    if (this.affine != null) {
                        this.affine.transform(coords, 0, coords, 0, this.index === 0 ? 1 : 2);
                    }
                    return type;
                };
                return QuadIterator;
            }());
            geom.QuadIterator = QuadIterator;
            QuadIterator["__class"] = "java.awt.geom.QuadIterator";
            QuadIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * <code>RectangularShape</code> is the base class for a number of {@link Shape}
             * objects whose geometry is defined by a rectangular frame. This class does not
             * directly specify any specific geometry by itself, but merely provides
             * manipulation methods inherited by a whole category of <code>Shape</code>
             * objects. The manipulation methods provided by this class can be used to query
             * and modify the rectangular frame, which provides a reference for the
             * subclasses to define their geometry.
             *
             * @author Jim Graham
             * @since 1.2
             */
            var RectangularShape = (function () {
                /**
                 * This is an abstract class that cannot be instantiated directly.
                 *
                 * @see Arc2D
                 * @see Ellipse2D
                 * @see Rectangle2D
                 * @see RoundRectangle2D
                 * @since 1.2
                 */
                function RectangularShape() {
                }
                /**
                 * Returns the smallest X coordinate of the framing rectangle of the
                 * <code>Shape</code> in <code>double</code> precision.
                 *
                 * @return the smallest X coordinate of the framing rectangle of the
                 * <code>Shape</code>.
                 * @since 1.2
                 */
                RectangularShape.prototype.getMinX = function () {
                    return this.getX();
                };
                /**
                 * Returns the smallest Y coordinate of the framing rectangle of the
                 * <code>Shape</code> in <code>double</code> precision.
                 *
                 * @return the smallest Y coordinate of the framing rectangle of the
                 * <code>Shape</code>.
                 * @since 1.2
                 */
                RectangularShape.prototype.getMinY = function () {
                    return this.getY();
                };
                /**
                 * Returns the largest X coordinate of the framing rectangle of the
                 * <code>Shape</code> in <code>double</code> precision.
                 *
                 * @return the largest X coordinate of the framing rectangle of the
                 * <code>Shape</code>.
                 * @since 1.2
                 */
                RectangularShape.prototype.getMaxX = function () {
                    return this.getX() + this.getWidth();
                };
                /**
                 * Returns the largest Y coordinate of the framing rectangle of the
                 * <code>Shape</code> in <code>double</code> precision.
                 *
                 * @return the largest Y coordinate of the framing rectangle of the
                 * <code>Shape</code>.
                 * @since 1.2
                 */
                RectangularShape.prototype.getMaxY = function () {
                    return this.getY() + this.getHeight();
                };
                /**
                 * Returns the X coordinate of the center of the framing rectangle of the
                 * <code>Shape</code> in <code>double</code> precision.
                 *
                 * @return the X coordinate of the center of the framing rectangle of the
                 * <code>Shape</code>.
                 * @since 1.2
                 */
                RectangularShape.prototype.getCenterX = function () {
                    return this.getX() + this.getWidth() / 2.0;
                };
                /**
                 * Returns the Y coordinate of the center of the framing rectangle of the
                 * <code>Shape</code> in <code>double</code> precision.
                 *
                 * @return the Y coordinate of the center of the framing rectangle of the
                 * <code>Shape</code>.
                 * @since 1.2
                 */
                RectangularShape.prototype.getCenterY = function () {
                    return this.getY() + this.getHeight() / 2.0;
                };
                /**
                 * Returns the framing {@link Rectangle2D} that defines the overall shape of
                 * this object.
                 *
                 * @return a <code>Rectangle2D</code>, specified in <code>double</code>
                 * coordinates.
                 * @see #setFrame(double, double, double, double)
                 * @see #setFrame(Point2D, Dimension2D)
                 * @see #setFrame(Rectangle2D)
                 * @since 1.2
                 */
                RectangularShape.prototype.getFrame = function () {
                    return new java.awt.geom.Rectangle2D.Double(this.getX(), this.getY(), this.getWidth(), this.getHeight());
                };
                RectangularShape.prototype.setFrame = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.setFrame$double$double$double$double(x, y, w, h);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && w === undefined && h === undefined) {
                        return this.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.setFrame$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the location and size of the framing rectangle of this
                 * <code>Shape</code> to the specified rectangular values.
                 *
                 * @param x
                 * the X coordinate of the upper-left corner of the specified
                 * rectangular shape
                 * @param y
                 * the Y coordinate of the upper-left corner of the specified
                 * rectangular shape
                 * @param w
                 * the width of the specified rectangular shape
                 * @param h
                 * the height of the specified rectangular shape
                 * @see #getFrame
                 * @since 1.2
                 */
                RectangularShape.prototype.setFrame$double$double$double$double = function (x, y, w, h) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets the location and size of the framing rectangle of this
                 * <code>Shape</code> to the specified {@link Point2D} and
                 * {@link Dimension2D}, respectively. The framing rectangle is used by the
                 * subclasses of <code>RectangularShape</code> to define their geometry.
                 *
                 * @param loc
                 * the specified <code>Point2D</code>
                 * @param size
                 * the specified <code>Dimension2D</code>
                 * @see #getFrame
                 * @since 1.2
                 */
                RectangularShape.prototype.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D = function (loc, size) {
                    this.setFrame(loc.getX(), loc.getY(), size.getWidth(), size.getHeight());
                };
                /**
                 * Sets the framing rectangle of this <code>Shape</code> to be the specified
                 * <code>Rectangle2D</code>. The framing rectangle is used by the subclasses
                 * of <code>RectangularShape</code> to define their geometry.
                 *
                 * @param r
                 * the specified <code>Rectangle2D</code>
                 * @see #getFrame
                 * @since 1.2
                 */
                RectangularShape.prototype.setFrame$java_awt_geom_Rectangle2D = function (r) {
                    this.setFrame(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * Sets the diagonal of the framing rectangle of this <code>Shape</code>
                 * based on the two specified coordinates. The framing rectangle is used by
                 * the subclasses of <code>RectangularShape</code> to define their geometry.
                 *
                 * @param x1
                 * the X coordinate of the start point of the specified diagonal
                 * @param y1
                 * the Y coordinate of the start point of the specified diagonal
                 * @param x2
                 * the X coordinate of the end point of the specified diagonal
                 * @param y2
                 * the Y coordinate of the end point of the specified diagonal
                 * @since 1.2
                 */
                RectangularShape.prototype.setFrameFromDiagonal = function (x1, y1, x2, y2) {
                    var _this = this;
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (x2 < x1) {
                                var t = x1;
                                x1 = x2;
                                x2 = t;
                            }
                            if (y2 < y1) {
                                var t = y1;
                                y1 = y2;
                                y2 = t;
                            }
                            _this.setFrame(x1, y1, x2 - x1, y2 - y1);
                        })();
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
                        return this.setFrameFromDiagonal$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the diagonal of the framing rectangle of this <code>Shape</code>
                 * based on two specified <code>Point2D</code> objects. The framing
                 * rectangle is used by the subclasses of <code>RectangularShape</code> to
                 * define their geometry.
                 *
                 * @param p1
                 * the start <code>Point2D</code> of the specified diagonal
                 * @param p2
                 * the end <code>Point2D</code> of the specified diagonal
                 * @since 1.2
                 */
                RectangularShape.prototype.setFrameFromDiagonal$java_awt_geom_Point2D$java_awt_geom_Point2D = function (p1, p2) {
                    this.setFrameFromDiagonal(p1.getX(), p1.getY(), p2.getX(), p2.getY());
                };
                /**
                 * Sets the framing rectangle of this <code>Shape</code> based on the
                 * specified center point coordinates and corner point coordinates. The
                 * framing rectangle is used by the subclasses of
                 * <code>RectangularShape</code> to define their geometry.
                 *
                 * @param centerX
                 * the X coordinate of the specified center point
                 * @param centerY
                 * the Y coordinate of the specified center point
                 * @param cornerX
                 * the X coordinate of the specified corner point
                 * @param cornerY
                 * the Y coordinate of the specified corner point
                 * @since 1.2
                 */
                RectangularShape.prototype.setFrameFromCenter = function (centerX, centerY, cornerX, cornerY) {
                    var _this = this;
                    if (((typeof centerX === 'number') || centerX === null) && ((typeof centerY === 'number') || centerY === null) && ((typeof cornerX === 'number') || cornerX === null) && ((typeof cornerY === 'number') || cornerY === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            var halfW = Math.abs(cornerX - centerX);
                            var halfH = Math.abs(cornerY - centerY);
                            _this.setFrame(centerX - halfW, centerY - halfH, halfW * 2.0, halfH * 2.0);
                        })();
                    }
                    else if (((centerX != null && centerX instanceof java.awt.geom.Point2D) || centerX === null) && ((centerY != null && centerY instanceof java.awt.geom.Point2D) || centerY === null) && cornerX === undefined && cornerY === undefined) {
                        return this.setFrameFromCenter$java_awt_geom_Point2D$java_awt_geom_Point2D(centerX, centerY);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the framing rectangle of this <code>Shape</code> based on a
                 * specified center <code>Point2D</code> and corner <code>Point2D</code>.
                 * The framing rectangle is used by the subclasses of
                 * <code>RectangularShape</code> to define their geometry.
                 *
                 * @param center
                 * the specified center <code>Point2D</code>
                 * @param corner
                 * the specified corner <code>Point2D</code>
                 * @since 1.2
                 */
                RectangularShape.prototype.setFrameFromCenter$java_awt_geom_Point2D$java_awt_geom_Point2D = function (center, corner) {
                    this.setFrameFromCenter(center.getX(), center.getY(), corner.getX(), corner.getY());
                };
                RectangularShape.prototype.contains = function (x, y, w, h, origrect) {
                    if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                RectangularShape.prototype.contains$java_awt_geom_Point2D = function (p) {
                    return this.contains(p.getX(), p.getY());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                RectangularShape.prototype.intersects$java_awt_geom_Rectangle2D = function (r) {
                    return this.intersects(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                RectangularShape.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
                    return this.contains(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                RectangularShape.prototype.getBounds = function () {
                    var width = this.getWidth();
                    var height = this.getHeight();
                    if (width < 0 || height < 0) {
                        return new java.awt.Rectangle();
                    }
                    var x = this.getX();
                    var y = this.getY();
                    var x1 = Math.floor(x);
                    var y1 = Math.floor(y);
                    var x2 = Math.ceil(x + width);
                    var y2 = Math.ceil(y + height);
                    return new java.awt.Rectangle((x1 | 0), (y1 | 0), ((x2 - x1) | 0), ((y2 - y1) | 0));
                };
                /**
                 * Returns an iterator object that iterates along the <code>Shape</code>
                 * object's boundary and provides access to a flattened view of the outline
                 * of the <code>Shape</code> object's geometry.
                 * <p>
                 * Only SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types will be returned
                 * by the iterator.
                 * <p>
                 * The amount of subdivision of the curved segments is controlled by the
                 * <code>flatness</code> parameter, which specifies the maximum distance
                 * that any point on the unflattened transformed curve can deviate from the
                 * returned flattened path segments. An optional {@link AffineTransform} can
                 * be specified so that the coordinates returned in the iteration are
                 * transformed accordingly.
                 *
                 * @param at
                 * an optional <code>AffineTransform</code> to be applied to the
                 * coordinates as they are returned in the iteration, or
                 * <code>null</code> if untransformed coordinates are desired.
                 * @param flatness
                 * the maximum distance that the line segments used to
                 * approximate the curved segments are allowed to deviate from
                 * any point on the original curve
                 * @return a <code>PathIterator</code> object that provides access to the
                 * <code>Shape</code> object's flattened geometry.
                 * @since 1.2
                 */
                RectangularShape.prototype.getPathIterator = function (at, flatness) {
                    var _this = this;
                    if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            return new java.awt.geom.FlatteningPathIterator(_this.getPathIterator(at), flatness);
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Creates a new object of the same class and with the same contents as this
                 * object.
                 *
                 * @return a clone of this instance.
                 * @exception OutOfMemoryError
                 * if there is not enough memory.
                 * @see java.lang.Cloneable
                 * @since 1.2
                 */
                RectangularShape.prototype.clone = function () {
                    try {
                        return javaemul.internal.ObjectHelper.clone(this);
                    }
                    catch (e) {
                        throw new java.lang.InternalError(e);
                    }
                    ;
                };
                return RectangularShape;
            }());
            geom.RectangularShape = RectangularShape;
            RectangularShape["__class"] = "java.awt.geom.RectangularShape";
            RectangularShape["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * A utility class to iterate over the path segments of a rectangle through the
             * PathIterator interface.
             *
             * @author Jim Graham
             */
            var RectIterator = (function () {
                function RectIterator(r, at) {
                    this.x = 0;
                    this.y = 0;
                    this.w = 0;
                    this.h = 0;
                    this.index = 0;
                    this.x = r.getX();
                    this.y = r.getY();
                    this.w = r.getWidth();
                    this.h = r.getHeight();
                    this.affine = at;
                    if (this.w < 0 || this.h < 0) {
                        this.index = 6;
                    }
                }
                /**
                 * Return the winding rule for determining the insideness of the path.
                 *
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 */
                RectIterator.prototype.getWindingRule = function () {
                    return java.awt.geom.PathIterator.WIND_NON_ZERO;
                };
                /**
                 * Tests if there are more points to read.
                 *
                 * @return true if there are more points to read
                 */
                RectIterator.prototype.isDone = function () {
                    return this.index > 5;
                };
                RectIterator.prototype.next = function (doNext) {
                    if (doNext === undefined) {
                        return this.next$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Moves the iterator to the next segment of the path forwards along the
                 * primary direction of traversal as long as there are more points in that
                 * direction.
                 */
                RectIterator.prototype.next$ = function () {
                    this.index++;
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of float x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                RectIterator.prototype.currentSegment = function (coords) {
                    var _this = this;
                    if (((coords != null && coords instanceof Array) || coords === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (_this.isDone()) {
                                throw new java.util.NoSuchElementException("rect iterator out of bounds");
                            }
                            if (_this.index === 5) {
                                return java.awt.geom.PathIterator.SEG_CLOSE;
                            }
                            coords[0] = _this.x;
                            coords[1] = _this.y;
                            if (_this.index === 1 || _this.index === 2) {
                                coords[0] += _this.w;
                            }
                            if (_this.index === 2 || _this.index === 3) {
                                coords[1] += _this.h;
                            }
                            if (_this.affine != null) {
                                _this.affine.transform(coords, 0, coords, 0, 1);
                            }
                            return (_this.index === 0 ? java.awt.geom.PathIterator.SEG_MOVETO : java.awt.geom.PathIterator.SEG_LINETO);
                        })();
                    }
                    else if (((coords != null && coords instanceof Array) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A double array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of double x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                RectIterator.prototype.currentSegment$double_A = function (coords) {
                    if (this.isDone()) {
                        throw new java.util.NoSuchElementException("rect iterator out of bounds");
                    }
                    if (this.index === 5) {
                        return java.awt.geom.PathIterator.SEG_CLOSE;
                    }
                    coords[0] = this.x;
                    coords[1] = this.y;
                    if (this.index === 1 || this.index === 2) {
                        coords[0] += this.w;
                    }
                    if (this.index === 2 || this.index === 3) {
                        coords[1] += this.h;
                    }
                    if (this.affine != null) {
                        this.affine.transform(coords, 0, coords, 0, 1);
                    }
                    return (this.index === 0 ? java.awt.geom.PathIterator.SEG_MOVETO : java.awt.geom.PathIterator.SEG_LINETO);
                };
                return RectIterator;
            }());
            geom.RectIterator = RectIterator;
            RectIterator["__class"] = "java.awt.geom.RectIterator";
            RectIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * A utility class to iterate over the path segments of an rounded rectangle
             * through the PathIterator interface.
             *
             * @author Jim Graham
             */
            var RoundRectIterator = (function () {
                function RoundRectIterator(rr, at) {
                    this.x = 0;
                    this.y = 0;
                    this.w = 0;
                    this.h = 0;
                    this.aw = 0;
                    this.ah = 0;
                    this.index = 0;
                    this.x = rr.getX();
                    this.y = rr.getY();
                    this.w = rr.getWidth();
                    this.h = rr.getHeight();
                    this.aw = Math.min(this.w, Math.abs(rr.getArcWidth()));
                    this.ah = Math.min(this.h, Math.abs(rr.getArcHeight()));
                    this.affine = at;
                    if (this.aw < 0 || this.ah < 0) {
                        this.index = RoundRectIterator.ctrlpts_$LI$().length;
                    }
                }
                /**
                 * Return the winding rule for determining the insideness of the path.
                 *
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 */
                RoundRectIterator.prototype.getWindingRule = function () {
                    return java.awt.geom.PathIterator.WIND_NON_ZERO;
                };
                /**
                 * Tests if there are more points to read.
                 *
                 * @return true if there are more points to read
                 */
                RoundRectIterator.prototype.isDone = function () {
                    return this.index >= RoundRectIterator.ctrlpts_$LI$().length;
                };
                RoundRectIterator.prototype.next = function (doNext) {
                    if (doNext === undefined) {
                        return this.next$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Moves the iterator to the next segment of the path forwards along the
                 * primary direction of traversal as long as there are more points in that
                 * direction.
                 */
                RoundRectIterator.prototype.next$ = function () {
                    this.index++;
                };
                RoundRectIterator.angle_$LI$ = function () { if (RoundRectIterator.angle == null)
                    RoundRectIterator.angle = Math.PI / 4.0; return RoundRectIterator.angle; };
                ;
                RoundRectIterator.a_$LI$ = function () { if (RoundRectIterator.a == null)
                    RoundRectIterator.a = 1.0 - Math.cos(RoundRectIterator.angle_$LI$()); return RoundRectIterator.a; };
                ;
                RoundRectIterator.b_$LI$ = function () { if (RoundRectIterator.b == null)
                    RoundRectIterator.b = Math.tan(RoundRectIterator.angle_$LI$()); return RoundRectIterator.b; };
                ;
                RoundRectIterator.c_$LI$ = function () { if (RoundRectIterator.c == null)
                    RoundRectIterator.c = Math.sqrt(1.0 + RoundRectIterator.b_$LI$() * RoundRectIterator.b_$LI$()) - 1 + RoundRectIterator.a_$LI$(); return RoundRectIterator.c; };
                ;
                RoundRectIterator.cv_$LI$ = function () { if (RoundRectIterator.cv == null)
                    RoundRectIterator.cv = 4.0 / 3.0 * RoundRectIterator.a_$LI$() * RoundRectIterator.b_$LI$() / RoundRectIterator.c_$LI$(); return RoundRectIterator.cv; };
                ;
                RoundRectIterator.acv_$LI$ = function () { if (RoundRectIterator.acv == null)
                    RoundRectIterator.acv = (1.0 - RoundRectIterator.cv_$LI$()) / 2.0; return RoundRectIterator.acv; };
                ;
                RoundRectIterator.ctrlpts_$LI$ = function () { if (RoundRectIterator.ctrlpts == null)
                    RoundRectIterator.ctrlpts = [[0.0, 0.0, 0.0, 0.5], [0.0, 0.0, 1.0, -0.5], [0.0, 0.0, 1.0, -RoundRectIterator.acv_$LI$(), 0.0, RoundRectIterator.acv_$LI$(), 1.0, 0.0, 0.0, 0.5, 1.0, 0.0], [1.0, -0.5, 1.0, 0.0], [1.0, -RoundRectIterator.acv_$LI$(), 1.0, 0.0, 1.0, 0.0, 1.0, -RoundRectIterator.acv_$LI$(), 1.0, 0.0, 1.0, -0.5], [1.0, 0.0, 0.0, 0.5], [1.0, 0.0, 0.0, RoundRectIterator.acv_$LI$(), 1.0, -RoundRectIterator.acv_$LI$(), 0.0, 0.0, 1.0, -0.5, 0.0, 0.0], [0.0, 0.5, 0.0, 0.0], [0.0, RoundRectIterator.acv_$LI$(), 0.0, 0.0, 0.0, 0.0, 0.0, RoundRectIterator.acv_$LI$(), 0.0, 0.0, 0.0, 0.5], []]; return RoundRectIterator.ctrlpts; };
                ;
                RoundRectIterator.types_$LI$ = function () { if (RoundRectIterator.types == null)
                    RoundRectIterator.types = [java.awt.geom.PathIterator.SEG_MOVETO, java.awt.geom.PathIterator.SEG_LINETO, java.awt.geom.PathIterator.SEG_CUBICTO, java.awt.geom.PathIterator.SEG_LINETO, java.awt.geom.PathIterator.SEG_CUBICTO, java.awt.geom.PathIterator.SEG_LINETO, java.awt.geom.PathIterator.SEG_CUBICTO, java.awt.geom.PathIterator.SEG_LINETO, java.awt.geom.PathIterator.SEG_CUBICTO, java.awt.geom.PathIterator.SEG_CLOSE]; return RoundRectIterator.types; };
                ;
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of float x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                RoundRectIterator.prototype.currentSegment = function (coords) {
                    var _this = this;
                    if (((coords != null && coords instanceof Array) || coords === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (_this.isDone()) {
                                throw new java.util.NoSuchElementException("roundrect iterator out of bounds");
                            }
                            var ctrls = RoundRectIterator.ctrlpts_$LI$()[_this.index];
                            var nc = 0;
                            for (var i = 0; i < ctrls.length; i += 4) {
                                coords[nc++] = (_this.x + ctrls[i + 0] * _this.w + ctrls[i + 1] * _this.aw);
                                coords[nc++] = (_this.y + ctrls[i + 2] * _this.h + ctrls[i + 3] * _this.ah);
                            }
                            if (_this.affine != null) {
                                _this.affine.transform(coords, 0, coords, 0, (nc / 2 | 0));
                            }
                            return RoundRectIterator.types_$LI$()[_this.index];
                        })();
                    }
                    else if (((coords != null && coords instanceof Array) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A double array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of double x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 */
                RoundRectIterator.prototype.currentSegment$double_A = function (coords) {
                    if (this.isDone()) {
                        throw new java.util.NoSuchElementException("roundrect iterator out of bounds");
                    }
                    var ctrls = RoundRectIterator.ctrlpts_$LI$()[this.index];
                    var nc = 0;
                    for (var i = 0; i < ctrls.length; i += 4) {
                        coords[nc++] = (this.x + ctrls[i + 0] * this.w + ctrls[i + 1] * this.aw);
                        coords[nc++] = (this.y + ctrls[i + 2] * this.h + ctrls[i + 3] * this.ah);
                    }
                    if (this.affine != null) {
                        this.affine.transform(coords, 0, coords, 0, (nc / 2 | 0));
                    }
                    return RoundRectIterator.types_$LI$()[this.index];
                };
                return RoundRectIterator;
            }());
            geom.RoundRectIterator = RoundRectIterator;
            RoundRectIterator["__class"] = "java.awt.geom.RoundRectIterator";
            RoundRectIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var Graphics = (function () {
            function Graphics() {
            }
            Graphics.prototype.create$ = function () { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
            Graphics.prototype.create = function (x, y, width, height) {
                var _this = this;
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        var g = _this.create();
                        if (g == null)
                            return null;
                        g.translate(x, y);
                        g.clipRect(0, 0, width, height);
                        return g;
                    })();
                }
                else if (x === undefined && y === undefined && width === undefined && height === undefined) {
                    return this.create$();
                }
                else
                    throw new Error('invalid overload');
            };
            Graphics.prototype.getClipBounds$ = function () { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
            Graphics.prototype.setClip = function (x, y, width, height) {
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                }
                else if (((x != null && (x["__interfaces"] != null && x["__interfaces"].indexOf("java.awt.Shape") >= 0 || x.constructor != null && x.constructor["__interfaces"] != null && x.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || x === null) && y === undefined && width === undefined && height === undefined) {
                    return this.setClip$java_awt_Shape(x);
                }
                else
                    throw new Error('invalid overload');
            };
            Graphics.prototype.setClip$java_awt_Shape = function (clip) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
            Graphics.prototype.drawRect = function (x, y, width, height) {
                if ((width < 0) || (height < 0)) {
                    return;
                }
                if (height === 0 || width === 0) {
                    this.drawLine(x, y, x + width, y + height);
                }
                else {
                    this.drawLine(x, y, x + width - 1, y);
                    this.drawLine(x + width, y, x + width, y + height - 1);
                    this.drawLine(x + width, y + height, x + 1, y + height);
                    this.drawLine(x, y + height, x, y + 1);
                }
            };
            Graphics.prototype.draw3DRect = function (x, y, width, height, raised) {
                var c = this.getColor();
                var brighter = c.brighter();
                var darker = c.darker();
                this.setColor(raised ? brighter : darker);
                this.drawLine(x, y, x, y + height);
                this.drawLine(x + 1, y, x + width - 1, y);
                this.setColor(raised ? darker : brighter);
                this.drawLine(x + 1, y + height, x + width, y + height);
                this.drawLine(x + width, y, x + width, y + height - 1);
                this.setColor(c);
            };
            Graphics.prototype.fill3DRect = function (x, y, width, height, raised) {
                var c = this.getColor();
                var brighter = c.brighter();
                var darker = c.darker();
                if (!raised) {
                    this.setColor(darker);
                }
                this.fillRect(x + 1, y + 1, width - 2, height - 2);
                this.setColor(raised ? brighter : darker);
                this.drawLine(x, y, x, y + height - 1);
                this.drawLine(x + 1, y, x + width - 2, y);
                this.setColor(raised ? darker : brighter);
                this.drawLine(x + 1, y + height - 1, x + width - 1, y + height - 1);
                this.drawLine(x + width - 1, y, x + width - 1, y + height - 2);
                this.setColor(c);
            };
            Graphics.prototype.drawPolygon = function (xPoints, yPoints, nPoints) {
                if (((xPoints != null && xPoints instanceof Array) || xPoints === null) && ((yPoints != null && yPoints instanceof Array) || yPoints === null) && ((typeof nPoints === 'number') || nPoints === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                }
                else if (((xPoints != null && xPoints instanceof java.awt.Polygon) || xPoints === null) && yPoints === undefined && nPoints === undefined) {
                    return this.drawPolygon$java_awt_Polygon(xPoints);
                }
                else
                    throw new Error('invalid overload');
            };
            Graphics.prototype.drawPolygon$java_awt_Polygon = function (p) {
                this.drawPolygon(p.xpoints, p.ypoints, p.npoints);
            };
            Graphics.prototype.fillPolygon = function (xPoints, yPoints, nPoints) {
                if (((xPoints != null && xPoints instanceof Array) || xPoints === null) && ((yPoints != null && yPoints instanceof Array) || yPoints === null) && ((typeof nPoints === 'number') || nPoints === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                }
                else if (((xPoints != null && xPoints instanceof java.awt.Polygon) || xPoints === null) && yPoints === undefined && nPoints === undefined) {
                    return this.fillPolygon$java_awt_Polygon(xPoints);
                }
                else
                    throw new Error('invalid overload');
            };
            Graphics.prototype.fillPolygon$java_awt_Polygon = function (p) {
                this.fillPolygon(p.xpoints, p.ypoints, p.npoints);
            };
            Graphics.prototype.drawImage$java_awt_Image$int$int$java_awt_image_ImageObserver = function (img, x, y, observer) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
            Graphics.prototype.drawImage$java_awt_Image$int$int$int$int$java_awt_image_ImageObserver = function (img, x, y, width, height, observer) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
            Graphics.prototype.drawImage$java_awt_Image$int$int$java_awt_Color$java_awt_image_ImageObserver = function (img, x, y, bgcolor, observer) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
            Graphics.prototype.drawImage$java_awt_Image$int$int$int$int$java_awt_Color$java_awt_image_ImageObserver = function (img, x, y, width, height, bgcolor, observer) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
            Graphics.prototype.drawImage$java_awt_Image$int$int$int$int$int$int$int$int$java_awt_image_ImageObserver = function (img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, observer) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
            Graphics.prototype.drawImage = function (img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, bgcolor, observer) {
                if (((img != null && img instanceof java.awt.Image) || img === null) && ((typeof dx1 === 'number') || dx1 === null) && ((typeof dy1 === 'number') || dy1 === null) && ((typeof dx2 === 'number') || dx2 === null) && ((typeof dy2 === 'number') || dy2 === null) && ((typeof sx1 === 'number') || sx1 === null) && ((typeof sy1 === 'number') || sy1 === null) && ((typeof sx2 === 'number') || sx2 === null) && ((typeof sy2 === 'number') || sy2 === null) && ((bgcolor != null && bgcolor instanceof java.awt.Color) || bgcolor === null) && ((observer != null && (observer["__interfaces"] != null && observer["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0 || observer.constructor != null && observer.constructor["__interfaces"] != null && observer.constructor["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0)) || observer === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return false;
                }
                else if (((img != null && img instanceof java.awt.Image) || img === null) && ((typeof dx1 === 'number') || dx1 === null) && ((typeof dy1 === 'number') || dy1 === null) && ((typeof dx2 === 'number') || dx2 === null) && ((typeof dy2 === 'number') || dy2 === null) && ((typeof sx1 === 'number') || sx1 === null) && ((typeof sy1 === 'number') || sy1 === null) && ((typeof sx2 === 'number') || sx2 === null) && ((typeof sy2 === 'number') || sy2 === null) && ((bgcolor != null && (bgcolor["__interfaces"] != null && bgcolor["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0 || bgcolor.constructor != null && bgcolor.constructor["__interfaces"] != null && bgcolor.constructor["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0)) || bgcolor === null) && observer === undefined) {
                    return this.drawImage$java_awt_Image$int$int$int$int$int$int$int$int$java_awt_image_ImageObserver(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, bgcolor);
                }
                else if (((img != null && img instanceof java.awt.Image) || img === null) && ((typeof dx1 === 'number') || dx1 === null) && ((typeof dy1 === 'number') || dy1 === null) && ((typeof dx2 === 'number') || dx2 === null) && ((typeof dy2 === 'number') || dy2 === null) && ((sx1 != null && sx1 instanceof java.awt.Color) || sx1 === null) && ((sy1 != null && (sy1["__interfaces"] != null && sy1["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0 || sy1.constructor != null && sy1.constructor["__interfaces"] != null && sy1.constructor["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0)) || sy1 === null) && sx2 === undefined && sy2 === undefined && bgcolor === undefined && observer === undefined) {
                    return this.drawImage$java_awt_Image$int$int$int$int$java_awt_Color$java_awt_image_ImageObserver(img, dx1, dy1, dx2, dy2, sx1, sy1);
                }
                else if (((img != null && img instanceof java.awt.Image) || img === null) && ((typeof dx1 === 'number') || dx1 === null) && ((typeof dy1 === 'number') || dy1 === null) && ((typeof dx2 === 'number') || dx2 === null) && ((typeof dy2 === 'number') || dy2 === null) && ((sx1 != null && (sx1["__interfaces"] != null && sx1["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0 || sx1.constructor != null && sx1.constructor["__interfaces"] != null && sx1.constructor["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0)) || sx1 === null) && sy1 === undefined && sx2 === undefined && sy2 === undefined && bgcolor === undefined && observer === undefined) {
                    return this.drawImage$java_awt_Image$int$int$int$int$java_awt_image_ImageObserver(img, dx1, dy1, dx2, dy2, sx1);
                }
                else if (((img != null && img instanceof java.awt.Image) || img === null) && ((typeof dx1 === 'number') || dx1 === null) && ((typeof dy1 === 'number') || dy1 === null) && ((dx2 != null && dx2 instanceof java.awt.Color) || dx2 === null) && ((dy2 != null && (dy2["__interfaces"] != null && dy2["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0 || dy2.constructor != null && dy2.constructor["__interfaces"] != null && dy2.constructor["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0)) || dy2 === null) && sx1 === undefined && sy1 === undefined && sx2 === undefined && sy2 === undefined && bgcolor === undefined && observer === undefined) {
                    return this.drawImage$java_awt_Image$int$int$java_awt_Color$java_awt_image_ImageObserver(img, dx1, dy1, dx2, dy2);
                }
                else if (((img != null && img instanceof java.awt.Image) || img === null) && ((typeof dx1 === 'number') || dx1 === null) && ((typeof dy1 === 'number') || dy1 === null) && ((dx2 != null && (dx2["__interfaces"] != null && dx2["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0 || dx2.constructor != null && dx2.constructor["__interfaces"] != null && dx2.constructor["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0)) || dx2 === null) && dy2 === undefined && sx1 === undefined && sy1 === undefined && sx2 === undefined && sy2 === undefined && bgcolor === undefined && observer === undefined) {
                    return this.drawImage$java_awt_Image$int$int$java_awt_image_ImageObserver(img, dx1, dy1, dx2);
                }
                else
                    throw new Error('invalid overload');
            };
            Graphics.prototype.finalize = function () {
                this.dispose();
            };
            Graphics.prototype.toString = function () {
                return (function (c) { return c["__class"] ? c["__class"] : c.name; })(this.constructor) + "[font=" + this.getFont() + ",color=" + this.getColor() + "]";
            };
            Graphics.prototype.hitClip = function (x, y, width, height) {
                var clipRect = this.getClipBounds();
                if (clipRect == null) {
                    return true;
                }
                return clipRect.intersects(x, y, width, height);
            };
            Graphics.prototype.getClipBounds = function (r) {
                var _this = this;
                if (((r != null && r instanceof java.awt.Rectangle) || r === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        var clipRect = _this.getClipBounds();
                        if (clipRect != null) {
                            r.x = clipRect.x;
                            r.y = clipRect.y;
                            r.width = clipRect.width;
                            r.height = clipRect.height;
                        }
                        else if (r == null) {
                            throw new java.lang.NullPointerException("null rectangle parameter");
                        }
                        return r;
                    })();
                }
                else if (r === undefined) {
                    return this.getClipBounds$();
                }
                else
                    throw new Error('invalid overload');
            };
            return Graphics;
        }());
        awt.Graphics = Graphics;
        Graphics["__class"] = "java.awt.Graphics";
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var GridLayout = (function () {
            function GridLayout(rows, cols) {
                this.created = false;
                this.currentPosition = 0;
                this.cols = 0;
                this.rows = 0;
                this.rows = rows;
                this.cols = cols;
            }
            GridLayout.prototype.addLayoutComponent = function (name, component) {
                if (((typeof name === 'string') || name === null) && ((component != null && component instanceof java.awt.Component) || component === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            };
            GridLayout.prototype.removeLayoutComponent = function (component) {
            };
            GridLayout.prototype.layoutContainer = function (parent) {
                if (!this.created) {
                    this.parent = parent;
                    this.created = true;
                    var div = parent.getHTMLElement();
                    this.table = document.createElement("table");
                    this.table.style.width = "100%";
                    this.table.style.height = "100%";
                    this.table.style.left = "0px";
                    this.table.style.right = "0px";
                    this.table.style.zIndex = "0";
                    for (var j = 0; j < this.rows; j++) {
                        var row = document.createElement("tr");
                        this.table.appendChild(row);
                        for (var i = 0; i < this.cols; i++) {
                            var col = document.createElement("td");
                            row.appendChild(col);
                            col.style.width = "" + (((100 | 0) / this.cols | 0)) + "%";
                        }
                    }
                    div.appendChild(this.table);
                }
            };
            GridLayout.prototype.onComponentAdded = function (parent, component, position) {
                var pos = 0;
                for (var j = 0; j < this.rows; j++) {
                    var row = this.table.childNodes[j];
                    for (var i = 0; i < this.cols; i++) {
                        var col = row.childNodes[i];
                        if (pos++ === this.currentPosition) {
                            col.appendChild(component.getHTMLElement());
                            component.getHTMLElement().style.width = "100%";
                            component.getHTMLElement().style.height = "100%";
                            this.currentPosition++;
                            return;
                        }
                    }
                }
            };
            return GridLayout;
        }());
        awt.GridLayout = GridLayout;
        GridLayout["__class"] = "java.awt.GridLayout";
        GridLayout["__interfaces"] = ["java.awt.LayoutManager"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        /**
         * Signals that an AWT component is not in an appropriate state for
         * the requested operation.
         *
         * @author      Jonni Kanerva
         */
        var IllegalComponentStateException = (function (_super) {
            __extends(IllegalComponentStateException, _super);
            /**
             * Constructs an IllegalComponentStateException with the specified detail
             * message.  A detail message is a String that describes this particular
             * exception.
             * @param s the String that contains a detailed message
             */
            function IllegalComponentStateException(s) {
                if (((typeof s === 'string') || s === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this, s);
                }
                else if (s === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this);
                }
                else
                    throw new Error('invalid overload');
            }
            IllegalComponentStateException.serialVersionUID = -1889339587208144238;
            return IllegalComponentStateException;
        }(java.lang.IllegalStateException));
        awt.IllegalComponentStateException = IllegalComponentStateException;
        IllegalComponentStateException["__class"] = "java.awt.IllegalComponentStateException";
        IllegalComponentStateException["__interfaces"] = ["java.io.Serializable"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var image;
        (function (image) {
            var ImageObserver;
            (function (ImageObserver) {
                ImageObserver.WIDTH = 1;
                ImageObserver.HEIGHT = 2;
                ImageObserver.PROPERTIES = 4;
                ImageObserver.SOMEBITS = 8;
                ImageObserver.FRAMEBITS = 16;
                ImageObserver.ALLBITS = 32;
                ImageObserver.ERROR = 64;
                ImageObserver.ABORT = 128;
            })(ImageObserver = image.ImageObserver || (image.ImageObserver = {}));
        })(image = awt.image || (awt.image = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var Image = (function () {
            function Image(src) {
                this.source = document.createElement("img");
                this.source.src = src;
            }
            Image.prototype.getWidth = function (observer) {
                var _this = this;
                if (((observer != null && (observer["__interfaces"] != null && observer["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0 || observer.constructor != null && observer.constructor["__interfaces"] != null && observer.constructor["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0)) || observer === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        return (_this.source.width | 0);
                    })();
                }
                else
                    throw new Error('invalid overload');
            };
            Image.prototype.getHeight = function (observer) {
                var _this = this;
                if (((observer != null && (observer["__interfaces"] != null && observer["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0 || observer.constructor != null && observer.constructor["__interfaces"] != null && observer.constructor["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0)) || observer === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        return (_this.source.height | 0);
                    })();
                }
                else
                    throw new Error('invalid overload');
            };
            Image.prototype.flush = function () {
            };
            /**
             * Use the default image-scaling algorithm.
             *
             * @since JDK1.1
             */
            Image.SCALE_DEFAULT = 1;
            /**
             * Choose an image-scaling algorithm that gives higher priority to scaling
             * speed than smoothness of the scaled image.
             *
             * @since JDK1.1
             */
            Image.SCALE_FAST = 2;
            Image.SCALE_SMOOTH = 4;
            Image.SCALE_REPLICATE = 8;
            Image.SCALE_AREA_AVERAGING = 16;
            return Image;
        }());
        awt.Image = Image;
        Image["__class"] = "java.awt.Image";
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var Insets = (function () {
            function Insets(top, left, bottom, right) {
                this.top = 0;
                this.left = 0;
                this.bottom = 0;
                this.right = 0;
                this.top = top;
                this.left = left;
                this.bottom = bottom;
                this.right = right;
            }
            Insets.prototype.set = function (top, left, bottom, right) {
                this.top = top;
                this.left = left;
                this.bottom = bottom;
                this.right = right;
            };
            Insets.prototype.equals = function (obj) {
                if (obj != null && obj instanceof java.awt.Insets) {
                    var insets = obj;
                    return ((this.top === insets.top) && (this.left === insets.left) && (this.bottom === insets.bottom) && (this.right === insets.right));
                }
                return false;
            };
            Insets.prototype.hashCode = function () {
                var sum1 = this.left + this.bottom;
                var sum2 = this.right + this.top;
                var val1 = (sum1 * (sum1 + 1) / 2 | 0) + this.left;
                var val2 = (sum2 * (sum2 + 1) / 2 | 0) + this.top;
                var sum3 = val1 + val2;
                return (sum3 * (sum3 + 1) / 2 | 0) + val2;
            };
            Insets.prototype.toString = function () {
                return (function (c) { return c["__class"] ? c["__class"] : c.name; })(this.constructor) + "[top=" + this.top + ",left=" + this.left + ",bottom=" + this.bottom + ",right=" + this.right + "]";
            };
            Insets.prototype.clone = function () {
                try {
                    return javaemul.internal.ObjectHelper.clone(this);
                }
                catch (e) {
                    throw new java.lang.InternalError(e);
                }
                ;
            };
            Insets.serialVersionUID = -2272572637695466749;
            return Insets;
        }());
        awt.Insets = Insets;
        Insets["__class"] = "java.awt.Insets";
        Insets["__interfaces"] = ["java.lang.Cloneable", "java.io.Serializable"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var MenuComponent = (function () {
            function MenuComponent() {
            }
            MenuComponent.prototype.getName = function () {
                return this.name;
            };
            MenuComponent.prototype.setName = function (name) {
                this.name = name;
            };
            return MenuComponent;
        }());
        awt.MenuComponent = MenuComponent;
        MenuComponent["__class"] = "java.awt.MenuComponent";
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var NoLayout = (function () {
            function NoLayout() {
                this.created = false;
            }
            NoLayout.prototype.addLayoutComponent = function (name, component) {
                if (((typeof name === 'string') || name === null) && ((component != null && component instanceof java.awt.Component) || component === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                    })();
                }
                else
                    throw new Error('invalid overload');
            };
            NoLayout.prototype.removeLayoutComponent = function (component) {
            };
            NoLayout.prototype.layoutContainer = function (parent) {
            };
            NoLayout.prototype.onComponentAdded = function (parent, component, position) {
                var div = parent.getHTMLElement();
                div.appendChild(component.getHTMLElement());
                component.getHTMLElement().style.width = "100%";
                component.getHTMLElement().style.height = "100%";
            };
            return NoLayout;
        }());
        awt.NoLayout = NoLayout;
        NoLayout["__class"] = "java.awt.NoLayout";
        NoLayout["__interfaces"] = ["java.awt.LayoutManager"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var Polygon = (function () {
            function Polygon(xpoints, ypoints, npoints) {
                var _this = this;
                if (((xpoints != null && xpoints instanceof Array) || xpoints === null) && ((ypoints != null && ypoints instanceof Array) || ypoints === null) && ((typeof npoints === 'number') || npoints === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    this.npoints = 0;
                    (function () {
                        if (npoints > xpoints.length || npoints > ypoints.length) {
                            throw new java.lang.IndexOutOfBoundsException("npoints > xpoints.length || npoints > ypoints.length");
                        }
                        if (npoints < 0) {
                            throw new java.lang.NegativeArraySizeException("npoints < 0");
                        }
                        _this.npoints = npoints;
                        _this.xpoints = java.util.Arrays.copyOf(xpoints, npoints);
                        _this.ypoints = java.util.Arrays.copyOf(ypoints, npoints);
                    })();
                }
                else if (xpoints === undefined && ypoints === undefined && npoints === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    this.npoints = 0;
                    (function () {
                        _this.xpoints = new Array(Polygon.MIN_LENGTH);
                        _this.ypoints = new Array(Polygon.MIN_LENGTH);
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            Polygon.prototype.reset = function () {
                this.npoints = 0;
                this.bounds = null;
            };
            Polygon.prototype.invalidate = function () {
                this.bounds = null;
            };
            Polygon.prototype.translate = function (deltaX, deltaY) {
                for (var i = 0; i < this.npoints; i++) {
                    this.xpoints[i] += deltaX;
                    this.ypoints[i] += deltaY;
                }
                if (this.bounds != null) {
                    this.bounds.translate(deltaX, deltaY);
                }
            };
            Polygon.prototype.calculateBounds = function (xpoints, ypoints, npoints) {
                var boundsMinX = javaemul.internal.IntegerHelper.MAX_VALUE;
                var boundsMinY = javaemul.internal.IntegerHelper.MAX_VALUE;
                var boundsMaxX = javaemul.internal.IntegerHelper.MIN_VALUE;
                var boundsMaxY = javaemul.internal.IntegerHelper.MIN_VALUE;
                for (var i = 0; i < npoints; i++) {
                    var x = xpoints[i];
                    boundsMinX = Math.min(boundsMinX, x);
                    boundsMaxX = Math.max(boundsMaxX, x);
                    var y = ypoints[i];
                    boundsMinY = Math.min(boundsMinY, y);
                    boundsMaxY = Math.max(boundsMaxY, y);
                }
                this.bounds = new java.awt.Rectangle(boundsMinX, boundsMinY, boundsMaxX - boundsMinX, boundsMaxY - boundsMinY);
            };
            Polygon.prototype.updateBounds = function (x, y) {
                if (x < this.bounds.x) {
                    this.bounds.width = this.bounds.width + (this.bounds.x - x);
                    this.bounds.x = x;
                }
                else {
                    this.bounds.width = Math.max(this.bounds.width, x - this.bounds.x);
                }
                if (y < this.bounds.y) {
                    this.bounds.height = this.bounds.height + (this.bounds.y - y);
                    this.bounds.y = y;
                }
                else {
                    this.bounds.height = Math.max(this.bounds.height, y - this.bounds.y);
                }
            };
            Polygon.prototype.addPoint = function (x, y) {
                if (this.npoints >= this.xpoints.length || this.npoints >= this.ypoints.length) {
                    var newLength = this.npoints * 2;
                    if (newLength < Polygon.MIN_LENGTH) {
                        newLength = Polygon.MIN_LENGTH;
                    }
                    else if ((newLength & (newLength - 1)) !== 0) {
                        newLength = javaemul.internal.IntegerHelper.highestOneBit(newLength);
                    }
                    this.xpoints = java.util.Arrays.copyOf(this.xpoints, newLength);
                    this.ypoints = java.util.Arrays.copyOf(this.ypoints, newLength);
                }
                this.xpoints[this.npoints] = x;
                this.ypoints[this.npoints] = y;
                this.npoints++;
                if (this.bounds != null) {
                    this.updateBounds(x, y);
                }
            };
            Polygon.prototype.getBounds = function () {
                return this.getBoundingBox();
            };
            Polygon.prototype.getBoundingBox = function () {
                if (this.npoints === 0) {
                    return new java.awt.Rectangle();
                }
                if (this.bounds == null) {
                    this.calculateBounds(this.xpoints, this.ypoints, this.npoints);
                }
                return this.bounds.getBounds();
            };
            Polygon.prototype.contains$java_awt_Point = function (p) {
                return this.contains(p.x, p.y);
            };
            Polygon.prototype.contains$int$int = function (x, y) {
                return this.contains(x, y);
            };
            Polygon.prototype.inside = function (x, y) {
                return this.contains(x, y);
            };
            Polygon.prototype.getBounds2D = function () {
                return this.getBounds();
            };
            Polygon.prototype.contains$double$double = function (x, y) {
                if (this.npoints <= 2 || !this.getBoundingBox().contains(x, y)) {
                    return false;
                }
                var hits = 0;
                var lastx = this.xpoints[this.npoints - 1];
                var lasty = this.ypoints[this.npoints - 1];
                var curx;
                var cury;
                for (var i = 0; i < this.npoints; lastx = curx, lasty = cury, i++) {
                    curx = this.xpoints[i];
                    cury = this.ypoints[i];
                    if (cury === lasty) {
                        continue;
                    }
                    var leftx = void 0;
                    if (curx < lastx) {
                        if (x >= lastx) {
                            continue;
                        }
                        leftx = curx;
                    }
                    else {
                        if (x >= curx) {
                            continue;
                        }
                        leftx = lastx;
                    }
                    var test1 = void 0;
                    var test2 = void 0;
                    if (cury < lasty) {
                        if (y < cury || y >= lasty) {
                            continue;
                        }
                        if (x < leftx) {
                            hits++;
                            continue;
                        }
                        test1 = x - curx;
                        test2 = y - cury;
                    }
                    else {
                        if (y < lasty || y >= cury) {
                            continue;
                        }
                        if (x < leftx) {
                            hits++;
                            continue;
                        }
                        test1 = x - lastx;
                        test2 = y - lasty;
                    }
                    if (test1 < (test2 / (lasty - cury) * (lastx - curx))) {
                        hits++;
                    }
                }
                return ((hits & 1) !== 0);
            };
            Polygon.prototype.getCrossings = function (xlo, ylo, xhi, yhi) {
                var cross = new sun.awt.geom.Crossings.EvenOdd(xlo, ylo, xhi, yhi);
                var lastx = this.xpoints[this.npoints - 1];
                var lasty = this.ypoints[this.npoints - 1];
                var curx;
                var cury;
                for (var i = 0; i < this.npoints; i++) {
                    curx = this.xpoints[i];
                    cury = this.ypoints[i];
                    if (cross.accumulateLine(lastx, lasty, curx, cury)) {
                        return null;
                    }
                    lastx = curx;
                    lasty = cury;
                }
                return cross;
            };
            Polygon.prototype.contains$java_awt_geom_Point2D = function (p) {
                return this.contains(p.getX(), p.getY());
            };
            Polygon.prototype.intersects = function (x, y, w, h) {
                var _this = this;
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        if (_this.npoints <= 0 || !_this.getBoundingBox().intersects(x, y, w, h)) {
                            return false;
                        }
                        var cross = _this.getCrossings(x, y, x + w, y + h);
                        return (cross == null || !cross.isEmpty());
                    })();
                }
                else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                    return this.intersects$java_awt_geom_Rectangle2D(x);
                }
                else
                    throw new Error('invalid overload');
            };
            Polygon.prototype.intersects$java_awt_geom_Rectangle2D = function (r) {
                return this.intersects(r.getX(), r.getY(), r.getWidth(), r.getHeight());
            };
            Polygon.prototype.contains = function (x, y, w, h) {
                var _this = this;
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        if (_this.npoints <= 0 || !_this.getBoundingBox().intersects(x, y, w, h)) {
                            return false;
                        }
                        var cross = _this.getCrossings(x, y, x + w, y + h);
                        return (cross != null && cross.covers(y, y + h));
                    })();
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
                    return this.contains$int$int(x, y);
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
                    return this.contains$double$double(x, y);
                }
                else if (((x != null && x instanceof java.awt.Point) || x === null) && y === undefined && w === undefined && h === undefined) {
                    return this.contains$java_awt_Point(x);
                }
                else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                    return this.contains$java_awt_geom_Point2D(x);
                }
                else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                    return this.contains$java_awt_geom_Rectangle2D(x);
                }
                else
                    throw new Error('invalid overload');
            };
            Polygon.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
                return this.contains(r.getX(), r.getY(), r.getWidth(), r.getHeight());
            };
            Polygon.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                return new Polygon.PolygonPathIterator(this, this, at);
            };
            Polygon.prototype.getPathIterator = function (at, flatness) {
                var _this = this;
                if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        return _this.getPathIterator(at);
                    })();
                }
                else if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && flatness === undefined) {
                    return this.getPathIterator$java_awt_geom_AffineTransform(at);
                }
                else
                    throw new Error('invalid overload');
            };
            Polygon.serialVersionUID = -6460061437900069969;
            Polygon.MIN_LENGTH = 4;
            return Polygon;
        }());
        awt.Polygon = Polygon;
        Polygon["__class"] = "java.awt.Polygon";
        Polygon["__interfaces"] = ["java.awt.Shape", "java.io.Serializable"];
        var Polygon;
        (function (Polygon) {
            var PolygonPathIterator = (function () {
                function PolygonPathIterator(__parent, pg, at) {
                    this.__parent = __parent;
                    this.index = 0;
                    this.poly = pg;
                    this.transform = at;
                    if (pg.npoints === 0) {
                        this.index = 1;
                    }
                }
                PolygonPathIterator.prototype.getWindingRule = function () {
                    return java.awt.geom.PathIterator.WIND_EVEN_ODD;
                };
                PolygonPathIterator.prototype.isDone = function () {
                    return this.index > this.poly.npoints;
                };
                PolygonPathIterator.prototype.next = function (doNext) {
                    if (doNext === undefined) {
                        return this.next$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                PolygonPathIterator.prototype.next$ = function () {
                    this.index++;
                };
                PolygonPathIterator.prototype.currentSegment = function (coords) {
                    var _this = this;
                    if (((coords != null && coords instanceof Array) || coords === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (_this.index >= _this.poly.npoints) {
                                return java.awt.geom.PathIterator.SEG_CLOSE;
                            }
                            coords[0] = _this.poly.xpoints[_this.index];
                            coords[1] = _this.poly.ypoints[_this.index];
                            if (_this.transform != null) {
                                _this.transform.transform(coords, 0, coords, 0, 1);
                            }
                            return (_this.index === 0 ? java.awt.geom.PathIterator.SEG_MOVETO : java.awt.geom.PathIterator.SEG_LINETO);
                        })();
                    }
                    else if (((coords != null && coords instanceof Array) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                PolygonPathIterator.prototype.currentSegment$double_A = function (coords) {
                    if (this.index >= this.poly.npoints) {
                        return java.awt.geom.PathIterator.SEG_CLOSE;
                    }
                    coords[0] = this.poly.xpoints[this.index];
                    coords[1] = this.poly.ypoints[this.index];
                    if (this.transform != null) {
                        this.transform.transform(coords, 0, coords, 0, 1);
                    }
                    return (this.index === 0 ? java.awt.geom.PathIterator.SEG_MOVETO : java.awt.geom.PathIterator.SEG_LINETO);
                };
                return PolygonPathIterator;
            }());
            Polygon.PolygonPathIterator = PolygonPathIterator;
            PolygonPathIterator["__class"] = "java.awt.Polygon.PolygonPathIterator";
            PolygonPathIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
        })(Polygon = awt.Polygon || (awt.Polygon = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var Toolkit = (function () {
            function Toolkit() {
                this.images = (new java.util.HashMap());
            }
            Toolkit.getProperty = function (key, defaultValue) {
                return defaultValue;
            };
            Toolkit.getDefaultToolkit = function () {
                if (Toolkit.toolkit == null) {
                    Toolkit.toolkit = new Toolkit();
                }
                return Toolkit.toolkit;
            };
            Toolkit.prototype.createImage = function (filename) {
                try {
                    var image_1 = javax.imageio.ImageIO.read(new java.io.File(filename));
                    this.images.put(filename, image_1);
                    return image_1;
                }
                catch (e) {
                    return null;
                }
                ;
            };
            Toolkit.prototype.getImage = function (filename) {
                return this.createImage(filename);
            };
            return Toolkit;
        }());
        awt.Toolkit = Toolkit;
        Toolkit["__class"] = "java.awt.Toolkit";
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var Transparency;
        (function (Transparency) {
            Transparency.OPAQUE = 1;
            Transparency.BITMASK = 2;
            Transparency.TRANSLUCENT = 3;
        })(Transparency = awt.Transparency || (awt.Transparency = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var beans;
    (function (beans) {
        var ChangeListenerMap = (function () {
            function ChangeListenerMap() {
            }
            ChangeListenerMap.prototype.newProxy = function (name, listener) {
                if (((typeof name === 'string') || name === null) && ((listener != null) || listener === null)) {
                    return this.newProxy$java_lang_String$java_util_EventListener(name, listener);
                }
                else
                    throw new Error('invalid overload');
            };
            ChangeListenerMap.prototype.newProxy$java_lang_String$java_util_EventListener = function (name, listener) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
            ChangeListenerMap.prototype.add = function (name, listener) {
                if (this.map == null) {
                    this.map = (new java.util.HashMap());
                }
                var array = this.map.get(name);
                var size = (array != null) ? array.length : 0;
                var clone = this.newArray(size + 1);
                clone[size] = listener;
                if (array != null) {
                    java.lang.System.arraycopy(array, 0, clone, 0, size);
                }
                this.map.put(name, clone);
            };
            ChangeListenerMap.prototype.remove = function (name, listener) {
                if (this.map != null) {
                    var array = this.map.get(name);
                    if (array != null) {
                        for (var i = 0; i < array.length; i++) {
                            if (listener.equals(array[i])) {
                                var size = array.length - 1;
                                if (size > 0) {
                                    var clone = this.newArray(size);
                                    java.lang.System.arraycopy(array, 0, clone, 0, i);
                                    java.lang.System.arraycopy(array, i + 1, clone, i, size - i);
                                    this.map.put(name, clone);
                                }
                                else {
                                    this.map.remove(name);
                                    if (this.map.isEmpty()) {
                                        this.map = null;
                                    }
                                }
                                break;
                            }
                        }
                    }
                }
            };
            /**
             * Returns the list of listeners for the specified property.
             *
             * @param name
             * the name of the property
             * @return the corresponding list of listeners
             */
            ChangeListenerMap.prototype.get = function (name) {
                return (this.map != null) ? this.map.get(name) : null;
            };
            /**
             * Sets new list of listeners for the specified property.
             *
             * @param name
             * the name of the property
             * @param listeners
             * new list of listeners
             */
            ChangeListenerMap.prototype.set = function (name, listeners) {
                if (listeners != null) {
                    if (this.map == null) {
                        this.map = (new java.util.HashMap());
                    }
                    this.map.put(name, listeners);
                }
                else if (this.map != null) {
                    this.map.remove(name);
                    if (this.map.isEmpty()) {
                        this.map = null;
                    }
                }
            };
            /**
             * Returns all listeners in the map.
             *
             * @return an array of all listeners
             */
            ChangeListenerMap.prototype.getListeners$ = function () {
                if (this.map == null) {
                    return this.newArray(0);
                }
                var list = (new java.util.ArrayList());
                var listeners = this.map.get(null);
                if (listeners != null) {
                    for (var index123 = 0; index123 < listeners.length; index123++) {
                        var listener = listeners[index123];
                        {
                            list.add(listener);
                        }
                    }
                }
                for (var index124 = this.map.entrySet().iterator(); index124.hasNext();) {
                    var entry = index124.next();
                    {
                        var name_1 = entry.getKey();
                        if (name_1 != null) {
                            {
                                var array126 = entry.getValue();
                                for (var index125 = 0; index125 < array126.length; index125++) {
                                    var listener = array126[index125];
                                    {
                                        list.add(this.newProxy(name_1, listener));
                                    }
                                }
                            }
                        }
                    }
                }
                return list.toArray(this.newArray(list.size()));
            };
            /**
             * Returns listeners that have been associated with the named property.
             *
             * @param name
             * the name of the property
             * @return an array of listeners for the named property
             */
            ChangeListenerMap.prototype.getListeners = function (name) {
                var _this = this;
                if (((typeof name === 'string') || name === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        if (name != null) {
                            var listeners = _this.get(name);
                            if (listeners != null) {
                                return (listeners).slice(0);
                            }
                        }
                        return _this.newArray(0);
                    })();
                }
                else if (name === undefined) {
                    return this.getListeners$();
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Indicates whether the map contains at least one listener to be notified.
             *
             * @param name
             * the name of the property
             * @return {@code true} if at least one listener exists or {@code false}
             * otherwise
             */
            ChangeListenerMap.prototype.hasListeners = function (name) {
                if (this.map == null) {
                    return false;
                }
                var array = this.map.get(null);
                return (array != null) || ((name != null) && (null != this.map.get(name)));
            };
            /**
             * Returns a set of entries from the map. Each entry is a pair consisted of
             * the property name and the corresponding list of listeners.
             *
             * @return a set of entries from the map
             */
            ChangeListenerMap.prototype.getEntries = function () {
                return (this.map != null) ? this.map.entrySet() : java.util.Collections.emptySet();
            };
            ChangeListenerMap.prototype.extract = function (listener) {
                if (((listener != null) || listener === null)) {
                    return this.extract$java_util_EventListener(listener);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Extracts a real listener from the proxy listener. It is necessary because
             * default proxy class is not serializable.
             *
             * @return a real listener
             */
            ChangeListenerMap.prototype.extract$java_util_EventListener = function (listener) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
            return ChangeListenerMap;
        }());
        beans.ChangeListenerMap = ChangeListenerMap;
        ChangeListenerMap["__class"] = "java.beans.ChangeListenerMap";
    })(beans = java.beans || (java.beans = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var beans;
    (function (beans) {
        var PropertyChangeEvent = (function (_super) {
            __extends(PropertyChangeEvent, _super);
            function PropertyChangeEvent(source, propertyName, oldValue, newValue) {
                _super.call(this, source);
                this.propertyName = propertyName;
                this.newValue = newValue;
                this.oldValue = oldValue;
            }
            PropertyChangeEvent.prototype.getPropertyName = function () {
                return this.propertyName;
            };
            PropertyChangeEvent.prototype.getNewValue = function () {
                return this.newValue;
            };
            PropertyChangeEvent.prototype.getOldValue = function () {
                return this.oldValue;
            };
            PropertyChangeEvent.prototype.setPropagationId = function (propagationId) {
                this.propagationId = propagationId;
            };
            PropertyChangeEvent.prototype.getPropagationId = function () {
                return this.propagationId;
            };
            PropertyChangeEvent.prototype.toString = function () {
                var sb = new java.lang.StringBuilder(/* getName */ (function (c) { return c["__class"] ? c["__class"] : c.name; })(this.constructor));
                sb.append("[propertyName=").append(this.getPropertyName());
                this.appendTo(sb);
                sb.append("; oldValue=").append(this.getOldValue());
                sb.append("; newValue=").append(this.getNewValue());
                sb.append("; propagationId=").append(this.getPropagationId());
                sb.append("; source=").append(this.getSource());
                return sb.append("]").toString();
            };
            PropertyChangeEvent.prototype.appendTo = function (sb) {
            };
            PropertyChangeEvent.serialVersionUID = 7042693688939648123;
            return PropertyChangeEvent;
        }(java.util.EventObject));
        beans.PropertyChangeEvent = PropertyChangeEvent;
        PropertyChangeEvent["__class"] = "java.beans.PropertyChangeEvent";
        PropertyChangeEvent["__interfaces"] = ["java.io.Serializable"];
    })(beans = java.beans || (java.beans = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var beans;
    (function (beans) {
        var PropertyChangeListenerProxy = (function (_super) {
            __extends(PropertyChangeListenerProxy, _super);
            /**
             * Constructor which binds the {@code PropertyChangeListener}
             * to a specific property.
             *
             * @param propertyName  the name of the property to listen on
             * @param listener      the listener object
             */
            function PropertyChangeListenerProxy(propertyName, listener) {
                _super.call(this, listener);
                this.propertyName = propertyName;
            }
            /**
             * Forwards the property change event to the listener delegate.
             *
             * @param event  the property change event
             */
            PropertyChangeListenerProxy.prototype.propertyChange = function (event) {
                this.getListener().propertyChange(event);
            };
            /**
             * Returns the name of the named property associated with the listener.
             *
             * @return the name of the named property associated with the listener
             */
            PropertyChangeListenerProxy.prototype.getPropertyName = function () {
                return this.propertyName;
            };
            return PropertyChangeListenerProxy;
        }(java.util.EventListenerProxy));
        beans.PropertyChangeListenerProxy = PropertyChangeListenerProxy;
        PropertyChangeListenerProxy["__class"] = "java.beans.PropertyChangeListenerProxy";
        PropertyChangeListenerProxy["__interfaces"] = ["java.util.EventListener", "java.beans.PropertyChangeListener"];
    })(beans = java.beans || (java.beans = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var imageio;
    (function (imageio) {
        var ImageIO = (function () {
            function ImageIO() {
            }
            ImageIO.read = function (input) {
                var src = "data:image/png;base64," + java.io.LocalStorageFileSystem.fs.getEntry(input.getAbsolutePath()).data;
                return new java.awt.image.BufferedImage(src);
            };
            return ImageIO;
        }());
        imageio.ImageIO = ImageIO;
        ImageIO["__class"] = "javax.imageio.ImageIO";
    })(imageio = javax.imageio || (javax.imageio = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        /**
         * This class provides default implementations for the JFC <code>Action</code>
         * interface. Standard behaviors like the get and set methods for
         * <code>Action</code> object properties (icon, text, and enabled) are defined
         * here. The developer need only subclass this abstract class and define the
         * <code>actionPerformed</code> method.
         * <p>
         * <strong>Warning:</strong> Serialized objects of this class will not be
         * compatible with future Swing releases. The current serialization support is
         * appropriate for short term storage or RMI between applications running the
         * same version of Swing. As of 1.4, support for long term storage of all
         * JavaBeans&trade; has been added to the <code>java.beans</code> package.
         * Please see {@link java.beans.XMLEncoder}.
         *
         * @author Georges Saab
         * @see Action
         */
        var AbstractAction = (function () {
            /**
             * Creates an {@code Action} with the specified name and small icon.
             *
             * @param name
             * the name ({@code Action.NAME}) for the action; a value of
             * {@code null} is ignored
             * @param icon
             * the small icon ({@code Action.SMALL_ICON}) for the action; a
             * value of {@code null} is ignored
             */
            function AbstractAction(name, icon) {
                var _this = this;
                /**
                 * Specifies whether action is enabled; the default is true.
                 */
                this.enabled = true;
                if (((typeof name === 'string') || name === null) && ((icon != null && (icon["__interfaces"] != null && icon["__interfaces"].indexOf("javax.swing.Icon") >= 0 || icon.constructor != null && icon.constructor["__interfaces"] != null && icon.constructor["__interfaces"].indexOf("javax.swing.Icon") >= 0)) || icon === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_8 = Array.prototype.slice.call(arguments);
                        this.enabled = true;
                        (function () {
                            _this.putValue(javax.swing.Action.NAME, name);
                        })();
                    }
                    (function () {
                        _this.putValue(javax.swing.Action.SMALL_ICON, icon);
                    })();
                }
                else if (((typeof name === 'string') || name === null) && icon === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    this.enabled = true;
                    (function () {
                        _this.putValue(javax.swing.Action.NAME, name);
                    })();
                }
                else if (name === undefined && icon === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    this.enabled = true;
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Sets the enabled state of a component from an Action.
             *
             * @param c
             * the Component to set the enabled state on
             * @param a
             * the Action to set the enabled state from, may be null
             */
            AbstractAction.setEnabledFromAction = function (c, a) {
                c.setEnabled((a != null) ? a.isEnabled() : true);
            };
            /**
             * Sets the tooltip text of a component from an Action.
             *
             * @param c
             * the Component to set the tooltip text on
             * @param a
             * the Action to set the tooltip text from, may be null
             */
            AbstractAction.setToolTipTextFromAction = function (c, a) {
            };
            AbstractAction.hasSelectedKey = function (a) {
                return (a != null && a.getValue(javax.swing.Action.SELECTED_KEY) != null);
            };
            AbstractAction.isSelected = function (a) {
                return (javaemul.internal.BooleanHelper.TRUE === a.getValue(javax.swing.Action.SELECTED_KEY));
            };
            /**
             * Gets the <code>Object</code> associated with the specified key.
             *
             * @param key
             * a string containing the specified <code>key</code>
             * @return the binding <code>Object</code> stored with this key; if there
             * are no keys, it will return <code>null</code>
             * @see Action#getValue
             */
            AbstractAction.prototype.getValue = function (key) {
                if (key === "enabled") {
                    return this.enabled;
                }
                if (this.arrayTable == null) {
                    return null;
                }
                return this.arrayTable.get(key);
            };
            /**
             * Sets the <code>Value</code> associated with the specified key.
             *
             * @param key
             * the <code>String</code> that identifies the stored object
             * @param newValue
             * the <code>Object</code> to store using this key
             * @see Action#putValue
             */
            AbstractAction.prototype.putValue = function (key, newValue) {
                var oldValue = null;
                if (key === "enabled") {
                    if (newValue == null || !(typeof newValue === 'boolean')) {
                        newValue = false;
                    }
                    oldValue = this.enabled;
                    this.enabled = newValue;
                }
                else {
                    if (this.arrayTable == null) {
                        this.arrayTable = (new java.util.HashMap());
                    }
                    if (this.arrayTable.containsKey(key))
                        oldValue = this.arrayTable.get(key);
                    if (newValue == null) {
                        this.arrayTable.remove(key);
                    }
                    else {
                        this.arrayTable.put(key, newValue);
                    }
                }
                this.firePropertyChange(key, oldValue, newValue);
            };
            /**
             * Returns true if the action is enabled.
             *
             * @return true if the action is enabled, false otherwise
             * @see Action#isEnabled
             */
            AbstractAction.prototype.isEnabled = function () {
                return this.enabled;
            };
            /**
             * Sets whether the {@code Action} is enabled. The default is {@code true}.
             *
             * @param newValue
             * {@code true} to enable the action, {@code false} to disable it
             * @see Action#setEnabled
             */
            AbstractAction.prototype.setEnabled = function (newValue) {
                var oldValue = this.enabled;
                if (oldValue !== newValue) {
                    this.enabled = newValue;
                    this.firePropertyChange("enabled", javaemul.internal.BooleanHelper.valueOf(oldValue), javaemul.internal.BooleanHelper.valueOf(newValue));
                }
            };
            /**
             * Returns an array of <code>Object</code>s which are keys for which values
             * have been set for this <code>AbstractAction</code>, or <code>null</code>
             * if no keys have values set.
             *
             * @return an array of key objects, or <code>null</code> if no keys have
             * values set
             * @since 1.3
             */
            AbstractAction.prototype.getKeys = function () {
                if (this.arrayTable == null) {
                    return null;
                }
                var keys = new Array(this.arrayTable.size());
                keys = this.arrayTable.keySet().toArray(keys);
                return keys;
            };
            /**
             * Supports reporting bound property changes. This method can be called when
             * a bound property has changed and it will send the appropriate
             * <code>PropertyChangeEvent</code> to any registered
             * <code>PropertyChangeListeners</code>.
             */
            AbstractAction.prototype.firePropertyChange = function (propertyName, oldValue, newValue) {
                if (this.changeSupport == null || (oldValue != null && newValue != null && (oldValue === newValue))) {
                    return;
                }
                this.changeSupport.firePropertyChange(propertyName, oldValue, newValue);
            };
            /**
             * Adds a <code>PropertyChangeListener</code> to the listener list. The
             * listener is registered for all properties.
             * <p>
             * A <code>PropertyChangeEvent</code> will get fired in response to setting
             * a bound property, e.g. <code>setFont</code>, <code>setBackground</code>,
             * or <code>setForeground</code>. Note that if the current component is
             * inheriting its foreground, background, or font from its container, then
             * no event will be fired in response to a change in the inherited property.
             *
             * @param listener
             * The <code>PropertyChangeListener</code> to be added
             *
             * @see Action#addPropertyChangeListener
             */
            AbstractAction.prototype.addPropertyChangeListener = function (listener) {
                if (this.changeSupport == null) {
                    this.changeSupport = new javax.swing.event.SwingPropertyChangeSupport(this);
                }
                this.changeSupport.addPropertyChangeListener(listener);
            };
            /**
             * Removes a <code>PropertyChangeListener</code> from the listener list.
             * This removes a <code>PropertyChangeListener</code> that was registered
             * for all properties.
             *
             * @param listener
             * the <code>PropertyChangeListener</code> to be removed
             *
             * @see Action#removePropertyChangeListener
             */
            AbstractAction.prototype.removePropertyChangeListener = function (listener) {
                if (this.changeSupport == null) {
                    return;
                }
                this.changeSupport.removePropertyChangeListener(listener);
            };
            /**
             * Returns an array of all the <code>PropertyChangeListener</code>s added to
             * this AbstractAction with addPropertyChangeListener().
             *
             * @return all of the <code>PropertyChangeListener</code>s added or an empty
             * array if no listeners have been added
             * @since 1.4
             */
            AbstractAction.prototype.getPropertyChangeListeners = function () {
                if (this.changeSupport == null) {
                    return new Array(0);
                }
                return this.changeSupport.getPropertyChangeListeners();
            };
            /**
             * Clones the abstract action. This gives the clone its own copy of the
             * key/value list, which is not handled for you by
             * <code>Object.clone()</code>.
             */
            AbstractAction.prototype.clone = function () {
                var newAction = javaemul.internal.ObjectHelper.clone(this);
                {
                    if (this.arrayTable != null) {
                        newAction.arrayTable = (new java.util.Hashtable(this.arrayTable));
                    }
                }
                ;
                return newAction;
            };
            return AbstractAction;
        }());
        swing.AbstractAction = AbstractAction;
        AbstractAction["__class"] = "javax.swing.AbstractAction";
        AbstractAction["__interfaces"] = ["java.util.EventListener", "java.lang.Cloneable", "java.awt.event.ActionListener", "javax.swing.Action", "java.io.Serializable"];
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        /**
         * The abstract definition for the data model that provides
         * a <code>List</code> with its contents.
         * <p>
         * <strong>Warning:</strong>
         * Serialized objects of this class will not be compatible with
         * future Swing releases. The current serialization support is
         * appropriate for short term storage or RMI between applications running
         * the same version of Swing.  As of 1.4, support for long term storage
         * of all JavaBeans&trade;
         * has been added to the <code>java.beans</code> package.
         * Please see {@link java.beans.XMLEncoder}.
         *
         * @param <E> the type of the elements of this model
         *
         * @author Hans Muller
         */
        var AbstractListModel = (function () {
            function AbstractListModel() {
                this.listenerList = new javax.swing.event.EventListenerList();
            }
            /**
             * Adds a listener to the list that's notified each time a change
             * to the data model occurs.
             *
             * @param l the <code>ListDataListener</code> to be added
             */
            AbstractListModel.prototype.addListDataListener = function (l) {
                this.listenerList.add("javax.swing.event.ListDataListener", l);
            };
            /**
             * Removes a listener from the list that's notified each time a
             * change to the data model occurs.
             *
             * @param l the <code>ListDataListener</code> to be removed
             */
            AbstractListModel.prototype.removeListDataListener = function (l) {
                this.listenerList.remove("javax.swing.event.ListDataListener", l);
            };
            /**
             * Returns an array of all the list data listeners
             * registered on this <code>AbstractListModel</code>.
             *
             * @return all of this model's <code>ListDataListener</code>s,
             * or an empty array if no list data listeners
             * are currently registered
             *
             * @see #addListDataListener
             * @see #removeListDataListener
             *
             * @since 1.4
             */
            AbstractListModel.prototype.getListDataListeners = function () {
                return this.listenerList.getListeners("javax.swing.event.ListDataListener");
            };
            /**
             * <code>AbstractListModel</code> subclasses must call this method
             * <b>after</b>
             * one or more elements of the list change.  The changed elements
             * are specified by the closed interval index0, index1 -- the endpoints
             * are included.  Note that
             * index0 need not be less than or equal to index1.
             *
             * @param source the <code>ListModel</code> that changed, typically "this"
             * @param index0 one end of the new interval
             * @param index1 the other end of the new interval
             * @see EventListenerList
             * @see DefaultListModel
             */
            AbstractListModel.prototype.fireContentsChanged = function (source, index0, index1) {
                var listeners = this.listenerList.getListenerList();
                var e = null;
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "javax.swing.event.ListDataListener") {
                        if (e == null) {
                            e = new javax.swing.event.ListDataEvent(source, javax.swing.event.ListDataEvent.CONTENTS_CHANGED, index0, index1);
                        }
                        listeners[i + 1].contentsChanged(e);
                    }
                }
            };
            /**
             * <code>AbstractListModel</code> subclasses must call this method
             * <b>after</b>
             * one or more elements are added to the model.  The new elements
             * are specified by a closed interval index0, index1 -- the enpoints
             * are included.  Note that
             * index0 need not be less than or equal to index1.
             *
             * @param source the <code>ListModel</code> that changed, typically "this"
             * @param index0 one end of the new interval
             * @param index1 the other end of the new interval
             * @see EventListenerList
             * @see DefaultListModel
             */
            AbstractListModel.prototype.fireIntervalAdded = function (source, index0, index1) {
                var listeners = this.listenerList.getListenerList();
                var e = null;
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "javax.swing.event.ListDataListener") {
                        if (e == null) {
                            e = new javax.swing.event.ListDataEvent(source, javax.swing.event.ListDataEvent.INTERVAL_ADDED, index0, index1);
                        }
                        listeners[i + 1].intervalAdded(e);
                    }
                }
            };
            /**
             * <code>AbstractListModel</code> subclasses must call this method
             * <b>after</b> one or more elements are removed from the model.
             * <code>index0</code> and <code>index1</code> are the end points
             * of the interval that's been removed.  Note that <code>index0</code>
             * need not be less than or equal to <code>index1</code>.
             *
             * @param source the <code>ListModel</code> that changed, typically "this"
             * @param index0 one end of the removed interval,
             * including <code>index0</code>
             * @param index1 the other end of the removed interval,
             * including <code>index1</code>
             * @see EventListenerList
             * @see DefaultListModel
             */
            AbstractListModel.prototype.fireIntervalRemoved = function (source, index0, index1) {
                var listeners = this.listenerList.getListenerList();
                var e = null;
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "javax.swing.event.ListDataListener") {
                        if (e == null) {
                            e = new javax.swing.event.ListDataEvent(source, javax.swing.event.ListDataEvent.INTERVAL_REMOVED, index0, index1);
                        }
                        listeners[i + 1].intervalRemoved(e);
                    }
                }
            };
            /**
             * Returns an array of all the objects currently registered as
             * <code><em>Foo</em>Listener</code>s
             * upon this model.
             * <code><em>Foo</em>Listener</code>s
             * are registered using the <code>add<em>Foo</em>Listener</code> method.
             * <p>
             * You can specify the <code>listenerType</code> argument
             * with a class literal, such as <code><em>Foo</em>Listener.class</code>.
             * For example, you can query a list model
             * <code>m</code>
             * for its list data listeners
             * with the following code:
             *
             * <pre>ListDataListener[] ldls = (ListDataListener[])(m.getListeners(ListDataListener.class));</pre>
             *
             * If no such listeners exist,
             * this method returns an empty array.
             *
             * @param listenerType  the type of listeners requested;
             * this parameter should specify an interface
             * that descends from <code>java.util.EventListener</code>
             * @return an array of all objects registered as
             * <code><em>Foo</em>Listener</code>s
             * on this model,
             * or an empty array if no such
             * listeners have been added
             * @exception ClassCastException if <code>listenerType</code> doesn't
             * specify a class or interface that implements
             * <code>java.util.EventListener</code>
             *
             * @see #getListDataListeners
             *
             * @since 1.3
             */
            AbstractListModel.prototype.getListeners = function (listenerType) {
                return this.listenerList.getListeners(listenerType);
            };
            return AbstractListModel;
        }());
        swing.AbstractListModel = AbstractListModel;
        AbstractListModel["__class"] = "javax.swing.AbstractListModel";
        AbstractListModel["__interfaces"] = ["javax.swing.ListModel", "java.io.Serializable"];
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var Action;
        (function (Action) {
            Action.DEFAULT = "Default";
            Action.NAME = "Name";
            Action.SHORT_DESCRIPTION = "ShortDescription";
            Action.LONG_DESCRIPTION = "LongDescription";
            Action.SMALL_ICON = "SmallIcon";
            Action.ACTION_COMMAND_KEY = "ActionCommandKey";
            Action.ACCELERATOR_KEY = "AcceleratorKey";
            Action.MNEMONIC_KEY = "MnemonicKey";
            Action.SELECTED_KEY = "SwingSelectedKey";
            Action.DISPLAYED_MNEMONIC_INDEX_KEY = "SwingDisplayedMnemonicIndexKey";
            Action.LARGE_ICON_KEY = "SwingLargeIconKey";
        })(Action = swing.Action || (swing.Action = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        /**
         * A package-private PropertyChangeListener which listens for property changes
         * on an Action and updates the properties of an ActionEvent source.
         * <p>
         * Subclasses must override the actionPropertyChanged method, which is invoked
         * from the propertyChange method as long as the target is still valid.
         * </p>
         * <p>
         * WARNING WARNING WARNING WARNING WARNING WARNING:<br>
         * Do NOT create an annonymous inner class that extends this! If you do a strong
         * reference will be held to the containing class, which in most cases defeats
         * the purpose of this class.
         *
         * @param T
         * the type of JComponent the underlying Action is attached to
         *
         * @author Georges Saab
         * @see AbstractButton
         */
        var ActionPropertyChangeListener = (function () {
            function ActionPropertyChangeListener(c, a) {
                this.setTarget(c);
                this.action = a;
            }
            ActionPropertyChangeListener.prototype.propertyChange = function (e) {
                var target = this.getTarget();
                if (target == null) {
                    this.getAction().removePropertyChangeListener(this);
                }
                else {
                    this.actionPropertyChanged(target, this.getAction(), e);
                }
            };
            ActionPropertyChangeListener.prototype.actionPropertyChanged = function (cb, action, e) {
                if (((cb != null) || cb === null) && ((action != null && (action["__interfaces"] != null && action["__interfaces"].indexOf("javax.swing.Action") >= 0 || action.constructor != null && action.constructor["__interfaces"] != null && action.constructor["__interfaces"].indexOf("javax.swing.Action") >= 0)) || action === null) && ((e != null && e instanceof java.beans.PropertyChangeEvent) || e === null)) {
                    return this.actionPropertyChanged$javax_swing_JComponent$javax_swing_Action$java_beans_PropertyChangeEvent(cb, action, e);
                }
                else
                    throw new Error('invalid overload');
            };
            ActionPropertyChangeListener.prototype.actionPropertyChanged$javax_swing_JComponent$javax_swing_Action$java_beans_PropertyChangeEvent = function (target, action, e) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
            ActionPropertyChangeListener.prototype.setTarget = function (c) {
                this.target = c;
            };
            ActionPropertyChangeListener.prototype.getTarget = function () {
                return this.target;
            };
            ActionPropertyChangeListener.prototype.getAction = function () {
                return this.action;
            };
            return ActionPropertyChangeListener;
        }());
        swing.ActionPropertyChangeListener = ActionPropertyChangeListener;
        ActionPropertyChangeListener["__class"] = "javax.swing.ActionPropertyChangeListener";
        ActionPropertyChangeListener["__interfaces"] = ["java.util.EventListener", "java.beans.PropertyChangeListener", "java.io.Serializable"];
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var BoxLayout = (function () {
            function BoxLayout(target, axis) {
                this.axis = 0;
                if (axis !== BoxLayout.X_AXIS && axis !== BoxLayout.Y_AXIS && axis !== BoxLayout.LINE_AXIS && axis !== BoxLayout.PAGE_AXIS) {
                    throw new Error("Invalid axis");
                }
                this.axis = axis;
                this.target = target;
            }
            BoxLayout.prototype.getTarget = function () {
                return this.target;
            };
            BoxLayout.prototype.getAxis = function () {
                return this.axis;
            };
            BoxLayout.prototype.invalidateLayout = function (target) {
            };
            BoxLayout.prototype.addLayoutComponent = function (name, comp) {
                if (((typeof name === 'string') || name === null) && ((comp != null && comp instanceof java.awt.Component) || comp === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                    })();
                }
                else if (((name != null && name instanceof java.awt.Component) || name === null) && ((comp != null) || comp === null)) {
                    return this.addLayoutComponent$java_awt_Component$java_lang_Object(name, comp);
                }
                else
                    throw new Error('invalid overload');
            };
            BoxLayout.prototype.removeLayoutComponent = function (comp) {
            };
            BoxLayout.prototype.addLayoutComponent$java_awt_Component$java_lang_Object = function (comp, constraints) {
                if (this.axis === BoxLayout.X_AXIS || this.axis === BoxLayout.LINE_AXIS) {
                    var tr = this.table.firstChild;
                    if (tr == null) {
                        tr = document.createElement("tr");
                        this.table.appendChild(tr);
                    }
                    var td = document.createElement("td");
                    td.appendChild(comp.getHTMLElement());
                    tr.appendChild(td);
                }
                else {
                    var tr = document.createElement("tr");
                    var td = document.createElement("td");
                    tr.appendChild(td);
                    td.appendChild(comp.getHTMLElement());
                    this.table.appendChild(tr);
                }
            };
            BoxLayout.prototype.maximumLayoutSize = function (target) {
                return null;
            };
            BoxLayout.prototype.getLayoutAlignmentX = function (target) {
                return 0;
            };
            BoxLayout.prototype.getLayoutAlignmentY = function (target) {
                return 0;
            };
            BoxLayout.prototype.layoutContainer = function (target) {
                if (this.table == null) {
                    this.table = document.createElement("table");
                    var div = target.getHTMLElement();
                    div.appendChild(this.table);
                }
            };
            BoxLayout.prototype.onComponentAdded = function (parent, component, position) {
            };
            BoxLayout.X_AXIS = 0;
            BoxLayout.Y_AXIS = 1;
            BoxLayout.LINE_AXIS = 2;
            BoxLayout.PAGE_AXIS = 3;
            return BoxLayout;
        }());
        swing.BoxLayout = BoxLayout;
        BoxLayout["__class"] = "javax.swing.BoxLayout";
        BoxLayout["__interfaces"] = ["java.awt.LayoutManager2", "java.awt.LayoutManager", "java.io.Serializable"];
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var ButtonGroup = (function () {
            function ButtonGroup() {
                this.buttons = (new java.util.Vector());
                this.selection = null;
            }
            ButtonGroup.prototype.add = function (b) {
                if (b == null) {
                    return;
                }
                this.buttons.addElement(b);
                if (b.isSelected()) {
                    if (this.selection == null) {
                        this.selection = b.getModel();
                    }
                    else {
                        b.setSelected(false);
                    }
                }
                b.getModel().setGroup(this);
            };
            ButtonGroup.prototype.remove = function (b) {
                if (b == null) {
                    return;
                }
                this.buttons.removeElement(b);
                if (b.getModel() === this.selection) {
                    this.selection = null;
                }
                b.getModel().setGroup(null);
            };
            ButtonGroup.prototype.clearSelection = function () {
                if (this.selection != null) {
                    var oldSelection = this.selection;
                    this.selection = null;
                    oldSelection.setSelected(false);
                }
            };
            ButtonGroup.prototype.getElements = function () {
                return this.buttons.elements();
            };
            ButtonGroup.prototype.getSelection = function () {
                return this.selection;
            };
            ButtonGroup.prototype.setSelected = function (m, b) {
                if (b && m != null && m !== this.selection) {
                    var oldSelection = this.selection;
                    this.selection = m;
                    if (oldSelection != null) {
                        oldSelection.setSelected(false);
                    }
                    m.setSelected(true);
                }
            };
            ButtonGroup.prototype.isSelected = function (m) {
                return (m === this.selection);
            };
            ButtonGroup.prototype.getButtonCount = function () {
                if (this.buttons == null) {
                    return 0;
                }
                else {
                    return this.buttons.size();
                }
            };
            return ButtonGroup;
        }());
        swing.ButtonGroup = ButtonGroup;
        ButtonGroup["__class"] = "javax.swing.ButtonGroup";
        ButtonGroup["__interfaces"] = ["java.io.Serializable"];
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        /**
         * A generic implementation of BoundedRangeModel.
         * <p>
         * <strong>Warning:</strong>
         * Serialized objects of this class will not be compatible with
         * future Swing releases. The current serialization support is
         * appropriate for short term storage or RMI between applications running
         * the same version of Swing.  As of 1.4, support for long term storage
         * of all JavaBeans&trade;
         * has been added to the <code>java.beans</code> package.
         * Please see {@link java.beans.XMLEncoder}.
         *
         * @author David Kloba
         * @author Hans Muller
         * @see BoundedRangeModel
         */
        var DefaultBoundedRangeModel = (function () {
            /**
             * Initializes value, extent, minimum and maximum. Adjusting is false.
             * Throws an <code>IllegalArgumentException</code> if the following
             * constraints aren't satisfied:
             * <pre>
             * min &lt;= value &lt;= value+extent &lt;= max
             * </pre>
             */
            function DefaultBoundedRangeModel(value, extent, min, max) {
                var _this = this;
                /**
                 * Only one <code>ChangeEvent</code> is needed per model instance since the
                 * event's only (read-only) state is the source property.  The source
                 * of events generated here is always "this".
                 */
                this.changeEvent = null;
                /**
                 * The listeners waiting for model changes.
                 */
                this.listenerList = new javax.swing.event.EventListenerList();
                this.value = 0;
                this.extent = 0;
                this.min = 0;
                this.max = 100;
                this.isAdjusting = false;
                if (((typeof value === 'number') || value === null) && ((typeof extent === 'number') || extent === null) && ((typeof min === 'number') || min === null) && ((typeof max === 'number') || max === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    this.changeEvent = null;
                    this.listenerList = new javax.swing.event.EventListenerList();
                    this.value = 0;
                    this.extent = 0;
                    this.min = 0;
                    this.max = 100;
                    this.isAdjusting = false;
                    (function () {
                        if ((max >= min) && (value >= min) && ((value + extent) >= value) && ((value + extent) <= max)) {
                            _this.value = value;
                            _this.extent = extent;
                            _this.min = min;
                            _this.max = max;
                        }
                        else {
                            throw new java.lang.IllegalArgumentException("invalid range properties");
                        }
                    })();
                }
                else if (value === undefined && extent === undefined && min === undefined && max === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    this.changeEvent = null;
                    this.listenerList = new javax.swing.event.EventListenerList();
                    this.value = 0;
                    this.extent = 0;
                    this.min = 0;
                    this.max = 100;
                    this.isAdjusting = false;
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Returns the model's current value.
             * @return the model's current value
             * @see #setValue
             * @see BoundedRangeModel#getValue
             */
            DefaultBoundedRangeModel.prototype.getValue = function () {
                return this.value;
            };
            /**
             * Returns the model's extent.
             * @return the model's extent
             * @see #setExtent
             * @see BoundedRangeModel#getExtent
             */
            DefaultBoundedRangeModel.prototype.getExtent = function () {
                return this.extent;
            };
            /**
             * Returns the model's minimum.
             * @return the model's minimum
             * @see #setMinimum
             * @see BoundedRangeModel#getMinimum
             */
            DefaultBoundedRangeModel.prototype.getMinimum = function () {
                return this.min;
            };
            /**
             * Returns the model's maximum.
             * @return  the model's maximum
             * @see #setMaximum
             * @see BoundedRangeModel#getMaximum
             */
            DefaultBoundedRangeModel.prototype.getMaximum = function () {
                return this.max;
            };
            /**
             * Sets the current value of the model. For a slider, that
             * determines where the knob appears. Ensures that the new
             * value, <I>n</I> falls within the model's constraints:
             * <pre>
             * minimum &lt;= value &lt;= value+extent &lt;= maximum
             * </pre>
             *
             * @see BoundedRangeModel#setValue
             */
            DefaultBoundedRangeModel.prototype.setValue = function (n) {
                n = Math.min(n, javaemul.internal.IntegerHelper.MAX_VALUE - this.extent);
                var newValue = Math.max(n, this.min);
                if (newValue + this.extent > this.max) {
                    newValue = this.max - this.extent;
                }
                this.setRangeProperties(newValue, this.extent, this.min, this.max, this.isAdjusting);
            };
            /**
             * Sets the extent to <I>n</I> after ensuring that <I>n</I>
             * is greater than or equal to zero and falls within the model's
             * constraints:
             * <pre>
             * minimum &lt;= value &lt;= value+extent &lt;= maximum
             * </pre>
             * @see BoundedRangeModel#setExtent
             */
            DefaultBoundedRangeModel.prototype.setExtent = function (n) {
                var newExtent = Math.max(0, n);
                if (this.value + newExtent > this.max) {
                    newExtent = this.max - this.value;
                }
                this.setRangeProperties(this.value, newExtent, this.min, this.max, this.isAdjusting);
            };
            /**
             * Sets the minimum to <I>n</I> after ensuring that <I>n</I>
             * that the other three properties obey the model's constraints:
             * <pre>
             * minimum &lt;= value &lt;= value+extent &lt;= maximum
             * </pre>
             * @see #getMinimum
             * @see BoundedRangeModel#setMinimum
             */
            DefaultBoundedRangeModel.prototype.setMinimum = function (n) {
                var newMax = Math.max(n, this.max);
                var newValue = Math.max(n, this.value);
                var newExtent = Math.min(newMax - newValue, this.extent);
                this.setRangeProperties(newValue, newExtent, n, newMax, this.isAdjusting);
            };
            /**
             * Sets the maximum to <I>n</I> after ensuring that <I>n</I>
             * that the other three properties obey the model's constraints:
             * <pre>
             * minimum &lt;= value &lt;= value+extent &lt;= maximum
             * </pre>
             * @see BoundedRangeModel#setMaximum
             */
            DefaultBoundedRangeModel.prototype.setMaximum = function (n) {
                var newMin = Math.min(n, this.min);
                var newExtent = Math.min(n - newMin, this.extent);
                var newValue = Math.min(n - newExtent, this.value);
                this.setRangeProperties(newValue, newExtent, newMin, n, this.isAdjusting);
            };
            /**
             * Sets the <code>valueIsAdjusting</code> property.
             *
             * @see #getValueIsAdjusting
             * @see #setValue
             * @see BoundedRangeModel#setValueIsAdjusting
             */
            DefaultBoundedRangeModel.prototype.setValueIsAdjusting = function (b) {
                this.setRangeProperties(this.value, this.extent, this.min, this.max, b);
            };
            /**
             * Returns true if the value is in the process of changing
             * as a result of actions being taken by the user.
             *
             * @return the value of the <code>valueIsAdjusting</code> property
             * @see #setValue
             * @see BoundedRangeModel#getValueIsAdjusting
             */
            DefaultBoundedRangeModel.prototype.getValueIsAdjusting = function () {
                return this.isAdjusting;
            };
            /**
             * Sets all of the <code>BoundedRangeModel</code> properties after forcing
             * the arguments to obey the usual constraints:
             * <pre>
             * minimum &lt;= value &lt;= value+extent &lt;= maximum
             * </pre>
             * <p>
             * At most, one <code>ChangeEvent</code> is generated.
             *
             * @see BoundedRangeModel#setRangeProperties
             * @see #setValue
             * @see #setExtent
             * @see #setMinimum
             * @see #setMaximum
             * @see #setValueIsAdjusting
             */
            DefaultBoundedRangeModel.prototype.setRangeProperties = function (newValue, newExtent, newMin, newMax, adjusting) {
                if (newMin > newMax) {
                    newMin = newMax;
                }
                if (newValue > newMax) {
                    newMax = newValue;
                }
                if (newValue < newMin) {
                    newMin = newValue;
                }
                if ((Math.round(newExtent) + Math.round(newValue)) > newMax) {
                    newExtent = newMax - newValue;
                }
                if (newExtent < 0) {
                    newExtent = 0;
                }
                var isChange = (newValue !== this.value) || (newExtent !== this.extent) || (newMin !== this.min) || (newMax !== this.max) || (adjusting !== this.isAdjusting);
                if (isChange) {
                    this.value = newValue;
                    this.extent = newExtent;
                    this.min = newMin;
                    this.max = newMax;
                    this.isAdjusting = adjusting;
                    this.fireStateChanged();
                }
            };
            /**
             * Adds a <code>ChangeListener</code>.  The change listeners are run each
             * time any one of the Bounded Range model properties changes.
             *
             * @param l the ChangeListener to add
             * @see #removeChangeListener
             * @see BoundedRangeModel#addChangeListener
             */
            DefaultBoundedRangeModel.prototype.addChangeListener = function (l) {
                this.listenerList.add("javax.swing.event.ChangeListener", l);
            };
            /**
             * Removes a <code>ChangeListener</code>.
             *
             * @param l the <code>ChangeListener</code> to remove
             * @see #addChangeListener
             * @see BoundedRangeModel#removeChangeListener
             */
            DefaultBoundedRangeModel.prototype.removeChangeListener = function (l) {
                this.listenerList.remove("javax.swing.event.ChangeListener", l);
            };
            /**
             * Returns an array of all the change listeners
             * registered on this <code>DefaultBoundedRangeModel</code>.
             *
             * @return all of this model's <code>ChangeListener</code>s
             * or an empty
             * array if no change listeners are currently registered
             *
             * @see #addChangeListener
             * @see #removeChangeListener
             *
             * @since 1.4
             */
            DefaultBoundedRangeModel.prototype.getChangeListeners = function () {
                return this.listenerList.getListeners("javax.swing.event.ChangeListener");
            };
            /**
             * Runs each <code>ChangeListener</code>'s <code>stateChanged</code> method.
             *
             * @see #setRangeProperties
             * @see EventListenerList
             */
            DefaultBoundedRangeModel.prototype.fireStateChanged = function () {
                var listeners = this.listenerList.getListenerList();
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "javax.swing.event.ChangeListener") {
                        if (this.changeEvent == null) {
                            this.changeEvent = new javax.swing.event.ChangeEvent(this);
                        }
                        listeners[i + 1].stateChanged(this.changeEvent);
                    }
                }
            };
            /**
             * Returns a string that displays all of the
             * <code>BoundedRangeModel</code> properties.
             */
            DefaultBoundedRangeModel.prototype.toString = function () {
                var modelString = "value=" + this.getValue() + ", " + "extent=" + this.getExtent() + ", " + "min=" + this.getMinimum() + ", " + "max=" + this.getMaximum() + ", " + "adj=" + this.getValueIsAdjusting();
                return (function (c) { return c["__class"] ? c["__class"] : c.name; })(this.constructor) + "[" + modelString + "]";
            };
            /**
             * Returns an array of all the objects currently registered as
             * <code><em>Foo</em>Listener</code>s
             * upon this model.
             * <code><em>Foo</em>Listener</code>s
             * are registered using the <code>add<em>Foo</em>Listener</code> method.
             * <p>
             * You can specify the <code>listenerType</code> argument
             * with a class literal, such as <code><em>Foo</em>Listener.class</code>.
             * For example, you can query a <code>DefaultBoundedRangeModel</code>
             * instance <code>m</code>
             * for its change listeners
             * with the following code:
             *
             * <pre>ChangeListener[] cls = (ChangeListener[])(m.getListeners(ChangeListener.class));</pre>
             *
             * If no such listeners exist,
             * this method returns an empty array.
             *
             * @param listenerType  the type of listeners requested;
             * this parameter should specify an interface
             * that descends from <code>java.util.EventListener</code>
             * @return an array of all objects registered as
             * <code><em>Foo</em>Listener</code>s
             * on this model,
             * or an empty array if no such
             * listeners have been added
             * @exception ClassCastException if <code>listenerType</code> doesn't
             * specify a class or interface that implements
             * <code>java.util.EventListener</code>
             *
             * @see #getChangeListeners
             *
             * @since 1.3
             */
            DefaultBoundedRangeModel.prototype.getListeners = function (listenerType) {
                return this.listenerList.getListeners(listenerType);
            };
            return DefaultBoundedRangeModel;
        }());
        swing.DefaultBoundedRangeModel = DefaultBoundedRangeModel;
        DefaultBoundedRangeModel["__class"] = "javax.swing.DefaultBoundedRangeModel";
        DefaultBoundedRangeModel["__interfaces"] = ["javax.swing.BoundedRangeModel", "java.io.Serializable"];
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var DefaultButtonModel = (function () {
            function DefaultButtonModel() {
                this.stateMask = 0;
                this.actionCommand = null;
                this.group = null;
                this.mnemonic = 0;
                this.changeEvent = null;
                this.listenerList = new javax.swing.event.EventListenerList();
                this.menuItem = false;
                this.stateMask = 0;
                this.setEnabled(true);
            }
            DefaultButtonModel.ARMED_$LI$ = function () { if (DefaultButtonModel.ARMED == null)
                DefaultButtonModel.ARMED = 1 << 0; return DefaultButtonModel.ARMED; };
            ;
            DefaultButtonModel.SELECTED_$LI$ = function () { if (DefaultButtonModel.SELECTED == null)
                DefaultButtonModel.SELECTED = 1 << 1; return DefaultButtonModel.SELECTED; };
            ;
            DefaultButtonModel.PRESSED_$LI$ = function () { if (DefaultButtonModel.PRESSED == null)
                DefaultButtonModel.PRESSED = 1 << 2; return DefaultButtonModel.PRESSED; };
            ;
            DefaultButtonModel.ENABLED_$LI$ = function () { if (DefaultButtonModel.ENABLED == null)
                DefaultButtonModel.ENABLED = 1 << 3; return DefaultButtonModel.ENABLED; };
            ;
            DefaultButtonModel.ROLLOVER_$LI$ = function () { if (DefaultButtonModel.ROLLOVER == null)
                DefaultButtonModel.ROLLOVER = 1 << 4; return DefaultButtonModel.ROLLOVER; };
            ;
            DefaultButtonModel.prototype.setActionCommand = function (actionCommand) {
                this.actionCommand = actionCommand;
            };
            DefaultButtonModel.prototype.getActionCommand = function () {
                return this.actionCommand;
            };
            DefaultButtonModel.prototype.isArmed = function () {
                return (this.stateMask & DefaultButtonModel.ARMED_$LI$()) !== 0;
            };
            DefaultButtonModel.prototype.isSelected = function () {
                return (this.stateMask & DefaultButtonModel.SELECTED_$LI$()) !== 0;
            };
            DefaultButtonModel.prototype.isEnabled = function () {
                return (this.stateMask & DefaultButtonModel.ENABLED_$LI$()) !== 0;
            };
            DefaultButtonModel.prototype.isPressed = function () {
                return (this.stateMask & DefaultButtonModel.PRESSED_$LI$()) !== 0;
            };
            DefaultButtonModel.prototype.isRollover = function () {
                return (this.stateMask & DefaultButtonModel.ROLLOVER_$LI$()) !== 0;
            };
            DefaultButtonModel.prototype.setArmed = function (b) {
                if (this.isMenuItem()) {
                    if ((this.isArmed() === b)) {
                        return;
                    }
                }
                else {
                    if ((this.isArmed() === b) || !this.isEnabled()) {
                        return;
                    }
                }
                if (b) {
                    this.stateMask |= DefaultButtonModel.ARMED_$LI$();
                }
                else {
                    this.stateMask &= ~DefaultButtonModel.ARMED_$LI$();
                }
                this.fireStateChanged();
            };
            DefaultButtonModel.prototype.setEnabled = function (b) {
                if (this.isEnabled() === b) {
                    return;
                }
                if (b) {
                    this.stateMask |= DefaultButtonModel.ENABLED_$LI$();
                }
                else {
                    this.stateMask &= ~DefaultButtonModel.ENABLED_$LI$();
                    this.stateMask &= ~DefaultButtonModel.ARMED_$LI$();
                    this.stateMask &= ~DefaultButtonModel.PRESSED_$LI$();
                }
                this.fireStateChanged();
            };
            DefaultButtonModel.prototype.setSelected = function (b) {
                if (this.isSelected() === b) {
                    return;
                }
                if (b) {
                    this.stateMask |= DefaultButtonModel.SELECTED_$LI$();
                }
                else {
                    this.stateMask &= ~DefaultButtonModel.SELECTED_$LI$();
                }
                this.fireItemStateChanged(new java.awt.event.ItemEvent(this, java.awt.event.ItemEvent.ITEM_STATE_CHANGED_$LI$(), this, b ? java.awt.event.ItemEvent.SELECTED : java.awt.event.ItemEvent.DESELECTED));
                this.fireStateChanged();
            };
            DefaultButtonModel.prototype.setPressed = function (b) {
                if ((this.isPressed() === b) || !this.isEnabled()) {
                    return;
                }
                if (b) {
                    this.stateMask |= DefaultButtonModel.PRESSED_$LI$();
                }
                else {
                    this.stateMask &= ~DefaultButtonModel.PRESSED_$LI$();
                }
                if (!this.isPressed() && this.isArmed()) {
                    var modifiers = 0;
                    this.fireActionPerformed(new java.awt.event.ActionEvent(this, java.awt.event.ActionEvent.ACTION_PERFORMED_$LI$(), this.getActionCommand(), 0, modifiers));
                }
                this.fireStateChanged();
            };
            DefaultButtonModel.prototype.setRollover = function (b) {
                if ((this.isRollover() === b) || !this.isEnabled()) {
                    return;
                }
                if (b) {
                    this.stateMask |= DefaultButtonModel.ROLLOVER_$LI$();
                }
                else {
                    this.stateMask &= ~DefaultButtonModel.ROLLOVER_$LI$();
                }
                this.fireStateChanged();
            };
            DefaultButtonModel.prototype.setMnemonic = function (key) {
                this.mnemonic = key;
                this.fireStateChanged();
            };
            DefaultButtonModel.prototype.getMnemonic = function () {
                return this.mnemonic;
            };
            DefaultButtonModel.prototype.addChangeListener = function (l) {
                this.listenerList.add("javax.swing.event.ChangeListener", l);
            };
            DefaultButtonModel.prototype.removeChangeListener = function (l) {
                this.listenerList.remove("javax.swing.event.ChangeListener", l);
            };
            DefaultButtonModel.prototype.getChangeListeners = function () {
                return this.listenerList.getListeners("javax.swing.event.ChangeListener");
            };
            DefaultButtonModel.prototype.fireStateChanged = function () {
                var listeners = this.listenerList.getListenerList();
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "javax.swing.event.ChangeListener") {
                        if (this.changeEvent == null)
                            this.changeEvent = new javax.swing.event.ChangeEvent(this);
                        listeners[i + 1].stateChanged(this.changeEvent);
                    }
                }
            };
            DefaultButtonModel.prototype.addActionListener = function (l) {
                this.listenerList.add("java.awt.event.ActionListener", l);
            };
            DefaultButtonModel.prototype.removeActionListener = function (l) {
                this.listenerList.remove("java.awt.event.ActionListener", l);
            };
            DefaultButtonModel.prototype.getActionListeners = function () {
                return this.listenerList.getListeners("java.awt.event.ActionListener");
            };
            DefaultButtonModel.prototype.fireActionPerformed = function (e) {
                var listeners = this.listenerList.getListenerList();
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "java.awt.event.ActionListener") {
                        listeners[i + 1].actionPerformed(e);
                    }
                }
            };
            DefaultButtonModel.prototype.addItemListener = function (l) {
                this.listenerList.add("java.awt.event.ItemListener", l);
            };
            DefaultButtonModel.prototype.removeItemListener = function (l) {
                this.listenerList.remove("java.awt.event.ItemListener", l);
            };
            DefaultButtonModel.prototype.getItemListeners = function () {
                return this.listenerList.getListeners("java.awt.event.ItemListener");
            };
            DefaultButtonModel.prototype.fireItemStateChanged = function (e) {
                var listeners = this.listenerList.getListenerList();
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "java.awt.event.ItemListener") {
                        listeners[i + 1].itemStateChanged(e);
                    }
                }
            };
            DefaultButtonModel.prototype.getListeners = function (listenerType) {
                return this.listenerList.getListeners(listenerType);
            };
            DefaultButtonModel.prototype.getSelectedObjects = function () {
                return null;
            };
            DefaultButtonModel.prototype.setGroup = function (group) {
                this.group = group;
            };
            DefaultButtonModel.prototype.getGroup = function () {
                return this.group;
            };
            DefaultButtonModel.prototype.isMenuItem = function () {
                return this.menuItem;
            };
            DefaultButtonModel.prototype.setMenuItem = function (menuItem) {
                this.menuItem = menuItem;
            };
            return DefaultButtonModel;
        }());
        swing.DefaultButtonModel = DefaultButtonModel;
        DefaultButtonModel["__class"] = "javax.swing.DefaultButtonModel";
        DefaultButtonModel["__interfaces"] = ["java.awt.ItemSelectable", "javax.swing.ButtonModel", "java.io.Serializable"];
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        /**
         * Default data model for list selections.
         * <p>
         * <strong>Warning:</strong>
         * Serialized objects of this class will not be compatible with
         * future Swing releases. The current serialization support is
         * appropriate for short term storage or RMI between applications running
         * the same version of Swing.  As of 1.4, support for long term storage
         * of all JavaBeans&trade;
         * has been added to the <code>java.beans</code> package.
         * Please see {@link java.beans.XMLEncoder}.
         *
         * @author Philip Milne
         * @author Hans Muller
         * @see ListSelectionModel
         */
        var DefaultListSelectionModel = (function () {
            function DefaultListSelectionModel() {
                this.selectionMode = javax.swing.ListSelectionModel.MULTIPLE_INTERVAL_SELECTION;
                this.minIndex = DefaultListSelectionModel.MAX_$LI$();
                this.maxIndex = DefaultListSelectionModel.MIN;
                this.anchorIndex = -1;
                this.leadIndex = -1;
                this.firstAdjustedIndex = DefaultListSelectionModel.MAX_$LI$();
                this.lastAdjustedIndex = DefaultListSelectionModel.MIN;
                this.isAdjusting = false;
                this.firstChangedIndex = DefaultListSelectionModel.MAX_$LI$();
                this.lastChangedIndex = DefaultListSelectionModel.MIN;
                this.value = new java.util.BitSet(32);
                this.listenerList = new javax.swing.event.EventListenerList();
                this.leadAnchorNotificationEnabled = true;
            }
            DefaultListSelectionModel.MAX_$LI$ = function () { if (DefaultListSelectionModel.MAX == null)
                DefaultListSelectionModel.MAX = javaemul.internal.IntegerHelper.MAX_VALUE; return DefaultListSelectionModel.MAX; };
            ;
            /**
             * {@inheritDoc}
             */
            DefaultListSelectionModel.prototype.getMinSelectionIndex = function () {
                return this.isSelectionEmpty() ? -1 : this.minIndex;
            };
            /**
             * {@inheritDoc}
             */
            DefaultListSelectionModel.prototype.getMaxSelectionIndex = function () {
                return this.maxIndex;
            };
            /**
             * {@inheritDoc}
             */
            DefaultListSelectionModel.prototype.getValueIsAdjusting = function () {
                return this.isAdjusting;
            };
            /**
             * {@inheritDoc}
             */
            DefaultListSelectionModel.prototype.getSelectionMode = function () {
                return this.selectionMode;
            };
            /**
             * {@inheritDoc}
             * @throws IllegalArgumentException {@inheritDoc}
             */
            DefaultListSelectionModel.prototype.setSelectionMode = function (selectionMode) {
                switch ((selectionMode)) {
                    case javax.swing.ListSelectionModel.SINGLE_SELECTION:
                    case javax.swing.ListSelectionModel.SINGLE_INTERVAL_SELECTION:
                    case javax.swing.ListSelectionModel.MULTIPLE_INTERVAL_SELECTION:
                        this.selectionMode = selectionMode;
                        break;
                    default:
                        throw new java.lang.IllegalArgumentException("invalid selectionMode");
                }
            };
            /**
             * {@inheritDoc}
             */
            DefaultListSelectionModel.prototype.isSelectedIndex = function (index) {
                return ((index < this.minIndex) || (index > this.maxIndex)) ? false : this.value.get(index);
            };
            /**
             * {@inheritDoc}
             */
            DefaultListSelectionModel.prototype.isSelectionEmpty = function () {
                return (this.minIndex > this.maxIndex);
            };
            /**
             * {@inheritDoc}
             */
            DefaultListSelectionModel.prototype.addListSelectionListener = function (l) {
                this.listenerList.add("javax.swing.event.ListSelectionListener", l);
            };
            /**
             * {@inheritDoc}
             */
            DefaultListSelectionModel.prototype.removeListSelectionListener = function (l) {
                this.listenerList.remove("javax.swing.event.ListSelectionListener", l);
            };
            /**
             * Returns an array of all the list selection listeners
             * registered on this <code>DefaultListSelectionModel</code>.
             *
             * @return all of this model's <code>ListSelectionListener</code>s
             * or an empty
             * array if no list selection listeners are currently registered
             *
             * @see #addListSelectionListener
             * @see #removeListSelectionListener
             *
             * @since 1.4
             */
            DefaultListSelectionModel.prototype.getListSelectionListeners = function () {
                return this.listenerList.getListeners("javax.swing.event.ListSelectionListener");
            };
            /**
             * Notifies listeners that we have ended a series of adjustments.
             */
            DefaultListSelectionModel.prototype.fireValueChanged$boolean = function (isAdjusting) {
                if (this.lastChangedIndex === DefaultListSelectionModel.MIN) {
                    return;
                }
                var oldFirstChangedIndex = this.firstChangedIndex;
                var oldLastChangedIndex = this.lastChangedIndex;
                this.firstChangedIndex = DefaultListSelectionModel.MAX_$LI$();
                this.lastChangedIndex = DefaultListSelectionModel.MIN;
                this.fireValueChanged(oldFirstChangedIndex, oldLastChangedIndex, isAdjusting);
            };
            /**
             * Notifies <code>ListSelectionListeners</code> that the value
             * of the selection, in the closed interval <code>firstIndex</code>,
             * <code>lastIndex</code>, has changed.
             */
            DefaultListSelectionModel.prototype.fireValueChanged$int$int = function (firstIndex, lastIndex) {
                this.fireValueChanged(firstIndex, lastIndex, this.getValueIsAdjusting());
            };
            /**
             * @param firstIndex the first index in the interval
             * @param lastIndex the last index in the interval
             * @param isAdjusting true if this is the final change in a series of
             * adjustments
             * @see EventListenerList
             */
            DefaultListSelectionModel.prototype.fireValueChanged = function (firstIndex, lastIndex, isAdjusting) {
                var _this = this;
                if (((typeof firstIndex === 'number') || firstIndex === null) && ((typeof lastIndex === 'number') || lastIndex === null) && ((typeof isAdjusting === 'boolean') || isAdjusting === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        var listeners = _this.listenerList.getListenerList();
                        var e = null;
                        for (var i = listeners.length - 2; i >= 0; i -= 2) {
                            if (listeners[i] === "javax.swing.event.ListSelectionListener") {
                                if (e == null) {
                                    e = new javax.swing.event.ListSelectionEvent(_this, firstIndex, lastIndex, isAdjusting);
                                }
                                listeners[i + 1].valueChanged(e);
                            }
                        }
                    })();
                }
                else if (((typeof firstIndex === 'number') || firstIndex === null) && ((typeof lastIndex === 'number') || lastIndex === null) && isAdjusting === undefined) {
                    return this.fireValueChanged$int$int(firstIndex, lastIndex);
                }
                else if (((typeof firstIndex === 'boolean') || firstIndex === null) && lastIndex === undefined && isAdjusting === undefined) {
                    return this.fireValueChanged$boolean(firstIndex);
                }
                else if (firstIndex === undefined && lastIndex === undefined && isAdjusting === undefined) {
                    return this.fireValueChanged$();
                }
                else
                    throw new Error('invalid overload');
            };
            DefaultListSelectionModel.prototype.fireValueChanged$ = function () {
                if (this.lastAdjustedIndex === DefaultListSelectionModel.MIN) {
                    return;
                }
                if (this.getValueIsAdjusting()) {
                    this.firstChangedIndex = Math.min(this.firstChangedIndex, this.firstAdjustedIndex);
                    this.lastChangedIndex = Math.max(this.lastChangedIndex, this.lastAdjustedIndex);
                }
                var oldFirstAdjustedIndex = this.firstAdjustedIndex;
                var oldLastAdjustedIndex = this.lastAdjustedIndex;
                this.firstAdjustedIndex = DefaultListSelectionModel.MAX_$LI$();
                this.lastAdjustedIndex = DefaultListSelectionModel.MIN;
                this.fireValueChanged(oldFirstAdjustedIndex, oldLastAdjustedIndex);
            };
            /**
             * Returns an array of all the objects currently registered as
             * <code><em>Foo</em>Listener</code>s
             * upon this model.
             * <code><em>Foo</em>Listener</code>s
             * are registered using the <code>add<em>Foo</em>Listener</code> method.
             * <p>
             * You can specify the <code>listenerType</code> argument
             * with a class literal, such as <code><em>Foo</em>Listener.class</code>.
             * For example, you can query a <code>DefaultListSelectionModel</code>
             * instance <code>m</code>
             * for its list selection listeners
             * with the following code:
             *
             * <pre>ListSelectionListener[] lsls = (ListSelectionListener[])(m.getListeners(ListSelectionListener.class));</pre>
             *
             * If no such listeners exist,
             * this method returns an empty array.
             *
             * @param listenerType  the type of listeners requested;
             * this parameter should specify an interface
             * that descends from <code>java.util.EventListener</code>
             * @return an array of all objects registered as
             * <code><em>Foo</em>Listener</code>s
             * on this model,
             * or an empty array if no such
             * listeners have been added
             * @exception ClassCastException if <code>listenerType</code> doesn't
             * specify a class or interface that implements
             * <code>java.util.EventListener</code>
             *
             * @see #getListSelectionListeners
             *
             * @since 1.3
             */
            DefaultListSelectionModel.prototype.getListeners = function (listenerType) {
                return this.listenerList.getListeners(listenerType);
            };
            DefaultListSelectionModel.prototype.markAsDirty = function (r) {
                if (r === -1) {
                    return;
                }
                this.firstAdjustedIndex = Math.min(this.firstAdjustedIndex, r);
                this.lastAdjustedIndex = Math.max(this.lastAdjustedIndex, r);
            };
            DefaultListSelectionModel.prototype.set = function (r) {
                if (this.value.get(r)) {
                    return;
                }
                this.value.set(r);
                this.markAsDirty(r);
                this.minIndex = Math.min(this.minIndex, r);
                this.maxIndex = Math.max(this.maxIndex, r);
            };
            DefaultListSelectionModel.prototype.clear = function (r) {
                if (!this.value.get(r)) {
                    return;
                }
                this.value.clear(r);
                this.markAsDirty(r);
                if (r === this.minIndex) {
                    for (this.minIndex = this.minIndex + 1; this.minIndex <= this.maxIndex; this.minIndex++) {
                        if (this.value.get(this.minIndex)) {
                            break;
                        }
                    }
                }
                if (r === this.maxIndex) {
                    for (this.maxIndex = this.maxIndex - 1; this.minIndex <= this.maxIndex; this.maxIndex--) {
                        if (this.value.get(this.maxIndex)) {
                            break;
                        }
                    }
                }
                if (this.isSelectionEmpty()) {
                    this.minIndex = DefaultListSelectionModel.MAX_$LI$();
                    this.maxIndex = DefaultListSelectionModel.MIN;
                }
            };
            /**
             * Sets the value of the leadAnchorNotificationEnabled flag.
             * @see             #isLeadAnchorNotificationEnabled()
             */
            DefaultListSelectionModel.prototype.setLeadAnchorNotificationEnabled = function (flag) {
                this.leadAnchorNotificationEnabled = flag;
            };
            /**
             * Returns the value of the <code>leadAnchorNotificationEnabled</code> flag.
             * When <code>leadAnchorNotificationEnabled</code> is true the model
             * generates notification events with bounds that cover all the changes to
             * the selection plus the changes to the lead and anchor indices.
             * Setting the flag to false causes a narrowing of the event's bounds to
             * include only the elements that have been selected or deselected since
             * the last change. Either way, the model continues to maintain the lead
             * and anchor variables internally. The default is true.
             * <p>
             * Note: It is possible for the lead or anchor to be changed without a
             * change to the selection. Notification of these changes is often
             * important, such as when the new lead or anchor needs to be updated in
             * the view. Therefore, caution is urged when changing the default value.
             *
             * @return  the value of the <code>leadAnchorNotificationEnabled</code> flag
             * @see             #setLeadAnchorNotificationEnabled(boolean)
             */
            DefaultListSelectionModel.prototype.isLeadAnchorNotificationEnabled = function () {
                return this.leadAnchorNotificationEnabled;
            };
            DefaultListSelectionModel.prototype.updateLeadAnchorIndices = function (anchorIndex, leadIndex) {
                if (this.leadAnchorNotificationEnabled) {
                    if (this.anchorIndex !== anchorIndex) {
                        this.markAsDirty(this.anchorIndex);
                        this.markAsDirty(anchorIndex);
                    }
                    if (this.leadIndex !== leadIndex) {
                        this.markAsDirty(this.leadIndex);
                        this.markAsDirty(leadIndex);
                    }
                }
                this.anchorIndex = anchorIndex;
                this.leadIndex = leadIndex;
            };
            DefaultListSelectionModel.prototype.contains = function (a, b, i) {
                return (i >= a) && (i <= b);
            };
            DefaultListSelectionModel.prototype.changeSelection = function (clearMin, clearMax, setMin, setMax, clearFirst) {
                if (clearFirst === void 0) { clearFirst = true; }
                for (var i = Math.min(setMin, clearMin); i <= Math.max(setMax, clearMax); i++) {
                    var shouldClear = this.contains(clearMin, clearMax, i);
                    var shouldSet = this.contains(setMin, setMax, i);
                    if (shouldSet && shouldClear) {
                        if (clearFirst) {
                            shouldClear = false;
                        }
                        else {
                            shouldSet = false;
                        }
                    }
                    if (shouldSet) {
                        this.set(i);
                    }
                    if (shouldClear) {
                        this.clear(i);
                    }
                }
                this.fireValueChanged();
            };
            /**
             * {@inheritDoc}
             */
            DefaultListSelectionModel.prototype.clearSelection = function () {
                this.removeSelectionIntervalImpl(this.minIndex, this.maxIndex, false);
            };
            /**
             * Changes the selection to be between {@code index0} and {@code index1}
             * inclusive. {@code index0} doesn't have to be less than or equal to
             * {@code index1}.
             * <p>
             * In {@code SINGLE_SELECTION} selection mode, only the second index
             * is used.
             * <p>
             * If this represents a change to the current selection, then each
             * {@code ListSelectionListener} is notified of the change.
             * <p>
             * If either index is {@code -1}, this method does nothing and returns
             * without exception. Otherwise, if either index is less than {@code -1},
             * an {@code IndexOutOfBoundsException} is thrown.
             *
             * @param index0 one end of the interval.
             * @param index1 other end of the interval
             * @throws IndexOutOfBoundsException if either index is less than {@code -1}
             * (and neither index is {@code -1})
             * @see #addListSelectionListener
             */
            DefaultListSelectionModel.prototype.setSelectionInterval = function (index0, index1) {
                if (index0 === -1 || index1 === -1) {
                    return;
                }
                if (this.getSelectionMode() === javax.swing.ListSelectionModel.SINGLE_SELECTION) {
                    index0 = index1;
                }
                this.updateLeadAnchorIndices(index0, index1);
                var clearMin = this.minIndex;
                var clearMax = this.maxIndex;
                var setMin = Math.min(index0, index1);
                var setMax = Math.max(index0, index1);
                this.changeSelection(clearMin, clearMax, setMin, setMax);
            };
            /**
             * Changes the selection to be the set union of the current selection
             * and the indices between {@code index0} and {@code index1} inclusive.
             * <p>
             * In {@code SINGLE_SELECTION} selection mode, this is equivalent
             * to calling {@code setSelectionInterval}, and only the second index
             * is used. In {@code SINGLE_INTERVAL_SELECTION} selection mode, this
             * method behaves like {@code setSelectionInterval}, unless the given
             * interval is immediately adjacent to or overlaps the existing selection,
             * and can therefore be used to grow it.
             * <p>
             * If this represents a change to the current selection, then each
             * {@code ListSelectionListener} is notified of the change. Note that
             * {@code index0} doesn't have to be less than or equal to {@code index1}.
             * <p>
             * If either index is {@code -1}, this method does nothing and returns
             * without exception. Otherwise, if either index is less than {@code -1},
             * an {@code IndexOutOfBoundsException} is thrown.
             *
             * @param index0 one end of the interval.
             * @param index1 other end of the interval
             * @throws IndexOutOfBoundsException if either index is less than {@code -1}
             * (and neither index is {@code -1})
             * @see #addListSelectionListener
             * @see #setSelectionInterval
             */
            DefaultListSelectionModel.prototype.addSelectionInterval = function (index0, index1) {
                if (index0 === -1 || index1 === -1) {
                    return;
                }
                if (this.getSelectionMode() === javax.swing.ListSelectionModel.SINGLE_SELECTION) {
                    this.setSelectionInterval(index0, index1);
                    return;
                }
                this.updateLeadAnchorIndices(index0, index1);
                var clearMin = DefaultListSelectionModel.MAX_$LI$();
                var clearMax = DefaultListSelectionModel.MIN;
                var setMin = Math.min(index0, index1);
                var setMax = Math.max(index0, index1);
                if (this.getSelectionMode() === javax.swing.ListSelectionModel.SINGLE_INTERVAL_SELECTION && (setMax < this.minIndex - 1 || setMin > this.maxIndex + 1)) {
                    this.setSelectionInterval(index0, index1);
                    return;
                }
                this.changeSelection(clearMin, clearMax, setMin, setMax);
            };
            /**
             * Changes the selection to be the set difference of the current selection
             * and the indices between {@code index0} and {@code index1} inclusive.
             * {@code index0} doesn't have to be less than or equal to {@code index1}.
             * <p>
             * In {@code SINGLE_INTERVAL_SELECTION} selection mode, if the removal
             * would produce two disjoint selections, the removal is extended through
             * the greater end of the selection. For example, if the selection is
             * {@code 0-10} and you supply indices {@code 5,6} (in any order) the
             * resulting selection is {@code 0-4}.
             * <p>
             * If this represents a change to the current selection, then each
             * {@code ListSelectionListener} is notified of the change.
             * <p>
             * If either index is {@code -1}, this method does nothing and returns
             * without exception. Otherwise, if either index is less than {@code -1},
             * an {@code IndexOutOfBoundsException} is thrown.
             *
             * @param index0 one end of the interval
             * @param index1 other end of the interval
             * @throws IndexOutOfBoundsException if either index is less than {@code -1}
             * (and neither index is {@code -1})
             * @see #addListSelectionListener
             */
            DefaultListSelectionModel.prototype.removeSelectionInterval = function (index0, index1) {
                this.removeSelectionIntervalImpl(index0, index1, true);
            };
            DefaultListSelectionModel.prototype.removeSelectionIntervalImpl = function (index0, index1, changeLeadAnchor) {
                if (index0 === -1 || index1 === -1) {
                    return;
                }
                if (changeLeadAnchor) {
                    this.updateLeadAnchorIndices(index0, index1);
                }
                var clearMin = Math.min(index0, index1);
                var clearMax = Math.max(index0, index1);
                var setMin = DefaultListSelectionModel.MAX_$LI$();
                var setMax = DefaultListSelectionModel.MIN;
                if (this.getSelectionMode() !== javax.swing.ListSelectionModel.MULTIPLE_INTERVAL_SELECTION && clearMin > this.minIndex && clearMax < this.maxIndex) {
                    clearMax = this.maxIndex;
                }
                this.changeSelection(clearMin, clearMax, setMin, setMax);
            };
            DefaultListSelectionModel.prototype.setState = function (index, state) {
                if (state) {
                    this.set(index);
                }
                else {
                    this.clear(index);
                }
            };
            /**
             * Insert length indices beginning before/after index. If the value
             * at index is itself selected and the selection mode is not
             * SINGLE_SELECTION, set all of the newly inserted items as selected.
             * Otherwise leave them unselected. This method is typically
             * called to sync the selection model with a corresponding change
             * in the data model.
             */
            DefaultListSelectionModel.prototype.insertIndexInterval = function (index, length, before) {
                var insMinIndex = (before) ? index : index + 1;
                var insMaxIndex = (insMinIndex + length) - 1;
                for (var i = this.maxIndex; i >= insMinIndex; i--) {
                    this.setState(i + length, this.value.get(i));
                }
                var setInsertedValues = ((this.getSelectionMode() === javax.swing.ListSelectionModel.SINGLE_SELECTION) ? false : this.value.get(index));
                for (var i = insMinIndex; i <= insMaxIndex; i++) {
                    this.setState(i, setInsertedValues);
                }
                var leadIndex = this.leadIndex;
                if (leadIndex > index || (before && leadIndex === index)) {
                    leadIndex = this.leadIndex + length;
                }
                var anchorIndex = this.anchorIndex;
                if (anchorIndex > index || (before && anchorIndex === index)) {
                    anchorIndex = this.anchorIndex + length;
                }
                if (leadIndex !== this.leadIndex || anchorIndex !== this.anchorIndex) {
                    this.updateLeadAnchorIndices(anchorIndex, leadIndex);
                }
                this.fireValueChanged();
            };
            /**
             * Remove the indices in the interval index0,index1 (inclusive) from
             * the selection model.  This is typically called to sync the selection
             * model width a corresponding change in the data model.  Note
             * that (as always) index0 need not be &lt;= index1.
             */
            DefaultListSelectionModel.prototype.removeIndexInterval = function (index0, index1) {
                var rmMinIndex = Math.min(index0, index1);
                var rmMaxIndex = Math.max(index0, index1);
                var gapLength = (rmMaxIndex - rmMinIndex) + 1;
                for (var i = rmMinIndex; i <= this.maxIndex; i++) {
                    this.setState(i, this.value.get(i + gapLength));
                }
                var leadIndex = this.leadIndex;
                if (leadIndex === 0 && rmMinIndex === 0) {
                }
                else if (leadIndex > rmMaxIndex) {
                    leadIndex = this.leadIndex - gapLength;
                }
                else if (leadIndex >= rmMinIndex) {
                    leadIndex = rmMinIndex - 1;
                }
                var anchorIndex = this.anchorIndex;
                if (anchorIndex === 0 && rmMinIndex === 0) {
                }
                else if (anchorIndex > rmMaxIndex) {
                    anchorIndex = this.anchorIndex - gapLength;
                }
                else if (anchorIndex >= rmMinIndex) {
                    anchorIndex = rmMinIndex - 1;
                }
                if (leadIndex !== this.leadIndex || anchorIndex !== this.anchorIndex) {
                    this.updateLeadAnchorIndices(anchorIndex, leadIndex);
                }
                this.fireValueChanged();
            };
            /**
             * {@inheritDoc}
             */
            DefaultListSelectionModel.prototype.setValueIsAdjusting = function (isAdjusting) {
                if (isAdjusting !== this.isAdjusting) {
                    this.isAdjusting = isAdjusting;
                    this.fireValueChanged(isAdjusting);
                }
            };
            /**
             * Returns a string that displays and identifies this
             * object's properties.
             *
             * @return a <code>String</code> representation of this object
             */
            DefaultListSelectionModel.prototype.toString = function () {
                var s = ((this.getValueIsAdjusting()) ? "~" : "=") + this.value.toString();
                return (function (c) { return c["__class"] ? c["__class"] : c.name; })(this.constructor) + " " + ('' + this.hashCode()) + " " + s;
            };
            /**
             * Returns a clone of this selection model with the same selection.
             * <code>listenerLists</code> are not duplicated.
             *
             * @exception CloneNotSupportedException if the selection model does not
             * both (a) implement the Cloneable interface and (b) define a
             * <code>clone</code> method.
             */
            DefaultListSelectionModel.prototype.clone = function () {
                var clone = javaemul.internal.ObjectHelper.clone(this);
                clone.value = this.value.clone();
                clone.listenerList = new javax.swing.event.EventListenerList();
                return clone;
            };
            /**
             * {@inheritDoc}
             */
            DefaultListSelectionModel.prototype.getAnchorSelectionIndex = function () {
                return this.anchorIndex;
            };
            /**
             * {@inheritDoc}
             */
            DefaultListSelectionModel.prototype.getLeadSelectionIndex = function () {
                return this.leadIndex;
            };
            /**
             * Set the anchor selection index, leaving all selection values unchanged.
             * If leadAnchorNotificationEnabled is true, send a notification covering
             * the old and new anchor cells.
             *
             * @see #getAnchorSelectionIndex
             * @see #setLeadSelectionIndex
             */
            DefaultListSelectionModel.prototype.setAnchorSelectionIndex = function (anchorIndex) {
                this.updateLeadAnchorIndices(anchorIndex, this.leadIndex);
                this.fireValueChanged();
            };
            /**
             * Set the lead selection index, leaving all selection values unchanged.
             * If leadAnchorNotificationEnabled is true, send a notification covering
             * the old and new lead cells.
             *
             * @param leadIndex the new lead selection index
             *
             * @see #setAnchorSelectionIndex
             * @see #setLeadSelectionIndex
             * @see #getLeadSelectionIndex
             *
             * @since 1.5
             */
            DefaultListSelectionModel.prototype.moveLeadSelectionIndex = function (leadIndex) {
                if (leadIndex === -1) {
                    if (this.anchorIndex !== -1) {
                        return;
                    }
                }
                this.updateLeadAnchorIndices(this.anchorIndex, leadIndex);
                this.fireValueChanged();
            };
            /**
             * Sets the lead selection index, ensuring that values between the
             * anchor and the new lead are either all selected or all deselected.
             * If the value at the anchor index is selected, first clear all the
             * values in the range [anchor, oldLeadIndex], then select all the values
             * values in the range [anchor, newLeadIndex], where oldLeadIndex is the old
             * leadIndex and newLeadIndex is the new one.
             * <p>
             * If the value at the anchor index is not selected, do the same thing in
             * reverse selecting values in the old range and deselecting values in the
             * new one.
             * <p>
             * Generate a single event for this change and notify all listeners.
             * For the purposes of generating minimal bounds in this event, do the
             * operation in a single pass; that way the first and last index inside the
             * ListSelectionEvent that is broadcast will refer to cells that actually
             * changed value because of this method. If, instead, this operation were
             * done in two steps the effect on the selection state would be the same
             * but two events would be generated and the bounds around the changed
             * values would be wider, including cells that had been first cleared only
             * to later be set.
             * <p>
             * This method can be used in the <code>mouseDragged</code> method
             * of a UI class to extend a selection.
             *
             * @see #getLeadSelectionIndex
             * @see #setAnchorSelectionIndex
             */
            DefaultListSelectionModel.prototype.setLeadSelectionIndex = function (leadIndex) {
                var anchorIndex = this.anchorIndex;
                if (leadIndex === -1) {
                    if (anchorIndex === -1) {
                        this.updateLeadAnchorIndices(anchorIndex, leadIndex);
                        this.fireValueChanged();
                    }
                    return;
                }
                else if (anchorIndex === -1) {
                    return;
                }
                if (this.leadIndex === -1) {
                    this.leadIndex = leadIndex;
                }
                var shouldSelect = this.value.get(this.anchorIndex);
                if (this.getSelectionMode() === javax.swing.ListSelectionModel.SINGLE_SELECTION) {
                    anchorIndex = leadIndex;
                    shouldSelect = true;
                }
                var oldMin = Math.min(this.anchorIndex, this.leadIndex);
                var oldMax = Math.max(this.anchorIndex, this.leadIndex);
                var newMin = Math.min(anchorIndex, leadIndex);
                var newMax = Math.max(anchorIndex, leadIndex);
                this.updateLeadAnchorIndices(anchorIndex, leadIndex);
                if (shouldSelect) {
                    this.changeSelection(oldMin, oldMax, newMin, newMax);
                }
                else {
                    this.changeSelection(newMin, newMax, oldMin, oldMax, false);
                }
            };
            DefaultListSelectionModel.MIN = -1;
            return DefaultListSelectionModel;
        }());
        swing.DefaultListSelectionModel = DefaultListSelectionModel;
        DefaultListSelectionModel["__class"] = "javax.swing.DefaultListSelectionModel";
        DefaultListSelectionModel["__interfaces"] = ["javax.swing.ListSelectionModel", "java.lang.Cloneable", "java.io.Serializable"];
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        /**
         * A generic implementation of SingleSelectionModel.
         * <p>
         * <strong>Warning:</strong>
         * Serialized objects of this class will not be compatible with
         * future Swing releases. The current serialization support is
         * appropriate for short term storage or RMI between applications running
         * the same version of Swing.  As of 1.4, support for long term storage
         * of all JavaBeans&trade;
         * has been added to the <code>java.beans</code> package.
         * Please see {@link java.beans.XMLEncoder}.
         *
         * @author Dave Moore
         */
        var DefaultSingleSelectionModel = (function () {
            function DefaultSingleSelectionModel() {
                this.changeEvent = null;
                /**
                 * The collection of registered listeners
                 */
                this.listenerList = new javax.swing.event.EventListenerList();
                this.index = -1;
            }
            DefaultSingleSelectionModel.prototype.getSelectedIndex = function () {
                return this.index;
            };
            DefaultSingleSelectionModel.prototype.setSelectedIndex = function (index) {
                if (this.index !== index) {
                    this.index = index;
                    this.fireStateChanged();
                }
            };
            DefaultSingleSelectionModel.prototype.clearSelection = function () {
                this.setSelectedIndex(-1);
            };
            DefaultSingleSelectionModel.prototype.isSelected = function () {
                var ret = false;
                if (this.getSelectedIndex() !== -1) {
                    ret = true;
                }
                return ret;
            };
            /**
             * Adds a <code>ChangeListener</code> to the button.
             */
            DefaultSingleSelectionModel.prototype.addChangeListener = function (l) {
                this.listenerList.add("javax.swing.event.ChangeListener", l);
            };
            /**
             * Removes a <code>ChangeListener</code> from the button.
             */
            DefaultSingleSelectionModel.prototype.removeChangeListener = function (l) {
                this.listenerList.remove("javax.swing.event.ChangeListener", l);
            };
            /**
             * Returns an array of all the change listeners
             * registered on this <code>DefaultSingleSelectionModel</code>.
             *
             * @return all of this model's <code>ChangeListener</code>s
             * or an empty
             * array if no change listeners are currently registered
             *
             * @see #addChangeListener
             * @see #removeChangeListener
             *
             * @since 1.4
             */
            DefaultSingleSelectionModel.prototype.getChangeListeners = function () {
                return this.listenerList.getListeners("javax.swing.event.ChangeListener");
            };
            /**
             * Notifies all listeners that have registered interest for
             * notification on this event type.  The event instance
             * is created lazily.
             * @see EventListenerList
             */
            DefaultSingleSelectionModel.prototype.fireStateChanged = function () {
                var listeners = this.listenerList.getListenerList();
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "javax.swing.event.ChangeListener") {
                        if (this.changeEvent == null)
                            this.changeEvent = new javax.swing.event.ChangeEvent(this);
                        listeners[i + 1].stateChanged(this.changeEvent);
                    }
                }
            };
            /**
             * Returns an array of all the objects currently registered as
             * <code><em>Foo</em>Listener</code>s
             * upon this model.
             * <code><em>Foo</em>Listener</code>s
             * are registered using the <code>add<em>Foo</em>Listener</code> method.
             * <p>
             * You can specify the <code>listenerType</code> argument
             * with a class literal, such as <code><em>Foo</em>Listener.class</code>.
             * For example, you can query a <code>DefaultSingleSelectionModel</code>
             * instance <code>m</code>
             * for its change listeners
             * with the following code:
             *
             * <pre>ChangeListener[] cls = (ChangeListener[])(m.getListeners(ChangeListener.class));</pre>
             *
             * If no such listeners exist,
             * this method returns an empty array.
             *
             * @param listenerType  the type of listeners requested;
             * this parameter should specify an interface
             * that descends from <code>java.util.EventListener</code>
             * @return an array of all objects registered as
             * <code><em>Foo</em>Listener</code>s
             * on this model,
             * or an empty array if no such
             * listeners have been added
             * @exception ClassCastException if <code>listenerType</code> doesn't
             * specify a class or interface that implements
             * <code>java.util.EventListener</code>
             *
             * @see #getChangeListeners
             *
             * @since 1.3
             */
            DefaultSingleSelectionModel.prototype.getListeners = function (listenerType) {
                return this.listenerList.getListeners(listenerType);
            };
            return DefaultSingleSelectionModel;
        }());
        swing.DefaultSingleSelectionModel = DefaultSingleSelectionModel;
        DefaultSingleSelectionModel["__class"] = "javax.swing.DefaultSingleSelectionModel";
        DefaultSingleSelectionModel["__interfaces"] = ["javax.swing.SingleSelectionModel", "java.io.Serializable"];
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        /**
         * Drop modes, used to determine the method by which a component
         * tracks and indicates a drop location during drag and drop.
         *
         * @author Shannon Hickey
         * @see JTable#setDropMode
         * @see JList#setDropMode
         * @see JTree#setDropMode
         * @see javax.swing.text.JTextComponent#setDropMode
         * @since 1.6
         */
        (function (DropMode) {
            DropMode[DropMode["USE_SELECTION"] = 0] = "USE_SELECTION";
            DropMode[DropMode["ON"] = 1] = "ON";
            DropMode[DropMode["INSERT"] = 2] = "INSERT";
            DropMode[DropMode["INSERT_ROWS"] = 3] = "INSERT_ROWS";
            DropMode[DropMode["INSERT_COLS"] = 4] = "INSERT_COLS";
            DropMode[DropMode["ON_OR_INSERT"] = 5] = "ON_OR_INSERT";
            DropMode[DropMode["ON_OR_INSERT_ROWS"] = 6] = "ON_OR_INSERT_ROWS";
            DropMode[DropMode["ON_OR_INSERT_COLS"] = 7] = "ON_OR_INSERT_COLS";
        })(swing.DropMode || (swing.DropMode = {}));
        var DropMode = swing.DropMode;
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var event;
        (function (event) {
            var ChangeEvent = (function (_super) {
                __extends(ChangeEvent, _super);
                function ChangeEvent(source) {
                    _super.call(this, source);
                }
                return ChangeEvent;
            }(java.util.EventObject));
            event.ChangeEvent = ChangeEvent;
            ChangeEvent["__class"] = "javax.swing.event.ChangeEvent";
            ChangeEvent["__interfaces"] = ["java.io.Serializable"];
        })(event = swing.event || (swing.event = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var event;
        (function (event) {
            var EventListenerList = (function () {
                function EventListenerList() {
                    this.listenerList = EventListenerList.NULL_ARRAY_$LI$();
                }
                EventListenerList.NULL_ARRAY_$LI$ = function () { if (EventListenerList.NULL_ARRAY == null)
                    EventListenerList.NULL_ARRAY = new Array(0); return EventListenerList.NULL_ARRAY; };
                ;
                EventListenerList.prototype.getListenerList = function () {
                    return this.listenerList;
                };
                EventListenerList.prototype.getListeners = function (t) {
                    var _this = this;
                    if (((t != null && t instanceof java.lang.Class) || t === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            var lList = _this.listenerList;
                            var n = _this.getListenerCount(lList, t);
                            var result = new Array(n);
                            var j = 0;
                            for (var i = lList.length - 2; i >= 0; i -= 2) {
                                if (lList[i] === t) {
                                    result[j++] = lList[i + 1];
                                }
                            }
                            return result;
                        })();
                    }
                    else if (((typeof t === 'string') || t === null)) {
                        return this.getListeners$java_lang_String(t);
                    }
                    else
                        throw new Error('invalid overload');
                };
                EventListenerList.prototype.getListeners$java_lang_String = function (t) {
                    var lList = this.listenerList;
                    var n = this.getListenerCount(lList, t);
                    var result = new Array(n);
                    var j = 0;
                    for (var i = lList.length - 2; i >= 0; i -= 2) {
                        if (lList[i] === t) {
                            result[j++] = lList[i + 1];
                        }
                    }
                    return result;
                };
                EventListenerList.prototype.getListenerCount$ = function () {
                    return (this.listenerList.length / 2 | 0);
                };
                EventListenerList.prototype.getListenerCount$java_lang_Class = function (t) {
                    var lList = this.listenerList;
                    return this.getListenerCount(lList, t);
                };
                EventListenerList.prototype.getListenerCount$java_lang_String = function (t) {
                    var lList = this.listenerList;
                    return this.getListenerCount(lList, t);
                };
                EventListenerList.prototype.getListenerCount = function (list, t) {
                    if (((list != null && list instanceof Array) || list === null) && ((t != null && t instanceof java.lang.Class) || t === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            var count = 0;
                            for (var i = 0; i < list.length; i += 2) {
                                if (t === list[i])
                                    count++;
                            }
                            return count;
                        })();
                    }
                    else if (((list != null && list instanceof Array) || list === null) && ((typeof t === 'string') || t === null)) {
                        return this.getListenerCount$java_lang_Object_A$java_lang_String(list, t);
                    }
                    else if (((list != null && list instanceof java.lang.Class) || list === null) && t === undefined) {
                        return this.getListenerCount$java_lang_Class(list);
                    }
                    else if (((typeof list === 'string') || list === null) && t === undefined) {
                        return this.getListenerCount$java_lang_String(list);
                    }
                    else if (list === undefined && t === undefined) {
                        return this.getListenerCount$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                EventListenerList.prototype.getListenerCount$java_lang_Object_A$java_lang_String = function (list, t) {
                    var count = 0;
                    for (var i = 0; i < list.length; i += 2) {
                        if (t === list[i])
                            count++;
                    }
                    return count;
                };
                EventListenerList.prototype.add = function (t, l) {
                    if (l == null) {
                        return;
                    }
                    if (this.listenerList === EventListenerList.NULL_ARRAY_$LI$()) {
                        this.listenerList = [t, l];
                    }
                    else {
                        var i = this.listenerList.length;
                        var tmp = new Array(i + 2);
                        java.lang.System.arraycopy(this.listenerList, 0, tmp, 0, i);
                        tmp[i] = t;
                        tmp[i + 1] = l;
                        this.listenerList = tmp;
                    }
                };
                EventListenerList.prototype.remove = function (t, l) {
                    if (l == null) {
                        return;
                    }
                    var index = -1;
                    for (var i = this.listenerList.length - 2; i >= 0; i -= 2) {
                        if ((this.listenerList[i] === t) && ((this.listenerList[i + 1] === l) === true)) {
                            index = i;
                            break;
                        }
                    }
                    if (index !== -1) {
                        var tmp = new Array(this.listenerList.length - 2);
                        java.lang.System.arraycopy(this.listenerList, 0, tmp, 0, index);
                        if (index < tmp.length)
                            java.lang.System.arraycopy(this.listenerList, index + 2, tmp, index, tmp.length - index);
                        this.listenerList = (tmp.length === 0) ? EventListenerList.NULL_ARRAY_$LI$() : tmp;
                    }
                };
                /**
                 * Returns a string representation of the EventListenerList.
                 */
                EventListenerList.prototype.toString = function () {
                    var lList = this.listenerList;
                    var s = "EventListenerList: ";
                    s += (lList.length / 2 | 0) + " listeners: ";
                    for (var i = 0; i <= lList.length - 2; i += 2) {
                        s += " type " + (function (c) { return c["__class"] ? c["__class"] : c.name; })(lList[i]);
                        s += " listener " + lList[i + 1];
                    }
                    return s;
                };
                return EventListenerList;
            }());
            event.EventListenerList = EventListenerList;
            EventListenerList["__class"] = "javax.swing.event.EventListenerList";
            EventListenerList["__interfaces"] = ["java.io.Serializable"];
        })(event = swing.event || (swing.event = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var event;
        (function (event) {
            var ListDataEvent = (function (_super) {
                __extends(ListDataEvent, _super);
                function ListDataEvent(source, type, index0, index1) {
                    _super.call(this, source);
                    this.type = 0;
                    this.index0 = 0;
                    this.index1 = 0;
                    this.type = type;
                    this.index0 = Math.min(index0, index1);
                    this.index1 = Math.max(index0, index1);
                }
                ListDataEvent.prototype.getType = function () {
                    return this.type;
                };
                ListDataEvent.prototype.getIndex0 = function () {
                    return this.index0;
                };
                ListDataEvent.prototype.getIndex1 = function () {
                    return this.index1;
                };
                ListDataEvent.prototype.toString = function () {
                    return (function (c) { return c["__class"] ? c["__class"] : c.name; })(this.constructor) + "[type=" + this.type + ",index0=" + this.index0 + ",index1=" + this.index1 + "]";
                };
                ListDataEvent.CONTENTS_CHANGED = 0;
                ListDataEvent.INTERVAL_ADDED = 1;
                ListDataEvent.INTERVAL_REMOVED = 2;
                return ListDataEvent;
            }(java.util.EventObject));
            event.ListDataEvent = ListDataEvent;
            ListDataEvent["__class"] = "javax.swing.event.ListDataEvent";
            ListDataEvent["__interfaces"] = ["java.io.Serializable"];
        })(event = swing.event || (swing.event = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var event;
        (function (event) {
            /**
             * An event that characterizes a change in selection. The change is limited to a
             * a single inclusive interval. The selection of at least one index within the
             * range will have changed. A decent {@code ListSelectionModel} implementation
             * will keep the range as small as possible. {@code ListSelectionListeners} will
             * generally query the source of the event for the new selected status of each
             * potentially changed row.
             * <p>
             * <strong>Warning:</strong>
             * Serialized objects of this class will not be compatible with
             * future Swing releases. The current serialization support is
             * appropriate for short term storage or RMI between applications running
             * the same version of Swing.  As of 1.4, support for long term storage
             * of all JavaBeans&trade;
             * has been added to the <code>java.beans</code> package.
             * Please see {@link java.beans.XMLEncoder}.
             *
             * @author Hans Muller
             * @author Ray Ryan
             * @see ListSelectionModel
             */
            var ListSelectionEvent = (function (_super) {
                __extends(ListSelectionEvent, _super);
                /**
                 * Represents a change in selection status between {@code firstIndex} and
                 * {@code lastIndex}, inclusive. {@code firstIndex} is less than or equal to
                 * {@code lastIndex}. The selection of at least one index within the range will
                 * have changed.
                 *
                 * @param firstIndex the first index in the range, &lt;= lastIndex
                 * @param lastIndex the last index in the range, &gt;= firstIndex
                 * @param isAdjusting whether or not this is one in a series of
                 * multiple events, where changes are still being made
                 */
                function ListSelectionEvent(source, firstIndex, lastIndex, isAdjusting) {
                    _super.call(this, source);
                    this.firstIndex = 0;
                    this.lastIndex = 0;
                    this.isAdjusting = false;
                    this.firstIndex = firstIndex;
                    this.lastIndex = lastIndex;
                    this.isAdjusting = isAdjusting;
                }
                /**
                 * Returns the index of the first row whose selection may have changed.
                 * {@code getFirstIndex() &lt;= getLastIndex()}
                 *
                 * @return the first row whose selection value may have changed,
                 * where zero is the first row
                 */
                ListSelectionEvent.prototype.getFirstIndex = function () {
                    return this.firstIndex;
                };
                /**
                 * Returns the index of the last row whose selection may have changed.
                 * {@code getLastIndex() &gt;= getFirstIndex()}
                 *
                 * @return the last row whose selection value may have changed,
                 * where zero is the first row
                 */
                ListSelectionEvent.prototype.getLastIndex = function () {
                    return this.lastIndex;
                };
                /**
                 * Returns whether or not this is one in a series of multiple events,
                 * where changes are still being made. See the documentation for
                 * {@link javax.swing.ListSelectionModel#setValueIsAdjusting} for
                 * more details on how this is used.
                 *
                 * @return {@code true} if this is one in a series of multiple events,
                 * where changes are still being made
                 */
                ListSelectionEvent.prototype.getValueIsAdjusting = function () {
                    return this.isAdjusting;
                };
                /**
                 * Returns a {@code String} that displays and identifies this
                 * object's properties.
                 *
                 * @return a String representation of this object
                 */
                ListSelectionEvent.prototype.toString = function () {
                    var properties = " source=" + this.getSource() + " firstIndex= " + this.firstIndex + " lastIndex= " + this.lastIndex + " isAdjusting= " + this.isAdjusting + " ";
                    return (function (c) { return c["__class"] ? c["__class"] : c.name; })(this.constructor) + "[" + properties + "]";
                };
                return ListSelectionEvent;
            }(java.util.EventObject));
            event.ListSelectionEvent = ListSelectionEvent;
            ListSelectionEvent["__class"] = "javax.swing.event.ListSelectionEvent";
            ListSelectionEvent["__interfaces"] = ["java.io.Serializable"];
        })(event = swing.event || (swing.event = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var event;
        (function (event) {
            /**
             * MenuEvent is used to notify interested parties that
             * the menu which is the event source has been posted,
             * selected, or canceled.
             * <p>
             * <strong>Warning:</strong>
             * Serialized objects of this class will not be compatible with
             * future Swing releases. The current serialization support is
             * appropriate for short term storage or RMI between applications running
             * the same version of Swing.  As of 1.4, support for long term storage
             * of all JavaBeans&trade;
             * has been added to the <code>java.beans</code> package.
             * Please see {@link java.beans.XMLEncoder}.
             *
             * @author Georges Saab
             * @author David Karlton
             */
            var MenuEvent = (function (_super) {
                __extends(MenuEvent, _super);
                /**
                 * Constructs a MenuEvent object.
                 *
                 * @param source  the Object that originated the event
                 * (typically <code>this</code>)
                 */
                function MenuEvent(source) {
                    _super.call(this, source);
                }
                return MenuEvent;
            }(java.util.EventObject));
            event.MenuEvent = MenuEvent;
            MenuEvent["__class"] = "javax.swing.event.MenuEvent";
            MenuEvent["__interfaces"] = ["java.io.Serializable"];
        })(event = swing.event || (swing.event = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var event;
        (function (event) {
            /**
             * PopupMenuEvent only contains the source of the event which is the JPoupMenu
             * sending the event
             * <p>
             * <strong>Warning:</strong>
             * Serialized objects of this class will not be compatible with
             * future Swing releases. The current serialization support is
             * appropriate for short term storage or RMI between applications running
             * the same version of Swing.  As of 1.4, support for long term storage
             * of all JavaBeans&trade;
             * has been added to the <code>java.beans</code> package.
             * Please see {@link java.beans.XMLEncoder}.
             *
             * @author Arnaud Weber
             */
            var PopupMenuEvent = (function (_super) {
                __extends(PopupMenuEvent, _super);
                /**
                 * Constructs a PopupMenuEvent object.
                 *
                 * @param source  the Object that originated the event
                 * (typically <code>this</code>)
                 */
                function PopupMenuEvent(source) {
                    _super.call(this, source);
                }
                return PopupMenuEvent;
            }(java.util.EventObject));
            event.PopupMenuEvent = PopupMenuEvent;
            PopupMenuEvent["__class"] = "javax.swing.event.PopupMenuEvent";
            PopupMenuEvent["__interfaces"] = ["java.io.Serializable"];
        })(event = swing.event || (swing.event = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var event;
        (function (event) {
            /**
             * An event indicating that an operation which can be undone has occurred.
             * <p>
             * <strong>Warning:</strong>
             * Serialized objects of this class will not be compatible with
             * future Swing releases. The current serialization support is
             * appropriate for short term storage or RMI between applications running
             * the same version of Swing.  As of 1.4, support for long term storage
             * of all JavaBeans&trade;
             * has been added to the <code>java.beans</code> package.
             * Please see {@link java.beans.XMLEncoder}.
             *
             * @author Ray Ryan
             */
            var UndoableEditEvent = (function (_super) {
                __extends(UndoableEditEvent, _super);
                /**
                 * Constructs an UndoableEditEvent object.
                 *
                 * @param source  the Object that originated the event
                 * (typically <code>this</code>)
                 * @param edit    an UndoableEdit object
                 */
                function UndoableEditEvent(source, edit) {
                    _super.call(this, source);
                    this.myEdit = edit;
                }
                /**
                 * Returns the edit value.
                 *
                 * @return the UndoableEdit object encapsulating the edit
                 */
                UndoableEditEvent.prototype.getEdit = function () {
                    return this.myEdit;
                };
                return UndoableEditEvent;
            }(java.util.EventObject));
            event.UndoableEditEvent = UndoableEditEvent;
            UndoableEditEvent["__class"] = "javax.swing.event.UndoableEditEvent";
            UndoableEditEvent["__interfaces"] = ["java.io.Serializable"];
        })(event = swing.event || (swing.event = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var ImageIcon = (function () {
            function ImageIcon(filename, description) {
                var _this = this;
                if (((typeof filename === 'string') || filename === null) && ((typeof description === 'string') || description === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    this.loadStatus = 0;
                    this.width = 0;
                    this.height = 0;
                    (function () {
                        _this.image = java.awt.Toolkit.getDefaultToolkit().getImage(filename);
                        if (_this.image == null) {
                            return;
                        }
                        _this.filename = filename;
                        _this.description = description;
                        _this.loadImage(_this.image);
                    })();
                }
                else if (((filename != null && filename instanceof java.awt.Image) || filename === null) && ((typeof description === 'string') || description === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    var image_2 = __args[0];
                    {
                        var __args_9 = Array.prototype.slice.call(arguments);
                        this.loadStatus = 0;
                        this.width = 0;
                        this.height = 0;
                        (function () {
                            _this.image = image_2;
                            _this.loadImage(image_2);
                        })();
                    }
                    (function () {
                        _this.description = description;
                    })();
                }
                else if (((typeof filename === 'string') || filename === null) && description === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_10 = Array.prototype.slice.call(arguments);
                        var description_1 = __args_10[0];
                        this.loadStatus = 0;
                        this.width = 0;
                        this.height = 0;
                        (function () {
                            _this.image = java.awt.Toolkit.getDefaultToolkit().getImage(filename);
                            if (_this.image == null) {
                                return;
                            }
                            _this.filename = filename;
                            _this.description = description_1;
                            _this.loadImage(_this.image);
                        })();
                    }
                }
                else if (((filename != null && filename instanceof java.awt.Image) || filename === null) && description === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var image_3 = __args[0];
                    this.loadStatus = 0;
                    this.width = 0;
                    this.height = 0;
                    (function () {
                        _this.image = image_3;
                        _this.loadImage(image_3);
                    })();
                }
                else if (filename === undefined && description === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    this.loadStatus = 0;
                    this.width = 0;
                    this.height = 0;
                }
                else
                    throw new Error('invalid overload');
            }
            ImageIcon.prototype.getInternalHTMLImageElement = function () {
                return this.image == null ? null : this.image.source;
            };
            ImageIcon.prototype.loadImage = function (image) {
                image.getWidth(null);
                image.getHeight(null);
            };
            ImageIcon.prototype.getImageLoadStatus = function () {
                return this.loadStatus;
            };
            ImageIcon.prototype.getImage = function () {
                return this.image;
            };
            ImageIcon.prototype.setImage = function (image) {
                this.image = image;
                this.loadImage(image);
            };
            ImageIcon.prototype.getDescription = function () {
                return this.description;
            };
            ImageIcon.prototype.setDescription = function (description) {
                this.description = description;
            };
            ImageIcon.prototype.paintIcon = function (c, g, x, y) {
                g.drawImage(this.image, x, y, this.imageObserver);
            };
            ImageIcon.prototype.getIconWidth = function () {
                return this.width;
            };
            ImageIcon.prototype.getIconHeight = function () {
                return this.height;
            };
            ImageIcon.prototype.setImageObserver = function (observer) {
                this.imageObserver = observer;
            };
            ImageIcon.prototype.getImageObserver = function () {
                return this.imageObserver;
            };
            ImageIcon.prototype.toString = function () {
                if (this.description != null) {
                    return this.description;
                }
                return "ImageIcon";
            };
            return ImageIcon;
        }());
        swing.ImageIcon = ImageIcon;
        ImageIcon["__class"] = "javax.swing.ImageIcon";
        ImageIcon["__interfaces"] = ["javax.swing.Icon", "java.io.Serializable"];
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var ListSelectionModel;
        (function (ListSelectionModel) {
            /**
             * A value for the selectionMode property: select one list index
             * at a time.
             *
             * @see #setSelectionMode
             */
            ListSelectionModel.SINGLE_SELECTION = 0;
            /**
             * A value for the selectionMode property: select one contiguous
             * range of indices at a time.
             *
             * @see #setSelectionMode
             */
            ListSelectionModel.SINGLE_INTERVAL_SELECTION = 1;
            /**
             * A value for the selectionMode property: select one or more
             * contiguous ranges of indices at a time.
             *
             * @see #setSelectionMode
             */
            ListSelectionModel.MULTIPLE_INTERVAL_SELECTION = 2;
        })(ListSelectionModel = swing.ListSelectionModel || (swing.ListSelectionModel = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        /**
         * A MenuSelectionManager owns the selection in menu hierarchy.
         *
         * @author Arnaud Weber
         */
        var MenuSelectionManager = (function () {
            function MenuSelectionManager() {
            }
            return MenuSelectionManager;
        }());
        swing.MenuSelectionManager = MenuSelectionManager;
        MenuSelectionManager["__class"] = "javax.swing.MenuSelectionManager";
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var SwingConstants;
        (function (SwingConstants) {
            /**
             * The central position in an area. Used for
             * both compass-direction constants (NORTH, etc.)
             * and box-orientation constants (TOP, etc.).
             */
            SwingConstants.CENTER = 0;
            /**
             * Box-orientation constant used to specify the top of a box.
             */
            SwingConstants.TOP = 1;
            /**
             * Box-orientation constant used to specify the left side of a box.
             */
            SwingConstants.LEFT = 2;
            /**
             * Box-orientation constant used to specify the bottom of a box.
             */
            SwingConstants.BOTTOM = 3;
            /**
             * Box-orientation constant used to specify the right side of a box.
             */
            SwingConstants.RIGHT = 4;
            /**
             * Compass-direction North (up).
             */
            SwingConstants.NORTH = 1;
            /**
             * Compass-direction north-east (upper right).
             */
            SwingConstants.NORTH_EAST = 2;
            /**
             * Compass-direction east (right).
             */
            SwingConstants.EAST = 3;
            /**
             * Compass-direction south-east (lower right).
             */
            SwingConstants.SOUTH_EAST = 4;
            /**
             * Compass-direction south (down).
             */
            SwingConstants.SOUTH = 5;
            /**
             * Compass-direction south-west (lower left).
             */
            SwingConstants.SOUTH_WEST = 6;
            /**
             * Compass-direction west (left).
             */
            SwingConstants.WEST = 7;
            /**
             * Compass-direction north west (upper left).
             */
            SwingConstants.NORTH_WEST = 8;
            /**
             * Horizontal orientation. Used for scrollbars and sliders.
             */
            SwingConstants.HORIZONTAL = 0;
            /**
             * Vertical orientation. Used for scrollbars and sliders.
             */
            SwingConstants.VERTICAL = 1;
            /**
             * Identifies the leading edge of text for use with left-to-right
             * and right-to-left languages. Used by buttons and labels.
             */
            SwingConstants.LEADING = 10;
            /**
             * Identifies the trailing edge of text for use with left-to-right
             * and right-to-left languages. Used by buttons and labels.
             */
            SwingConstants.TRAILING = 11;
            /**
             * Identifies the next direction in a sequence.
             *
             * @since 1.4
             */
            SwingConstants.NEXT = 12;
            /**
             * Identifies the previous direction in a sequence.
             *
             * @since 1.4
             */
            SwingConstants.PREVIOUS = 13;
        })(SwingConstants = swing.SwingConstants || (swing.SwingConstants = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var text;
        (function (text) {
            var Position;
            (function (Position) {
                /**
                 * A typesafe enumeration to indicate bias to a position
                 * in the model.  A position indicates a location between
                 * two characters.  The bias can be used to indicate an
                 * interest toward one of the two sides of the position
                 * in boundary conditions where a simple offset is
                 * ambiguous.
                 */
                var Bias = (function () {
                    function Bias(name) {
                        this.name = name;
                    }
                    Bias.Forward_$LI$ = function () { if (Bias.Forward == null)
                        Bias.Forward = new Position.Bias("Forward"); return Bias.Forward; };
                    ;
                    Bias.Backward_$LI$ = function () { if (Bias.Backward == null)
                        Bias.Backward = new Position.Bias("Backward"); return Bias.Backward; };
                    ;
                    /**
                     * string representation
                     */
                    Bias.prototype.toString = function () {
                        return this.name;
                    };
                    return Bias;
                }());
                Position.Bias = Bias;
                Bias["__class"] = "javax.swing.text.Position.Bias";
            })(Position = text.Position || (text.Position = {}));
        })(text = swing.text || (swing.text = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var UIManager = (function () {
            function UIManager() {
            }
            UIManager.getString = function (key) {
                switch ((key)) {
                    case "AbstractUndoableEdit.redoText":
                        return "Redo";
                    case "AbstractUndoableEdit.undoText":
                        return "Undo";
                    default:
                        return "<undefided>";
                }
            };
            return UIManager;
        }());
        swing.UIManager = UIManager;
        UIManager["__class"] = "javax.swing.UIManager";
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var undo;
        (function (undo) {
            /**
             * An abstract implementation of <code>UndoableEdit</code>,
             * implementing simple responses to all boolean methods in
             * that interface.
             *
             * @author Ray Ryan
             */
            var AbstractUndoableEdit = (function () {
                /**
                 * Creates an <code>AbstractUndoableEdit</code> which defaults
                 * <code>hasBeenDone</code> and <code>alive</code> to <code>true</code>.
                 */
                function AbstractUndoableEdit() {
                    this.hasBeenDone = false;
                    this.alive = false;
                    this.hasBeenDone = true;
                    this.alive = true;
                }
                /**
                 * Sets <code>alive</code> to false. Note that this
                 * is a one way operation; dead edits cannot be resurrected.
                 * Sending <code>undo</code> or <code>redo</code> to
                 * a dead edit results in an exception being thrown.
                 *
                 * <p>Typically an edit is killed when it is consolidated by
                 * another edit's <code>addEdit</code> or <code>replaceEdit</code>
                 * method, or when it is dequeued from an <code>UndoManager</code>.
                 */
                AbstractUndoableEdit.prototype.die = function () {
                    this.alive = false;
                };
                /**
                 * Throws <code>CannotUndoException</code> if <code>canUndo</code>
                 * returns <code>false</code>. Sets <code>hasBeenDone</code>
                 * to <code>false</code>. Subclasses should override to undo the
                 * operation represented by this edit. Override should begin with
                 * a call to super.
                 *
                 * @exception CannotUndoException if <code>canUndo</code>
                 * returns <code>false</code>
                 * @see     #canUndo
                 */
                AbstractUndoableEdit.prototype.undo = function () {
                    if (!this.canUndo()) {
                        throw new javax.swing.undo.CannotUndoException();
                    }
                    this.hasBeenDone = false;
                };
                /**
                 * Returns true if this edit is <code>alive</code>
                 * and <code>hasBeenDone</code> is <code>true</code>.
                 *
                 * @return true if this edit is <code>alive</code>
                 * and <code>hasBeenDone</code> is <code>true</code>
                 *
                 * @see     #die
                 * @see     #undo
                 * @see     #redo
                 */
                AbstractUndoableEdit.prototype.canUndo = function () {
                    return this.alive && this.hasBeenDone;
                };
                /**
                 * Throws <code>CannotRedoException</code> if <code>canRedo</code>
                 * returns false. Sets <code>hasBeenDone</code> to <code>true</code>.
                 * Subclasses should override to redo the operation represented by
                 * this edit. Override should begin with a call to super.
                 *
                 * @exception CannotRedoException if <code>canRedo</code>
                 * returns <code>false</code>
                 * @see     #canRedo
                 */
                AbstractUndoableEdit.prototype.redo = function () {
                    if (!this.canRedo()) {
                        throw new javax.swing.undo.CannotRedoException();
                    }
                    this.hasBeenDone = true;
                };
                /**
                 * Returns <code>true</code> if this edit is <code>alive</code>
                 * and <code>hasBeenDone</code> is <code>false</code>.
                 *
                 * @return <code>true</code> if this edit is <code>alive</code>
                 * and <code>hasBeenDone</code> is <code>false</code>
                 * @see     #die
                 * @see     #undo
                 * @see     #redo
                 */
                AbstractUndoableEdit.prototype.canRedo = function () {
                    return this.alive && !this.hasBeenDone;
                };
                /**
                 * This default implementation returns false.
                 *
                 * @param anEdit the edit to be added
                 * @return false
                 *
                 * @see UndoableEdit#addEdit
                 */
                AbstractUndoableEdit.prototype.addEdit = function (anEdit) {
                    return false;
                };
                /**
                 * This default implementation returns false.
                 *
                 * @param anEdit the edit to replace
                 * @return false
                 *
                 * @see UndoableEdit#replaceEdit
                 */
                AbstractUndoableEdit.prototype.replaceEdit = function (anEdit) {
                    return false;
                };
                /**
                 * This default implementation returns true.
                 *
                 * @return true
                 * @see UndoableEdit#isSignificant
                 */
                AbstractUndoableEdit.prototype.isSignificant = function () {
                    return true;
                };
                /**
                 * This default implementation returns "". Used by
                 * <code>getUndoPresentationName</code> and
                 * <code>getRedoPresentationName</code> to
                 * construct the strings they return. Subclasses should override to
                 * return an appropriate description of the operation this edit
                 * represents.
                 *
                 * @return the empty string ""
                 *
                 * @see     #getUndoPresentationName
                 * @see     #getRedoPresentationName
                 */
                AbstractUndoableEdit.prototype.getPresentationName = function () {
                    return "";
                };
                /**
                 * Retreives the value from the defaults table with key
                 * <code>AbstractUndoableEdit.undoText</code> and returns
                 * that value followed by a space, followed by
                 * <code>getPresentationName</code>.
                 * If <code>getPresentationName</code> returns "",
                 * then the defaults value is returned alone.
                 *
                 * @return the value from the defaults table with key
                 * <code>AbstractUndoableEdit.undoText</code>, followed
                 * by a space, followed by <code>getPresentationName</code>
                 * unless <code>getPresentationName</code> is "" in which
                 * case, the defaults value is returned alone.
                 * @see #getPresentationName
                 */
                AbstractUndoableEdit.prototype.getUndoPresentationName = function () {
                    var name = this.getPresentationName();
                    if (!("" === name)) {
                        name = javax.swing.UIManager.getString("AbstractUndoableEdit.undoText") + " " + name;
                    }
                    else {
                        name = javax.swing.UIManager.getString("AbstractUndoableEdit.undoText");
                    }
                    return name;
                };
                /**
                 * Retreives the value from the defaults table with key
                 * <code>AbstractUndoableEdit.redoText</code> and returns
                 * that value followed by a space, followed by
                 * <code>getPresentationName</code>.
                 * If <code>getPresentationName</code> returns "",
                 * then the defaults value is returned alone.
                 *
                 * @return the value from the defaults table with key
                 * <code>AbstractUndoableEdit.redoText</code>, followed
                 * by a space, followed by <code>getPresentationName</code>
                 * unless <code>getPresentationName</code> is "" in which
                 * case, the defaults value is returned alone.
                 * @see #getPresentationName
                 */
                AbstractUndoableEdit.prototype.getRedoPresentationName = function () {
                    var name = this.getPresentationName();
                    if (!("" === name)) {
                        name = javax.swing.UIManager.getString("AbstractUndoableEdit.redoText") + " " + name;
                    }
                    else {
                        name = javax.swing.UIManager.getString("AbstractUndoableEdit.redoText");
                    }
                    return name;
                };
                /**
                 * Returns a string that displays and identifies this
                 * object's properties.
                 *
                 * @return a String representation of this object
                 */
                AbstractUndoableEdit.prototype.toString = function () {
                    return (function (c) { return c["__class"] ? c["__class"] : c.name; })(this.constructor) + " hasBeenDone: " + this.hasBeenDone + " alive: " + this.alive;
                };
                /**
                 * String returned by <code>getUndoPresentationName</code>;
                 * as of Java 2 platform v1.3.1 this field is no longer used. This value
                 * is now localized and comes from the defaults table with key
                 * <code>AbstractUndoableEdit.undoText</code>.
                 *
                 * @see javax.swing.UIDefaults
                 */
                AbstractUndoableEdit.UndoName = "Undo";
                /**
                 * String returned by <code>getRedoPresentationName</code>;
                 * as of Java 2 platform v1.3.1 this field is no longer used. This value
                 * is now localized and comes from the defaults table with key
                 * <code>AbstractUndoableEdit.redoText</code>.
                 *
                 * @see javax.swing.UIDefaults
                 */
                AbstractUndoableEdit.RedoName = "Redo";
                return AbstractUndoableEdit;
            }());
            undo.AbstractUndoableEdit = AbstractUndoableEdit;
            AbstractUndoableEdit["__class"] = "javax.swing.undo.AbstractUndoableEdit";
            AbstractUndoableEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit", "java.io.Serializable"];
        })(undo = swing.undo || (swing.undo = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var undo;
        (function (undo) {
            /**
             * Thrown when an UndoableEdit is told to <code>redo()</code> and can't.
             * <p>
             * <strong>Warning:</strong>
             * Serialized objects of this class will not be compatible with
             * future Swing releases. The current serialization support is
             * appropriate for short term storage or RMI between applications running
             * the same version of Swing.  As of 1.4, support for long term storage
             * of all JavaBeans&trade;
             * has been added to the <code>java.beans</code> package.
             * Please see {@link java.beans.XMLEncoder}.
             *
             * @author Ray Ryan
             */
            var CannotRedoException = (function (_super) {
                __extends(CannotRedoException, _super);
                function CannotRedoException() {
                    _super.call(this);
                }
                return CannotRedoException;
            }(Error));
            undo.CannotRedoException = CannotRedoException;
            CannotRedoException["__class"] = "javax.swing.undo.CannotRedoException";
            CannotRedoException["__interfaces"] = ["java.io.Serializable"];
        })(undo = swing.undo || (swing.undo = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var undo;
        (function (undo) {
            /**
             * Thrown when an UndoableEdit is told to <code>undo()</code> and can't.
             * <p>
             * <strong>Warning:</strong>
             * Serialized objects of this class will not be compatible with
             * future Swing releases. The current serialization support is
             * appropriate for short term storage or RMI between applications running
             * the same version of Swing.  As of 1.4, support for long term storage
             * of all JavaBeans&trade;
             * has been added to the <code>java.beans</code> package.
             * Please see {@link java.beans.XMLEncoder}.
             *
             * @author Ray Ryan
             */
            var CannotUndoException = (function (_super) {
                __extends(CannotUndoException, _super);
                function CannotUndoException() {
                    _super.call(this);
                }
                return CannotUndoException;
            }(Error));
            undo.CannotUndoException = CannotUndoException;
            CannotUndoException["__class"] = "javax.swing.undo.CannotUndoException";
            CannotUndoException["__interfaces"] = ["java.io.Serializable"];
        })(undo = swing.undo || (swing.undo = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var undo;
        (function (undo) {
            var StateEditable;
            (function (StateEditable) {
                /**
                 * Resource ID for this class.
                 */
                StateEditable.RCSID = "$Id: StateEditable.java,v 1.2 1997/09/08 19:39:08 marklin Exp $";
            })(StateEditable = undo.StateEditable || (undo.StateEditable = {}));
        })(undo = swing.undo || (swing.undo = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var undo;
        (function (undo) {
            /**
             * A support class used for managing <code>UndoableEdit</code> listeners.
             *
             * @author Ray Ryan
             */
            var UndoableEditSupport = (function () {
                /**
                 * Constructs an <code>UndoableEditSupport</code> object.
                 *
                 * @param r
                 * an <code>Object</code>
                 */
                function UndoableEditSupport(r) {
                    if (r === void 0) { r = null; }
                    this.updateLevel = 0;
                    this.realSource = r == null ? this : r;
                    this.updateLevel = 0;
                    this.compoundEdit = null;
                    this.listeners = (new java.util.Vector());
                }
                /**
                 * Registers an <code>UndoableEditListener</code>. The listener is notified
                 * whenever an edit occurs which can be undone.
                 *
                 * @param l
                 * an <code>UndoableEditListener</code> object
                 * @see #removeUndoableEditListener
                 */
                UndoableEditSupport.prototype.addUndoableEditListener = function (l) {
                    this.listeners.addElement(l);
                };
                /**
                 * Removes an <code>UndoableEditListener</code>.
                 *
                 * @param l
                 * the <code>UndoableEditListener</code> object to be removed
                 * @see #addUndoableEditListener
                 */
                UndoableEditSupport.prototype.removeUndoableEditListener = function (l) {
                    this.listeners.removeElement(l);
                };
                /**
                 * Returns an array of all the <code>UndoableEditListener</code>s added to
                 * this UndoableEditSupport with addUndoableEditListener().
                 *
                 * @return all of the <code>UndoableEditListener</code>s added or an empty
                 * array if no listeners have been added
                 * @since 1.4
                 */
                UndoableEditSupport.prototype.getUndoableEditListeners = function () {
                    return this.listeners.toArray(new Array(0));
                };
                /**
                 * Called only from <code>postEdit</code> and <code>endUpdate</code>. Calls
                 * <code>undoableEditHappened</code> in all listeners. No synchronization is
                 * performed here, since the two calling methods are synchronized.
                 */
                UndoableEditSupport.prototype._postEdit = function (e) {
                    var ev = new javax.swing.event.UndoableEditEvent(this.realSource, e);
                    var cursor = this.listeners.clone().elements();
                    while ((cursor.hasMoreElements())) {
                        cursor.nextElement().undoableEditHappened(ev);
                    }
                    ;
                };
                /**
                 * DEADLOCK WARNING: Calling this method may call
                 * <code>undoableEditHappened</code> in all listeners. It is unwise to call
                 * this method from one of its listeners.
                 */
                UndoableEditSupport.prototype.postEdit = function (e) {
                    if (this.updateLevel === 0) {
                        this._postEdit(e);
                    }
                    else {
                        this.compoundEdit.addEdit(e);
                    }
                };
                /**
                 * Returns the update level value.
                 *
                 * @return an integer representing the update level
                 */
                UndoableEditSupport.prototype.getUpdateLevel = function () {
                    return this.updateLevel;
                };
                /**
                 */
                UndoableEditSupport.prototype.beginUpdate = function () {
                    if (this.updateLevel === 0) {
                        this.compoundEdit = this.createCompoundEdit();
                    }
                    this.updateLevel++;
                };
                /**
                 * Called only from <code>beginUpdate</code>. Exposed here for subclasses'
                 * use.
                 */
                UndoableEditSupport.prototype.createCompoundEdit = function () {
                    return new javax.swing.undo.CompoundEdit();
                };
                /**
                 * DEADLOCK WARNING: Calling this method may call
                 * <code>undoableEditHappened</code> in all listeners. It is unwise to call
                 * this method from one of its listeners.
                 */
                UndoableEditSupport.prototype.endUpdate = function () {
                    this.updateLevel--;
                    if (this.updateLevel === 0) {
                        this.compoundEdit.end();
                        this._postEdit(this.compoundEdit);
                        this.compoundEdit = null;
                    }
                };
                /**
                 * Returns a string that displays and identifies this object's properties.
                 *
                 * @return a <code>String</code> representation of this object
                 */
                UndoableEditSupport.prototype.toString = function () {
                    return (function (c) { return c["__class"] ? c["__class"] : c.name; })(this.constructor) + " updateLevel: " + this.updateLevel + " listeners: " + this.listeners + " compoundEdit: " + this.compoundEdit;
                };
                return UndoableEditSupport;
            }());
            undo.UndoableEditSupport = UndoableEditSupport;
            UndoableEditSupport["__class"] = "javax.swing.undo.UndoableEditSupport";
        })(undo = swing.undo || (swing.undo = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var WindowConstants;
        (function (WindowConstants) {
            WindowConstants.DO_NOTHING_ON_CLOSE = 0;
            WindowConstants.HIDE_ON_CLOSE = 1;
            WindowConstants.DISPOSE_ON_CLOSE = 2;
            WindowConstants.EXIT_ON_CLOSE = 3;
        })(WindowConstants = swing.WindowConstants || (swing.WindowConstants = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var sun;
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var ChainEnd = (function () {
                function ChainEnd(first, partner) {
                    this.etag = 0;
                    this.head = first;
                    this.tail = first;
                    this.partner = partner;
                    this.etag = first.getEdgeTag();
                }
                ChainEnd.prototype.getChain = function () {
                    return this.head;
                };
                ChainEnd.prototype.setOtherEnd = function (partner) {
                    this.partner = partner;
                };
                ChainEnd.prototype.getPartner = function () {
                    return this.partner;
                };
                ChainEnd.prototype.linkTo = function (that) {
                    if (this.etag === sun.awt.geom.AreaOp.ETAG_IGNORE || that.etag === sun.awt.geom.AreaOp.ETAG_IGNORE) {
                        throw new java.lang.InternalError("ChainEnd linked more than once!");
                    }
                    if (this.etag === that.etag) {
                        throw new java.lang.InternalError("Linking chains of the same type!");
                    }
                    var enter;
                    var exit;
                    if (this.etag === sun.awt.geom.AreaOp.ETAG_ENTER) {
                        enter = this;
                        exit = that;
                    }
                    else {
                        enter = that;
                        exit = this;
                    }
                    this.etag = sun.awt.geom.AreaOp.ETAG_IGNORE;
                    that.etag = sun.awt.geom.AreaOp.ETAG_IGNORE;
                    enter.tail.setNext(exit.head);
                    enter.tail = exit.tail;
                    if (this.partner === that) {
                        return enter.head;
                    }
                    var otherenter = exit.partner;
                    var otherexit = enter.partner;
                    otherenter.partner = otherexit;
                    otherexit.partner = otherenter;
                    if (enter.head.getYTop() < otherenter.head.getYTop()) {
                        enter.tail.setNext(otherenter.head);
                        otherenter.head = enter.head;
                    }
                    else {
                        otherexit.tail.setNext(enter.head);
                        otherexit.tail = enter.tail;
                    }
                    return null;
                };
                ChainEnd.prototype.addLink = function (newlink) {
                    if (this.etag === sun.awt.geom.AreaOp.ETAG_ENTER) {
                        this.tail.setNext(newlink);
                        this.tail = newlink;
                    }
                    else {
                        newlink.setNext(this.head);
                        this.head = newlink;
                    }
                };
                ChainEnd.prototype.getX = function () {
                    if (this.etag === sun.awt.geom.AreaOp.ETAG_ENTER) {
                        return this.tail.getXBot();
                    }
                    else {
                        return this.head.getXBot();
                    }
                };
                return ChainEnd;
            }());
            geom.ChainEnd = ChainEnd;
            ChainEnd["__class"] = "sun.awt.geom.ChainEnd";
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var sun;
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Crossings = (function () {
                function Crossings(xlo, ylo, xhi, yhi) {
                    this.limit = 0;
                    this.yranges = new Array(10);
                    this.tmp = (new java.util.Vector());
                    this.xlo = 0;
                    this.ylo = 0;
                    this.xhi = 0;
                    this.yhi = 0;
                    this.xlo = xlo;
                    this.ylo = ylo;
                    this.xhi = xhi;
                    this.yhi = yhi;
                }
                Crossings.prototype.getXLo = function () {
                    return this.xlo;
                };
                Crossings.prototype.getYLo = function () {
                    return this.ylo;
                };
                Crossings.prototype.getXHi = function () {
                    return this.xhi;
                };
                Crossings.prototype.getYHi = function () {
                    return this.yhi;
                };
                Crossings.prototype.print = function () {
                    console.info("Crossings [");
                    console.info("  bounds = [" + this.ylo + ", " + this.yhi + "]");
                    for (var i = 0; i < this.limit; i += 2) {
                        console.info("  [" + this.yranges[i] + ", " + this.yranges[i + 1] + "]");
                    }
                    console.info("]");
                };
                Crossings.prototype.isEmpty = function () {
                    return (this.limit === 0);
                };
                Crossings.findCrossings = function (curves, xlo, ylo, xhi, yhi) {
                    if (((curves != null && curves instanceof java.util.Vector) || curves === null) && ((typeof xlo === 'number') || xlo === null) && ((typeof ylo === 'number') || ylo === null) && ((typeof xhi === 'number') || xhi === null) && ((typeof yhi === 'number') || yhi === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            var cross = new Crossings.EvenOdd(xlo, ylo, xhi, yhi);
                            var enum_ = curves.elements();
                            while ((enum_.hasMoreElements())) {
                                var c = enum_.nextElement();
                                if (c.accumulateCrossings(cross)) {
                                    return null;
                                }
                            }
                            ;
                            if (Crossings.debug) {
                                cross.print();
                            }
                            return cross;
                        })();
                    }
                    else if (((curves != null && (curves["__interfaces"] != null && curves["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || curves.constructor != null && curves.constructor["__interfaces"] != null && curves.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || curves === null) && ((typeof xlo === 'number') || xlo === null) && ((typeof ylo === 'number') || ylo === null) && ((typeof xhi === 'number') || xhi === null) && ((typeof yhi === 'number') || yhi === null)) {
                        return sun.awt.geom.Crossings.findCrossings$java_awt_geom_PathIterator$double$double$double$double(curves, xlo, ylo, xhi, yhi);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Crossings.findCrossings$java_awt_geom_PathIterator$double$double$double$double = function (pi, xlo, ylo, xhi, yhi) {
                    var cross;
                    if (pi.getWindingRule() === java.awt.geom.PathIterator.WIND_EVEN_ODD) {
                        cross = new Crossings.EvenOdd(xlo, ylo, xhi, yhi);
                    }
                    else {
                        cross = new Crossings.NonZero(xlo, ylo, xhi, yhi);
                    }
                    var coords = new Array(23);
                    var movx = 0;
                    var movy = 0;
                    var curx = 0;
                    var cury = 0;
                    var newx;
                    var newy;
                    while ((!pi.isDone())) {
                        var type = pi.currentSegment(coords);
                        switch ((type)) {
                            case java.awt.geom.PathIterator.SEG_MOVETO:
                                if (movy !== cury && cross.accumulateLine(curx, cury, movx, movy)) {
                                    return null;
                                }
                                movx = curx = coords[0];
                                movy = cury = coords[1];
                                break;
                            case java.awt.geom.PathIterator.SEG_LINETO:
                                newx = coords[0];
                                newy = coords[1];
                                if (cross.accumulateLine(curx, cury, newx, newy)) {
                                    return null;
                                }
                                curx = newx;
                                cury = newy;
                                break;
                            case java.awt.geom.PathIterator.SEG_QUADTO:
                                newx = coords[2];
                                newy = coords[3];
                                if (cross.accumulateQuad(curx, cury, coords)) {
                                    return null;
                                }
                                curx = newx;
                                cury = newy;
                                break;
                            case java.awt.geom.PathIterator.SEG_CUBICTO:
                                newx = coords[4];
                                newy = coords[5];
                                if (cross.accumulateCubic(curx, cury, coords)) {
                                    return null;
                                }
                                curx = newx;
                                cury = newy;
                                break;
                            case java.awt.geom.PathIterator.SEG_CLOSE:
                                if (movy !== cury && cross.accumulateLine(curx, cury, movx, movy)) {
                                    return null;
                                }
                                curx = movx;
                                cury = movy;
                                break;
                        }
                        pi.next();
                    }
                    ;
                    if (movy !== cury) {
                        if (cross.accumulateLine(curx, cury, movx, movy)) {
                            return null;
                        }
                    }
                    if (Crossings.debug) {
                        cross.print();
                    }
                    return cross;
                };
                Crossings.prototype.accumulateLine$double$double$double$double = function (x0, y0, x1, y1) {
                    if (y0 <= y1) {
                        return this.accumulateLine(x0, y0, x1, y1, 1);
                    }
                    else {
                        return this.accumulateLine(x1, y1, x0, y0, -1);
                    }
                };
                Crossings.prototype.accumulateLine = function (x0, y0, x1, y1, direction) {
                    var _this = this;
                    if (((typeof x0 === 'number') || x0 === null) && ((typeof y0 === 'number') || y0 === null) && ((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof direction === 'number') || direction === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (_this.yhi <= y0 || _this.ylo >= y1) {
                                return false;
                            }
                            if (x0 >= _this.xhi && x1 >= _this.xhi) {
                                return false;
                            }
                            if (y0 === y1) {
                                return (x0 >= _this.xlo || x1 >= _this.xlo);
                            }
                            var xstart;
                            var ystart;
                            var xend;
                            var yend;
                            var dx = (x1 - x0);
                            var dy = (y1 - y0);
                            if (y0 < _this.ylo) {
                                xstart = x0 + (_this.ylo - y0) * dx / dy;
                                ystart = _this.ylo;
                            }
                            else {
                                xstart = x0;
                                ystart = y0;
                            }
                            if (_this.yhi < y1) {
                                xend = x0 + (_this.yhi - y0) * dx / dy;
                                yend = _this.yhi;
                            }
                            else {
                                xend = x1;
                                yend = y1;
                            }
                            if (xstart >= _this.xhi && xend >= _this.xhi) {
                                return false;
                            }
                            if (xstart > _this.xlo || xend > _this.xlo) {
                                return true;
                            }
                            _this.record(ystart, yend, direction);
                            return false;
                        })();
                    }
                    else if (((typeof x0 === 'number') || x0 === null) && ((typeof y0 === 'number') || y0 === null) && ((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && direction === undefined) {
                        return this.accumulateLine$double$double$double$double(x0, y0, x1, y1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Crossings.prototype.accumulateQuad = function (x0, y0, coords) {
                    if (y0 < this.ylo && coords[1] < this.ylo && coords[3] < this.ylo) {
                        return false;
                    }
                    if (y0 > this.yhi && coords[1] > this.yhi && coords[3] > this.yhi) {
                        return false;
                    }
                    if (x0 > this.xhi && coords[0] > this.xhi && coords[2] > this.xhi) {
                        return false;
                    }
                    if (x0 < this.xlo && coords[0] < this.xlo && coords[2] < this.xlo) {
                        if (y0 < coords[3]) {
                            this.record(Math.max(y0, this.ylo), Math.min(coords[3], this.yhi), 1);
                        }
                        else if (y0 > coords[3]) {
                            this.record(Math.max(coords[3], this.ylo), Math.min(y0, this.yhi), -1);
                        }
                        return false;
                    }
                    sun.awt.geom.Curve.insertQuad(this.tmp, x0, y0, coords);
                    var enum_ = this.tmp.elements();
                    while ((enum_.hasMoreElements())) {
                        var c = enum_.nextElement();
                        if (c.accumulateCrossings(this)) {
                            return true;
                        }
                    }
                    ;
                    this.tmp.clear();
                    return false;
                };
                Crossings.prototype.accumulateCubic = function (x0, y0, coords) {
                    if (y0 < this.ylo && coords[1] < this.ylo && coords[3] < this.ylo && coords[5] < this.ylo) {
                        return false;
                    }
                    if (y0 > this.yhi && coords[1] > this.yhi && coords[3] > this.yhi && coords[5] > this.yhi) {
                        return false;
                    }
                    if (x0 > this.xhi && coords[0] > this.xhi && coords[2] > this.xhi && coords[4] > this.xhi) {
                        return false;
                    }
                    if (x0 < this.xlo && coords[0] < this.xlo && coords[2] < this.xlo && coords[4] < this.xlo) {
                        if (y0 <= coords[5]) {
                            this.record(Math.max(y0, this.ylo), Math.min(coords[5], this.yhi), 1);
                        }
                        else {
                            this.record(Math.max(coords[5], this.ylo), Math.min(y0, this.yhi), -1);
                        }
                        return false;
                    }
                    sun.awt.geom.Curve.insertCubic(this.tmp, x0, y0, coords);
                    var enum_ = this.tmp.elements();
                    while ((enum_.hasMoreElements())) {
                        var c = enum_.nextElement();
                        if (c.accumulateCrossings(this)) {
                            return true;
                        }
                    }
                    ;
                    this.tmp.clear();
                    return false;
                };
                Crossings.debug = false;
                return Crossings;
            }());
            geom.Crossings = Crossings;
            Crossings["__class"] = "sun.awt.geom.Crossings";
            var Crossings;
            (function (Crossings) {
                var EvenOdd = (function (_super) {
                    __extends(EvenOdd, _super);
                    function EvenOdd(xlo, ylo, xhi, yhi) {
                        _super.call(this, xlo, ylo, xhi, yhi);
                    }
                    EvenOdd.prototype.covers = function (ystart, yend) {
                        return (this.limit === 2 && this.yranges[0] <= ystart && this.yranges[1] >= yend);
                    };
                    EvenOdd.prototype.record = function (ystart, yend, direction) {
                        if (ystart >= yend) {
                            return;
                        }
                        var from = 0;
                        while ((from < this.limit && ystart > this.yranges[from + 1])) {
                            from += 2;
                        }
                        ;
                        var to = from;
                        while ((from < this.limit)) {
                            var yrlo = this.yranges[from++];
                            var yrhi = this.yranges[from++];
                            if (yend < yrlo) {
                                this.yranges[to++] = ystart;
                                this.yranges[to++] = yend;
                                ystart = yrlo;
                                yend = yrhi;
                                continue;
                            }
                            var yll = void 0;
                            var ylh = void 0;
                            var yhl = void 0;
                            var yhh = void 0;
                            if (ystart < yrlo) {
                                yll = ystart;
                                ylh = yrlo;
                            }
                            else {
                                yll = yrlo;
                                ylh = ystart;
                            }
                            if (yend < yrhi) {
                                yhl = yend;
                                yhh = yrhi;
                            }
                            else {
                                yhl = yrhi;
                                yhh = yend;
                            }
                            if (ylh === yhl) {
                                ystart = yll;
                                yend = yhh;
                            }
                            else {
                                if (ylh > yhl) {
                                    ystart = yhl;
                                    yhl = ylh;
                                    ylh = ystart;
                                }
                                if (yll !== ylh) {
                                    this.yranges[to++] = yll;
                                    this.yranges[to++] = ylh;
                                }
                                ystart = yhl;
                                yend = yhh;
                            }
                            if (ystart >= yend) {
                                break;
                            }
                        }
                        ;
                        if (to < from && from < this.limit) {
                            java.lang.System.arraycopy(this.yranges, from, this.yranges, to, this.limit - from);
                        }
                        to += (this.limit - from);
                        if (ystart < yend) {
                            if (to >= this.yranges.length) {
                                var newranges = new Array(to + 10);
                                java.lang.System.arraycopy(this.yranges, 0, newranges, 0, to);
                                this.yranges = newranges;
                            }
                            this.yranges[to++] = ystart;
                            this.yranges[to++] = yend;
                        }
                        this.limit = to;
                    };
                    return EvenOdd;
                }(sun.awt.geom.Crossings));
                Crossings.EvenOdd = EvenOdd;
                EvenOdd["__class"] = "sun.awt.geom.Crossings.EvenOdd";
                var NonZero = (function (_super) {
                    __extends(NonZero, _super);
                    function NonZero(xlo, ylo, xhi, yhi) {
                        _super.call(this, xlo, ylo, xhi, yhi);
                        this.crosscounts = new Array((this.yranges.length / 2 | 0));
                    }
                    NonZero.prototype.covers = function (ystart, yend) {
                        var i = 0;
                        while ((i < this.limit)) {
                            var ylo = this.yranges[i++];
                            var yhi = this.yranges[i++];
                            if (ystart >= yhi) {
                                continue;
                            }
                            if (ystart < ylo) {
                                return false;
                            }
                            if (yend <= yhi) {
                                return true;
                            }
                            ystart = yhi;
                        }
                        ;
                        return (ystart >= yend);
                    };
                    NonZero.prototype.remove = function (cur) {
                        this.limit -= 2;
                        var rem = this.limit - cur;
                        if (rem > 0) {
                            java.lang.System.arraycopy(this.yranges, cur + 2, this.yranges, cur, rem);
                            java.lang.System.arraycopy(this.crosscounts, (cur / 2 | 0) + 1, this.crosscounts, (cur / 2 | 0), (rem / 2 | 0));
                        }
                    };
                    NonZero.prototype.insert = function (cur, lo, hi, dir) {
                        var rem = this.limit - cur;
                        var oldranges = this.yranges;
                        var oldcounts = this.crosscounts;
                        if (this.limit >= this.yranges.length) {
                            this.yranges = new Array(this.limit + 10);
                            java.lang.System.arraycopy(oldranges, 0, this.yranges, 0, cur);
                            this.crosscounts = new Array(((this.limit + 10) / 2 | 0));
                            java.lang.System.arraycopy(oldcounts, 0, this.crosscounts, 0, (cur / 2 | 0));
                        }
                        if (rem > 0) {
                            java.lang.System.arraycopy(oldranges, cur, this.yranges, cur + 2, rem);
                            java.lang.System.arraycopy(oldcounts, (cur / 2 | 0), this.crosscounts, (cur / 2 | 0) + 1, (rem / 2 | 0));
                        }
                        this.yranges[cur + 0] = lo;
                        this.yranges[cur + 1] = hi;
                        this.crosscounts[(cur / 2 | 0)] = dir;
                        this.limit += 2;
                    };
                    NonZero.prototype.record = function (ystart, yend, direction) {
                        if (ystart >= yend) {
                            return;
                        }
                        var cur = 0;
                        while ((cur < this.limit && ystart > this.yranges[cur + 1])) {
                            cur += 2;
                        }
                        ;
                        if (cur < this.limit) {
                            var rdir = this.crosscounts[(cur / 2 | 0)];
                            var yrlo = this.yranges[cur + 0];
                            var yrhi = this.yranges[cur + 1];
                            if (yrhi === ystart && rdir === direction) {
                                if (cur + 2 === this.limit) {
                                    this.yranges[cur + 1] = yend;
                                    return;
                                }
                                this.remove(cur);
                                ystart = yrlo;
                                rdir = this.crosscounts[(cur / 2 | 0)];
                                yrlo = this.yranges[cur + 0];
                                yrhi = this.yranges[cur + 1];
                            }
                            if (yend < yrlo) {
                                this.insert(cur, ystart, yend, direction);
                                return;
                            }
                            if (yend === yrlo && rdir === direction) {
                                this.yranges[cur] = ystart;
                                return;
                            }
                            if (ystart < yrlo) {
                                this.insert(cur, ystart, yrlo, direction);
                                cur += 2;
                                ystart = yrlo;
                            }
                            else if (yrlo < ystart) {
                                this.insert(cur, yrlo, ystart, rdir);
                                cur += 2;
                                yrlo = ystart;
                            }
                            var newdir = rdir + direction;
                            var newend = Math.min(yend, yrhi);
                            if (newdir === 0) {
                                this.remove(cur);
                            }
                            else {
                                this.crosscounts[(cur / 2 | 0)] = newdir;
                                this.yranges[cur++] = ystart;
                                this.yranges[cur++] = newend;
                            }
                            ystart = yrlo = newend;
                            if (yrlo < yrhi) {
                                this.insert(cur, yrlo, yrhi, rdir);
                            }
                        }
                        if (ystart < yend) {
                            this.insert(cur, ystart, yend, direction);
                        }
                    };
                    return NonZero;
                }(sun.awt.geom.Crossings));
                Crossings.NonZero = NonZero;
                NonZero["__class"] = "sun.awt.geom.Crossings.NonZero";
            })(Crossings = geom.Crossings || (geom.Crossings = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var sun;
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Curve = (function () {
                function Curve(direction) {
                    this.direction = 0;
                    this.direction = direction;
                }
                Curve.insertMove = function (curves, x, y) {
                    curves.add(new sun.awt.geom.Order0(x, y));
                };
                Curve.insertLine = function (curves, x0, y0, x1, y1) {
                    if (y0 < y1) {
                        curves.add(new sun.awt.geom.Order1(x0, y0, x1, y1, Curve.INCREASING));
                    }
                    else if (y0 > y1) {
                        curves.add(new sun.awt.geom.Order1(x1, y1, x0, y0, Curve.DECREASING));
                    }
                    else {
                    }
                };
                Curve.insertQuad = function (curves, x0, y0, coords) {
                    var y1 = coords[3];
                    if (y0 > y1) {
                        sun.awt.geom.Order2.insert(curves, coords, coords[2], y1, coords[0], coords[1], x0, y0, Curve.DECREASING);
                    }
                    else if (y0 === y1 && y0 === coords[1]) {
                        return;
                    }
                    else {
                        sun.awt.geom.Order2.insert(curves, coords, x0, y0, coords[0], coords[1], coords[2], y1, Curve.INCREASING);
                    }
                };
                Curve.insertCubic = function (curves, x0, y0, coords) {
                    var y1 = coords[5];
                    if (y0 > y1) {
                        sun.awt.geom.Order3.insert(curves, coords, coords[4], y1, coords[2], coords[3], coords[0], coords[1], x0, y0, Curve.DECREASING);
                    }
                    else if (y0 === y1 && y0 === coords[1] && y0 === coords[3]) {
                        return;
                    }
                    else {
                        sun.awt.geom.Order3.insert(curves, coords, x0, y0, coords[0], coords[1], coords[2], coords[3], coords[4], y1, Curve.INCREASING);
                    }
                };
                /**
                 * Calculates the number of times the given path crosses the ray extending
                 * to the right from (px,py). If the point lies on a part of the path, then
                 * no crossings are counted for that intersection. +1 is added for each
                 * crossing where the Y coordinate is increasing -1 is added for each
                 * crossing where the Y coordinate is decreasing The return value is the sum
                 * of all crossings for every segment in the path. The path must start with
                 * a SEG_MOVETO, otherwise an exception is thrown. The caller must check
                 * p[xy] for NaN values. The caller may also reject infinite p[xy] values as
                 * well.
                 */
                Curve.pointCrossingsForPath = function (pi, px, py) {
                    if (pi.isDone()) {
                        return 0;
                    }
                    var coords = new Array(6);
                    if (pi.currentSegment(coords) !== java.awt.geom.PathIterator.SEG_MOVETO) {
                        throw new java.awt.geom.IllegalPathStateException("missing initial moveto in path definition");
                    }
                    pi.next();
                    var movx = coords[0];
                    var movy = coords[1];
                    var curx = movx;
                    var cury = movy;
                    var endx;
                    var endy;
                    var crossings = 0;
                    while ((!pi.isDone())) {
                        switch ((pi.currentSegment(coords))) {
                            case java.awt.geom.PathIterator.SEG_MOVETO:
                                if (cury !== movy) {
                                    crossings += Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                                }
                                movx = curx = coords[0];
                                movy = cury = coords[1];
                                break;
                            case java.awt.geom.PathIterator.SEG_LINETO:
                                endx = coords[0];
                                endy = coords[1];
                                crossings += Curve.pointCrossingsForLine(px, py, curx, cury, endx, endy);
                                curx = endx;
                                cury = endy;
                                break;
                            case java.awt.geom.PathIterator.SEG_QUADTO:
                                endx = coords[2];
                                endy = coords[3];
                                crossings += Curve.pointCrossingsForQuad(px, py, curx, cury, coords[0], coords[1], endx, endy, 0);
                                curx = endx;
                                cury = endy;
                                break;
                            case java.awt.geom.PathIterator.SEG_CUBICTO:
                                endx = coords[4];
                                endy = coords[5];
                                crossings += Curve.pointCrossingsForCubic(px, py, curx, cury, coords[0], coords[1], coords[2], coords[3], endx, endy, 0);
                                curx = endx;
                                cury = endy;
                                break;
                            case java.awt.geom.PathIterator.SEG_CLOSE:
                                if (cury !== movy) {
                                    crossings += Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                                }
                                curx = movx;
                                cury = movy;
                                break;
                        }
                        pi.next();
                    }
                    ;
                    if (cury !== movy) {
                        crossings += Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                    }
                    return crossings;
                };
                /**
                 * Calculates the number of times the line from (x0,y0) to (x1,y1) crosses
                 * the ray extending to the right from (px,py). If the point lies on the
                 * line, then no crossings are recorded. +1 is returned for a crossing where
                 * the Y coordinate is increasing -1 is returned for a crossing where the Y
                 * coordinate is decreasing
                 */
                Curve.pointCrossingsForLine = function (px, py, x0, y0, x1, y1) {
                    if (py < y0 && py < y1)
                        return 0;
                    if (py >= y0 && py >= y1)
                        return 0;
                    if (px >= x0 && px >= x1)
                        return 0;
                    if (px < x0 && px < x1)
                        return (y0 < y1) ? 1 : -1;
                    var xintercept = x0 + (py - y0) * (x1 - x0) / (y1 - y0);
                    if (px >= xintercept)
                        return 0;
                    return (y0 < y1) ? 1 : -1;
                };
                /**
                 * Calculates the number of times the quad from (x0,y0) to (x1,y1) crosses
                 * the ray extending to the right from (px,py). If the point lies on a part
                 * of the curve, then no crossings are counted for that intersection. the
                 * level parameter should be 0 at the top-level call and will count up for
                 * each recursion level to prevent infinite recursion +1 is added for each
                 * crossing where the Y coordinate is increasing -1 is added for each
                 * crossing where the Y coordinate is decreasing
                 */
                Curve.pointCrossingsForQuad = function (px, py, x0, y0, xc, yc, x1, y1, level) {
                    if (py < y0 && py < yc && py < y1)
                        return 0;
                    if (py >= y0 && py >= yc && py >= y1)
                        return 0;
                    if (px >= x0 && px >= xc && px >= x1)
                        return 0;
                    if (px < x0 && px < xc && px < x1) {
                        if (py >= y0) {
                            if (py < y1)
                                return 1;
                        }
                        else {
                            if (py >= y1)
                                return -1;
                        }
                        return 0;
                    }
                    if (level > 52)
                        return Curve.pointCrossingsForLine(px, py, x0, y0, x1, y1);
                    var x0c = (x0 + xc) / 2;
                    var y0c = (y0 + yc) / 2;
                    var xc1 = (xc + x1) / 2;
                    var yc1 = (yc + y1) / 2;
                    xc = (x0c + xc1) / 2;
                    yc = (y0c + yc1) / 2;
                    if (isNaN(xc) || isNaN(yc)) {
                        return 0;
                    }
                    return (Curve.pointCrossingsForQuad(px, py, x0, y0, x0c, y0c, xc, yc, level + 1) + Curve.pointCrossingsForQuad(px, py, xc, yc, xc1, yc1, x1, y1, level + 1));
                };
                /**
                 * Calculates the number of times the cubic from (x0,y0) to (x1,y1) crosses
                 * the ray extending to the right from (px,py). If the point lies on a part
                 * of the curve, then no crossings are counted for that intersection. the
                 * level parameter should be 0 at the top-level call and will count up for
                 * each recursion level to prevent infinite recursion +1 is added for each
                 * crossing where the Y coordinate is increasing -1 is added for each
                 * crossing where the Y coordinate is decreasing
                 */
                Curve.pointCrossingsForCubic = function (px, py, x0, y0, xc0, yc0, xc1, yc1, x1, y1, level) {
                    if (py < y0 && py < yc0 && py < yc1 && py < y1)
                        return 0;
                    if (py >= y0 && py >= yc0 && py >= yc1 && py >= y1)
                        return 0;
                    if (px >= x0 && px >= xc0 && px >= xc1 && px >= x1)
                        return 0;
                    if (px < x0 && px < xc0 && px < xc1 && px < x1) {
                        if (py >= y0) {
                            if (py < y1)
                                return 1;
                        }
                        else {
                            if (py >= y1)
                                return -1;
                        }
                        return 0;
                    }
                    if (level > 52)
                        return Curve.pointCrossingsForLine(px, py, x0, y0, x1, y1);
                    var xmid = (xc0 + xc1) / 2;
                    var ymid = (yc0 + yc1) / 2;
                    xc0 = (x0 + xc0) / 2;
                    yc0 = (y0 + yc0) / 2;
                    xc1 = (xc1 + x1) / 2;
                    yc1 = (yc1 + y1) / 2;
                    var xc0m = (xc0 + xmid) / 2;
                    var yc0m = (yc0 + ymid) / 2;
                    var xmc1 = (xmid + xc1) / 2;
                    var ymc1 = (ymid + yc1) / 2;
                    xmid = (xc0m + xmc1) / 2;
                    ymid = (yc0m + ymc1) / 2;
                    if (isNaN(xmid) || isNaN(ymid)) {
                        return 0;
                    }
                    return (Curve.pointCrossingsForCubic(px, py, x0, y0, xc0, yc0, xc0m, yc0m, xmid, ymid, level + 1) + Curve.pointCrossingsForCubic(px, py, xmid, ymid, xmc1, ymc1, xc1, yc1, x1, y1, level + 1));
                };
                /**
                 * Accumulate the number of times the path crosses the shadow extending to
                 * the right of the rectangle. See the comment for the RECT_INTERSECTS
                 * constant for more complete details. The return value is the sum of all
                 * crossings for both the top and bottom of the shadow for every segment in
                 * the path, or the special value RECT_INTERSECTS if the path ever enters
                 * the interior of the rectangle. The path must start with a SEG_MOVETO,
                 * otherwise an exception is thrown. The caller must check r[xy]{min,max}
                 * for NaN values.
                 */
                Curve.rectCrossingsForPath = function (pi, rxmin, rymin, rxmax, rymax) {
                    if (rxmax <= rxmin || rymax <= rymin) {
                        return 0;
                    }
                    if (pi.isDone()) {
                        return 0;
                    }
                    var coords = new Array(6);
                    if (pi.currentSegment(coords) !== java.awt.geom.PathIterator.SEG_MOVETO) {
                        throw new java.awt.geom.IllegalPathStateException("missing initial moveto in path definition");
                    }
                    pi.next();
                    var curx;
                    var cury;
                    var movx;
                    var movy;
                    var endx;
                    var endy;
                    curx = movx = coords[0];
                    cury = movy = coords[1];
                    var crossings = 0;
                    while ((crossings !== Curve.RECT_INTERSECTS && !pi.isDone())) {
                        switch ((pi.currentSegment(coords))) {
                            case java.awt.geom.PathIterator.SEG_MOVETO:
                                if (curx !== movx || cury !== movy) {
                                    crossings = Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                                }
                                movx = curx = coords[0];
                                movy = cury = coords[1];
                                break;
                            case java.awt.geom.PathIterator.SEG_LINETO:
                                endx = coords[0];
                                endy = coords[1];
                                crossings = Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, endx, endy);
                                curx = endx;
                                cury = endy;
                                break;
                            case java.awt.geom.PathIterator.SEG_QUADTO:
                                endx = coords[2];
                                endy = coords[3];
                                crossings = Curve.rectCrossingsForQuad(crossings, rxmin, rymin, rxmax, rymax, curx, cury, coords[0], coords[1], endx, endy, 0);
                                curx = endx;
                                cury = endy;
                                break;
                            case java.awt.geom.PathIterator.SEG_CUBICTO:
                                endx = coords[4];
                                endy = coords[5];
                                crossings = Curve.rectCrossingsForCubic(crossings, rxmin, rymin, rxmax, rymax, curx, cury, coords[0], coords[1], coords[2], coords[3], endx, endy, 0);
                                curx = endx;
                                cury = endy;
                                break;
                            case java.awt.geom.PathIterator.SEG_CLOSE:
                                if (curx !== movx || cury !== movy) {
                                    crossings = Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                                }
                                curx = movx;
                                cury = movy;
                                break;
                        }
                        pi.next();
                    }
                    ;
                    if (crossings !== Curve.RECT_INTERSECTS && (curx !== movx || cury !== movy)) {
                        crossings = Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                    }
                    return crossings;
                };
                /**
                 * Accumulate the number of times the line crosses the shadow extending to
                 * the right of the rectangle. See the comment for the RECT_INTERSECTS
                 * constant for more complete details.
                 */
                Curve.rectCrossingsForLine = function (crossings, rxmin, rymin, rxmax, rymax, x0, y0, x1, y1) {
                    if (y0 >= rymax && y1 >= rymax)
                        return crossings;
                    if (y0 <= rymin && y1 <= rymin)
                        return crossings;
                    if (x0 <= rxmin && x1 <= rxmin)
                        return crossings;
                    if (x0 >= rxmax && x1 >= rxmax) {
                        if (y0 < y1) {
                            if (y0 <= rymin)
                                crossings++;
                            if (y1 >= rymax)
                                crossings++;
                        }
                        else if (y1 < y0) {
                            if (y1 <= rymin)
                                crossings--;
                            if (y0 >= rymax)
                                crossings--;
                        }
                        return crossings;
                    }
                    if ((x0 > rxmin && x0 < rxmax && y0 > rymin && y0 < rymax) || (x1 > rxmin && x1 < rxmax && y1 > rymin && y1 < rymax)) {
                        return Curve.RECT_INTERSECTS;
                    }
                    var xi0 = x0;
                    if (y0 < rymin) {
                        xi0 += ((rymin - y0) * (x1 - x0) / (y1 - y0));
                    }
                    else if (y0 > rymax) {
                        xi0 += ((rymax - y0) * (x1 - x0) / (y1 - y0));
                    }
                    var xi1 = x1;
                    if (y1 < rymin) {
                        xi1 += ((rymin - y1) * (x0 - x1) / (y0 - y1));
                    }
                    else if (y1 > rymax) {
                        xi1 += ((rymax - y1) * (x0 - x1) / (y0 - y1));
                    }
                    if (xi0 <= rxmin && xi1 <= rxmin)
                        return crossings;
                    if (xi0 >= rxmax && xi1 >= rxmax) {
                        if (y0 < y1) {
                            if (y0 <= rymin)
                                crossings++;
                            if (y1 >= rymax)
                                crossings++;
                        }
                        else if (y1 < y0) {
                            if (y1 <= rymin)
                                crossings--;
                            if (y0 >= rymax)
                                crossings--;
                        }
                        return crossings;
                    }
                    return Curve.RECT_INTERSECTS;
                };
                /**
                 * Accumulate the number of times the quad crosses the shadow extending to
                 * the right of the rectangle. See the comment for the RECT_INTERSECTS
                 * constant for more complete details.
                 */
                Curve.rectCrossingsForQuad = function (crossings, rxmin, rymin, rxmax, rymax, x0, y0, xc, yc, x1, y1, level) {
                    if (y0 >= rymax && yc >= rymax && y1 >= rymax)
                        return crossings;
                    if (y0 <= rymin && yc <= rymin && y1 <= rymin)
                        return crossings;
                    if (x0 <= rxmin && xc <= rxmin && x1 <= rxmin)
                        return crossings;
                    if (x0 >= rxmax && xc >= rxmax && x1 >= rxmax) {
                        if (y0 < y1) {
                            if (y0 <= rymin && y1 > rymin)
                                crossings++;
                            if (y0 < rymax && y1 >= rymax)
                                crossings++;
                        }
                        else if (y1 < y0) {
                            if (y1 <= rymin && y0 > rymin)
                                crossings--;
                            if (y1 < rymax && y0 >= rymax)
                                crossings--;
                        }
                        return crossings;
                    }
                    if ((x0 < rxmax && x0 > rxmin && y0 < rymax && y0 > rymin) || (x1 < rxmax && x1 > rxmin && y1 < rymax && y1 > rymin)) {
                        return Curve.RECT_INTERSECTS;
                    }
                    if (level > 52) {
                        return Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, x0, y0, x1, y1);
                    }
                    var x0c = (x0 + xc) / 2;
                    var y0c = (y0 + yc) / 2;
                    var xc1 = (xc + x1) / 2;
                    var yc1 = (yc + y1) / 2;
                    xc = (x0c + xc1) / 2;
                    yc = (y0c + yc1) / 2;
                    if (isNaN(xc) || isNaN(yc)) {
                        return 0;
                    }
                    crossings = Curve.rectCrossingsForQuad(crossings, rxmin, rymin, rxmax, rymax, x0, y0, x0c, y0c, xc, yc, level + 1);
                    if (crossings !== Curve.RECT_INTERSECTS) {
                        crossings = Curve.rectCrossingsForQuad(crossings, rxmin, rymin, rxmax, rymax, xc, yc, xc1, yc1, x1, y1, level + 1);
                    }
                    return crossings;
                };
                /**
                 * Accumulate the number of times the cubic crosses the shadow extending to
                 * the right of the rectangle. See the comment for the RECT_INTERSECTS
                 * constant for more complete details.
                 */
                Curve.rectCrossingsForCubic = function (crossings, rxmin, rymin, rxmax, rymax, x0, y0, xc0, yc0, xc1, yc1, x1, y1, level) {
                    if (y0 >= rymax && yc0 >= rymax && yc1 >= rymax && y1 >= rymax) {
                        return crossings;
                    }
                    if (y0 <= rymin && yc0 <= rymin && yc1 <= rymin && y1 <= rymin) {
                        return crossings;
                    }
                    if (x0 <= rxmin && xc0 <= rxmin && xc1 <= rxmin && x1 <= rxmin) {
                        return crossings;
                    }
                    if (x0 >= rxmax && xc0 >= rxmax && xc1 >= rxmax && x1 >= rxmax) {
                        if (y0 < y1) {
                            if (y0 <= rymin && y1 > rymin)
                                crossings++;
                            if (y0 < rymax && y1 >= rymax)
                                crossings++;
                        }
                        else if (y1 < y0) {
                            if (y1 <= rymin && y0 > rymin)
                                crossings--;
                            if (y1 < rymax && y0 >= rymax)
                                crossings--;
                        }
                        return crossings;
                    }
                    if ((x0 > rxmin && x0 < rxmax && y0 > rymin && y0 < rymax) || (x1 > rxmin && x1 < rxmax && y1 > rymin && y1 < rymax)) {
                        return Curve.RECT_INTERSECTS;
                    }
                    if (level > 52) {
                        return Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, x0, y0, x1, y1);
                    }
                    var xmid = (xc0 + xc1) / 2;
                    var ymid = (yc0 + yc1) / 2;
                    xc0 = (x0 + xc0) / 2;
                    yc0 = (y0 + yc0) / 2;
                    xc1 = (xc1 + x1) / 2;
                    yc1 = (yc1 + y1) / 2;
                    var xc0m = (xc0 + xmid) / 2;
                    var yc0m = (yc0 + ymid) / 2;
                    var xmc1 = (xmid + xc1) / 2;
                    var ymc1 = (ymid + yc1) / 2;
                    xmid = (xc0m + xmc1) / 2;
                    ymid = (yc0m + ymc1) / 2;
                    if (isNaN(xmid) || isNaN(ymid)) {
                        return 0;
                    }
                    crossings = Curve.rectCrossingsForCubic(crossings, rxmin, rymin, rxmax, rymax, x0, y0, xc0, yc0, xc0m, yc0m, xmid, ymid, level + 1);
                    if (crossings !== Curve.RECT_INTERSECTS) {
                        crossings = Curve.rectCrossingsForCubic(crossings, rxmin, rymin, rxmax, rymax, xmid, ymid, xmc1, ymc1, xc1, yc1, x1, y1, level + 1);
                    }
                    return crossings;
                };
                Curve.prototype.getDirection = function () {
                    return this.direction;
                };
                Curve.prototype.getWithDirection = function (direction) {
                    return (this.direction === direction ? this : this.getReversedCurve());
                };
                Curve.round = function (v) {
                    return v;
                };
                Curve.orderof = function (x1, x2) {
                    if (x1 < x2) {
                        return -1;
                    }
                    if (x1 > x2) {
                        return 1;
                    }
                    return 0;
                };
                Curve.signeddiffbits = function (y1, y2) {
                    return (javaemul.internal.DoubleHelper.doubleToLongBits(y1) - javaemul.internal.DoubleHelper.doubleToLongBits(y2));
                };
                Curve.diffbits = function (y1, y2) {
                    return Math.abs(javaemul.internal.DoubleHelper.doubleToLongBits(y1) - javaemul.internal.DoubleHelper.doubleToLongBits(y2));
                };
                Curve.prev = function (v) {
                    return javaemul.internal.DoubleHelper.longBitsToDouble(javaemul.internal.DoubleHelper.doubleToLongBits(v) - 1);
                };
                Curve.next = function (v) {
                    return javaemul.internal.DoubleHelper.longBitsToDouble(javaemul.internal.DoubleHelper.doubleToLongBits(v) + 1);
                };
                Curve.prototype.toString = function () {
                    return ("Curve[" + this.getOrder() + ", " + ("(" + Curve.round(this.getX0()) + ", " + Curve.round(this.getY0()) + "), ") + this.controlPointString() + ("(" + Curve.round(this.getX1()) + ", " + Curve.round(this.getY1()) + "), ") + (this.direction === Curve.INCREASING ? "D" : "U") + "]");
                };
                Curve.prototype.controlPointString = function () {
                    return "";
                };
                Curve.prototype.crossingsFor = function (x, y) {
                    if (y >= this.getYTop() && y < this.getYBot()) {
                        if (x < this.getXMax() && (x < this.getXMin() || x < this.XforY(y))) {
                            return 1;
                        }
                    }
                    return 0;
                };
                Curve.prototype.accumulateCrossings = function (c) {
                    var xhi = c.getXHi();
                    if (this.getXMin() >= xhi) {
                        return false;
                    }
                    var xlo = c.getXLo();
                    var ylo = c.getYLo();
                    var yhi = c.getYHi();
                    var y0 = this.getYTop();
                    var y1 = this.getYBot();
                    var tstart;
                    var ystart;
                    var tend;
                    var yend;
                    if (y0 < ylo) {
                        if (y1 <= ylo) {
                            return false;
                        }
                        ystart = ylo;
                        tstart = this.TforY(ylo);
                    }
                    else {
                        if (y0 >= yhi) {
                            return false;
                        }
                        ystart = y0;
                        tstart = 0;
                    }
                    if (y1 > yhi) {
                        yend = yhi;
                        tend = this.TforY(yhi);
                    }
                    else {
                        yend = y1;
                        tend = 1;
                    }
                    var hitLo = false;
                    var hitHi = false;
                    while ((true)) {
                        var x = this.XforT(tstart);
                        if (x < xhi) {
                            if (hitHi || x > xlo) {
                                return true;
                            }
                            hitLo = true;
                        }
                        else {
                            if (hitLo) {
                                return true;
                            }
                            hitHi = true;
                        }
                        if (tstart >= tend) {
                            break;
                        }
                        tstart = this.nextVertical(tstart, tend);
                    }
                    ;
                    if (hitLo) {
                        c.record(ystart, yend, this.direction);
                    }
                    return false;
                };
                Curve.prototype.getSubCurve$double$double = function (ystart, yend) {
                    return this.getSubCurve(ystart, yend, this.direction);
                };
                Curve.prototype.getSubCurve = function (ystart, yend, dir) {
                    if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && ((typeof dir === 'number') || dir === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return null;
                    }
                    else if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && dir === undefined) {
                        return this.getSubCurve$double$double(ystart, yend);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Curve.prototype.compareTo = function (that, yrange) {
                    var y0 = yrange[0];
                    var y1 = yrange[1];
                    y1 = Math.min(Math.min(y1, this.getYBot()), that.getYBot());
                    if (y1 <= yrange[0]) {
                        console.error("this == " + this);
                        console.error("that == " + that);
                        console.info("target range = " + yrange[0] + "=>" + yrange[1]);
                        throw new java.lang.InternalError("backstepping from " + yrange[0] + " to " + y1);
                    }
                    yrange[1] = y1;
                    if (this.getXMax() <= that.getXMin()) {
                        if (this.getXMin() === that.getXMax()) {
                            return 0;
                        }
                        return -1;
                    }
                    if (this.getXMin() >= that.getXMax()) {
                        return 1;
                    }
                    var s0 = this.TforY(y0);
                    var ys0 = this.YforT(s0);
                    if (ys0 < y0) {
                        s0 = this.refineTforY(s0, ys0, y0);
                        ys0 = this.YforT(s0);
                    }
                    var s1 = this.TforY(y1);
                    if (this.YforT(s1) < y0) {
                        s1 = this.refineTforY(s1, this.YforT(s1), y0);
                    }
                    var t0 = that.TforY(y0);
                    var yt0 = that.YforT(t0);
                    if (yt0 < y0) {
                        t0 = that.refineTforY(t0, yt0, y0);
                        yt0 = that.YforT(t0);
                    }
                    var t1 = that.TforY(y1);
                    if (that.YforT(t1) < y0) {
                        t1 = that.refineTforY(t1, that.YforT(t1), y0);
                    }
                    var xs0 = this.XforT(s0);
                    var xt0 = that.XforT(t0);
                    var scale = Math.max(Math.abs(y0), Math.abs(y1));
                    var ymin = Math.max(scale * 1.0E-14, 1.0E-300);
                    if (this.fairlyClose(xs0, xt0)) {
                        var bump = ymin;
                        var maxbump = Math.min(ymin * 1.0E13, (y1 - y0) * 0.1);
                        var y = y0 + bump;
                        while ((y <= y1)) {
                            if (this.fairlyClose(this.XforY(y), that.XforY(y))) {
                                if ((bump *= 2) > maxbump) {
                                    bump = maxbump;
                                }
                            }
                            else {
                                y -= bump;
                                while ((true)) {
                                    bump /= 2;
                                    var newy = y + bump;
                                    if (newy <= y) {
                                        break;
                                    }
                                    if (this.fairlyClose(this.XforY(newy), that.XforY(newy))) {
                                        y = newy;
                                    }
                                }
                                ;
                                break;
                            }
                            y += bump;
                        }
                        ;
                        if (y > y0) {
                            if (y < y1) {
                                yrange[1] = y;
                            }
                            return 0;
                        }
                    }
                    if (ymin <= 0) {
                        console.info("ymin = " + ymin);
                    }
                    while ((s0 < s1 && t0 < t1)) {
                        var sh = this.nextVertical(s0, s1);
                        var xsh = this.XforT(sh);
                        var ysh = this.YforT(sh);
                        var th = that.nextVertical(t0, t1);
                        var xth = that.XforT(th);
                        var yth = that.YforT(th);
                        try {
                            if (this.findIntersect(that, yrange, ymin, 0, 0, s0, xs0, ys0, sh, xsh, ysh, t0, xt0, yt0, th, xth, yth)) {
                                break;
                            }
                        }
                        catch (t) {
                            console.error("Error: " + t);
                            console.error("y range was " + yrange[0] + "=>" + yrange[1]);
                            console.error("s y range is " + ys0 + "=>" + ysh);
                            console.error("t y range is " + yt0 + "=>" + yth);
                            console.error("ymin is " + ymin);
                            return 0;
                        }
                        ;
                        if (ysh < yth) {
                            if (ysh > yrange[0]) {
                                if (ysh < yrange[1]) {
                                    yrange[1] = ysh;
                                }
                                break;
                            }
                            s0 = sh;
                            xs0 = xsh;
                            ys0 = ysh;
                        }
                        else {
                            if (yth > yrange[0]) {
                                if (yth < yrange[1]) {
                                    yrange[1] = yth;
                                }
                                break;
                            }
                            t0 = th;
                            xt0 = xth;
                            yt0 = yth;
                        }
                    }
                    ;
                    var ymid = (yrange[0] + yrange[1]) / 2;
                    return Curve.orderof(this.XforY(ymid), that.XforY(ymid));
                };
                Curve.prototype.findIntersect = function (that, yrange, ymin, slevel, tlevel, s0, xs0, ys0, s1, xs1, ys1, t0, xt0, yt0, t1, xt1, yt1) {
                    if (ys0 > yt1 || yt0 > ys1) {
                        return false;
                    }
                    if (Math.min(xs0, xs1) > Math.max(xt0, xt1) || Math.max(xs0, xs1) < Math.min(xt0, xt1)) {
                        return false;
                    }
                    if (s1 - s0 > Curve.TMIN) {
                        var s = (s0 + s1) / 2;
                        var xs = this.XforT(s);
                        var ys = this.YforT(s);
                        if (s === s0 || s === s1) {
                            console.info("s0 = " + s0);
                            console.info("s1 = " + s1);
                            throw new java.lang.InternalError("no s progress!");
                        }
                        if (t1 - t0 > Curve.TMIN) {
                            var t = (t0 + t1) / 2;
                            var xt = that.XforT(t);
                            var yt = that.YforT(t);
                            if (t === t0 || t === t1) {
                                console.info("t0 = " + t0);
                                console.info("t1 = " + t1);
                                throw new java.lang.InternalError("no t progress!");
                            }
                            if (ys >= yt0 && yt >= ys0) {
                                if (this.findIntersect(that, yrange, ymin, slevel + 1, tlevel + 1, s0, xs0, ys0, s, xs, ys, t0, xt0, yt0, t, xt, yt)) {
                                    return true;
                                }
                            }
                            if (ys >= yt) {
                                if (this.findIntersect(that, yrange, ymin, slevel + 1, tlevel + 1, s0, xs0, ys0, s, xs, ys, t, xt, yt, t1, xt1, yt1)) {
                                    return true;
                                }
                            }
                            if (yt >= ys) {
                                if (this.findIntersect(that, yrange, ymin, slevel + 1, tlevel + 1, s, xs, ys, s1, xs1, ys1, t0, xt0, yt0, t, xt, yt)) {
                                    return true;
                                }
                            }
                            if (ys1 >= yt && yt1 >= ys) {
                                if (this.findIntersect(that, yrange, ymin, slevel + 1, tlevel + 1, s, xs, ys, s1, xs1, ys1, t, xt, yt, t1, xt1, yt1)) {
                                    return true;
                                }
                            }
                        }
                        else {
                            if (ys >= yt0) {
                                if (this.findIntersect(that, yrange, ymin, slevel + 1, tlevel, s0, xs0, ys0, s, xs, ys, t0, xt0, yt0, t1, xt1, yt1)) {
                                    return true;
                                }
                            }
                            if (yt1 >= ys) {
                                if (this.findIntersect(that, yrange, ymin, slevel + 1, tlevel, s, xs, ys, s1, xs1, ys1, t0, xt0, yt0, t1, xt1, yt1)) {
                                    return true;
                                }
                            }
                        }
                    }
                    else if (t1 - t0 > Curve.TMIN) {
                        var t = (t0 + t1) / 2;
                        var xt = that.XforT(t);
                        var yt = that.YforT(t);
                        if (t === t0 || t === t1) {
                            console.info("t0 = " + t0);
                            console.info("t1 = " + t1);
                            throw new java.lang.InternalError("no t progress!");
                        }
                        if (yt >= ys0) {
                            if (this.findIntersect(that, yrange, ymin, slevel, tlevel + 1, s0, xs0, ys0, s1, xs1, ys1, t0, xt0, yt0, t, xt, yt)) {
                                return true;
                            }
                        }
                        if (ys1 >= yt) {
                            if (this.findIntersect(that, yrange, ymin, slevel, tlevel + 1, s0, xs0, ys0, s1, xs1, ys1, t, xt, yt, t1, xt1, yt1)) {
                                return true;
                            }
                        }
                    }
                    else {
                        var xlk = xs1 - xs0;
                        var ylk = ys1 - ys0;
                        var xnm = xt1 - xt0;
                        var ynm = yt1 - yt0;
                        var xmk = xt0 - xs0;
                        var ymk = yt0 - ys0;
                        var det = xnm * ylk - ynm * xlk;
                        if (det !== 0) {
                            var detinv = 1 / det;
                            var s = (xnm * ymk - ynm * xmk) * detinv;
                            var t = (xlk * ymk - ylk * xmk) * detinv;
                            if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
                                s = s0 + s * (s1 - s0);
                                t = t0 + t * (t1 - t0);
                                if (s < 0 || s > 1 || t < 0 || t > 1) {
                                    console.info("Uh oh!");
                                }
                                var y = (this.YforT(s) + that.YforT(t)) / 2;
                                if (y <= yrange[1] && y > yrange[0]) {
                                    yrange[1] = y;
                                    return true;
                                }
                            }
                        }
                    }
                    return false;
                };
                Curve.prototype.refineTforY = function (t0, yt0, y0) {
                    var t1 = 1;
                    while ((true)) {
                        var th = (t0 + t1) / 2;
                        if (th === t0 || th === t1) {
                            return t1;
                        }
                        var y = this.YforT(th);
                        if (y < y0) {
                            t0 = th;
                            yt0 = y;
                        }
                        else if (y > y0) {
                            t1 = th;
                        }
                        else {
                            return t1;
                        }
                    }
                    ;
                };
                Curve.prototype.fairlyClose = function (v1, v2) {
                    return (Math.abs(v1 - v2) < Math.max(Math.abs(v1), Math.abs(v2)) * 1.0E-10);
                };
                Curve.INCREASING = 1;
                Curve.DECREASING = -1;
                /**
                 * The rectangle intersection test counts the number of times that the path
                 * crosses through the shadow that the rectangle projects to the right
                 * towards (x => +INFINITY).
                 *
                 * During processing of the path it actually counts every time the path
                 * crosses either or both of the top and bottom edges of that shadow. If the
                 * path enters from the top, the count is incremented. If it then exits back
                 * through the top, the same way it came in, the count is decremented and
                 * there is no impact on the winding count. If, instead, the path exits out
                 * the bottom, then the count is incremented again and a full pass through
                 * the shadow is indicated by the winding count having been incremented by
                 * 2.
                 *
                 * Thus, the winding count that it accumulates is actually double the real
                 * winding count. Since the path is continuous, the final answer should be a
                 * multiple of 2, otherwise there is a logic error somewhere.
                 *
                 * If the path ever has a direct hit on the rectangle, then a special value
                 * is returned. This special value terminates all ongoing accumulation on up
                 * through the call chain and ends up getting returned to the calling
                 * function which can then produce an answer directly. For intersection
                 * tests, the answer is always "true" if the path intersects the rectangle.
                 * For containment tests, the answer is always "false" if the path
                 * intersects the rectangle. Thus, no further processing is ever needed if
                 * an intersection occurs.
                 */
                Curve.RECT_INTERSECTS = -2147483648;
                Curve.TMIN = 0.001;
                return Curve;
            }());
            geom.Curve = Curve;
            Curve["__class"] = "sun.awt.geom.Curve";
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var sun;
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var CurveLink = (function () {
                function CurveLink(curve, ystart, yend, etag) {
                    this.ytop = 0;
                    this.ybot = 0;
                    this.etag = 0;
                    this.curve = curve;
                    this.ytop = ystart;
                    this.ybot = yend;
                    this.etag = etag;
                    if (this.ytop < curve.getYTop() || this.ybot > curve.getYBot()) {
                        throw new java.lang.InternalError("bad curvelink [" + this.ytop + "=>" + this.ybot + "] for " + curve);
                    }
                }
                CurveLink.prototype.absorb$sun_awt_geom_CurveLink = function (link) {
                    return this.absorb(link.curve, link.ytop, link.ybot, link.etag);
                };
                CurveLink.prototype.absorb = function (curve, ystart, yend, etag) {
                    var _this = this;
                    if (((curve != null && curve instanceof sun.awt.geom.Curve) || curve === null) && ((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && ((typeof etag === 'number') || etag === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (_this.curve !== curve || _this.etag !== etag || _this.ybot < ystart || _this.ytop > yend) {
                                return false;
                            }
                            if (ystart < curve.getYTop() || yend > curve.getYBot()) {
                                throw new java.lang.InternalError("bad curvelink [" + ystart + "=>" + yend + "] for " + curve);
                            }
                            _this.ytop = Math.min(_this.ytop, ystart);
                            _this.ybot = Math.max(_this.ybot, yend);
                            return true;
                        })();
                    }
                    else if (((curve != null && curve instanceof sun.awt.geom.CurveLink) || curve === null) && ystart === undefined && yend === undefined && etag === undefined) {
                        return this.absorb$sun_awt_geom_CurveLink(curve);
                    }
                    else
                        throw new Error('invalid overload');
                };
                CurveLink.prototype.isEmpty = function () {
                    return (this.ytop === this.ybot);
                };
                CurveLink.prototype.getCurve = function () {
                    return this.curve;
                };
                CurveLink.prototype.getSubCurve = function () {
                    if (this.ytop === this.curve.getYTop() && this.ybot === this.curve.getYBot()) {
                        return this.curve.getWithDirection(this.etag);
                    }
                    return this.curve.getSubCurve(this.ytop, this.ybot, this.etag);
                };
                CurveLink.prototype.getMoveto = function () {
                    return new sun.awt.geom.Order0(this.getXTop(), this.getYTop());
                };
                CurveLink.prototype.getXTop = function () {
                    return this.curve.XforY(this.ytop);
                };
                CurveLink.prototype.getYTop = function () {
                    return this.ytop;
                };
                CurveLink.prototype.getXBot = function () {
                    return this.curve.XforY(this.ybot);
                };
                CurveLink.prototype.getYBot = function () {
                    return this.ybot;
                };
                CurveLink.prototype.getX = function () {
                    return this.curve.XforY(this.ytop);
                };
                CurveLink.prototype.getEdgeTag = function () {
                    return this.etag;
                };
                CurveLink.prototype.setNext = function (link) {
                    this.next = link;
                };
                CurveLink.prototype.getNext = function () {
                    return this.next;
                };
                return CurveLink;
            }());
            geom.CurveLink = CurveLink;
            CurveLink["__class"] = "sun.awt.geom.CurveLink";
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var sun;
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Edge = (function () {
                function Edge(c, ctag, etag) {
                    if (etag === void 0) { etag = sun.awt.geom.AreaOp.ETAG_IGNORE; }
                    this.ctag = 0;
                    this.etag = 0;
                    this.activey = 0;
                    this.equivalence = 0;
                    this.lastResult = 0;
                    this.lastLimit = 0;
                    this.curve = c;
                    this.ctag = ctag;
                    this.etag = etag;
                }
                Edge.prototype.getCurve = function () {
                    return this.curve;
                };
                Edge.prototype.getCurveTag = function () {
                    return this.ctag;
                };
                Edge.prototype.getEdgeTag = function () {
                    return this.etag;
                };
                Edge.prototype.setEdgeTag = function (etag) {
                    this.etag = etag;
                };
                Edge.prototype.getEquivalence = function () {
                    return this.equivalence;
                };
                Edge.prototype.setEquivalence = function (eq) {
                    this.equivalence = eq;
                };
                Edge.prototype.compareTo = function (other, yrange) {
                    if (other === this.lastEdge && yrange[0] < this.lastLimit) {
                        if (yrange[1] > this.lastLimit) {
                            yrange[1] = this.lastLimit;
                        }
                        return this.lastResult;
                    }
                    if (this === other.lastEdge && yrange[0] < other.lastLimit) {
                        if (yrange[1] > other.lastLimit) {
                            yrange[1] = other.lastLimit;
                        }
                        return 0 - other.lastResult;
                    }
                    var ret = this.curve.compareTo(other.curve, yrange);
                    this.lastEdge = other;
                    this.lastLimit = yrange[1];
                    this.lastResult = ret;
                    return ret;
                };
                Edge.prototype.record = function (yend, etag) {
                    this.activey = yend;
                    this.etag = etag;
                };
                Edge.prototype.isActiveFor = function (y, etag) {
                    return (this.etag === etag && this.activey >= y);
                };
                Edge.prototype.toString = function () {
                    return ("Edge[" + this.curve + ", " + (this.ctag === sun.awt.geom.AreaOp.CTAG_LEFT ? "L" : "R") + ", " + (this.etag === sun.awt.geom.AreaOp.ETAG_ENTER ? "I" : (this.etag === sun.awt.geom.AreaOp.ETAG_EXIT ? "O" : "N")) + "]");
                };
                Edge.INIT_PARTS = 4;
                Edge.GROW_PARTS = 10;
                return Edge;
            }());
            geom.Edge = Edge;
            Edge["__class"] = "sun.awt.geom.Edge";
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var event;
        (function (event) {
            /**
             * The adjustment event emitted by Adjustable objects like
             * {@link java.awt.Scrollbar} and {@link java.awt.ScrollPane}.
             * When the user changes the value of the scrolling component,
             * it receives an instance of {@code AdjustmentEvent}.
             * <p>
             * An unspecified behavior will be caused if the {@code id} parameter
             * of any particular {@code AdjustmentEvent} instance is not
             * in the range from {@code ADJUSTMENT_FIRST} to {@code ADJUSTMENT_LAST}.
             * <p>
             * The {@code type} of any {@code AdjustmentEvent} instance takes one of the following
             * values:
             * <ul>
             * <li> {@code UNIT_INCREMENT}
             * <li> {@code UNIT_DECREMENT}
             * <li> {@code BLOCK_INCREMENT}
             * <li> {@code BLOCK_DECREMENT}
             * <li> {@code TRACK}
             * </ul>
             * Assigning the value different from listed above will cause an unspecified behavior.
             * @see java.awt.Adjustable
             * @see AdjustmentListener
             *
             * @author Amy Fowler
             * @since 1.1
             */
            var AdjustmentEvent = (function (_super) {
                __extends(AdjustmentEvent, _super);
                /**
                 * Constructs an <code>AdjustmentEvent</code> object with the
                 * specified Adjustable source, event type, adjustment type, and value.
                 * <p> This method throws an
                 * <code>IllegalArgumentException</code> if <code>source</code>
                 * is <code>null</code>.
                 *
                 * @param source The <code>Adjustable</code> object where the
                 * event originated
                 * @param id     An integer indicating the type of event.
                 * For information on allowable values, see
                 * the class description for {@link AdjustmentEvent}
                 * @param type   An integer indicating the adjustment type.
                 * For information on allowable values, see
                 * the class description for {@link AdjustmentEvent}
                 * @param value  The current value of the adjustment
                 * @param isAdjusting A boolean that equals <code>true</code> if the event is one
                 * of a series of multiple adjusting events,
                 * otherwise <code>false</code>
                 * @throws IllegalArgumentException if <code>source</code> is null
                 * @since 1.4
                 * @see #getSource()
                 * @see #getID()
                 * @see #getAdjustmentType()
                 * @see #getValue()
                 * @see #getValueIsAdjusting()
                 */
                function AdjustmentEvent(source, id, type, value, isAdjusting) {
                    if (isAdjusting === void 0) { isAdjusting = false; }
                    _super.call(this, source, id);
                    this.value = 0;
                    this.adjustmentType = 0;
                    this.isAdjusting = false;
                    this.adjustable = source;
                    this.adjustmentType = type;
                    this.value = value;
                    this.isAdjusting = isAdjusting;
                }
                AdjustmentEvent.ADJUSTMENT_VALUE_CHANGED_$LI$ = function () { if (AdjustmentEvent.ADJUSTMENT_VALUE_CHANGED == null)
                    AdjustmentEvent.ADJUSTMENT_VALUE_CHANGED = AdjustmentEvent.ADJUSTMENT_FIRST; return AdjustmentEvent.ADJUSTMENT_VALUE_CHANGED; };
                ;
                /**
                 * Returns the <code>Adjustable</code> object where this event originated.
                 *
                 * @return the <code>Adjustable</code> object where this event originated
                 */
                AdjustmentEvent.prototype.getAdjustable = function () {
                    return this.adjustable;
                };
                /**
                 * Returns the current value in the adjustment event.
                 *
                 * @return the current value in the adjustment event
                 */
                AdjustmentEvent.prototype.getValue = function () {
                    return this.value;
                };
                /**
                 * Returns the type of adjustment which caused the value changed
                 * event.  It will have one of the following values:
                 * <ul>
                 * <li>{@link #UNIT_INCREMENT}
                 * <li>{@link #UNIT_DECREMENT}
                 * <li>{@link #BLOCK_INCREMENT}
                 * <li>{@link #BLOCK_DECREMENT}
                 * <li>{@link #TRACK}
                 * </ul>
                 * @return one of the adjustment values listed above
                 */
                AdjustmentEvent.prototype.getAdjustmentType = function () {
                    return this.adjustmentType;
                };
                /**
                 * Returns <code>true</code> if this is one of multiple
                 * adjustment events.
                 *
                 * @return <code>true</code> if this is one of multiple
                 * adjustment events, otherwise returns <code>false</code>
                 * @since 1.4
                 */
                AdjustmentEvent.prototype.getValueIsAdjusting = function () {
                    return this.isAdjusting;
                };
                AdjustmentEvent.prototype.paramString = function () {
                    var typeStr;
                    switch ((this.id)) {
                        case AdjustmentEvent.ADJUSTMENT_VALUE_CHANGED_$LI$():
                            typeStr = "ADJUSTMENT_VALUE_CHANGED";
                            break;
                        default:
                            typeStr = "unknown type";
                    }
                    var adjTypeStr;
                    switch ((this.adjustmentType)) {
                        case AdjustmentEvent.UNIT_INCREMENT:
                            adjTypeStr = "UNIT_INCREMENT";
                            break;
                        case AdjustmentEvent.UNIT_DECREMENT:
                            adjTypeStr = "UNIT_DECREMENT";
                            break;
                        case AdjustmentEvent.BLOCK_INCREMENT:
                            adjTypeStr = "BLOCK_INCREMENT";
                            break;
                        case AdjustmentEvent.BLOCK_DECREMENT:
                            adjTypeStr = "BLOCK_DECREMENT";
                            break;
                        case AdjustmentEvent.TRACK:
                            adjTypeStr = "TRACK";
                            break;
                        default:
                            adjTypeStr = "unknown type";
                    }
                    return typeStr + ",adjType=" + adjTypeStr + ",value=" + this.value + ",isAdjusting=" + this.isAdjusting;
                };
                /**
                 * Marks the first integer id for the range of adjustment event ids.
                 */
                AdjustmentEvent.ADJUSTMENT_FIRST = 601;
                /**
                 * Marks the last integer id for the range of adjustment event ids.
                 */
                AdjustmentEvent.ADJUSTMENT_LAST = 601;
                /**
                 * The unit increment adjustment type.
                 */
                AdjustmentEvent.UNIT_INCREMENT = 1;
                /**
                 * The unit decrement adjustment type.
                 */
                AdjustmentEvent.UNIT_DECREMENT = 2;
                /**
                 * The block decrement adjustment type.
                 */
                AdjustmentEvent.BLOCK_DECREMENT = 3;
                /**
                 * The block increment adjustment type.
                 */
                AdjustmentEvent.BLOCK_INCREMENT = 4;
                /**
                 * The absolute tracking adjustment type.
                 */
                AdjustmentEvent.TRACK = 5;
                AdjustmentEvent.serialVersionUID = 5700290645205279921;
                return AdjustmentEvent;
            }(java.awt.AWTEvent));
            event.AdjustmentEvent = AdjustmentEvent;
            AdjustmentEvent["__class"] = "java.awt.event.AdjustmentEvent";
            AdjustmentEvent["__interfaces"] = ["java.io.Serializable"];
        })(event = awt.event || (awt.event = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var event;
        (function (event) {
            var ComponentEvent = (function (_super) {
                __extends(ComponentEvent, _super);
                function ComponentEvent(source, id) {
                    _super.call(this, source, id);
                }
                ComponentEvent.COMPONENT_MOVED_$LI$ = function () { if (ComponentEvent.COMPONENT_MOVED == null)
                    ComponentEvent.COMPONENT_MOVED = ComponentEvent.COMPONENT_FIRST; return ComponentEvent.COMPONENT_MOVED; };
                ;
                ComponentEvent.COMPONENT_RESIZED_$LI$ = function () { if (ComponentEvent.COMPONENT_RESIZED == null)
                    ComponentEvent.COMPONENT_RESIZED = 1 + ComponentEvent.COMPONENT_FIRST; return ComponentEvent.COMPONENT_RESIZED; };
                ;
                ComponentEvent.COMPONENT_SHOWN_$LI$ = function () { if (ComponentEvent.COMPONENT_SHOWN == null)
                    ComponentEvent.COMPONENT_SHOWN = 2 + ComponentEvent.COMPONENT_FIRST; return ComponentEvent.COMPONENT_SHOWN; };
                ;
                ComponentEvent.COMPONENT_HIDDEN_$LI$ = function () { if (ComponentEvent.COMPONENT_HIDDEN == null)
                    ComponentEvent.COMPONENT_HIDDEN = 3 + ComponentEvent.COMPONENT_FIRST; return ComponentEvent.COMPONENT_HIDDEN; };
                ;
                ComponentEvent.prototype.getComponent = function () {
                    return (this.source != null && this.source instanceof java.awt.Component) ? this.source : null;
                };
                ComponentEvent.prototype.paramString = function () {
                    var typeStr;
                    var b = (this.source != null ? this.source.getBounds() : null);
                    switch ((this.id)) {
                        case ComponentEvent.COMPONENT_SHOWN_$LI$():
                            typeStr = "COMPONENT_SHOWN";
                            break;
                        case ComponentEvent.COMPONENT_HIDDEN_$LI$():
                            typeStr = "COMPONENT_HIDDEN";
                            break;
                        case ComponentEvent.COMPONENT_MOVED_$LI$():
                            typeStr = "COMPONENT_MOVED (" + b.x + "," + b.y + " " + b.width + "x" + b.height + ")";
                            break;
                        case ComponentEvent.COMPONENT_RESIZED_$LI$():
                            typeStr = "COMPONENT_RESIZED (" + b.x + "," + b.y + " " + b.width + "x" + b.height + ")";
                            break;
                        default:
                            typeStr = "unknown type";
                    }
                    return typeStr;
                };
                ComponentEvent.COMPONENT_FIRST = 100;
                ComponentEvent.COMPONENT_LAST = 103;
                ComponentEvent.serialVersionUID = 8101406823902992965;
                return ComponentEvent;
            }(java.awt.AWTEvent));
            event.ComponentEvent = ComponentEvent;
            ComponentEvent["__class"] = "java.awt.event.ComponentEvent";
            ComponentEvent["__interfaces"] = ["java.io.Serializable"];
        })(event = awt.event || (awt.event = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var event;
        (function (event) {
            var ItemEvent = (function (_super) {
                __extends(ItemEvent, _super);
                function ItemEvent(source, id, item, stateChange) {
                    _super.call(this, source, id);
                    this.stateChange = 0;
                    this.item = item;
                    this.stateChange = stateChange;
                }
                ItemEvent.ITEM_STATE_CHANGED_$LI$ = function () { if (ItemEvent.ITEM_STATE_CHANGED == null)
                    ItemEvent.ITEM_STATE_CHANGED = ItemEvent.ITEM_FIRST; return ItemEvent.ITEM_STATE_CHANGED; };
                ;
                ItemEvent.prototype.getItemSelectable = function () {
                    return this.source;
                };
                ItemEvent.prototype.getItem = function () {
                    return this.item;
                };
                ItemEvent.prototype.getStateChange = function () {
                    return this.stateChange;
                };
                ItemEvent.prototype.paramString = function () {
                    var typeStr;
                    switch ((this.id)) {
                        case ItemEvent.ITEM_STATE_CHANGED_$LI$():
                            typeStr = "ITEM_STATE_CHANGED";
                            break;
                        default:
                            typeStr = "unknown type";
                    }
                    var stateStr;
                    switch ((this.stateChange)) {
                        case ItemEvent.SELECTED:
                            stateStr = "SELECTED";
                            break;
                        case ItemEvent.DESELECTED:
                            stateStr = "DESELECTED";
                            break;
                        default:
                            stateStr = "unknown type";
                    }
                    return typeStr + ",item=" + this.item + ",stateChange=" + stateStr;
                };
                ItemEvent.ITEM_FIRST = 701;
                ItemEvent.ITEM_LAST = 701;
                ItemEvent.SELECTED = 1;
                ItemEvent.DESELECTED = 2;
                ItemEvent.serialVersionUID = -608708132447206933;
                return ItemEvent;
            }(java.awt.AWTEvent));
            event.ItemEvent = ItemEvent;
            ItemEvent["__class"] = "java.awt.event.ItemEvent";
            ItemEvent["__interfaces"] = ["java.io.Serializable"];
        })(event = awt.event || (awt.event = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var event;
        (function (event) {
            /**
             * A semantic event which indicates that an object's text changed.
             * This high-level event is generated by an object (such as a TextComponent)
             * when its text changes. The event is passed to
             * every <code>TextListener</code> object which registered to receive such
             * events using the component's <code>addTextListener</code> method.
             * <P>
             * The object that implements the <code>TextListener</code> interface gets
             * this <code>TextEvent</code> when the event occurs. The listener is
             * spared the details of processing individual mouse movements and key strokes
             * Instead, it can process a "meaningful" (semantic) event like "text changed".
             * <p>
             * An unspecified behavior will be caused if the {@code id} parameter
             * of any particular {@code TextEvent} instance is not
             * in the range from {@code TEXT_FIRST} to {@code TEXT_LAST}.
             *
             * @author Georges Saab
             *
             * @see java.awt.TextComponent
             * @see TextListener
             *
             * @since 1.1
             */
            var TextEvent = (function (_super) {
                __extends(TextEvent, _super);
                /**
                 * Constructs a <code>TextEvent</code> object.
                 * <p> This method throws an
                 * <code>IllegalArgumentException</code> if <code>source</code>
                 * is <code>null</code>.
                 *
                 * @param source The (<code>TextComponent</code>) object that
                 * originated the event
                 * @param id     An integer that identifies the event type.
                 * For information on allowable values, see
                 * the class description for {@link TextEvent}
                 * @throws IllegalArgumentException if <code>source</code> is null
                 * @see #getSource()
                 * @see #getID()
                 */
                function TextEvent(source, id) {
                    _super.call(this, source, id);
                }
                TextEvent.TEXT_VALUE_CHANGED_$LI$ = function () { if (TextEvent.TEXT_VALUE_CHANGED == null)
                    TextEvent.TEXT_VALUE_CHANGED = TextEvent.TEXT_FIRST; return TextEvent.TEXT_VALUE_CHANGED; };
                ;
                /**
                 * Returns a parameter string identifying this text event.
                 * This method is useful for event-logging and for debugging.
                 *
                 * @return a string identifying the event and its attributes
                 */
                TextEvent.prototype.paramString = function () {
                    var typeStr;
                    switch ((this.id)) {
                        case TextEvent.TEXT_VALUE_CHANGED_$LI$():
                            typeStr = "TEXT_VALUE_CHANGED";
                            break;
                        default:
                            typeStr = "unknown type";
                    }
                    return typeStr;
                };
                /**
                 * The first number in the range of ids used for text events.
                 */
                TextEvent.TEXT_FIRST = 900;
                /**
                 * The last number in the range of ids used for text events.
                 */
                TextEvent.TEXT_LAST = 900;
                TextEvent.serialVersionUID = 6269902291250941179;
                return TextEvent;
            }(java.awt.AWTEvent));
            event.TextEvent = TextEvent;
            TextEvent["__class"] = "java.awt.event.TextEvent";
            TextEvent["__interfaces"] = ["java.io.Serializable"];
        })(event = awt.event || (awt.event = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var Button = (function (_super) {
            __extends(Button, _super);
            function Button(label) {
                _super.call(this);
                this.label = label;
                this.actionCommand = label;
            }
            Button.prototype.getHTMLElement = function () {
                return _super.prototype.getHTMLElement.call(this);
            };
            Button.prototype.createHTML = function () {
                if (this.htmlElement != null) {
                    return;
                }
                this.htmlElement = document.createElement("button");
            };
            Button.prototype.initHTML = function () {
                _super.prototype.initHTML.call(this);
                this.htmlElement.innerHTML = this.label;
                this.initActionListener();
            };
            Button.prototype.initActionListener = function () {
                var _this = this;
                if (this.actionListener != null) {
                    this.htmlElement.onclick = function (e) {
                        console.log("htmlElement clicked: " + _this.actionCommand);
                        _this.actionListener.actionPerformed(new java.awt.event.ActionEvent(_this, 0, _this.actionCommand));
                        return e;
                    };
                }
            };
            Button.prototype.addActionListener = function (actionListener) {
                this.actionListener = actionListener;
                if (this.htmlElement != null) {
                    this.initActionListener();
                }
            };
            Button.prototype.setBackground = function (background) {
                this.background = background;
            };
            return Button;
        }(java.awt.Component));
        awt.Button = Button;
        Button["__class"] = "java.awt.Button";
        Button["__interfaces"] = ["java.awt.HTMLComponent"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var Checkbox = (function (_super) {
            __extends(Checkbox, _super);
            function Checkbox(label, group, state) {
                var _this = this;
                if (((typeof label === 'string') || label === null) && ((group != null && group instanceof java.awt.CheckboxGroup) || group === null) && ((typeof state === 'boolean') || state === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_11 = Array.prototype.slice.call(arguments);
                        _super.call(this);
                        this.state = false;
                        (function () {
                            _this.label = label;
                            _this.state = state;
                            _this.group = group;
                            _this.itemListeners = (new Array());
                            if (state && (group != null)) {
                                group.setSelectedCheckbox(_this);
                            }
                        })();
                    }
                }
                else if (((typeof label === 'string') || label === null) && ((typeof group === 'boolean') || group === null) && ((state != null && state instanceof java.awt.CheckboxGroup) || state === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    var state_1 = __args[1];
                    var group_1 = __args[2];
                    _super.call(this);
                    this.state = false;
                    (function () {
                        _this.label = label;
                        _this.state = state_1;
                        _this.group = group_1;
                        _this.itemListeners = (new Array());
                        if (state_1 && (group_1 != null)) {
                            group_1.setSelectedCheckbox(_this);
                        }
                    })();
                }
                else if (((typeof label === 'string') || label === null) && ((typeof group === 'boolean') || group === null) && state === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var state_2 = __args[1];
                    {
                        var __args_12 = Array.prototype.slice.call(arguments);
                        var group_2 = null;
                        _super.call(this);
                        this.state = false;
                        (function () {
                            _this.label = label;
                            _this.state = state_2;
                            _this.group = group_2;
                            _this.itemListeners = (new Array());
                            if (state_2 && (group_2 != null)) {
                                group_2.setSelectedCheckbox(_this);
                            }
                        })();
                    }
                }
                else if (((typeof label === 'string') || label === null) && group === undefined && state === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_13 = Array.prototype.slice.call(arguments);
                        var state_3 = false;
                        var group_3 = null;
                        _super.call(this);
                        this.state = false;
                        (function () {
                            _this.label = label;
                            _this.state = state_3;
                            _this.group = group_3;
                            _this.itemListeners = (new Array());
                            if (state_3 && (group_3 != null)) {
                                group_3.setSelectedCheckbox(_this);
                            }
                        })();
                    }
                }
                else if (label === undefined && group === undefined && state === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_14 = Array.prototype.slice.call(arguments);
                        var label_1 = "";
                        var state_4 = false;
                        var group_4 = null;
                        _super.call(this);
                        this.state = false;
                        (function () {
                            _this.label = label_1;
                            _this.state = state_4;
                            _this.group = group_4;
                            _this.itemListeners = (new Array());
                            if (state_4 && (group_4 != null)) {
                                group_4.setSelectedCheckbox(_this);
                            }
                        })();
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            Checkbox.prototype.getHTMLElement = function () {
                return _super.prototype.getHTMLElement.call(this);
            };
            Checkbox.prototype.createHTML = function () {
                if (this.htmlElement != null) {
                    return;
                }
                this.htmlElement = document.createElement("label");
                this.htmlElement.appendChild(this.htmlLabel = document.createTextNode(""));
                this.htmlCheckbox = document.createElement("input");
                this.htmlCheckbox.type = this.group == null ? "checkbox" : "radio";
                this.htmlElement.appendChild(this.htmlCheckbox);
            };
            Checkbox.prototype.initHTML = function () {
                var _this = this;
                _super.prototype.initHTML.call(this);
                this.htmlCheckbox.checked = this.state;
                this.htmlLabel.data = this.label;
                this.htmlCheckbox.onclick = function (e) {
                    console.info(e + " / " + _this.htmlCheckbox.checked);
                    _this.setState(_this.htmlCheckbox.checked);
                    _this.processItemEvent(new java.awt.event.ItemEvent(_this, 0, null, _this.htmlCheckbox.checked ? java.awt.event.ItemEvent.SELECTED : java.awt.event.ItemEvent.DESELECTED));
                    return e;
                };
            };
            Checkbox.prototype.constructComponentName = function () {
                {
                    return Checkbox.base + Checkbox.nameCounter++;
                }
                ;
            };
            Checkbox.prototype.getLabel = function () {
                return this.label;
            };
            Checkbox.prototype.setLabel = function (label) {
                {
                    if (label !== this.label && (this.label == null || !(this.label === label))) {
                        this.label = label;
                    }
                }
                ;
            };
            Checkbox.prototype.getState = function () {
                return this.state;
            };
            Checkbox.prototype.setStateInternal = function (state) {
                this.state = state;
                if (this.htmlCheckbox != null) {
                    this.htmlCheckbox.checked = state;
                }
            };
            Checkbox.prototype.setState = function (state) {
                var group = this.group;
                if (group != null) {
                    if (state) {
                        group.setSelectedCheckbox(this);
                    }
                    else if (group.getSelectedCheckbox() === this) {
                        state = true;
                    }
                }
                this.setStateInternal(state);
            };
            Checkbox.prototype.getSelectedObjects = function () {
                if (this.state) {
                    var items = new Array(1);
                    items[0] = this.label;
                    return items;
                }
                return null;
            };
            Checkbox.prototype.getCheckboxGroup = function () {
                return this.group;
            };
            Checkbox.prototype.setCheckboxGroup = function (g) {
                var oldGroup;
                var oldState;
                if (this.group === g) {
                    return;
                }
                {
                    oldGroup = this.group;
                    oldState = this.getState();
                    this.group = g;
                    if (this.group != null && this.getState()) {
                        if (this.group.getSelectedCheckbox() != null) {
                            this.setState(false);
                        }
                        else {
                            this.group.setSelectedCheckbox(this);
                        }
                    }
                }
                ;
                if (oldGroup != null && oldState) {
                    oldGroup.setSelectedCheckbox(null);
                }
            };
            Checkbox.prototype.addItemListener = function (l) {
                if (l == null) {
                    return;
                }
                this.itemListeners.push(l);
            };
            Checkbox.prototype.removeItemListener = function (l) {
                if (l == null) {
                    return;
                }
                var index = (this.itemListeners.indexOf(l) | 0);
                if (index > -1) {
                    this.itemListeners.splice(index, 1);
                }
            };
            Checkbox.prototype.getItemListeners = function () {
                return this.itemListeners;
            };
            Checkbox.prototype.getListeners = function (listenerType) {
                var result = (new Array());
                for (var i = 0; i < this.itemListeners.length; i++) {
                    if (this.itemListeners[i].constructor === listenerType) {
                        result.push((this.itemListeners[i]));
                    }
                }
                return result;
            };
            Checkbox.prototype.processItemEvent = function (e) {
                for (var index127 = 0; index127 < this.itemListeners.length; index127++) {
                    var listener = this.itemListeners[index127];
                    {
                        listener.itemStateChanged(e);
                    }
                }
            };
            Checkbox.prototype.paramString = function () {
                var str = _super.prototype.paramString.call(this);
                var label = this.label;
                if (label != null) {
                    str += ",label=" + label;
                }
                return str + ",state=" + this.state;
            };
            Checkbox.base = "checkbox";
            Checkbox.nameCounter = 0;
            Checkbox.serialVersionUID = 7270714317450821763;
            return Checkbox;
        }(java.awt.Component));
        awt.Checkbox = Checkbox;
        Checkbox["__class"] = "java.awt.Checkbox";
        Checkbox["__interfaces"] = ["java.awt.ItemSelectable", "java.awt.HTMLComponent"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var Choice = (function (_super) {
            __extends(Choice, _super);
            function Choice() {
                _super.call(this);
                this.selectedIndex = -1;
                this.pItems = (new java.util.Vector());
                this.itemListeners = (new Array());
            }
            Choice.prototype.createHTML = function () {
                this.htmlElement = document.createElement("select");
            };
            Choice.prototype.getHTMLElement = function () {
                return this.htmlElement;
            };
            Choice.prototype.initHTML = function () {
                var _this = this;
                _super.prototype.initHTML.call(this);
                this.getHTMLElement().onchange = function (e) {
                    var i = (_this.getHTMLElement().selectedIndex | 0);
                    var option = _this.getHTMLElement().childNodes.item(i);
                    _this.processItemEvent(new java.awt.event.ItemEvent(_this, 0, option.innerHTML, java.awt.event.ItemEvent.SELECTED));
                    return e;
                };
                for (var index128 = 0; index128 < this.getHTMLElement().childNodes.length; index128++) {
                    var n = this.getHTMLElement().childNodes[index128];
                    {
                        this.getHTMLElement().removeChild(n);
                    }
                }
                for (var i = 0; i < this.getItemCount(); i++) {
                    var option = document.createElement("option");
                    option.innerHTML = this.getItem(i);
                    option.value = this.getItem(i);
                    if (this.getSelectedIndex() === i) {
                        option.selected = true;
                    }
                    this.getHTMLElement().appendChild(option);
                }
            };
            Choice.prototype.constructComponentName = function () {
                {
                    return Choice.base + Choice.nameCounter++;
                }
                ;
            };
            Choice.prototype.getItemCount = function () {
                return this.countItems();
            };
            Choice.prototype.countItems = function () {
                return this.pItems.size();
            };
            Choice.prototype.getItem = function (index) {
                return this.getItemImpl(index);
            };
            Choice.prototype.getItemImpl = function (index) {
                return this.pItems.elementAt(index);
            };
            Choice.prototype.add = function (item) {
                this.addItem(item);
            };
            Choice.prototype.addItem = function (item) {
                {
                    this.insertNoInvalidate(item, this.pItems.size());
                }
                ;
            };
            Choice.prototype.insertNoInvalidate = function (item, index) {
                if (item == null) {
                    throw new java.lang.NullPointerException("cannot add null item to Choice");
                }
                this.pItems.insertElementAt(item, index);
                if (this.selectedIndex < 0 || this.selectedIndex >= index) {
                    this.select(0);
                }
                if (this.htmlElement != null) {
                    this.initHTML();
                }
            };
            Choice.prototype.insert = function (item, index) {
                {
                    if (index < 0) {
                        throw new java.lang.IllegalArgumentException("index less than zero.");
                    }
                    index = Math.min(index, this.pItems.size());
                    this.insertNoInvalidate(item, index);
                }
                ;
            };
            Choice.prototype.remove = function (item) {
                var _this = this;
                if (((typeof item === 'string') || item === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        {
                            var index = _this.pItems.indexOf(item);
                            if (index < 0) {
                                throw new java.lang.IllegalArgumentException("item " + item + " not found in choice");
                            }
                            else {
                                _this.removeNoInvalidate(index);
                            }
                        }
                        ;
                    })();
                }
                else if (((typeof item === 'number') || item === null)) {
                    return this.remove$int(item);
                }
                else
                    throw new Error('invalid overload');
            };
            Choice.prototype.remove$int = function (position) {
                {
                    this.removeNoInvalidate(position);
                }
                ;
            };
            Choice.prototype.removeNoInvalidate = function (position) {
                this.pItems.removeElementAt(position);
                if (this.pItems.size() === 0) {
                    this.selectedIndex = -1;
                }
                else if (this.selectedIndex === position) {
                    this.select(0);
                }
                else if (this.selectedIndex > position) {
                    this.select(this.selectedIndex - 1);
                }
                if (this.htmlElement != null) {
                    this.initHTML();
                }
            };
            Choice.prototype.removeAll = function () {
                {
                    this.pItems.removeAllElements();
                    this.selectedIndex = -1;
                    if (this.htmlElement != null) {
                        this.initHTML();
                    }
                }
                ;
            };
            Choice.prototype.getSelectedItem = function () {
                return (this.selectedIndex >= 0) ? this.getItem(this.selectedIndex) : null;
            };
            Choice.prototype.getSelectedObjects = function () {
                if (this.selectedIndex >= 0) {
                    var items = new Array(1);
                    items[0] = this.getItem(this.selectedIndex);
                    return items;
                }
                return null;
            };
            Choice.prototype.getSelectedIndex = function () {
                return this.selectedIndex;
            };
            Choice.prototype.select$int = function (pos) {
                if ((pos >= this.pItems.size()) || (pos < 0)) {
                    throw new java.lang.IllegalArgumentException("illegal Choice item position: " + pos);
                }
                if (this.pItems.size() > 0) {
                    this.selectedIndex = pos;
                    if (this.htmlElement != null) {
                        this.initHTML();
                    }
                }
            };
            Choice.prototype.select = function (str) {
                var _this = this;
                if (((typeof str === 'string') || str === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        var index = _this.pItems.indexOf(str);
                        if (index >= 0) {
                            _this.select(index);
                        }
                    })();
                }
                else if (((typeof str === 'number') || str === null)) {
                    return this.select$int(str);
                }
                else
                    throw new Error('invalid overload');
            };
            Choice.prototype.addItemListener = function (l) {
                if (l == null) {
                    return;
                }
                this.itemListeners.push(l);
            };
            Choice.prototype.removeItemListener = function (l) {
                if (l == null) {
                    return;
                }
                var index = (this.itemListeners.indexOf(l) | 0);
                if (index > -1) {
                    this.itemListeners.splice(index, 1);
                }
            };
            Choice.prototype.getItemListeners = function () {
                return this.itemListeners;
            };
            Choice.prototype.getListeners = function (listenerType) {
                var result = (new Array());
                for (var i = 0; i < this.itemListeners.length; i++) {
                    if (this.itemListeners[i].constructor === listenerType) {
                        result.push((this.itemListeners[i]));
                    }
                }
                return result;
            };
            Choice.prototype.processItemEvent = function (e) {
                for (var index129 = 0; index129 < this.itemListeners.length; index129++) {
                    var listener = this.itemListeners[index129];
                    {
                        listener.itemStateChanged(e);
                    }
                }
            };
            Choice.prototype.paramString = function () {
                return _super.prototype.paramString.call(this) + ",current=" + this.getSelectedItem();
            };
            Choice.base = "choice";
            Choice.nameCounter = 0;
            Choice.serialVersionUID = -4075310674757313071;
            return Choice;
        }(java.awt.Component));
        awt.Choice = Choice;
        Choice["__class"] = "java.awt.Choice";
        Choice["__interfaces"] = ["java.awt.ItemSelectable", "java.awt.HTMLComponent"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var Container = (function (_super) {
            __extends(Container, _super);
            function Container() {
                _super.call(this);
                this.components = [];
            }
            Container.prototype.getLayout = function () {
                return this.layoutMgr;
            };
            Container.prototype.setLayout = function (mgr) {
                if (this.layoutMgr != null) {
                    if (this.components.length === 0) {
                        if (this.htmlElement != null) {
                            while ((this.htmlElement.firstChild != null)) {
                                this.htmlElement.removeChild(this.htmlElement.firstChild);
                            }
                            ;
                        }
                    }
                    else {
                        throw new Error("cannot change layout dynamically with the current implementation");
                    }
                }
                this.layoutMgr = mgr;
                this.layoutMgr.layoutContainer(this);
            };
            Container.prototype.doLayout = function () {
                this.layout();
            };
            Container.prototype.layout = function () {
                var layoutMgr = this.layoutMgr;
                if (layoutMgr != null) {
                }
            };
            Container.prototype.add$java_awt_Component = function (component) {
                this.add(null, component);
                return component;
            };
            Container.prototype.add$java_awt_Component$int = function (c, index) {
                this.components = (this.components).splice(index, 0, c);
                return c;
            };
            Container.prototype.add$java_lang_String$java_awt_Component = function (name, component) {
                this.addImpl(component, null, -1);
                return component;
            };
            Container.prototype.add$java_awt_Component$java_lang_Object = function (component, constraints) {
                this.addImpl(component, constraints, -1);
            };
            Container.prototype.add = function (component, constraints, index) {
                var _this = this;
                if (((component != null && component instanceof java.awt.Component) || component === null) && ((constraints != null) || constraints === null) && ((typeof index === 'number') || index === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        _this.addImpl(component, constraints, index);
                    })();
                }
                else if (((typeof component === 'string') || component === null) && ((constraints != null && constraints instanceof java.awt.Component) || constraints === null) && index === undefined) {
                    return this.add$java_lang_String$java_awt_Component(component, constraints);
                }
                else if (((component != null && component instanceof java.awt.Component) || component === null) && ((typeof constraints === 'number') || constraints === null) && index === undefined) {
                    return this.add$java_awt_Component$int(component, constraints);
                }
                else if (((component != null && component instanceof java.awt.Component) || component === null) && ((constraints != null) || constraints === null) && index === undefined) {
                    return this.add$java_awt_Component$java_lang_Object(component, constraints);
                }
                else if (((component != null && component instanceof java.awt.Component) || component === null) && constraints === undefined && index === undefined) {
                    return this.add$java_awt_Component(component);
                }
                else
                    throw new Error('invalid overload');
            };
            Container.prototype.addImpl = function (component, constraints, index) {
                (this.components).push(component);
                component.initHTML();
                if (this.layoutMgr != null) {
                    if (constraints != null && (this.layoutMgr != null && (this.layoutMgr["__interfaces"] != null && this.layoutMgr["__interfaces"].indexOf("java.awt.LayoutManager2") >= 0 || this.layoutMgr.constructor != null && this.layoutMgr.constructor["__interfaces"] != null && this.layoutMgr.constructor["__interfaces"].indexOf("java.awt.LayoutManager2") >= 0))) {
                        this.layoutMgr.addLayoutComponent(component, constraints);
                    }
                    else {
                        this.layoutMgr.onComponentAdded(this, component, -1);
                    }
                }
            };
            Container.prototype.doPaintInternal = function () {
                _super.prototype.doPaintInternal.call(this);
                for (var index130 = 0; index130 < this.components.length; index130++) {
                    var c = this.components[index130];
                    {
                        c.doPaintInternal();
                    }
                }
            };
            Container.prototype.getComponentCount = function () {
                return this.components.length;
            };
            Container.prototype.remove = function (item) {
                if (((item != null && item instanceof java.awt.Component) || item === null)) {
                    return this.remove$java_awt_Component(item);
                }
                else if (((typeof item === 'number') || item === null)) {
                    return this.remove$int(item);
                }
                else
                    throw new Error('invalid overload');
            };
            Container.prototype.remove$int = function (index) {
                this.components = (this.components).slice(index, 1);
            };
            Container.prototype.getComponent = function (n) {
                var _this = this;
                if (((typeof n === 'number') || n === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        return _this.components[n];
                    })();
                }
                else
                    throw new Error('invalid overload');
            };
            Container.prototype.getComponents = function () {
                return this.components;
            };
            Container.prototype.removeAll = function () {
                this.components = new Array(0);
            };
            Container.prototype.remove$java_awt_Component = function (c) {
                var i = ((this.components).indexOf(c) | 0);
                this.remove(i);
            };
            Container.prototype.getInsets = function () {
                return this.insets;
            };
            Container.prototype.setInsets = function (insets) {
                this.insets = insets;
            };
            return Container;
        }(java.awt.Component));
        awt.Container = Container;
        Container["__class"] = "java.awt.Container";
        Container["__interfaces"] = ["java.awt.HTMLComponent"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var Label = (function (_super) {
            __extends(Label, _super);
            function Label(text, alignment) {
                if (text === void 0) { text = ""; }
                if (alignment === void 0) { alignment = Label.LEFT; }
                _super.call(this);
                this.alignment = Label.LEFT;
                this.text = text;
                this.setAlignment(alignment);
            }
            /**
             * Construct a name for this component. Called by getName() when the name is
             * <code>null</code>.
             */
            Label.prototype.constructComponentName = function () {
                {
                    return Label.base + Label.nameCounter++;
                }
                ;
            };
            Label.prototype.getAlignment = function () {
                return this.alignment;
            };
            Label.prototype.setAlignment = function (alignment) {
                switch ((alignment)) {
                    case Label.LEFT:
                    case Label.CENTER:
                    case Label.RIGHT:
                        this.alignment = alignment;
                        return;
                }
                throw new java.lang.IllegalArgumentException("improper alignment: " + alignment);
            };
            Label.prototype.getText = function () {
                return this.text;
            };
            Label.prototype.setText = function (text) {
                {
                    if (text !== this.text && (this.text == null || !(this.text === text))) {
                        this.text = text;
                        if (this.htmlElement != null) {
                            this.htmlElement.innerHTML = text;
                        }
                    }
                }
                ;
            };
            Label.prototype.paramString = function () {
                var str = ",align=";
                switch ((this.alignment)) {
                    case Label.LEFT:
                        str += "left";
                        break;
                    case Label.CENTER:
                        str += "center";
                        break;
                    case Label.RIGHT:
                        str += "right";
                        break;
                }
                return _super.prototype.paramString.call(this) + str + ",text=" + this.text;
            };
            Label.prototype.getHTMLElement = function () {
                return _super.prototype.getHTMLElement.call(this);
            };
            Label.prototype.createHTML = function () {
                this.htmlElement = document.createElement("label");
            };
            Label.prototype.initHTML = function () {
                _super.prototype.initHTML.call(this);
                if (this.text != null) {
                    this.getHTMLElement().innerHTML = this.text;
                }
            };
            Label.LEFT = 0;
            Label.CENTER = 1;
            Label.RIGHT = 2;
            Label.base = "label";
            Label.nameCounter = 0;
            Label.serialVersionUID = 3094126758329070636;
            return Label;
        }(java.awt.Component));
        awt.Label = Label;
        Label["__class"] = "java.awt.Label";
        Label["__interfaces"] = ["java.awt.HTMLComponent"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var TextField = (function (_super) {
            __extends(TextField, _super);
            function TextField(cols) {
                _super.call(this);
            }
            TextField.prototype.getHTMLElement = function () {
                return this.htmlElement;
            };
            TextField.prototype.createHTML = function () {
                if (this.htmlElement != null) {
                    return;
                }
                this.htmlElement = document.createElement("input");
                this.htmlElement.setAttribute("type", "text");
            };
            TextField.prototype.initHTML = function () {
                _super.prototype.initHTML.call(this);
                this.htmlElement.id = "cmp" + java.awt.Component.CURRENT_ID++;
                this.initActionListener();
            };
            TextField.prototype.initActionListener = function () {
                var _this = this;
                if (this.actionListener != null) {
                    this.htmlElement.onclick = function (e) {
                        _this.actionListener.actionPerformed(new java.awt.event.ActionEvent(_this, 0, null));
                        return e;
                    };
                }
            };
            TextField.prototype.addActionListener = function (actionListener) {
                this.actionListener = actionListener;
                if (this.htmlElement != null) {
                    this.initActionListener();
                }
            };
            TextField.prototype.setText = function (text) {
                this.getHTMLElement().value = text;
            };
            TextField.prototype.getText = function () {
                return this.getHTMLElement().value;
            };
            return TextField;
        }(java.awt.Component));
        awt.TextField = TextField;
        TextField["__class"] = "java.awt.TextField";
        TextField["__interfaces"] = ["java.awt.HTMLComponent"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var event;
        (function (event) {
            var ActionEvent = (function (_super) {
                __extends(ActionEvent, _super);
                function ActionEvent(source, id, command, when, modifiers) {
                    var _this = this;
                    if (((source != null) || source === null) && ((typeof id === 'number') || id === null) && ((typeof command === 'string') || command === null) && ((typeof when === 'number') || when === null) && ((typeof modifiers === 'number') || modifiers === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        _super.call(this, source, id);
                        this.when = 0;
                        this.modifiers = 0;
                        (function () {
                            _this.actionCommand = command;
                            _this.when = when;
                            _this.modifiers = modifiers;
                        })();
                    }
                    else if (((source != null) || source === null) && ((typeof id === 'number') || id === null) && ((typeof command === 'string') || command === null) && ((typeof when === 'number') || when === null) && modifiers === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        var modifiers_2 = __args[3];
                        {
                            var __args_15 = Array.prototype.slice.call(arguments);
                            var when_2 = 0;
                            _super.call(this, source, id);
                            this.when = 0;
                            this.modifiers = 0;
                            (function () {
                                _this.actionCommand = command;
                                _this.when = when_2;
                                _this.modifiers = modifiers_2;
                            })();
                        }
                    }
                    else if (((source != null) || source === null) && ((typeof id === 'number') || id === null) && ((typeof command === 'string') || command === null) && when === undefined && modifiers === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        {
                            var __args_16 = Array.prototype.slice.call(arguments);
                            var modifiers_3 = 0;
                            {
                                var __args_17 = Array.prototype.slice.call(arguments);
                                var when_3 = 0;
                                _super.call(this, source, id);
                                this.when = 0;
                                this.modifiers = 0;
                                (function () {
                                    _this.actionCommand = command;
                                    _this.when = when_3;
                                    _this.modifiers = modifiers_3;
                                })();
                            }
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                ActionEvent.SHIFT_MASK_$LI$ = function () { if (ActionEvent.SHIFT_MASK == null)
                    ActionEvent.SHIFT_MASK = java.awt.Event.SHIFT_MASK_$LI$(); return ActionEvent.SHIFT_MASK; };
                ;
                ActionEvent.CTRL_MASK_$LI$ = function () { if (ActionEvent.CTRL_MASK == null)
                    ActionEvent.CTRL_MASK = java.awt.Event.CTRL_MASK_$LI$(); return ActionEvent.CTRL_MASK; };
                ;
                ActionEvent.META_MASK_$LI$ = function () { if (ActionEvent.META_MASK == null)
                    ActionEvent.META_MASK = java.awt.Event.META_MASK_$LI$(); return ActionEvent.META_MASK; };
                ;
                ActionEvent.ALT_MASK_$LI$ = function () { if (ActionEvent.ALT_MASK == null)
                    ActionEvent.ALT_MASK = java.awt.Event.ALT_MASK_$LI$(); return ActionEvent.ALT_MASK; };
                ;
                ActionEvent.ACTION_PERFORMED_$LI$ = function () { if (ActionEvent.ACTION_PERFORMED == null)
                    ActionEvent.ACTION_PERFORMED = ActionEvent.ACTION_FIRST; return ActionEvent.ACTION_PERFORMED; };
                ;
                ActionEvent.prototype.getActionCommand = function () {
                    return this.actionCommand;
                };
                ActionEvent.prototype.getWhen = function () {
                    return this.when;
                };
                ActionEvent.prototype.getModifiers = function () {
                    return this.modifiers;
                };
                ActionEvent.prototype.paramString = function () {
                    var typeStr;
                    switch ((this.id)) {
                        case ActionEvent.ACTION_PERFORMED_$LI$():
                            typeStr = "ACTION_PERFORMED";
                            break;
                        default:
                            typeStr = "unknown type";
                    }
                    return typeStr + ",cmd=" + this.actionCommand + ",when=" + this.when + ",modifiers=" + java.awt.event.KeyEvent.getKeyModifiersText(this.modifiers);
                };
                ActionEvent.ACTION_FIRST = 1001;
                ActionEvent.ACTION_LAST = 1001;
                ActionEvent.serialVersionUID = -7671078796273832149;
                return ActionEvent;
            }(java.awt.AWTEvent));
            event.ActionEvent = ActionEvent;
            ActionEvent["__class"] = "java.awt.event.ActionEvent";
            ActionEvent["__interfaces"] = ["java.io.Serializable"];
        })(event = awt.event || (awt.event = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        /**
         * The <code>Dimension</code> class encapsulates the width and
         * height of a component (in integer precision) in a single object.
         * The class is
         * associated with certain properties of components. Several methods
         * defined by the <code>Component</code> class and the
         * <code>LayoutManager</code> interface return a
         * <code>Dimension</code> object.
         * <p>
         * Normally the values of <code>width</code>
         * and <code>height</code> are non-negative integers.
         * The constructors that allow you to create a dimension do
         * not prevent you from setting a negative value for these properties.
         * If the value of <code>width</code> or <code>height</code> is
         * negative, the behavior of some methods defined by other objects is
         * undefined.
         *
         * @author      Sami Shaio
         * @author      Arthur van Hoff
         * @see         java.awt.Component
         * @see         java.awt.LayoutManager
         * @since       1.0
         */
        var Dimension = (function (_super) {
            __extends(Dimension, _super);
            /**
             * Constructs a <code>Dimension</code> and initializes
             * it to the specified width and specified height.
             *
             * @param width the specified width
             * @param height the specified height
             */
            function Dimension(width, height) {
                var _this = this;
                if (((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this);
                    this.width = 0;
                    this.height = 0;
                    (function () {
                        _this.width = width;
                        _this.height = height;
                    })();
                }
                else if (((width != null && width instanceof java.awt.Dimension) || width === null) && height === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var d = __args[0];
                    {
                        var __args_18 = Array.prototype.slice.call(arguments);
                        var width_1 = d.width;
                        var height_1 = d.height;
                        _super.call(this);
                        this.width = 0;
                        this.height = 0;
                        (function () {
                            _this.width = width_1;
                            _this.height = height_1;
                        })();
                    }
                }
                else if (width === undefined && height === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_19 = Array.prototype.slice.call(arguments);
                        var width_2 = 0;
                        var height_2 = 0;
                        _super.call(this);
                        this.width = 0;
                        this.height = 0;
                        (function () {
                            _this.width = width_2;
                            _this.height = height_2;
                        })();
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * {@inheritDoc}
             * @since 1.2
             */
            Dimension.prototype.getWidth = function () {
                return this.width;
            };
            /**
             * {@inheritDoc}
             * @since 1.2
             */
            Dimension.prototype.getHeight = function () {
                return this.height;
            };
            /**
             * Sets the size of this <code>Dimension</code> object to
             * the specified width and height in double precision.
             * Note that if <code>width</code> or <code>height</code>
             * are larger than <code>Integer.MAX_VALUE</code>, they will
             * be reset to <code>Integer.MAX_VALUE</code>.
             *
             * @param width  the new width for the <code>Dimension</code> object
             * @param height the new height for the <code>Dimension</code> object
             * @since 1.2
             */
            Dimension.prototype.setSize$double$double = function (width, height) {
                this.width = (Math.ceil(width) | 0);
                this.height = (Math.ceil(height) | 0);
            };
            /**
             * Gets the size of this <code>Dimension</code> object.
             * This method is included for completeness, to parallel the
             * <code>getSize</code> method defined by <code>Component</code>.
             *
             * @return   the size of this dimension, a new instance of
             * <code>Dimension</code> with the same width and height
             * @see      java.awt.Dimension#setSize
             * @see      java.awt.Component#getSize
             * @since    1.1
             */
            Dimension.prototype.getSize = function () {
                return new Dimension(this.width, this.height);
            };
            /**
             * Sets the size of this <code>Dimension</code> object to the specified size.
             * This method is included for completeness, to parallel the
             * <code>setSize</code> method defined by <code>Component</code>.
             * @param    d  the new size for this <code>Dimension</code> object
             * @see      java.awt.Dimension#getSize
             * @see      java.awt.Component#setSize
             * @since    1.1
             */
            Dimension.prototype.setSize$java_awt_Dimension = function (d) {
                this.setSize(d.width, d.height);
            };
            /**
             * Sets the size of this <code>Dimension</code> object
             * to the specified width and height.
             * This method is included for completeness, to parallel the
             * <code>setSize</code> method defined by <code>Component</code>.
             *
             * @param    width   the new width for this <code>Dimension</code> object
             * @param    height  the new height for this <code>Dimension</code> object
             * @see      java.awt.Dimension#getSize
             * @see      java.awt.Component#setSize
             * @since    1.1
             */
            Dimension.prototype.setSize = function (width, height) {
                var _this = this;
                if (((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        _this.width = width;
                        _this.height = height;
                    })();
                }
                else if (((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null)) {
                    return this.setSize$double$double(width, height);
                }
                else if (((width != null && width instanceof java.awt.Dimension) || width === null) && height === undefined) {
                    return this.setSize$java_awt_Dimension(width);
                }
                else if (((width != null && width instanceof java.awt.geom.Dimension2D) || width === null) && height === undefined) {
                    return this.setSize$java_awt_geom_Dimension2D(width);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Checks whether two dimension objects have equal values.
             */
            Dimension.prototype.equals = function (obj) {
                if (obj != null && obj instanceof java.awt.Dimension) {
                    var d = obj;
                    return (this.width === d.width) && (this.height === d.height);
                }
                return false;
            };
            /**
             * Returns the hash code for this <code>Dimension</code>.
             *
             * @return    a hash code for this <code>Dimension</code>
             */
            Dimension.prototype.hashCode = function () {
                var sum = this.width + this.height;
                return (sum * (sum + 1) / 2 | 0) + this.width;
            };
            /**
             * Returns a string representation of the values of this
             * <code>Dimension</code> object's <code>height</code> and
             * <code>width</code> fields. This method is intended to be used only
             * for debugging purposes, and the content and format of the returned
             * string may vary between implementations. The returned string may be
             * empty but may not be <code>null</code>.
             *
             * @return  a string representation of this <code>Dimension</code>
             * object
             */
            Dimension.prototype.toString = function () {
                return (function (c) { return c["__class"] ? c["__class"] : c.name; })(Dimension) + "[width=" + this.width + ",height=" + this.height + "]";
            };
            Dimension.serialVersionUID = 4723952579491349524;
            return Dimension;
        }(java.awt.geom.Dimension2D));
        awt.Dimension = Dimension;
        Dimension["__class"] = "java.awt.Dimension";
        Dimension["__interfaces"] = ["java.lang.Cloneable", "java.io.Serializable"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The {@code Path2D} class provides a simple, yet flexible shape which
             * represents an arbitrary geometric path. It can fully represent any path which
             * can be iterated by the {@link PathIterator} interface including all of its
             * segment types and winding rules and it implements all of the basic hit
             * testing methods of the {@link Shape} interface.
             * <p>
             * Use {@link Path2D.Float} when dealing with data that can be represented and
             * used with floating point precision. Use {@link Path2D.Double} for data that
             * requires the accuracy or range of double precision.
             * <p>
             * {@code Path2D} provides exactly those facilities required for basic
             * construction and management of a geometric path and implementation of the
             * above interfaces with little added interpretation. If it is useful to
             * manipulate the interiors of closed geometric shapes beyond simple hit testing
             * then the {@link Area} class provides additional capabilities specifically
             * targeted at closed figures. While both classes nominally implement the
             * {@code Shape} interface, they differ in purpose and together they provide two
             * useful views of a geometric shape where {@code Path2D} deals primarily with a
             * trajectory formed by path segments and {@code Area} deals more with
             * interpretation and manipulation of enclosed regions of 2D geometric space.
             * <p>
             * The {@link PathIterator} interface has more detailed descriptions of the
             * types of segments that make up a path and the winding rules that control how
             * to determine which regions are inside or outside the path.
             *
             * @author Jim Graham
             * @since 1.6
             */
            var Path2D = (function () {
                /**
                 * Constructs a new {@code Path2D} object from the given specified initial
                 * values. This method is only intended for internal use and should not be
                 * made public if the other constructors for this class are ever exposed.
                 *
                 * @param rule
                 * the winding rule
                 * @param initialTypes
                 * the size to make the initial array to store the path segment
                 * types
                 * @since 1.6
                 */
                function Path2D(rule, initialTypes) {
                    var _this = this;
                    if (((typeof rule === 'number') || rule === null) && ((typeof initialTypes === 'number') || initialTypes === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        this.numTypes = 0;
                        this.numCoords = 0;
                        this.windingRule = 0;
                        (function () {
                            _this.setWindingRule(rule);
                            _this.pointTypes = new Array(initialTypes);
                        })();
                    }
                    else if (rule === undefined && initialTypes === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        this.numTypes = 0;
                        this.numCoords = 0;
                        this.windingRule = 0;
                    }
                    else
                        throw new Error('invalid overload');
                }
                Path2D.WIND_EVEN_ODD_$LI$ = function () { if (Path2D.WIND_EVEN_ODD == null)
                    Path2D.WIND_EVEN_ODD = java.awt.geom.PathIterator.WIND_EVEN_ODD; return Path2D.WIND_EVEN_ODD; };
                ;
                Path2D.WIND_NON_ZERO_$LI$ = function () { if (Path2D.WIND_NON_ZERO == null)
                    Path2D.WIND_NON_ZERO = java.awt.geom.PathIterator.WIND_NON_ZERO; return Path2D.WIND_NON_ZERO; };
                ;
                Path2D.SEG_MOVETO_$LI$ = function () { if (Path2D.SEG_MOVETO == null)
                    Path2D.SEG_MOVETO = (java.awt.geom.PathIterator.SEG_MOVETO | 0); return Path2D.SEG_MOVETO; };
                ;
                Path2D.SEG_LINETO_$LI$ = function () { if (Path2D.SEG_LINETO == null)
                    Path2D.SEG_LINETO = (java.awt.geom.PathIterator.SEG_LINETO | 0); return Path2D.SEG_LINETO; };
                ;
                Path2D.SEG_QUADTO_$LI$ = function () { if (Path2D.SEG_QUADTO == null)
                    Path2D.SEG_QUADTO = (java.awt.geom.PathIterator.SEG_QUADTO | 0); return Path2D.SEG_QUADTO; };
                ;
                Path2D.SEG_CUBICTO_$LI$ = function () { if (Path2D.SEG_CUBICTO == null)
                    Path2D.SEG_CUBICTO = (java.awt.geom.PathIterator.SEG_CUBICTO | 0); return Path2D.SEG_CUBICTO; };
                ;
                Path2D.SEG_CLOSE_$LI$ = function () { if (Path2D.SEG_CLOSE == null)
                    Path2D.SEG_CLOSE = (java.awt.geom.PathIterator.SEG_CLOSE | 0); return Path2D.SEG_CLOSE; };
                ;
                Path2D.prototype.append$float$float = function (x, y) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                Path2D.prototype.append$double$double = function (x, y) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Adds a point to the path by moving to the specified coordinates
                 * specified in float precision.
                 * <p>
                 * This method provides a single precision variant of the double
                 * precision {@code moveTo()} method on the base {@code Path2D} class.
                 *
                 * @param x
                 * the specified X coordinate
                 * @param y
                 * the specified Y coordinate
                 * @see Path2D#moveTo
                 * @since 1.6
                 */
                Path2D.prototype.moveTo = function (x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.moveTo$double$double(x, y);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Adds a point to the path by moving to the specified coordinates specified
                 * in double precision.
                 *
                 * @param x
                 * the specified X coordinate
                 * @param y
                 * the specified Y coordinate
                 * @since 1.6
                 */
                Path2D.prototype.moveTo$double$double = function (x, y) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Adds a point to the path by drawing a straight line from the current
                 * coordinates to the new specified coordinates specified in float
                 * precision.
                 * <p>
                 * This method provides a single precision variant of the double
                 * precision {@code lineTo()} method on the base {@code Path2D} class.
                 *
                 * @param x
                 * the specified X coordinate
                 * @param y
                 * the specified Y coordinate
                 * @see Path2D#lineTo
                 * @since 1.6
                 */
                Path2D.prototype.lineTo = function (x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.lineTo$double$double(x, y);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Adds a point to the path by drawing a straight line from the current
                 * coordinates to the new specified coordinates specified in double
                 * precision.
                 *
                 * @param x
                 * the specified X coordinate
                 * @param y
                 * the specified Y coordinate
                 * @since 1.6
                 */
                Path2D.prototype.lineTo$double$double = function (x, y) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Adds a curved segment, defined by two new points, to the path by
                 * drawing a Quadratic curve that intersects both the current
                 * coordinates and the specified coordinates {@code (x2,y2)}, using the
                 * specified point {@code (x1,y1)} as a quadratic parametric control
                 * point. All coordinates are specified in float precision.
                 * <p>
                 * This method provides a single precision variant of the double
                 * precision {@code quadTo()} method on the base {@code Path2D} class.
                 *
                 * @param x1
                 * the X coordinate of the quadratic control point
                 * @param y1
                 * the Y coordinate of the quadratic control point
                 * @param x2
                 * the X coordinate of the final end point
                 * @param y2
                 * the Y coordinate of the final end point
                 * @see Path2D#quadTo
                 * @since 1.6
                 */
                Path2D.prototype.quadTo = function (x1, y1, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return this.quadTo$double$double$double$double(x1, y1, x2, y2);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Adds a curved segment, defined by two new points, to the path by drawing
                 * a Quadratic curve that intersects both the current coordinates and the
                 * specified coordinates {@code (x2,y2)}, using the specified point
                 * {@code (x1,y1)} as a quadratic parametric control point. All coordinates
                 * are specified in double precision.
                 *
                 * @param x1
                 * the X coordinate of the quadratic control point
                 * @param y1
                 * the Y coordinate of the quadratic control point
                 * @param x2
                 * the X coordinate of the final end point
                 * @param y2
                 * the Y coordinate of the final end point
                 * @since 1.6
                 */
                Path2D.prototype.quadTo$double$double$double$double = function (x1, y1, x2, y2) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Adds a curved segment, defined by three new points, to the path by
                 * drawing a B&eacute;zier curve that intersects both the current
                 * coordinates and the specified coordinates {@code (x3,y3)}, using the
                 * specified points {@code (x1,y1)} and {@code (x2,y2)} as B&eacute;zier
                 * control points. All coordinates are specified in float precision.
                 * <p>
                 * This method provides a single precision variant of the double
                 * precision {@code curveTo()} method on the base {@code Path2D} class.
                 *
                 * @param x1
                 * the X coordinate of the first B&eacute;zier control point
                 * @param y1
                 * the Y coordinate of the first B&eacute;zier control point
                 * @param x2
                 * the X coordinate of the second B&eacute;zier control point
                 * @param y2
                 * the Y coordinate of the second B&eacute;zier control point
                 * @param x3
                 * the X coordinate of the final end point
                 * @param y3
                 * the Y coordinate of the final end point
                 * @see Path2D#curveTo
                 * @since 1.6
                 */
                Path2D.prototype.curveTo = function (x1, y1, x2, y2, x3, y3) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null) && ((typeof x3 === 'number') || x3 === null) && ((typeof y3 === 'number') || y3 === null)) {
                        return this.curveTo$double$double$double$double$double$double(x1, y1, x2, y2, x3, y3);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Adds a curved segment, defined by three new points, to the path by
                 * drawing a B&eacute;zier curve that intersects both the current
                 * coordinates and the specified coordinates {@code (x3,y3)}, using the
                 * specified points {@code (x1,y1)} and {@code (x2,y2)} as B&eacute;zier
                 * control points. All coordinates are specified in double precision.
                 *
                 * @param x1
                 * the X coordinate of the first B&eacute;zier control point
                 * @param y1
                 * the Y coordinate of the first B&eacute;zier control point
                 * @param x2
                 * the X coordinate of the second B&eacute;zier control point
                 * @param y2
                 * the Y coordinate of the second B&eacute;zier control point
                 * @param x3
                 * the X coordinate of the final end point
                 * @param y3
                 * the Y coordinate of the final end point
                 * @since 1.6
                 */
                Path2D.prototype.curveTo$double$double$double$double$double$double = function (x1, y1, x2, y2, x3, y3) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Closes the current subpath by drawing a straight line back to the
                 * coordinates of the last {@code moveTo}. If the path is already closed
                 * then this method has no effect.
                 *
                 * @since 1.6
                 */
                Path2D.prototype.closePath = function () {
                    if (this.numTypes === 0 || this.pointTypes[this.numTypes - 1] !== Path2D.SEG_CLOSE_$LI$()) {
                        this.needRoom(true, 0);
                        this.pointTypes[this.numTypes++] = Path2D.SEG_CLOSE_$LI$();
                    }
                };
                /**
                 * Appends the geometry of the specified {@code Shape} object to the path,
                 * possibly connecting the new geometry to the existing path segments with a
                 * line segment. If the {@code connect} parameter is {@code true} and the
                 * path is not empty then any initial {@code moveTo} in the geometry of the
                 * appended {@code Shape} is turned into a {@code lineTo} segment. If the
                 * destination coordinates of such a connecting {@code lineTo} segment match
                 * the ending coordinates of a currently open subpath then the segment is
                 * omitted as superfluous. The winding rule of the specified {@code Shape}
                 * is ignored and the appended geometry is governed by the winding rule
                 * specified for this path.
                 *
                 * @param s
                 * the {@code Shape} whose geometry is appended to this path
                 * @param connect
                 * a boolean to control whether or not to turn an initial
                 * {@code moveTo} segment into a {@code lineTo} segment to
                 * connect the new geometry to the existing path
                 * @since 1.6
                 */
                Path2D.prototype.append = function (s, connect) {
                    var _this = this;
                    if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.Shape") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || s === null) && ((typeof connect === 'boolean') || connect === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            _this.append(s.getPathIterator(null), connect);
                        })();
                    }
                    else if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || s === null) && ((typeof connect === 'boolean') || connect === null)) {
                        return this.append$java_awt_geom_PathIterator$boolean(s, connect);
                    }
                    else if (((typeof s === 'number') || s === null) && ((typeof connect === 'number') || connect === null)) {
                        return this.append$float$float(s, connect);
                    }
                    else if (((typeof s === 'number') || s === null) && ((typeof connect === 'number') || connect === null)) {
                        return this.append$double$double(s, connect);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Appends the geometry of the specified {@link PathIterator} object to the
                 * path, possibly connecting the new geometry to the existing path segments
                 * with a line segment. If the {@code connect} parameter is {@code true} and
                 * the path is not empty then any initial {@code moveTo} in the geometry of
                 * the appended {@code Shape} is turned into a {@code lineTo} segment. If
                 * the destination coordinates of such a connecting {@code lineTo} segment
                 * match the ending coordinates of a currently open subpath then the segment
                 * is omitted as superfluous. The winding rule of the specified
                 * {@code Shape} is ignored and the appended geometry is governed by the
                 * winding rule specified for this path.
                 *
                 * @param pi
                 * the {@code PathIterator} whose geometry is appended to this
                 * path
                 * @param connect
                 * a boolean to control whether or not to turn an initial
                 * {@code moveTo} segment into a {@code lineTo} segment to
                 * connect the new geometry to the existing path
                 * @since 1.6
                 */
                Path2D.prototype.append$java_awt_geom_PathIterator$boolean = function (pi, connect) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Returns the fill style winding rule.
                 *
                 * @return an integer representing the current winding rule.
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 * @see #setWindingRule
                 * @since 1.6
                 */
                Path2D.prototype.getWindingRule = function () {
                    return this.windingRule;
                };
                /**
                 * Sets the winding rule for this path to the specified value.
                 *
                 * @param rule
                 * an integer representing the specified winding rule
                 * @exception IllegalArgumentException
                 * if {@code rule} is not either {@link #WIND_EVEN_ODD} or
                 * {@link #WIND_NON_ZERO}
                 * @see #getWindingRule
                 * @since 1.6
                 */
                Path2D.prototype.setWindingRule = function (rule) {
                    if (rule !== Path2D.WIND_EVEN_ODD_$LI$() && rule !== Path2D.WIND_NON_ZERO_$LI$()) {
                        throw new java.lang.IllegalArgumentException("winding rule must be WIND_EVEN_ODD or WIND_NON_ZERO");
                    }
                    this.windingRule = rule;
                };
                /**
                 * Returns the coordinates most recently added to the end of the path as a
                 * {@link Point2D} object.
                 *
                 * @return a {@code Point2D} object containing the ending coordinates of the
                 * path or {@code null} if there are no points in the path.
                 * @since 1.6
                 */
                Path2D.prototype.getCurrentPoint = function () {
                    var index = this.numCoords;
                    if (this.numTypes < 1 || index < 1) {
                        return null;
                    }
                    if (this.pointTypes[this.numTypes - 1] === Path2D.SEG_CLOSE_$LI$()) {
                        loop: for (var i = this.numTypes - 2; i > 0; i--) {
                            switch ((this.pointTypes[i])) {
                                case Path2D.SEG_MOVETO_$LI$():
                                    break loop;
                                case Path2D.SEG_LINETO_$LI$():
                                    index -= 2;
                                    break;
                                case Path2D.SEG_QUADTO_$LI$():
                                    index -= 4;
                                    break;
                                case Path2D.SEG_CUBICTO_$LI$():
                                    index -= 6;
                                    break;
                                case Path2D.SEG_CLOSE_$LI$():
                                    break;
                            }
                        }
                    }
                    return this.getPoint(index - 2);
                };
                /**
                 * Resets the path to empty. The append position is set back to the
                 * beginning of the path and all coordinates and point types are forgotten.
                 *
                 * @since 1.6
                 */
                Path2D.prototype.reset = function () {
                    this.numTypes = this.numCoords = 0;
                };
                /**
                 * Returns a new {@code Shape} representing a transformed version of this
                 * {@code Path2D}. Note that the exact type and coordinate precision of the
                 * return value is not specified for this method. The method will return a
                 * Shape that contains no less precision for the transformed geometry than
                 * this {@code Path2D} currently maintains, but it may contain no more
                 * precision either. If the tradeoff of precision vs. storage size in the
                 * result is important then the convenience constructors in the
                 * {@link Path2D.Float#Path2D.Float(Shape, AffineTransform) Path2D.Float}
                 * and {@link Path2D.Double#Path2D.Double(Shape, AffineTransform)
                 * Path2D.Double} subclasses should be used to make the choice explicit.
                 *
                 * @param at
                 * the {@code AffineTransform} used to transform a new
                 * {@code Shape}.
                 * @return a new {@code Shape}, transformed with the specified
                 * {@code AffineTransform}.
                 * @since 1.6
                 */
                Path2D.prototype.createTransformedShape = function (at) {
                    var p2d = this.clone();
                    if (at != null) {
                        p2d.transform(at);
                    }
                    return p2d;
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.6
                 */
                Path2D.prototype.getBounds = function () {
                    return this.getBounds2D().getBounds();
                };
                /**
                 * Tests if the specified coordinates are inside the closed boundary of the
                 * specified {@link PathIterator}.
                 * <p>
                 * This method provides a basic facility for implementors of the
                 * {@link Shape} interface to implement support for the
                 * {@link Shape#contains(double, double)} method.
                 *
                 * @param pi
                 * the specified {@code PathIterator}
                 * @param x
                 * the specified X coordinate
                 * @param y
                 * the specified Y coordinate
                 * @return {@code true} if the specified coordinates are inside the
                 * specified {@code PathIterator}; {@code false} otherwise
                 * @since 1.6
                 */
                Path2D.contains$java_awt_geom_PathIterator$double$double = function (pi, x, y) {
                    if (x * 0.0 + y * 0.0 === 0.0) {
                        var mask = (pi.getWindingRule() === Path2D.WIND_NON_ZERO_$LI$() ? -1 : 1);
                        var cross = sun.awt.geom.Curve.pointCrossingsForPath(pi, x, y);
                        return ((cross & mask) !== 0);
                    }
                    else {
                        return false;
                    }
                };
                /**
                 * Tests if the specified {@link Point2D} is inside the closed boundary of
                 * the specified {@link PathIterator}.
                 * <p>
                 * This method provides a basic facility for implementors of the
                 * {@link Shape} interface to implement support for the
                 * {@link Shape#contains(Point2D)} method.
                 *
                 * @param pi
                 * the specified {@code PathIterator}
                 * @param p
                 * the specified {@code Point2D}
                 * @return {@code true} if the specified coordinates are inside the
                 * specified {@code PathIterator}; {@code false} otherwise
                 * @since 1.6
                 */
                Path2D.contains$java_awt_geom_PathIterator$java_awt_geom_Point2D = function (pi, p) {
                    return Path2D.contains(pi, p.getX(), p.getY());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.6
                 */
                Path2D.prototype.contains$double$double = function (x, y) {
                    if (x * 0.0 + y * 0.0 === 0.0) {
                        if (this.numTypes < 2) {
                            return false;
                        }
                        var mask = (this.windingRule === Path2D.WIND_NON_ZERO_$LI$() ? -1 : 1);
                        return ((this.pointCrossings(x, y) & mask) !== 0);
                    }
                    else {
                        return false;
                    }
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.6
                 */
                Path2D.prototype.contains$java_awt_geom_Point2D = function (p) {
                    return this.contains(p.getX(), p.getY());
                };
                /**
                 * Tests if the specified rectangular area is entirely inside the closed
                 * boundary of the specified {@link PathIterator}.
                 * <p>
                 * This method provides a basic facility for implementors of the
                 * {@link Shape} interface to implement support for the
                 * {@link Shape#contains(double, double, double, double)} method.
                 * <p>
                 * This method object may conservatively return false in cases where the
                 * specified rectangular area intersects a segment of the path, but that
                 * segment does not represent a boundary between the interior and exterior
                 * of the path. Such segments could lie entirely within the interior of the
                 * path if they are part of a path with a {@link #WIND_NON_ZERO} winding
                 * rule or if the segments are retraced in the reverse direction such that
                 * the two sets of segments cancel each other out without any exterior area
                 * falling between them. To determine whether segments represent true
                 * boundaries of the interior of the path would require extensive
                 * calculations involving all of the segments of the path and the winding
                 * rule and are thus beyond the scope of this implementation.
                 *
                 * @param pi
                 * the specified {@code PathIterator}
                 * @param x
                 * the specified X coordinate
                 * @param y
                 * the specified Y coordinate
                 * @param w
                 * the width of the specified rectangular area
                 * @param h
                 * the height of the specified rectangular area
                 * @return {@code true} if the specified {@code PathIterator} contains the
                 * specified rectangular area; {@code false} otherwise.
                 * @since 1.6
                 */
                Path2D.contains = function (pi, x, y, w, h) {
                    if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || pi === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (isNaN(x + w) || isNaN(y + h)) {
                                return false;
                            }
                            if (w <= 0 || h <= 0) {
                                return false;
                            }
                            var mask = (pi.getWindingRule() === Path2D.WIND_NON_ZERO_$LI$() ? -1 : 2);
                            var crossings = sun.awt.geom.Curve.rectCrossingsForPath(pi, x, y, x + w, y + h);
                            return (crossings !== sun.awt.geom.Curve.RECT_INTERSECTS && (crossings & mask) !== 0);
                        })();
                    }
                    else if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || pi === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
                        return java.awt.geom.Path2D.contains$java_awt_geom_PathIterator$double$double(pi, x, y);
                    }
                    else if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || pi === null) && ((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return java.awt.geom.Path2D.contains$java_awt_geom_PathIterator$java_awt_geom_Point2D(pi, x);
                    }
                    else if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || pi === null) && ((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return java.awt.geom.Path2D.contains$java_awt_geom_PathIterator$java_awt_geom_Rectangle2D(pi, x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Tests if the specified {@link Rectangle2D} is entirely inside the closed
                 * boundary of the specified {@link PathIterator}.
                 * <p>
                 * This method provides a basic facility for implementors of the
                 * {@link Shape} interface to implement support for the
                 * {@link Shape#contains(Rectangle2D)} method.
                 * <p>
                 * This method object may conservatively return false in cases where the
                 * specified rectangular area intersects a segment of the path, but that
                 * segment does not represent a boundary between the interior and exterior
                 * of the path. Such segments could lie entirely within the interior of the
                 * path if they are part of a path with a {@link #WIND_NON_ZERO} winding
                 * rule or if the segments are retraced in the reverse direction such that
                 * the two sets of segments cancel each other out without any exterior area
                 * falling between them. To determine whether segments represent true
                 * boundaries of the interior of the path would require extensive
                 * calculations involving all of the segments of the path and the winding
                 * rule and are thus beyond the scope of this implementation.
                 *
                 * @param pi
                 * the specified {@code PathIterator}
                 * @param r
                 * a specified {@code Rectangle2D}
                 * @return {@code true} if the specified {@code PathIterator} contains the
                 * specified {@code Rectangle2D}; {@code false} otherwise.
                 * @since 1.6
                 */
                Path2D.contains$java_awt_geom_PathIterator$java_awt_geom_Rectangle2D = function (pi, r) {
                    return Path2D.contains(pi, r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * {@inheritDoc}
                 * <p>
                 * This method object may conservatively return false in cases where the
                 * specified rectangular area intersects a segment of the path, but that
                 * segment does not represent a boundary between the interior and exterior
                 * of the path. Such segments could lie entirely within the interior of the
                 * path if they are part of a path with a {@link #WIND_NON_ZERO} winding
                 * rule or if the segments are retraced in the reverse direction such that
                 * the two sets of segments cancel each other out without any exterior area
                 * falling between them. To determine whether segments represent true
                 * boundaries of the interior of the path would require extensive
                 * calculations involving all of the segments of the path and the winding
                 * rule and are thus beyond the scope of this implementation.
                 *
                 * @since 1.6
                 */
                Path2D.prototype.contains = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (isNaN(x + w) || isNaN(y + h)) {
                                return false;
                            }
                            if (w <= 0 || h <= 0) {
                                return false;
                            }
                            var mask = (_this.windingRule === Path2D.WIND_NON_ZERO_$LI$() ? -1 : 2);
                            var crossings = _this.rectCrossings(x, y, x + w, y + h);
                            return (crossings !== sun.awt.geom.Curve.RECT_INTERSECTS && (crossings & mask) !== 0);
                        })();
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 * <p>
                 * This method object may conservatively return false in cases where the
                 * specified rectangular area intersects a segment of the path, but that
                 * segment does not represent a boundary between the interior and exterior
                 * of the path. Such segments could lie entirely within the interior of the
                 * path if they are part of a path with a {@link #WIND_NON_ZERO} winding
                 * rule or if the segments are retraced in the reverse direction such that
                 * the two sets of segments cancel each other out without any exterior area
                 * falling between them. To determine whether segments represent true
                 * boundaries of the interior of the path would require extensive
                 * calculations involving all of the segments of the path and the winding
                 * rule and are thus beyond the scope of this implementation.
                 *
                 * @since 1.6
                 */
                Path2D.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
                    return this.contains(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * Tests if the interior of the specified {@link PathIterator} intersects
                 * the interior of a specified set of rectangular coordinates.
                 * <p>
                 * This method provides a basic facility for implementors of the
                 * {@link Shape} interface to implement support for the
                 * {@link Shape#intersects(double, double, double, double)} method.
                 * <p>
                 * This method object may conservatively return true in cases where the
                 * specified rectangular area intersects a segment of the path, but that
                 * segment does not represent a boundary between the interior and exterior
                 * of the path. Such a case may occur if some set of segments of the path
                 * are retraced in the reverse direction such that the two sets of segments
                 * cancel each other out without any interior area between them. To
                 * determine whether segments represent true boundaries of the interior of
                 * the path would require extensive calculations involving all of the
                 * segments of the path and the winding rule and are thus beyond the scope
                 * of this implementation.
                 *
                 * @param pi
                 * the specified {@code PathIterator}
                 * @param x
                 * the specified X coordinate
                 * @param y
                 * the specified Y coordinate
                 * @param w
                 * the width of the specified rectangular coordinates
                 * @param h
                 * the height of the specified rectangular coordinates
                 * @return {@code true} if the specified {@code PathIterator} and the
                 * interior of the specified set of rectangular coordinates
                 * intersect each other; {@code false} otherwise.
                 * @since 1.6
                 */
                Path2D.intersects = function (pi, x, y, w, h) {
                    if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || pi === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (isNaN(x + w) || isNaN(y + h)) {
                                return false;
                            }
                            if (w <= 0 || h <= 0) {
                                return false;
                            }
                            var mask = (pi.getWindingRule() === Path2D.WIND_NON_ZERO_$LI$() ? -1 : 2);
                            var crossings = sun.awt.geom.Curve.rectCrossingsForPath(pi, x, y, x + w, y + h);
                            return (crossings === sun.awt.geom.Curve.RECT_INTERSECTS || (crossings & mask) !== 0);
                        })();
                    }
                    else if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || pi === null) && ((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return java.awt.geom.Path2D.intersects$java_awt_geom_PathIterator$java_awt_geom_Rectangle2D(pi, x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Tests if the interior of the specified {@link PathIterator} intersects
                 * the interior of a specified {@link Rectangle2D}.
                 * <p>
                 * This method provides a basic facility for implementors of the
                 * {@link Shape} interface to implement support for the
                 * {@link Shape#intersects(Rectangle2D)} method.
                 * <p>
                 * This method object may conservatively return true in cases where the
                 * specified rectangular area intersects a segment of the path, but that
                 * segment does not represent a boundary between the interior and exterior
                 * of the path. Such a case may occur if some set of segments of the path
                 * are retraced in the reverse direction such that the two sets of segments
                 * cancel each other out without any interior area between them. To
                 * determine whether segments represent true boundaries of the interior of
                 * the path would require extensive calculations involving all of the
                 * segments of the path and the winding rule and are thus beyond the scope
                 * of this implementation.
                 *
                 * @param pi
                 * the specified {@code PathIterator}
                 * @param r
                 * the specified {@code Rectangle2D}
                 * @return {@code true} if the specified {@code PathIterator} and the
                 * interior of the specified {@code Rectangle2D} intersect each
                 * other; {@code false} otherwise.
                 * @since 1.6
                 */
                Path2D.intersects$java_awt_geom_PathIterator$java_awt_geom_Rectangle2D = function (pi, r) {
                    return Path2D.intersects(pi, r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * {@inheritDoc}
                 * <p>
                 * This method object may conservatively return true in cases where the
                 * specified rectangular area intersects a segment of the path, but that
                 * segment does not represent a boundary between the interior and exterior
                 * of the path. Such a case may occur if some set of segments of the path
                 * are retraced in the reverse direction such that the two sets of segments
                 * cancel each other out without any interior area between them. To
                 * determine whether segments represent true boundaries of the interior of
                 * the path would require extensive calculations involving all of the
                 * segments of the path and the winding rule and are thus beyond the scope
                 * of this implementation.
                 *
                 * @since 1.6
                 */
                Path2D.prototype.intersects = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (isNaN(x + w) || isNaN(y + h)) {
                                return false;
                            }
                            if (w <= 0 || h <= 0) {
                                return false;
                            }
                            var mask = (_this.windingRule === Path2D.WIND_NON_ZERO_$LI$() ? -1 : 2);
                            var crossings = _this.rectCrossings(x, y, x + w, y + h);
                            return (crossings === sun.awt.geom.Curve.RECT_INTERSECTS || (crossings & mask) !== 0);
                        })();
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 * <p>
                 * This method object may conservatively return true in cases where the
                 * specified rectangular area intersects a segment of the path, but that
                 * segment does not represent a boundary between the interior and exterior
                 * of the path. Such a case may occur if some set of segments of the path
                 * are retraced in the reverse direction such that the two sets of segments
                 * cancel each other out without any interior area between them. To
                 * determine whether segments represent true boundaries of the interior of
                 * the path would require extensive calculations involving all of the
                 * segments of the path and the winding rule and are thus beyond the scope
                 * of this implementation.
                 *
                 * @since 1.6
                 */
                Path2D.prototype.intersects$java_awt_geom_Rectangle2D = function (r) {
                    return this.intersects(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * {@inheritDoc}
                 * <p>
                 * The iterator for this class is not multi-threaded safe, which means that
                 * this {@code Path2D} class does not guarantee that modifications to the
                 * geometry of this {@code Path2D} object do not affect any iterations of
                 * that geometry that are already in process.
                 *
                 * @since 1.6
                 */
                Path2D.prototype.getPathIterator = function (at, flatness) {
                    var _this = this;
                    if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            return new java.awt.geom.FlatteningPathIterator(_this.getPathIterator(at), flatness);
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                };
                Path2D.INIT_SIZE = 20;
                Path2D.EXPAND_MAX = 500;
                return Path2D;
            }());
            geom.Path2D = Path2D;
            Path2D["__class"] = "java.awt.geom.Path2D";
            Path2D["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
            var Path2D;
            (function (Path2D) {
                var Iterator = (function () {
                    function Iterator(path) {
                        this.typeIdx = 0;
                        this.pointIdx = 0;
                        this.path = path;
                    }
                    Iterator.curvecoords_$LI$ = function () { if (Iterator.curvecoords == null)
                        Iterator.curvecoords = [2, 2, 4, 6, 0]; return Iterator.curvecoords; };
                    ;
                    Iterator.prototype.getWindingRule = function () {
                        return this.path.getWindingRule();
                    };
                    Iterator.prototype.isDone = function () {
                        return (this.typeIdx >= this.path.numTypes);
                    };
                    Iterator.prototype.next = function (doNext) {
                        if (doNext === undefined) {
                            return this.next$();
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    Iterator.prototype.next$ = function () {
                        var type = this.path.pointTypes[this.typeIdx++];
                        this.pointIdx += Iterator.curvecoords_$LI$()[type];
                    };
                    return Iterator;
                }());
                Path2D.Iterator = Iterator;
                Iterator["__class"] = "java.awt.geom.Path2D.Iterator";
                Iterator["__interfaces"] = ["java.awt.geom.PathIterator"];
                /**
                 * The {@code Float} class defines a geometric path with coordinates stored
                 * in single precision floating point.
                 *
                 * @since 1.6
                 */
                var Float = (function (_super) {
                    __extends(Float, _super);
                    /**
                     * Constructs a new single precision {@code Path2D} object from an
                     * arbitrary {@link Shape} object, transformed by an
                     * {@link AffineTransform} object. All of the initial geometry and the
                     * winding rule for this path are taken from the specified {@code Shape}
                     * object and transformed by the specified {@code AffineTransform}
                     * object.
                     *
                     * @param s
                     * the specified {@code Shape} object
                     * @param at
                     * the specified {@code AffineTransform} object
                     * @since 1.6
                     */
                    function Float(s, at) {
                        var _this = this;
                        if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.Shape") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || s === null) && ((at != null && at instanceof java.awt.geom.AffineTransform) || at === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            (function () {
                                if (s != null && s instanceof java.awt.geom.Path2D) {
                                    var p2d = s;
                                    _this.setWindingRule(p2d.windingRule);
                                    _this.numTypes = p2d.numTypes;
                                    _this.pointTypes = java.util.Arrays.copyOf(p2d.pointTypes, p2d.pointTypes.length);
                                    _this.numCoords = p2d.numCoords;
                                    _this.floatCoords = p2d.cloneCoordsFloat(at);
                                }
                                else {
                                    var pi = s.getPathIterator(at);
                                    _this.setWindingRule(pi.getWindingRule());
                                    _this.pointTypes = new Array(java.awt.geom.Path2D.INIT_SIZE);
                                    _this.floatCoords = new Array(java.awt.geom.Path2D.INIT_SIZE * 2);
                                    _this.append(pi, false);
                                }
                            })();
                        }
                        else if (((typeof s === 'number') || s === null) && ((typeof at === 'number') || at === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            var rule = __args[0];
                            var initialCapacity_1 = __args[1];
                            _super.call(this, rule, initialCapacity_1);
                            (function () {
                                _this.floatCoords = new Array(initialCapacity_1 * 2);
                            })();
                        }
                        else if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.Shape") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || s === null) && at === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            {
                                var __args_20 = Array.prototype.slice.call(arguments);
                                var at_1 = null;
                                _super.call(this);
                                (function () {
                                    if (s != null && s instanceof java.awt.geom.Path2D) {
                                        var p2d = s;
                                        _this.setWindingRule(p2d.windingRule);
                                        _this.numTypes = p2d.numTypes;
                                        _this.pointTypes = java.util.Arrays.copyOf(p2d.pointTypes, p2d.pointTypes.length);
                                        _this.numCoords = p2d.numCoords;
                                        _this.floatCoords = p2d.cloneCoordsFloat(at_1);
                                    }
                                    else {
                                        var pi = s.getPathIterator(at_1);
                                        _this.setWindingRule(pi.getWindingRule());
                                        _this.pointTypes = new Array(java.awt.geom.Path2D.INIT_SIZE);
                                        _this.floatCoords = new Array(java.awt.geom.Path2D.INIT_SIZE * 2);
                                        _this.append(pi, false);
                                    }
                                })();
                            }
                        }
                        else if (((typeof s === 'number') || s === null) && at === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            var rule = __args[0];
                            {
                                var __args_21 = Array.prototype.slice.call(arguments);
                                var initialCapacity_2 = java.awt.geom.Path2D.INIT_SIZE;
                                _super.call(this, rule, initialCapacity_2);
                                (function () {
                                    _this.floatCoords = new Array(initialCapacity_2 * 2);
                                })();
                            }
                        }
                        else if (s === undefined && at === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            {
                                var __args_22 = Array.prototype.slice.call(arguments);
                                var rule = java.awt.geom.Path2D.WIND_NON_ZERO_$LI$();
                                var initialCapacity_3 = java.awt.geom.Path2D.INIT_SIZE;
                                _super.call(this, rule, initialCapacity_3);
                                (function () {
                                    _this.floatCoords = new Array(initialCapacity_3 * 2);
                                })();
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    Float.prototype.cloneCoordsFloat = function (at) {
                        var ret;
                        if (at == null) {
                            ret = java.util.Arrays.copyOf(this.floatCoords, this.floatCoords.length);
                        }
                        else {
                            ret = new Array(this.floatCoords.length);
                            at.transform(this.floatCoords, 0, ret, 0, (this.numCoords / 2 | 0));
                        }
                        return ret;
                    };
                    Float.prototype.cloneCoordsDouble = function (at) {
                        var ret = new Array(this.floatCoords.length);
                        if (at == null) {
                            for (var i = 0; i < this.numCoords; i++) {
                                ret[i] = this.floatCoords[i];
                            }
                        }
                        else {
                            at.transform(this.floatCoords, 0, ret, 0, (this.numCoords / 2 | 0));
                        }
                        return ret;
                    };
                    Float.prototype.append$float$float = function (x, y) {
                        this.floatCoords[this.numCoords++] = x;
                        this.floatCoords[this.numCoords++] = y;
                    };
                    Float.prototype.append$double$double = function (x, y) {
                        this.floatCoords[this.numCoords++] = x;
                        this.floatCoords[this.numCoords++] = y;
                    };
                    Float.prototype.getPoint = function (coordindex) {
                        return new java.awt.geom.Point2D.Float(this.floatCoords[coordindex], this.floatCoords[coordindex + 1]);
                    };
                    Float.prototype.needRoom = function (needMove, newCoords) {
                        if (needMove && this.numTypes === 0) {
                            throw new java.awt.geom.IllegalPathStateException("missing initial moveto in path definition");
                        }
                        var size = this.pointTypes.length;
                        if (this.numTypes >= size) {
                            var grow = size;
                            if (grow > java.awt.geom.Path2D.EXPAND_MAX) {
                                grow = java.awt.geom.Path2D.EXPAND_MAX;
                            }
                            this.pointTypes = java.util.Arrays.copyOf(this.pointTypes, size + grow);
                        }
                        size = this.floatCoords.length;
                        if (this.numCoords + newCoords > size) {
                            var grow = size;
                            if (grow > java.awt.geom.Path2D.EXPAND_MAX * 2) {
                                grow = java.awt.geom.Path2D.EXPAND_MAX * 2;
                            }
                            if (grow < newCoords) {
                                grow = newCoords;
                            }
                            this.floatCoords = java.util.Arrays.copyOf(this.floatCoords, size + grow);
                        }
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Float.prototype.moveTo$double$double = function (x, y) {
                        if (this.numTypes > 0 && this.pointTypes[this.numTypes - 1] === java.awt.geom.Path2D.SEG_MOVETO_$LI$()) {
                            this.floatCoords[this.numCoords - 2] = x;
                            this.floatCoords[this.numCoords - 1] = y;
                        }
                        else {
                            this.needRoom(false, 2);
                            this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_MOVETO_$LI$();
                            this.floatCoords[this.numCoords++] = x;
                            this.floatCoords[this.numCoords++] = y;
                        }
                    };
                    /**
                     * Adds a point to the path by moving to the specified coordinates
                     * specified in float precision.
                     * <p>
                     * This method provides a single precision variant of the double
                     * precision {@code moveTo()} method on the base {@code Path2D} class.
                     *
                     * @param x
                     * the specified X coordinate
                     * @param y
                     * the specified Y coordinate
                     * @see Path2D#moveTo
                     * @since 1.6
                     */
                    Float.prototype.moveTo = function (x, y) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            return (function () {
                                if (_this.numTypes > 0 && _this.pointTypes[_this.numTypes - 1] === java.awt.geom.Path2D.SEG_MOVETO_$LI$()) {
                                    _this.floatCoords[_this.numCoords - 2] = x;
                                    _this.floatCoords[_this.numCoords - 1] = y;
                                }
                                else {
                                    _this.needRoom(false, 2);
                                    _this.pointTypes[_this.numTypes++] = java.awt.geom.Path2D.SEG_MOVETO_$LI$();
                                    _this.floatCoords[_this.numCoords++] = x;
                                    _this.floatCoords[_this.numCoords++] = y;
                                }
                            })();
                        }
                        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return this.moveTo$double$double(x, y);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Float.prototype.lineTo$double$double = function (x, y) {
                        this.needRoom(true, 2);
                        this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_LINETO_$LI$();
                        this.floatCoords[this.numCoords++] = x;
                        this.floatCoords[this.numCoords++] = y;
                    };
                    /**
                     * Adds a point to the path by drawing a straight line from the current
                     * coordinates to the new specified coordinates specified in float
                     * precision.
                     * <p>
                     * This method provides a single precision variant of the double
                     * precision {@code lineTo()} method on the base {@code Path2D} class.
                     *
                     * @param x
                     * the specified X coordinate
                     * @param y
                     * the specified Y coordinate
                     * @see Path2D#lineTo
                     * @since 1.6
                     */
                    Float.prototype.lineTo = function (x, y) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            return (function () {
                                _this.needRoom(true, 2);
                                _this.pointTypes[_this.numTypes++] = java.awt.geom.Path2D.SEG_LINETO_$LI$();
                                _this.floatCoords[_this.numCoords++] = x;
                                _this.floatCoords[_this.numCoords++] = y;
                            })();
                        }
                        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return this.lineTo$double$double(x, y);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Float.prototype.quadTo$double$double$double$double = function (x1, y1, x2, y2) {
                        this.needRoom(true, 4);
                        this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_QUADTO_$LI$();
                        this.floatCoords[this.numCoords++] = x1;
                        this.floatCoords[this.numCoords++] = y1;
                        this.floatCoords[this.numCoords++] = x2;
                        this.floatCoords[this.numCoords++] = y2;
                    };
                    /**
                     * Adds a curved segment, defined by two new points, to the path by
                     * drawing a Quadratic curve that intersects both the current
                     * coordinates and the specified coordinates {@code (x2,y2)}, using the
                     * specified point {@code (x1,y1)} as a quadratic parametric control
                     * point. All coordinates are specified in float precision.
                     * <p>
                     * This method provides a single precision variant of the double
                     * precision {@code quadTo()} method on the base {@code Path2D} class.
                     *
                     * @param x1
                     * the X coordinate of the quadratic control point
                     * @param y1
                     * the Y coordinate of the quadratic control point
                     * @param x2
                     * the X coordinate of the final end point
                     * @param y2
                     * the Y coordinate of the final end point
                     * @see Path2D#quadTo
                     * @since 1.6
                     */
                    Float.prototype.quadTo = function (x1, y1, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            return (function () {
                                _this.needRoom(true, 4);
                                _this.pointTypes[_this.numTypes++] = java.awt.geom.Path2D.SEG_QUADTO_$LI$();
                                _this.floatCoords[_this.numCoords++] = x1;
                                _this.floatCoords[_this.numCoords++] = y1;
                                _this.floatCoords[_this.numCoords++] = x2;
                                _this.floatCoords[_this.numCoords++] = y2;
                            })();
                        }
                        else if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.quadTo$double$double$double$double(x1, y1, x2, y2);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Float.prototype.curveTo$double$double$double$double$double$double = function (x1, y1, x2, y2, x3, y3) {
                        this.needRoom(true, 6);
                        this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_CUBICTO_$LI$();
                        this.floatCoords[this.numCoords++] = x1;
                        this.floatCoords[this.numCoords++] = y1;
                        this.floatCoords[this.numCoords++] = x2;
                        this.floatCoords[this.numCoords++] = y2;
                        this.floatCoords[this.numCoords++] = x3;
                        this.floatCoords[this.numCoords++] = y3;
                    };
                    /**
                     * Adds a curved segment, defined by three new points, to the path by
                     * drawing a B&eacute;zier curve that intersects both the current
                     * coordinates and the specified coordinates {@code (x3,y3)}, using the
                     * specified points {@code (x1,y1)} and {@code (x2,y2)} as B&eacute;zier
                     * control points. All coordinates are specified in float precision.
                     * <p>
                     * This method provides a single precision variant of the double
                     * precision {@code curveTo()} method on the base {@code Path2D} class.
                     *
                     * @param x1
                     * the X coordinate of the first B&eacute;zier control point
                     * @param y1
                     * the Y coordinate of the first B&eacute;zier control point
                     * @param x2
                     * the X coordinate of the second B&eacute;zier control point
                     * @param y2
                     * the Y coordinate of the second B&eacute;zier control point
                     * @param x3
                     * the X coordinate of the final end point
                     * @param y3
                     * the Y coordinate of the final end point
                     * @see Path2D#curveTo
                     * @since 1.6
                     */
                    Float.prototype.curveTo = function (x1, y1, x2, y2, x3, y3) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null) && ((typeof x3 === 'number') || x3 === null) && ((typeof y3 === 'number') || y3 === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            return (function () {
                                _this.needRoom(true, 6);
                                _this.pointTypes[_this.numTypes++] = java.awt.geom.Path2D.SEG_CUBICTO_$LI$();
                                _this.floatCoords[_this.numCoords++] = x1;
                                _this.floatCoords[_this.numCoords++] = y1;
                                _this.floatCoords[_this.numCoords++] = x2;
                                _this.floatCoords[_this.numCoords++] = y2;
                                _this.floatCoords[_this.numCoords++] = x3;
                                _this.floatCoords[_this.numCoords++] = y3;
                            })();
                        }
                        else if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null) && ((typeof x3 === 'number') || x3 === null) && ((typeof y3 === 'number') || y3 === null)) {
                            return this.curveTo$double$double$double$double$double$double(x1, y1, x2, y2, x3, y3);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    Float.prototype.pointCrossings = function (px, py) {
                        var movx;
                        var movy;
                        var curx;
                        var cury;
                        var endx;
                        var endy;
                        var coords = this.floatCoords;
                        curx = movx = coords[0];
                        cury = movy = coords[1];
                        var crossings = 0;
                        var ci = 2;
                        for (var i = 1; i < this.numTypes; i++) {
                            switch ((this.pointTypes[i])) {
                                case java.awt.geom.PathIterator.SEG_MOVETO:
                                    if (cury !== movy) {
                                        crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                                    }
                                    movx = curx = coords[ci++];
                                    movy = cury = coords[ci++];
                                    break;
                                case java.awt.geom.PathIterator.SEG_LINETO:
                                    crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, endx = coords[ci++], endy = coords[ci++]);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_QUADTO:
                                    crossings += sun.awt.geom.Curve.pointCrossingsForQuad(px, py, curx, cury, coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CUBICTO:
                                    crossings += sun.awt.geom.Curve.pointCrossingsForCubic(px, py, curx, cury, coords[ci++], coords[ci++], coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CLOSE:
                                    if (cury !== movy) {
                                        crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                                    }
                                    curx = movx;
                                    cury = movy;
                                    break;
                            }
                        }
                        if (cury !== movy) {
                            crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                        }
                        return crossings;
                    };
                    Float.prototype.rectCrossings = function (rxmin, rymin, rxmax, rymax) {
                        var coords = this.floatCoords;
                        var curx;
                        var cury;
                        var movx;
                        var movy;
                        var endx;
                        var endy;
                        curx = movx = coords[0];
                        cury = movy = coords[1];
                        var crossings = 0;
                        var ci = 2;
                        for (var i = 1; crossings !== sun.awt.geom.Curve.RECT_INTERSECTS && i < this.numTypes; i++) {
                            switch ((this.pointTypes[i])) {
                                case java.awt.geom.PathIterator.SEG_MOVETO:
                                    if (curx !== movx || cury !== movy) {
                                        crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                                    }
                                    movx = curx = coords[ci++];
                                    movy = cury = coords[ci++];
                                    break;
                                case java.awt.geom.PathIterator.SEG_LINETO:
                                    crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, endx = coords[ci++], endy = coords[ci++]);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_QUADTO:
                                    crossings = sun.awt.geom.Curve.rectCrossingsForQuad(crossings, rxmin, rymin, rxmax, rymax, curx, cury, coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CUBICTO:
                                    crossings = sun.awt.geom.Curve.rectCrossingsForCubic(crossings, rxmin, rymin, rxmax, rymax, curx, cury, coords[ci++], coords[ci++], coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CLOSE:
                                    if (curx !== movx || cury !== movy) {
                                        crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                                    }
                                    curx = movx;
                                    cury = movy;
                                    break;
                            }
                        }
                        if (crossings !== sun.awt.geom.Curve.RECT_INTERSECTS && (curx !== movx || cury !== movy)) {
                            crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                        }
                        return crossings;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Float.prototype.append = function (pi, connect) {
                        var _this = this;
                        if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || pi === null) && ((typeof connect === 'boolean') || connect === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            return (function () {
                                var coords = new Array(6);
                                while ((!pi.isDone())) {
                                    switch ((pi.currentSegment(coords))) {
                                        case java.awt.geom.Path2D.SEG_MOVETO_$LI$():
                                            if (!connect || _this.numTypes < 1 || _this.numCoords < 1) {
                                                _this.moveTo(coords[0], coords[1]);
                                                break;
                                            }
                                            if (_this.pointTypes[_this.numTypes - 1] !== java.awt.geom.Path2D.SEG_CLOSE_$LI$() && _this.floatCoords[_this.numCoords - 2] === coords[0] && _this.floatCoords[_this.numCoords - 1] === coords[1]) {
                                                break;
                                            }
                                            _this.lineTo(coords[0], coords[1]);
                                            break;
                                        case java.awt.geom.Path2D.SEG_LINETO_$LI$():
                                            _this.lineTo(coords[0], coords[1]);
                                            break;
                                        case java.awt.geom.Path2D.SEG_QUADTO_$LI$():
                                            _this.quadTo(coords[0], coords[1], coords[2], coords[3]);
                                            break;
                                        case java.awt.geom.Path2D.SEG_CUBICTO_$LI$():
                                            _this.curveTo(coords[0], coords[1], coords[2], coords[3], coords[4], coords[5]);
                                            break;
                                        case java.awt.geom.Path2D.SEG_CLOSE_$LI$():
                                            _this.closePath();
                                            break;
                                    }
                                    pi.next();
                                    connect = false;
                                }
                                ;
                            })();
                        }
                        else if (((typeof pi === 'number') || pi === null) && ((typeof connect === 'number') || connect === null)) {
                            return this.append$float$float(pi, connect);
                        }
                        else if (((typeof pi === 'number') || pi === null) && ((typeof connect === 'number') || connect === null)) {
                            return this.append$double$double(pi, connect);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Float.prototype.transform = function (at) {
                        at.transform(this.floatCoords, 0, this.floatCoords, 0, (this.numCoords / 2 | 0));
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Float.prototype.getBounds2D = function () {
                        var x1;
                        var y1;
                        var x2;
                        var y2;
                        var i = this.numCoords;
                        if (i > 0) {
                            y1 = y2 = this.floatCoords[--i];
                            x1 = x2 = this.floatCoords[--i];
                            while ((i > 0)) {
                                var y = this.floatCoords[--i];
                                var x = this.floatCoords[--i];
                                if (x < x1)
                                    x1 = x;
                                if (y < y1)
                                    y1 = y;
                                if (x > x2)
                                    x2 = x;
                                if (y > y2)
                                    y2 = y;
                            }
                            ;
                        }
                        else {
                            x1 = y1 = x2 = y2 = 0.0;
                        }
                        return new java.awt.geom.Rectangle2D.Float(x1, y1, x2 - x1, y2 - y1);
                    };
                    /**
                     * {@inheritDoc}
                     * <p>
                     * The iterator for this class is not multi-threaded safe, which means
                     * that the {@code Path2D} class does not guarantee that modifications
                     * to the geometry of this {@code Path2D} object do not affect any
                     * iterations of that geometry that are already in process.
                     *
                     * @since 1.6
                     */
                    Float.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                        if (at == null) {
                            return new Float.CopyIterator(this);
                        }
                        else {
                            return new Float.TxIterator(this, at);
                        }
                    };
                    /**
                     * Creates a new object of the same class as this object.
                     *
                     * @return a clone of this instance.
                     * @exception OutOfMemoryError
                     * if there is not enough memory.
                     * @see java.lang.Cloneable
                     * @since 1.6
                     */
                    Float.prototype.clone = function () {
                        if (this != null && this instanceof java.awt.geom.GeneralPath) {
                            return new java.awt.geom.GeneralPath(this);
                        }
                        else {
                            return new java.awt.geom.Path2D.Float(this);
                        }
                    };
                    Float.serialVersionUID = 6990832515060788886;
                    return Float;
                }(java.awt.geom.Path2D));
                Path2D.Float = Float;
                Float["__class"] = "java.awt.geom.Path2D.Float";
                Float["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
                var Float;
                (function (Float) {
                    var CopyIterator = (function (_super) {
                        __extends(CopyIterator, _super);
                        function CopyIterator(p2df) {
                            _super.call(this, p2df);
                            this.floatCoords = p2df.floatCoords;
                        }
                        CopyIterator.prototype.currentSegment = function (coords) {
                            var _this = this;
                            if (((coords != null && coords instanceof Array) || coords === null)) {
                                var __args = Array.prototype.slice.call(arguments);
                                return (function () {
                                    var type = _this.path.pointTypes[_this.typeIdx];
                                    var numCoords = java.awt.geom.Path2D.Iterator.curvecoords_$LI$()[type];
                                    if (numCoords > 0) {
                                        java.lang.System.arraycopy(_this.floatCoords, _this.pointIdx, coords, 0, numCoords);
                                    }
                                    return type;
                                })();
                            }
                            else if (((coords != null && coords instanceof Array) || coords === null)) {
                                return this.currentSegment$double_A(coords);
                            }
                            else
                                throw new Error('invalid overload');
                        };
                        CopyIterator.prototype.currentSegment$double_A = function (coords) {
                            var type = this.path.pointTypes[this.typeIdx];
                            var numCoords = java.awt.geom.Path2D.Iterator.curvecoords_$LI$()[type];
                            if (numCoords > 0) {
                                for (var i = 0; i < numCoords; i++) {
                                    coords[i] = this.floatCoords[this.pointIdx + i];
                                }
                            }
                            return type;
                        };
                        return CopyIterator;
                    }(java.awt.geom.Path2D.Iterator));
                    Float.CopyIterator = CopyIterator;
                    CopyIterator["__class"] = "java.awt.geom.Path2D.Float.CopyIterator";
                    CopyIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
                    var TxIterator = (function (_super) {
                        __extends(TxIterator, _super);
                        function TxIterator(p2df, at) {
                            _super.call(this, p2df);
                            this.floatCoords = p2df.floatCoords;
                            this.affine = at;
                        }
                        TxIterator.prototype.currentSegment = function (coords) {
                            var _this = this;
                            if (((coords != null && coords instanceof Array) || coords === null)) {
                                var __args = Array.prototype.slice.call(arguments);
                                return (function () {
                                    var type = _this.path.pointTypes[_this.typeIdx];
                                    var numCoords = java.awt.geom.Path2D.Iterator.curvecoords_$LI$()[type];
                                    if (numCoords > 0) {
                                        _this.affine.transform(_this.floatCoords, _this.pointIdx, coords, 0, (numCoords / 2 | 0));
                                    }
                                    return type;
                                })();
                            }
                            else if (((coords != null && coords instanceof Array) || coords === null)) {
                                return this.currentSegment$double_A(coords);
                            }
                            else
                                throw new Error('invalid overload');
                        };
                        TxIterator.prototype.currentSegment$double_A = function (coords) {
                            var type = this.path.pointTypes[this.typeIdx];
                            var numCoords = java.awt.geom.Path2D.Iterator.curvecoords_$LI$()[type];
                            if (numCoords > 0) {
                                this.affine.transform(this.floatCoords, this.pointIdx, coords, 0, (numCoords / 2 | 0));
                            }
                            return type;
                        };
                        return TxIterator;
                    }(java.awt.geom.Path2D.Iterator));
                    Float.TxIterator = TxIterator;
                    TxIterator["__class"] = "java.awt.geom.Path2D.Float.TxIterator";
                    TxIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
                })(Float = Path2D.Float || (Path2D.Float = {}));
                /**
                 * The {@code Double} class defines a geometric path with coordinates stored
                 * in double precision floating point.
                 *
                 * @since 1.6
                 */
                var Double = (function (_super) {
                    __extends(Double, _super);
                    /**
                     * Constructs a new double precision {@code Path2D} object from an
                     * arbitrary {@link Shape} object, transformed by an
                     * {@link AffineTransform} object. All of the initial geometry and the
                     * winding rule for this path are taken from the specified {@code Shape}
                     * object and transformed by the specified {@code AffineTransform}
                     * object.
                     *
                     * @param s
                     * the specified {@code Shape} object
                     * @param at
                     * the specified {@code AffineTransform} object
                     * @since 1.6
                     */
                    function Double(s, at) {
                        var _this = this;
                        if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.Shape") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || s === null) && ((at != null && at instanceof java.awt.geom.AffineTransform) || at === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            (function () {
                                if (s != null && s instanceof java.awt.geom.Path2D) {
                                    var p2d = s;
                                    _this.setWindingRule(p2d.windingRule);
                                    _this.numTypes = p2d.numTypes;
                                    _this.pointTypes = java.util.Arrays.copyOf(p2d.pointTypes, p2d.pointTypes.length);
                                    _this.numCoords = p2d.numCoords;
                                    _this.doubleCoords = p2d.cloneCoordsDouble(at);
                                }
                                else {
                                    var pi = s.getPathIterator(at);
                                    _this.setWindingRule(pi.getWindingRule());
                                    _this.pointTypes = new Array(java.awt.geom.Path2D.INIT_SIZE);
                                    _this.doubleCoords = new Array(java.awt.geom.Path2D.INIT_SIZE * 2);
                                    _this.append(pi, false);
                                }
                            })();
                        }
                        else if (((typeof s === 'number') || s === null) && ((typeof at === 'number') || at === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            var rule = __args[0];
                            var initialCapacity_4 = __args[1];
                            _super.call(this, rule, initialCapacity_4);
                            (function () {
                                _this.doubleCoords = new Array(initialCapacity_4 * 2);
                            })();
                        }
                        else if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.Shape") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || s === null) && at === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            {
                                var __args_23 = Array.prototype.slice.call(arguments);
                                var at_2 = null;
                                _super.call(this);
                                (function () {
                                    if (s != null && s instanceof java.awt.geom.Path2D) {
                                        var p2d = s;
                                        _this.setWindingRule(p2d.windingRule);
                                        _this.numTypes = p2d.numTypes;
                                        _this.pointTypes = java.util.Arrays.copyOf(p2d.pointTypes, p2d.pointTypes.length);
                                        _this.numCoords = p2d.numCoords;
                                        _this.doubleCoords = p2d.cloneCoordsDouble(at_2);
                                    }
                                    else {
                                        var pi = s.getPathIterator(at_2);
                                        _this.setWindingRule(pi.getWindingRule());
                                        _this.pointTypes = new Array(java.awt.geom.Path2D.INIT_SIZE);
                                        _this.doubleCoords = new Array(java.awt.geom.Path2D.INIT_SIZE * 2);
                                        _this.append(pi, false);
                                    }
                                })();
                            }
                        }
                        else if (((typeof s === 'number') || s === null) && at === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            var rule = __args[0];
                            {
                                var __args_24 = Array.prototype.slice.call(arguments);
                                var initialCapacity_5 = java.awt.geom.Path2D.INIT_SIZE;
                                _super.call(this, rule, initialCapacity_5);
                                (function () {
                                    _this.doubleCoords = new Array(initialCapacity_5 * 2);
                                })();
                            }
                        }
                        else if (s === undefined && at === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            {
                                var __args_25 = Array.prototype.slice.call(arguments);
                                var rule = java.awt.geom.Path2D.WIND_NON_ZERO_$LI$();
                                var initialCapacity_6 = java.awt.geom.Path2D.INIT_SIZE;
                                _super.call(this, rule, initialCapacity_6);
                                (function () {
                                    _this.doubleCoords = new Array(initialCapacity_6 * 2);
                                })();
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    Double.prototype.cloneCoordsFloat = function (at) {
                        var ret = new Array(this.doubleCoords.length);
                        if (at == null) {
                            for (var i = 0; i < this.numCoords; i++) {
                                ret[i] = this.doubleCoords[i];
                            }
                        }
                        else {
                            at.transform(this.doubleCoords, 0, ret, 0, (this.numCoords / 2 | 0));
                        }
                        return ret;
                    };
                    Double.prototype.cloneCoordsDouble = function (at) {
                        var ret;
                        if (at == null) {
                            ret = java.util.Arrays.copyOf(this.doubleCoords, this.doubleCoords.length);
                        }
                        else {
                            ret = new Array(this.doubleCoords.length);
                            at.transform(this.doubleCoords, 0, ret, 0, (this.numCoords / 2 | 0));
                        }
                        return ret;
                    };
                    Double.prototype.append$float$float = function (x, y) {
                        this.doubleCoords[this.numCoords++] = x;
                        this.doubleCoords[this.numCoords++] = y;
                    };
                    Double.prototype.append$double$double = function (x, y) {
                        this.doubleCoords[this.numCoords++] = x;
                        this.doubleCoords[this.numCoords++] = y;
                    };
                    Double.prototype.getPoint = function (coordindex) {
                        return new java.awt.geom.Point2D.Double(this.doubleCoords[coordindex], this.doubleCoords[coordindex + 1]);
                    };
                    Double.prototype.needRoom = function (needMove, newCoords) {
                        if (needMove && this.numTypes === 0) {
                            throw new java.awt.geom.IllegalPathStateException("missing initial moveto in path definition");
                        }
                        var size = this.pointTypes.length;
                        if (this.numTypes >= size) {
                            var grow = size;
                            if (grow > java.awt.geom.Path2D.EXPAND_MAX) {
                                grow = java.awt.geom.Path2D.EXPAND_MAX;
                            }
                            this.pointTypes = java.util.Arrays.copyOf(this.pointTypes, size + grow);
                        }
                        size = this.doubleCoords.length;
                        if (this.numCoords + newCoords > size) {
                            var grow = size;
                            if (grow > java.awt.geom.Path2D.EXPAND_MAX * 2) {
                                grow = java.awt.geom.Path2D.EXPAND_MAX * 2;
                            }
                            if (grow < newCoords) {
                                grow = newCoords;
                            }
                            this.doubleCoords = java.util.Arrays.copyOf(this.doubleCoords, size + grow);
                        }
                    };
                    /**
                     * Adds a point to the path by moving to the specified coordinates
                     * specified in float precision.
                     * <p>
                     * This method provides a single precision variant of the double
                     * precision {@code moveTo()} method on the base {@code Path2D} class.
                     *
                     * @param x
                     * the specified X coordinate
                     * @param y
                     * the specified Y coordinate
                     * @see Path2D#moveTo
                     * @since 1.6
                     */
                    Double.prototype.moveTo = function (x, y) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return this.moveTo$double$double(x, y);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Double.prototype.moveTo$double$double = function (x, y) {
                        if (this.numTypes > 0 && this.pointTypes[this.numTypes - 1] === java.awt.geom.Path2D.SEG_MOVETO_$LI$()) {
                            this.doubleCoords[this.numCoords - 2] = x;
                            this.doubleCoords[this.numCoords - 1] = y;
                        }
                        else {
                            this.needRoom(false, 2);
                            this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_MOVETO_$LI$();
                            this.doubleCoords[this.numCoords++] = x;
                            this.doubleCoords[this.numCoords++] = y;
                        }
                    };
                    /**
                     * Adds a point to the path by drawing a straight line from the current
                     * coordinates to the new specified coordinates specified in float
                     * precision.
                     * <p>
                     * This method provides a single precision variant of the double
                     * precision {@code lineTo()} method on the base {@code Path2D} class.
                     *
                     * @param x
                     * the specified X coordinate
                     * @param y
                     * the specified Y coordinate
                     * @see Path2D#lineTo
                     * @since 1.6
                     */
                    Double.prototype.lineTo = function (x, y) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return this.lineTo$double$double(x, y);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Double.prototype.lineTo$double$double = function (x, y) {
                        this.needRoom(true, 2);
                        this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_LINETO_$LI$();
                        this.doubleCoords[this.numCoords++] = x;
                        this.doubleCoords[this.numCoords++] = y;
                    };
                    /**
                     * Adds a curved segment, defined by two new points, to the path by
                     * drawing a Quadratic curve that intersects both the current
                     * coordinates and the specified coordinates {@code (x2,y2)}, using the
                     * specified point {@code (x1,y1)} as a quadratic parametric control
                     * point. All coordinates are specified in float precision.
                     * <p>
                     * This method provides a single precision variant of the double
                     * precision {@code quadTo()} method on the base {@code Path2D} class.
                     *
                     * @param x1
                     * the X coordinate of the quadratic control point
                     * @param y1
                     * the Y coordinate of the quadratic control point
                     * @param x2
                     * the X coordinate of the final end point
                     * @param y2
                     * the Y coordinate of the final end point
                     * @see Path2D#quadTo
                     * @since 1.6
                     */
                    Double.prototype.quadTo = function (x1, y1, x2, y2) {
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.quadTo$double$double$double$double(x1, y1, x2, y2);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Double.prototype.quadTo$double$double$double$double = function (x1, y1, x2, y2) {
                        this.needRoom(true, 4);
                        this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_QUADTO_$LI$();
                        this.doubleCoords[this.numCoords++] = x1;
                        this.doubleCoords[this.numCoords++] = y1;
                        this.doubleCoords[this.numCoords++] = x2;
                        this.doubleCoords[this.numCoords++] = y2;
                    };
                    /**
                     * Adds a curved segment, defined by three new points, to the path by
                     * drawing a B&eacute;zier curve that intersects both the current
                     * coordinates and the specified coordinates {@code (x3,y3)}, using the
                     * specified points {@code (x1,y1)} and {@code (x2,y2)} as B&eacute;zier
                     * control points. All coordinates are specified in float precision.
                     * <p>
                     * This method provides a single precision variant of the double
                     * precision {@code curveTo()} method on the base {@code Path2D} class.
                     *
                     * @param x1
                     * the X coordinate of the first B&eacute;zier control point
                     * @param y1
                     * the Y coordinate of the first B&eacute;zier control point
                     * @param x2
                     * the X coordinate of the second B&eacute;zier control point
                     * @param y2
                     * the Y coordinate of the second B&eacute;zier control point
                     * @param x3
                     * the X coordinate of the final end point
                     * @param y3
                     * the Y coordinate of the final end point
                     * @see Path2D#curveTo
                     * @since 1.6
                     */
                    Double.prototype.curveTo = function (x1, y1, x2, y2, x3, y3) {
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null) && ((typeof x3 === 'number') || x3 === null) && ((typeof y3 === 'number') || y3 === null)) {
                            return this.curveTo$double$double$double$double$double$double(x1, y1, x2, y2, x3, y3);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Double.prototype.curveTo$double$double$double$double$double$double = function (x1, y1, x2, y2, x3, y3) {
                        this.needRoom(true, 6);
                        this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_CUBICTO_$LI$();
                        this.doubleCoords[this.numCoords++] = x1;
                        this.doubleCoords[this.numCoords++] = y1;
                        this.doubleCoords[this.numCoords++] = x2;
                        this.doubleCoords[this.numCoords++] = y2;
                        this.doubleCoords[this.numCoords++] = x3;
                        this.doubleCoords[this.numCoords++] = y3;
                    };
                    Double.prototype.pointCrossings = function (px, py) {
                        var movx;
                        var movy;
                        var curx;
                        var cury;
                        var endx;
                        var endy;
                        var coords = this.doubleCoords;
                        curx = movx = coords[0];
                        cury = movy = coords[1];
                        var crossings = 0;
                        var ci = 2;
                        for (var i = 1; i < this.numTypes; i++) {
                            switch ((this.pointTypes[i])) {
                                case java.awt.geom.PathIterator.SEG_MOVETO:
                                    if (cury !== movy) {
                                        crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                                    }
                                    movx = curx = coords[ci++];
                                    movy = cury = coords[ci++];
                                    break;
                                case java.awt.geom.PathIterator.SEG_LINETO:
                                    crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, endx = coords[ci++], endy = coords[ci++]);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_QUADTO:
                                    crossings += sun.awt.geom.Curve.pointCrossingsForQuad(px, py, curx, cury, coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CUBICTO:
                                    crossings += sun.awt.geom.Curve.pointCrossingsForCubic(px, py, curx, cury, coords[ci++], coords[ci++], coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CLOSE:
                                    if (cury !== movy) {
                                        crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                                    }
                                    curx = movx;
                                    cury = movy;
                                    break;
                            }
                        }
                        if (cury !== movy) {
                            crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                        }
                        return crossings;
                    };
                    Double.prototype.rectCrossings = function (rxmin, rymin, rxmax, rymax) {
                        var coords = this.doubleCoords;
                        var curx;
                        var cury;
                        var movx;
                        var movy;
                        var endx;
                        var endy;
                        curx = movx = coords[0];
                        cury = movy = coords[1];
                        var crossings = 0;
                        var ci = 2;
                        for (var i = 1; crossings !== sun.awt.geom.Curve.RECT_INTERSECTS && i < this.numTypes; i++) {
                            switch ((this.pointTypes[i])) {
                                case java.awt.geom.PathIterator.SEG_MOVETO:
                                    if (curx !== movx || cury !== movy) {
                                        crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                                    }
                                    movx = curx = coords[ci++];
                                    movy = cury = coords[ci++];
                                    break;
                                case java.awt.geom.PathIterator.SEG_LINETO:
                                    endx = coords[ci++];
                                    endy = coords[ci++];
                                    crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, endx, endy);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_QUADTO:
                                    crossings = sun.awt.geom.Curve.rectCrossingsForQuad(crossings, rxmin, rymin, rxmax, rymax, curx, cury, coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CUBICTO:
                                    crossings = sun.awt.geom.Curve.rectCrossingsForCubic(crossings, rxmin, rymin, rxmax, rymax, curx, cury, coords[ci++], coords[ci++], coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CLOSE:
                                    if (curx !== movx || cury !== movy) {
                                        crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                                    }
                                    curx = movx;
                                    cury = movy;
                                    break;
                            }
                        }
                        if (crossings !== sun.awt.geom.Curve.RECT_INTERSECTS && (curx !== movx || cury !== movy)) {
                            crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                        }
                        return crossings;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Double.prototype.append = function (pi, connect) {
                        var _this = this;
                        if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || pi === null) && ((typeof connect === 'boolean') || connect === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            return (function () {
                                var coords = new Array(6);
                                while ((!pi.isDone())) {
                                    switch ((pi.currentSegment(coords))) {
                                        case java.awt.geom.Path2D.SEG_MOVETO_$LI$():
                                            if (!connect || _this.numTypes < 1 || _this.numCoords < 1) {
                                                _this.moveTo(coords[0], coords[1]);
                                                break;
                                            }
                                            if (_this.pointTypes[_this.numTypes - 1] !== java.awt.geom.Path2D.SEG_CLOSE_$LI$() && _this.doubleCoords[_this.numCoords - 2] === coords[0] && _this.doubleCoords[_this.numCoords - 1] === coords[1]) {
                                                break;
                                            }
                                            _this.lineTo(coords[0], coords[1]);
                                            break;
                                        case java.awt.geom.Path2D.SEG_LINETO_$LI$():
                                            _this.lineTo(coords[0], coords[1]);
                                            break;
                                        case java.awt.geom.Path2D.SEG_QUADTO_$LI$():
                                            _this.quadTo(coords[0], coords[1], coords[2], coords[3]);
                                            break;
                                        case java.awt.geom.Path2D.SEG_CUBICTO_$LI$():
                                            _this.curveTo(coords[0], coords[1], coords[2], coords[3], coords[4], coords[5]);
                                            break;
                                        case java.awt.geom.Path2D.SEG_CLOSE_$LI$():
                                            _this.closePath();
                                            break;
                                    }
                                    pi.next();
                                    connect = false;
                                }
                                ;
                            })();
                        }
                        else if (((typeof pi === 'number') || pi === null) && ((typeof connect === 'number') || connect === null)) {
                            return this.append$float$float(pi, connect);
                        }
                        else if (((typeof pi === 'number') || pi === null) && ((typeof connect === 'number') || connect === null)) {
                            return this.append$double$double(pi, connect);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Double.prototype.transform = function (at) {
                        at.transform(this.doubleCoords, 0, this.doubleCoords, 0, (this.numCoords / 2 | 0));
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     */
                    Double.prototype.getBounds2D = function () {
                        var x1;
                        var y1;
                        var x2;
                        var y2;
                        var i = this.numCoords;
                        if (i > 0) {
                            y1 = y2 = this.doubleCoords[--i];
                            x1 = x2 = this.doubleCoords[--i];
                            while ((i > 0)) {
                                var y = this.doubleCoords[--i];
                                var x = this.doubleCoords[--i];
                                if (x < x1)
                                    x1 = x;
                                if (y < y1)
                                    y1 = y;
                                if (x > x2)
                                    x2 = x;
                                if (y > y2)
                                    y2 = y;
                            }
                            ;
                        }
                        else {
                            x1 = y1 = x2 = y2 = 0.0;
                        }
                        return new java.awt.geom.Rectangle2D.Double(x1, y1, x2 - x1, y2 - y1);
                    };
                    /**
                     * {@inheritDoc}
                     * <p>
                     * The iterator for this class is not multi-threaded safe, which means
                     * that the {@code Path2D} class does not guarantee that modifications
                     * to the geometry of this {@code Path2D} object do not affect any
                     * iterations of that geometry that are already in process.
                     *
                     * @param at
                     * an {@code AffineTransform}
                     * @return a new {@code PathIterator} that iterates along the boundary
                     * of this {@code Shape} and provides access to the geometry of
                     * this {@code Shape}'s outline
                     * @since 1.6
                     */
                    Double.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                        if (at == null) {
                            return new Double.CopyIterator(this);
                        }
                        else {
                            return new Double.TxIterator(this, at);
                        }
                    };
                    /**
                     * Creates a new object of the same class as this object.
                     *
                     * @return a clone of this instance.
                     * @exception OutOfMemoryError
                     * if there is not enough memory.
                     * @see java.lang.Cloneable
                     * @since 1.6
                     */
                    Double.prototype.clone = function () {
                        return new java.awt.geom.Path2D.Double(this);
                    };
                    Double.serialVersionUID = 1826762518450014216;
                    return Double;
                }(java.awt.geom.Path2D));
                Path2D.Double = Double;
                Double["__class"] = "java.awt.geom.Path2D.Double";
                Double["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
                var Double;
                (function (Double) {
                    var CopyIterator = (function (_super) {
                        __extends(CopyIterator, _super);
                        function CopyIterator(p2dd) {
                            _super.call(this, p2dd);
                            this.doubleCoords = p2dd.doubleCoords;
                        }
                        CopyIterator.prototype.currentSegment = function (coords) {
                            var _this = this;
                            if (((coords != null && coords instanceof Array) || coords === null)) {
                                var __args = Array.prototype.slice.call(arguments);
                                return (function () {
                                    var type = _this.path.pointTypes[_this.typeIdx];
                                    var numCoords = java.awt.geom.Path2D.Iterator.curvecoords_$LI$()[type];
                                    if (numCoords > 0) {
                                        for (var i = 0; i < numCoords; i++) {
                                            coords[i] = _this.doubleCoords[_this.pointIdx + i];
                                        }
                                    }
                                    return type;
                                })();
                            }
                            else if (((coords != null && coords instanceof Array) || coords === null)) {
                                return this.currentSegment$double_A(coords);
                            }
                            else
                                throw new Error('invalid overload');
                        };
                        CopyIterator.prototype.currentSegment$double_A = function (coords) {
                            var type = this.path.pointTypes[this.typeIdx];
                            var numCoords = java.awt.geom.Path2D.Iterator.curvecoords_$LI$()[type];
                            if (numCoords > 0) {
                                java.lang.System.arraycopy(this.doubleCoords, this.pointIdx, coords, 0, numCoords);
                            }
                            return type;
                        };
                        return CopyIterator;
                    }(java.awt.geom.Path2D.Iterator));
                    Double.CopyIterator = CopyIterator;
                    CopyIterator["__class"] = "java.awt.geom.Path2D.Double.CopyIterator";
                    CopyIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
                    var TxIterator = (function (_super) {
                        __extends(TxIterator, _super);
                        function TxIterator(p2dd, at) {
                            _super.call(this, p2dd);
                            this.doubleCoords = p2dd.doubleCoords;
                            this.affine = at;
                        }
                        TxIterator.prototype.currentSegment = function (coords) {
                            var _this = this;
                            if (((coords != null && coords instanceof Array) || coords === null)) {
                                var __args = Array.prototype.slice.call(arguments);
                                return (function () {
                                    var type = _this.path.pointTypes[_this.typeIdx];
                                    var numCoords = java.awt.geom.Path2D.Iterator.curvecoords_$LI$()[type];
                                    if (numCoords > 0) {
                                        _this.affine.transform(_this.doubleCoords, _this.pointIdx, coords, 0, (numCoords / 2 | 0));
                                    }
                                    return type;
                                })();
                            }
                            else if (((coords != null && coords instanceof Array) || coords === null)) {
                                return this.currentSegment$double_A(coords);
                            }
                            else
                                throw new Error('invalid overload');
                        };
                        TxIterator.prototype.currentSegment$double_A = function (coords) {
                            var type = this.path.pointTypes[this.typeIdx];
                            var numCoords = java.awt.geom.Path2D.Iterator.curvecoords_$LI$()[type];
                            if (numCoords > 0) {
                                this.affine.transform(this.doubleCoords, this.pointIdx, coords, 0, (numCoords / 2 | 0));
                            }
                            return type;
                        };
                        return TxIterator;
                    }(java.awt.geom.Path2D.Iterator));
                    Double.TxIterator = TxIterator;
                    TxIterator["__class"] = "java.awt.geom.Path2D.Double.TxIterator";
                    TxIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
                })(Double = Path2D.Double || (Path2D.Double = {}));
            })(Path2D = geom.Path2D || (geom.Path2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        /**
         * A point representing a location in {@code (x,y)} coordinate space,
         * specified in integer precision.
         *
         * @author      Sami Shaio
         * @since       1.0
         */
        var Point = (function (_super) {
            __extends(Point, _super);
            /**
             * Constructs and initializes a point at the specified
             * {@code (x,y)} location in the coordinate space.
             * @param x the X coordinate of the newly constructed <code>Point</code>
             * @param y the Y coordinate of the newly constructed <code>Point</code>
             * @since 1.0
             */
            function Point(x, y) {
                var _this = this;
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this);
                    this.x = 0;
                    this.y = 0;
                    (function () {
                        _this.x = x;
                        _this.y = y;
                    })();
                }
                else if (((x != null && x instanceof java.awt.Point) || x === null) && y === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var p = __args[0];
                    {
                        var __args_26 = Array.prototype.slice.call(arguments);
                        var x_2 = p.x;
                        var y_2 = p.y;
                        _super.call(this);
                        this.x = 0;
                        this.y = 0;
                        (function () {
                            _this.x = x_2;
                            _this.y = y_2;
                        })();
                    }
                }
                else if (x === undefined && y === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_27 = Array.prototype.slice.call(arguments);
                        var x_3 = 0;
                        var y_3 = 0;
                        _super.call(this);
                        this.x = 0;
                        this.y = 0;
                        (function () {
                            _this.x = x_3;
                            _this.y = y_3;
                        })();
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * {@inheritDoc}
             * @since 1.2
             */
            Point.prototype.getX = function () {
                return this.x;
            };
            /**
             * {@inheritDoc}
             * @since 1.2
             */
            Point.prototype.getY = function () {
                return this.y;
            };
            /**
             * Returns the location of this point.
             * This method is included for completeness, to parallel the
             * <code>getLocation</code> method of <code>Component</code>.
             * @return      a copy of this point, at the same location
             * @see         java.awt.Component#getLocation
             * @see         java.awt.Point#setLocation(java.awt.Point)
             * @see         java.awt.Point#setLocation(int, int)
             * @since       1.1
             */
            Point.prototype.getLocation = function () {
                return new Point(this.x, this.y);
            };
            /**
             * Sets the location of the point to the specified location.
             * This method is included for completeness, to parallel the
             * <code>setLocation</code> method of <code>Component</code>.
             * @param       p  a point, the new location for this point
             * @see         java.awt.Component#setLocation(java.awt.Point)
             * @see         java.awt.Point#getLocation
             * @since       1.1
             */
            Point.prototype.setLocation$java_awt_Point = function (p) {
                this.setLocation(p.x, p.y);
            };
            /**
             * Changes the point to have the specified location.
             * <p>
             * This method is included for completeness, to parallel the
             * <code>setLocation</code> method of <code>Component</code>.
             * Its behavior is identical with <code>move(int,&nbsp;int)</code>.
             * @param       x the X coordinate of the new location
             * @param       y the Y coordinate of the new location
             * @see         java.awt.Component#setLocation(int, int)
             * @see         java.awt.Point#getLocation
             * @see         java.awt.Point#move(int, int)
             * @since       1.1
             */
            Point.prototype.setLocation = function (x, y) {
                var _this = this;
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        _this.move(x, y);
                    })();
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return this.setLocation$double$double(x, y);
                }
                else if (((x != null && x instanceof java.awt.Point) || x === null) && y === undefined) {
                    return this.setLocation$java_awt_Point(x);
                }
                else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined) {
                    return this.setLocation$java_awt_geom_Point2D(x);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Sets the location of this point to the specified double coordinates.
             * The double values will be rounded to integer values.
             * Any number smaller than <code>Integer.MIN_VALUE</code>
             * will be reset to <code>MIN_VALUE</code>, and any number
             * larger than <code>Integer.MAX_VALUE</code> will be
             * reset to <code>MAX_VALUE</code>.
             *
             * @param x the X coordinate of the new location
             * @param y the Y coordinate of the new location
             * @see #getLocation
             */
            Point.prototype.setLocation$double$double = function (x, y) {
                this.x = (Math.floor(x + 0.5) | 0);
                this.y = (Math.floor(y + 0.5) | 0);
            };
            /**
             * Moves this point to the specified location in the
             * {@code (x,y)} coordinate plane. This method
             * is identical with <code>setLocation(int,&nbsp;int)</code>.
             * @param       x the X coordinate of the new location
             * @param       y the Y coordinate of the new location
             * @see         java.awt.Component#setLocation(int, int)
             */
            Point.prototype.move = function (x, y) {
                this.x = x;
                this.y = y;
            };
            /**
             * Translates this point, at location {@code (x,y)},
             * by {@code dx} along the {@code x} axis and {@code dy}
             * along the {@code y} axis so that it now represents the point
             * {@code (x+dx,y+dy)}.
             *
             * @param       dx   the distance to move this point
             * along the X axis
             * @param       dy    the distance to move this point
             * along the Y axis
             */
            Point.prototype.translate = function (dx, dy) {
                this.x += dx;
                this.y += dy;
            };
            /**
             * Determines whether or not two points are equal. Two instances of
             * <code>Point2D</code> are equal if the values of their
             * <code>x</code> and <code>y</code> member fields, representing
             * their position in the coordinate space, are the same.
             * @param obj an object to be compared with this <code>Point2D</code>
             * @return <code>true</code> if the object to be compared is
             * an instance of <code>Point2D</code> and has
             * the same values; <code>false</code> otherwise.
             */
            Point.prototype.equals = function (obj) {
                if (obj != null && obj instanceof java.awt.Point) {
                    var pt = obj;
                    return (this.x === pt.x) && (this.y === pt.y);
                }
                return _super.prototype.equals.call(this, obj);
            };
            /**
             * Returns a string representation of this point and its location
             * in the {@code (x,y)} coordinate space. This method is
             * intended to be used only for debugging purposes, and the content
             * and format of the returned string may vary between implementations.
             * The returned string may be empty but may not be <code>null</code>.
             *
             * @return  a string representation of this point
             */
            Point.prototype.toString = function () {
                return (function (c) { return c["__class"] ? c["__class"] : c.name; })(Point) + "[x=" + this.x + ",y=" + this.y + "]";
            };
            Point.serialVersionUID = -5276940640259749850;
            return Point;
        }(java.awt.geom.Point2D));
        awt.Point = Point;
        Point["__class"] = "java.awt.Point";
        Point["__interfaces"] = ["java.lang.Cloneable", "java.io.Serializable"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * <CODE>Arc2D</CODE> is the abstract superclass for all objects that
             * store a 2D arc defined by a framing rectangle,
             * start angle, angular extent (length of the arc), and a closure type
             * (<CODE>OPEN</CODE>, <CODE>CHORD</CODE>, or <CODE>PIE</CODE>).
             * <p>
             * <a name="inscribes">
             * The arc is a partial section of a full ellipse which
             * inscribes the framing rectangle of its parent {@link RectangularShape}.
             * </a>
             * <a name="angles">
             * The angles are specified relative to the non-square
             * framing rectangle such that 45 degrees always falls on the line from
             * the center of the ellipse to the upper right corner of the framing
             * rectangle.
             * As a result, if the framing rectangle is noticeably longer along one
             * axis than the other, the angles to the start and end of the arc segment
             * will be skewed farther along the longer axis of the frame.
             * </a>
             * <p>
             * The actual storage representation of the coordinates is left to
             * the subclass.
             *
             * @author      Jim Graham
             * @since 1.2
             */
            var Arc2D = (function (_super) {
                __extends(Arc2D, _super);
                /**
                 * This is an abstract class that cannot be instantiated directly.
                 * Type-specific implementation subclasses are available for
                 * instantiation and provide a number of formats for storing
                 * the information necessary to satisfy the various accessor
                 * methods below.
                 *
                 * @param type The closure type of this arc:
                 * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
                 * @see java.awt.geom.Arc2D.Float
                 * @see java.awt.geom.Arc2D.Double
                 * @since 1.2
                 */
                function Arc2D(type) {
                    if (type === void 0) { type = Arc2D.OPEN; }
                    _super.call(this);
                    this.type = 0;
                    this.setArcType(type);
                }
                /**
                 * Returns the arc closure type of the arc: {@link #OPEN},
                 * {@link #CHORD}, or {@link #PIE}.
                 * @return One of the integer constant closure types defined
                 * in this class.
                 * @see #setArcType
                 * @since 1.2
                 */
                Arc2D.prototype.getArcType = function () {
                    return this.type;
                };
                /**
                 * Returns the starting point of the arc.  This point is the
                 * intersection of the ray from the center defined by the
                 * starting angle and the elliptical boundary of the arc.
                 *
                 * @return A <CODE>Point2D</CODE> object representing the
                 * x,y coordinates of the starting point of the arc.
                 * @since 1.2
                 */
                Arc2D.prototype.getStartPoint = function () {
                    var angle = (function (x) { return x * Math.PI / 180; })(-this.getAngleStart());
                    var x = this.getX() + (Math.cos(angle) * 0.5 + 0.5) * this.getWidth();
                    var y = this.getY() + (Math.sin(angle) * 0.5 + 0.5) * this.getHeight();
                    return new java.awt.geom.Point2D.Double(x, y);
                };
                /**
                 * Returns the ending point of the arc.  This point is the
                 * intersection of the ray from the center defined by the
                 * starting angle plus the angular extent of the arc and the
                 * elliptical boundary of the arc.
                 *
                 * @return A <CODE>Point2D</CODE> object representing the
                 * x,y coordinates  of the ending point of the arc.
                 * @since 1.2
                 */
                Arc2D.prototype.getEndPoint = function () {
                    var angle = (function (x) { return x * Math.PI / 180; })(-this.getAngleStart() - this.getAngleExtent());
                    var x = this.getX() + (Math.cos(angle) * 0.5 + 0.5) * this.getWidth();
                    var y = this.getY() + (Math.sin(angle) * 0.5 + 0.5) * this.getHeight();
                    return new java.awt.geom.Point2D.Double(x, y);
                };
                /**
                 * Sets the location, size, angular extents, and closure type of
                 * this arc to the specified double values.
                 *
                 * @param x The X coordinate of the upper-left corner of the arc.
                 * @param y The Y coordinate of the upper-left corner of the arc.
                 * @param w The overall width of the full ellipse of which
                 * this arc is a partial section.
                 * @param h The overall height of the full ellipse of which
                 * this arc is a partial section.
                 * @param angSt The starting angle of the arc in degrees.
                 * @param angExt The angular extent of the arc in degrees.
                 * @param closure The closure type for the arc:
                 * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
                 * @since 1.2
                 */
                Arc2D.prototype.setArc = function (x, y, w, h, angSt, angExt, closure) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof angSt === 'number') || angSt === null) && ((typeof angExt === 'number') || angExt === null) && ((typeof closure === 'number') || closure === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof angSt === 'number') || angSt === null) && angExt === undefined && closure === undefined) {
                        return this.setArc$java_awt_geom_Point2D$java_awt_geom_Dimension2D$double$double$int(x, y, w, h, angSt);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && angSt === undefined && angExt === undefined && closure === undefined) {
                        return this.setArc$java_awt_geom_Rectangle2D$double$double$int(x, y, w, h);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Arc2D) || x === null) && y === undefined && w === undefined && h === undefined && angSt === undefined && angExt === undefined && closure === undefined) {
                        return this.setArc$java_awt_geom_Arc2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the location, size, angular extents, and closure type of
                 * this arc to the specified values.
                 *
                 * @param loc The <CODE>Point2D</CODE> representing the coordinates of
                 * the upper-left corner of the arc.
                 * @param size The <CODE>Dimension2D</CODE> representing the width
                 * and height of the full ellipse of which this arc is
                 * a partial section.
                 * @param angSt The starting angle of the arc in degrees.
                 * @param angExt The angular extent of the arc in degrees.
                 * @param closure The closure type for the arc:
                 * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
                 * @since 1.2
                 */
                Arc2D.prototype.setArc$java_awt_geom_Point2D$java_awt_geom_Dimension2D$double$double$int = function (loc, size, angSt, angExt, closure) {
                    this.setArc(loc.getX(), loc.getY(), size.getWidth(), size.getHeight(), angSt, angExt, closure);
                };
                /**
                 * Sets the location, size, angular extents, and closure type of
                 * this arc to the specified values.
                 *
                 * @param rect The framing rectangle that defines the
                 * outer boundary of the full ellipse of which this arc is a
                 * partial section.
                 * @param angSt The starting angle of the arc in degrees.
                 * @param angExt The angular extent of the arc in degrees.
                 * @param closure The closure type for the arc:
                 * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
                 * @since 1.2
                 */
                Arc2D.prototype.setArc$java_awt_geom_Rectangle2D$double$double$int = function (rect, angSt, angExt, closure) {
                    this.setArc(rect.getX(), rect.getY(), rect.getWidth(), rect.getHeight(), angSt, angExt, closure);
                };
                /**
                 * Sets this arc to be the same as the specified arc.
                 *
                 * @param a The <CODE>Arc2D</CODE> to use to set the arc's values.
                 * @since 1.2
                 */
                Arc2D.prototype.setArc$java_awt_geom_Arc2D = function (a) {
                    this.setArc(a.getX(), a.getY(), a.getWidth(), a.getHeight(), a.getAngleStart(), a.getAngleExtent(), a.type);
                };
                /**
                 * Sets the position, bounds, angular extents, and closure type of
                 * this arc to the specified values. The arc is defined by a center
                 * point and a radius rather than a framing rectangle for the full ellipse.
                 *
                 * @param x The X coordinate of the center of the arc.
                 * @param y The Y coordinate of the center of the arc.
                 * @param radius The radius of the arc.
                 * @param angSt The starting angle of the arc in degrees.
                 * @param angExt The angular extent of the arc in degrees.
                 * @param closure The closure type for the arc:
                 * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
                 * @since 1.2
                 */
                Arc2D.prototype.setArcByCenter = function (x, y, radius, angSt, angExt, closure) {
                    this.setArc(x - radius, y - radius, radius * 2.0, radius * 2.0, angSt, angExt, closure);
                };
                /**
                 * Sets the position, bounds, and angular extents of this arc to the
                 * specified value. The starting angle of the arc is tangent to the
                 * line specified by points (p1, p2), the ending angle is tangent to
                 * the line specified by points (p2, p3), and the arc has the
                 * specified radius.
                 *
                 * @param p1 The first point that defines the arc. The starting
                 * angle of the arc is tangent to the line specified by points (p1, p2).
                 * @param p2 The second point that defines the arc. The starting
                 * angle of the arc is tangent to the line specified by points (p1, p2).
                 * The ending angle of the arc is tangent to the line specified by
                 * points (p2, p3).
                 * @param p3 The third point that defines the arc. The ending angle
                 * of the arc is tangent to the line specified by points (p2, p3).
                 * @param radius The radius of the arc.
                 * @since 1.2
                 */
                Arc2D.prototype.setArcByTangent = function (p1, p2, p3, radius) {
                    var ang1 = Math.atan2(p1.getY() - p2.getY(), p1.getX() - p2.getX());
                    var ang2 = Math.atan2(p3.getY() - p2.getY(), p3.getX() - p2.getX());
                    var diff = ang2 - ang1;
                    if (diff > Math.PI) {
                        ang2 -= Math.PI * 2.0;
                    }
                    else if (diff < -Math.PI) {
                        ang2 += Math.PI * 2.0;
                    }
                    var bisect = (ang1 + ang2) / 2.0;
                    var theta = Math.abs(ang2 - bisect);
                    var dist = radius / Math.sin(theta);
                    var x = p2.getX() + dist * Math.cos(bisect);
                    var y = p2.getY() + dist * Math.sin(bisect);
                    if (ang1 < ang2) {
                        ang1 -= Math.PI / 2.0;
                        ang2 += Math.PI / 2.0;
                    }
                    else {
                        ang1 += Math.PI / 2.0;
                        ang2 -= Math.PI / 2.0;
                    }
                    ang1 = (function (x) { return x * 180 / Math.PI; })(-ang1);
                    ang2 = (function (x) { return x * 180 / Math.PI; })(-ang2);
                    diff = ang2 - ang1;
                    if (diff < 0) {
                        diff += 360;
                    }
                    else {
                        diff -= 360;
                    }
                    this.setArcByCenter(x, y, radius, ang1, diff, this.type);
                };
                /**
                 * Sets the starting angle of this arc to the specified double
                 * value.
                 *
                 * @param angSt The starting angle of the arc in degrees.
                 * @see #getAngleStart
                 * @since 1.2
                 */
                Arc2D.prototype.setAngleStart$double = function (angSt) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets the starting angle of this arc to the angle that the
                 * specified point defines relative to the center of this arc.
                 * The angular extent of the arc will remain the same.
                 *
                 * @param p The <CODE>Point2D</CODE> that defines the starting angle.
                 * @see #getAngleStart
                 * @since 1.2
                 */
                Arc2D.prototype.setAngleStart = function (p) {
                    var _this = this;
                    if (((p != null && p instanceof java.awt.geom.Point2D) || p === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            var dx = _this.getHeight() * (p.getX() - _this.getCenterX());
                            var dy = _this.getWidth() * (p.getY() - _this.getCenterY());
                            _this.setAngleStart(-(function (x) { return x * 180 / Math.PI; })(Math.atan2(dy, dx)));
                        })();
                    }
                    else if (((typeof p === 'number') || p === null)) {
                        return this.setAngleStart$double(p);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the starting angle and angular extent of this arc using two
                 * sets of coordinates. The first set of coordinates is used to
                 * determine the angle of the starting point relative to the arc's
                 * center. The second set of coordinates is used to determine the
                 * angle of the end point relative to the arc's center.
                 * The arc will always be non-empty and extend counterclockwise
                 * from the first point around to the second point.
                 *
                 * @param x1 The X coordinate of the arc's starting point.
                 * @param y1 The Y coordinate of the arc's starting point.
                 * @param x2 The X coordinate of the arc's ending point.
                 * @param y2 The Y coordinate of the arc's ending point.
                 * @since 1.2
                 */
                Arc2D.prototype.setAngles = function (x1, y1, x2, y2) {
                    var _this = this;
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            var x = _this.getCenterX();
                            var y = _this.getCenterY();
                            var w = _this.getWidth();
                            var h = _this.getHeight();
                            var ang1 = Math.atan2(w * (y - y1), h * (x1 - x));
                            var ang2 = Math.atan2(w * (y - y2), h * (x2 - x));
                            ang2 -= ang1;
                            if (ang2 <= 0.0) {
                                ang2 += Math.PI * 2.0;
                            }
                            _this.setAngleStart(/* toDegrees */ (function (x) { return x * 180 / Math.PI; })(ang1));
                            _this.setAngleExtent(/* toDegrees */ (function (x) { return x * 180 / Math.PI; })(ang2));
                        })();
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
                        return this.setAngles$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the starting angle and angular extent of this arc using
                 * two points. The first point is used to determine the angle of
                 * the starting point relative to the arc's center.
                 * The second point is used to determine the angle of the end point
                 * relative to the arc's center.
                 * The arc will always be non-empty and extend counterclockwise
                 * from the first point around to the second point.
                 *
                 * @param p1 The <CODE>Point2D</CODE> that defines the arc's
                 * starting point.
                 * @param p2 The <CODE>Point2D</CODE> that defines the arc's
                 * ending point.
                 * @since 1.2
                 */
                Arc2D.prototype.setAngles$java_awt_geom_Point2D$java_awt_geom_Point2D = function (p1, p2) {
                    this.setAngles(p1.getX(), p1.getY(), p2.getX(), p2.getY());
                };
                /**
                 * Sets the closure type of this arc to the specified value:
                 * <CODE>OPEN</CODE>, <CODE>CHORD</CODE>, or <CODE>PIE</CODE>.
                 *
                 * @param type The integer constant that represents the closure
                 * type of this arc: {@link #OPEN}, {@link #CHORD}, or
                 * {@link #PIE}.
                 *
                 * @throws IllegalArgumentException if <code>type</code> is not
                 * 0, 1, or 2.+
                 * @see #getArcType
                 * @since 1.2
                 */
                Arc2D.prototype.setArcType = function (type) {
                    if (type < Arc2D.OPEN || type > Arc2D.PIE) {
                        throw new java.lang.IllegalArgumentException("invalid type for Arc: " + type);
                    }
                    this.type = type;
                };
                /**
                 * {@inheritDoc}
                 * Note that the arc
                 * <a href="Arc2D.html#inscribes">partially inscribes</a>
                 * the framing rectangle of this {@code RectangularShape}.
                 *
                 * @since 1.2
                 */
                Arc2D.prototype.setFrame = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            _this.setArc(x, y, w, h, _this.getAngleStart(), _this.getAngleExtent(), _this.type);
                        })();
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && w === undefined && h === undefined) {
                        return this.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.setFrame$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the high-precision framing rectangle of the arc.  The framing
                 * rectangle contains only the part of this <code>Arc2D</code> that is
                 * in between the starting and ending angles and contains the pie
                 * wedge, if this <code>Arc2D</code> has a <code>PIE</code> closure type.
                 * <p>
                 * This method differs from the
                 * {@link RectangularShape#getBounds() getBounds} in that the
                 * <code>getBounds</code> method only returns the bounds of the
                 * enclosing ellipse of this <code>Arc2D</code> without considering
                 * the starting and ending angles of this <code>Arc2D</code>.
                 *
                 * @return the <CODE>Rectangle2D</CODE> that represents the arc's
                 * framing rectangle.
                 * @since 1.2
                 */
                Arc2D.prototype.getBounds2D = function () {
                    if (this.isEmpty()) {
                        return this.makeBounds(this.getX(), this.getY(), this.getWidth(), this.getHeight());
                    }
                    var x1;
                    var y1;
                    var x2;
                    var y2;
                    if (this.getArcType() === Arc2D.PIE) {
                        x1 = y1 = x2 = y2 = 0.0;
                    }
                    else {
                        x1 = y1 = 1.0;
                        x2 = y2 = -1.0;
                    }
                    var angle = 0.0;
                    for (var i = 0; i < 6; i++) {
                        if (i < 4) {
                            angle += 90.0;
                            if (!this.containsAngle(angle)) {
                                continue;
                            }
                        }
                        else if (i === 4) {
                            angle = this.getAngleStart();
                        }
                        else {
                            angle += this.getAngleExtent();
                        }
                        var rads = (function (x) { return x * Math.PI / 180; })(-angle);
                        var xe = Math.cos(rads);
                        var ye = Math.sin(rads);
                        x1 = Math.min(x1, xe);
                        y1 = Math.min(y1, ye);
                        x2 = Math.max(x2, xe);
                        y2 = Math.max(y2, ye);
                    }
                    var w = this.getWidth();
                    var h = this.getHeight();
                    x2 = (x2 - x1) * 0.5 * w;
                    y2 = (y2 - y1) * 0.5 * h;
                    x1 = this.getX() + (x1 * 0.5 + 0.5) * w;
                    y1 = this.getY() + (y1 * 0.5 + 0.5) * h;
                    return this.makeBounds(x1, y1, x2, y2);
                };
                Arc2D.normalizeDegrees = function (angle) {
                    if (angle > 180.0) {
                        if (angle <= (180.0 + 360.0)) {
                            angle = angle - 360.0;
                        }
                        else {
                            angle = javaemul.internal.MathHelper.IEEEremainder(angle, 360.0);
                            if (angle === -180.0) {
                                angle = 180.0;
                            }
                        }
                    }
                    else if (angle <= -180.0) {
                        if (angle > (-180.0 - 360.0)) {
                            angle = angle + 360.0;
                        }
                        else {
                            angle = javaemul.internal.MathHelper.IEEEremainder(angle, 360.0);
                            if (angle === -180.0) {
                                angle = 180.0;
                            }
                        }
                    }
                    return angle;
                };
                /**
                 * Determines whether or not the specified angle is within the
                 * angular extents of the arc.
                 *
                 * @param angle The angle to test.
                 *
                 * @return <CODE>true</CODE> if the arc contains the angle,
                 * <CODE>false</CODE> if the arc doesn't contain the angle.
                 * @since 1.2
                 */
                Arc2D.prototype.containsAngle = function (angle) {
                    var angExt = this.getAngleExtent();
                    var backwards = (angExt < 0.0);
                    if (backwards) {
                        angExt = -angExt;
                    }
                    if (angExt >= 360.0) {
                        return true;
                    }
                    angle = Arc2D.normalizeDegrees(angle) - Arc2D.normalizeDegrees(this.getAngleStart());
                    if (backwards) {
                        angle = -angle;
                    }
                    if (angle < 0.0) {
                        angle += 360.0;
                    }
                    return (angle >= 0.0) && (angle < angExt);
                };
                /**
                 * Determines whether or not the specified point is inside the boundary
                 * of the arc.
                 *
                 * @param x The X coordinate of the point to test.
                 * @param y The Y coordinate of the point to test.
                 *
                 * @return <CODE>true</CODE> if the point lies within the bound of
                 * the arc, <CODE>false</CODE> if the point lies outside of the
                 * arc's bounds.
                 * @since 1.2
                 */
                Arc2D.prototype.contains$double$double = function (x, y) {
                    var ellw = this.getWidth();
                    if (ellw <= 0.0) {
                        return false;
                    }
                    var normx = (x - this.getX()) / ellw - 0.5;
                    var ellh = this.getHeight();
                    if (ellh <= 0.0) {
                        return false;
                    }
                    var normy = (y - this.getY()) / ellh - 0.5;
                    var distSq = (normx * normx + normy * normy);
                    if (distSq >= 0.25) {
                        return false;
                    }
                    var angExt = Math.abs(this.getAngleExtent());
                    if (angExt >= 360.0) {
                        return true;
                    }
                    var inarc = this.containsAngle(-(function (x) { return x * 180 / Math.PI; })(Math.atan2(normy, normx)));
                    if (this.type === Arc2D.PIE) {
                        return inarc;
                    }
                    if (inarc) {
                        if (angExt >= 180.0) {
                            return true;
                        }
                    }
                    else {
                        if (angExt <= 180.0) {
                            return false;
                        }
                    }
                    var angle = (function (x) { return x * Math.PI / 180; })(-this.getAngleStart());
                    var x1 = Math.cos(angle);
                    var y1 = Math.sin(angle);
                    angle += (function (x) { return x * Math.PI / 180; })(-this.getAngleExtent());
                    var x2 = Math.cos(angle);
                    var y2 = Math.sin(angle);
                    var inside = (java.awt.geom.Line2D.relativeCCW(x1, y1, x2, y2, 2 * normx, 2 * normy) * java.awt.geom.Line2D.relativeCCW(x1, y1, x2, y2, 0, 0) >= 0);
                    return inarc ? !inside : inside;
                };
                /**
                 * Determines whether or not the interior of the arc intersects
                 * the interior of the specified rectangle.
                 *
                 * @param x The X coordinate of the rectangle's upper-left corner.
                 * @param y The Y coordinate of the rectangle's upper-left corner.
                 * @param w The width of the rectangle.
                 * @param h The height of the rectangle.
                 *
                 * @return <CODE>true</CODE> if the arc intersects the rectangle,
                 * <CODE>false</CODE> if the arc doesn't intersect the rectangle.
                 * @since 1.2
                 */
                Arc2D.prototype.intersects = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            var aw = _this.getWidth();
                            var ah = _this.getHeight();
                            if (w <= 0 || h <= 0 || aw <= 0 || ah <= 0) {
                                return false;
                            }
                            var ext = _this.getAngleExtent();
                            if (ext === 0) {
                                return false;
                            }
                            var ax = _this.getX();
                            var ay = _this.getY();
                            var axw = ax + aw;
                            var ayh = ay + ah;
                            var xw = x + w;
                            var yh = y + h;
                            if (x >= axw || y >= ayh || xw <= ax || yh <= ay) {
                                return false;
                            }
                            var axc = _this.getCenterX();
                            var ayc = _this.getCenterY();
                            var sp = _this.getStartPoint();
                            var ep = _this.getEndPoint();
                            var sx = sp.getX();
                            var sy = sp.getY();
                            var ex = ep.getX();
                            var ey = ep.getY();
                            if (ayc >= y && ayc <= yh) {
                                if ((sx < xw && ex < xw && axc < xw && axw > x && _this.containsAngle(0)) || (sx > x && ex > x && axc > x && ax < xw && _this.containsAngle(180))) {
                                    return true;
                                }
                            }
                            if (axc >= x && axc <= xw) {
                                if ((sy > y && ey > y && ayc > y && ay < yh && _this.containsAngle(90)) || (sy < yh && ey < yh && ayc < yh && ayh > y && _this.containsAngle(270))) {
                                    return true;
                                }
                            }
                            var rect = new java.awt.geom.Rectangle2D.Double(x, y, w, h);
                            if (_this.type === Arc2D.PIE || Math.abs(ext) > 180) {
                                if (rect.intersectsLine(axc, ayc, sx, sy) || rect.intersectsLine(axc, ayc, ex, ey)) {
                                    return true;
                                }
                            }
                            else {
                                if (rect.intersectsLine(sx, sy, ex, ey)) {
                                    return true;
                                }
                            }
                            if (_this.contains(x, y) || _this.contains(x + w, y) || _this.contains(x, y + h) || _this.contains(x + w, y + h)) {
                                return true;
                            }
                            return false;
                        })();
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Determines whether or not the interior of the arc entirely contains
                 * the specified rectangle.
                 *
                 * @param x The X coordinate of the rectangle's upper-left corner.
                 * @param y The Y coordinate of the rectangle's upper-left corner.
                 * @param w The width of the rectangle.
                 * @param h The height of the rectangle.
                 *
                 * @return <CODE>true</CODE> if the arc contains the rectangle,
                 * <CODE>false</CODE> if the arc doesn't contain the rectangle.
                 * @since 1.2
                 */
                Arc2D.prototype.contains$double$double$double$double = function (x, y, w, h) {
                    return this.contains(x, y, w, h, null);
                };
                /**
                 * Determines whether or not the interior of the arc entirely contains
                 * the specified rectangle.
                 *
                 * @param r The <CODE>Rectangle2D</CODE> to test.
                 *
                 * @return <CODE>true</CODE> if the arc contains the rectangle,
                 * <CODE>false</CODE> if the arc doesn't contain the rectangle.
                 * @since 1.2
                 */
                Arc2D.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
                    return this.contains(r.getX(), r.getY(), r.getWidth(), r.getHeight(), r);
                };
                Arc2D.prototype.contains = function (x, y, w, h, origrect) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((origrect != null && origrect instanceof java.awt.geom.Rectangle2D) || origrect === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (!(_this.contains(x, y) && _this.contains(x + w, y) && _this.contains(x, y + h) && _this.contains(x + w, y + h))) {
                                return false;
                            }
                            if (_this.type !== Arc2D.PIE || Math.abs(_this.getAngleExtent()) <= 180.0) {
                                return true;
                            }
                            if (origrect == null) {
                                origrect = new java.awt.geom.Rectangle2D.Double(x, y, w, h);
                            }
                            var halfW = _this.getWidth() / 2.0;
                            var halfH = _this.getHeight() / 2.0;
                            var xc = _this.getX() + halfW;
                            var yc = _this.getY() + halfH;
                            var angle = (function (x) { return x * Math.PI / 180; })(-_this.getAngleStart());
                            var xe = xc + halfW * Math.cos(angle);
                            var ye = yc + halfH * Math.sin(angle);
                            if (origrect.intersectsLine(xc, yc, xe, ye)) {
                                return false;
                            }
                            angle += (function (x) { return x * Math.PI / 180; })(-_this.getAngleExtent());
                            xe = xc + halfW * Math.cos(angle);
                            ye = yc + halfH * Math.sin(angle);
                            return !origrect.intersectsLine(xc, yc, xe, ye);
                        })();
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && origrect === undefined) {
                        return this.contains$double$double$double$double(x, y, w, h);
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns an iteration object that defines the boundary of the
                 * arc.
                 * This iterator is multithread safe.
                 * <code>Arc2D</code> guarantees that
                 * modifications to the geometry of the arc
                 * do not affect any iterations of that geometry that
                 * are already in process.
                 *
                 * @param at an optional <CODE>AffineTransform</CODE> to be applied
                 * to the coordinates as they are returned in the iteration, or null
                 * if the untransformed coordinates are desired.
                 *
                 * @return A <CODE>PathIterator</CODE> that defines the arc's boundary.
                 * @since 1.2
                 */
                Arc2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                    return new java.awt.geom.ArcIterator(this, at);
                };
                /**
                 * Returns the hashcode for this <code>Arc2D</code>.
                 * @return the hashcode for this <code>Arc2D</code>.
                 * @since 1.6
                 */
                Arc2D.prototype.hashCode = function () {
                    var bits = javaemul.internal.DoubleHelper.doubleToLongBits(this.getX());
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getY()) * 37;
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getWidth()) * 43;
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getHeight()) * 47;
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getAngleStart()) * 53;
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getAngleExtent()) * 59;
                    bits += this.getArcType() * 61;
                    return (((bits | 0)) ^ (((bits >> 32) | 0)));
                };
                /**
                 * Determines whether or not the specified <code>Object</code> is
                 * equal to this <code>Arc2D</code>.  The specified
                 * <code>Object</code> is equal to this <code>Arc2D</code>
                 * if it is an instance of <code>Arc2D</code> and if its
                 * location, size, arc extents and type are the same as this
                 * <code>Arc2D</code>.
                 * @param obj  an <code>Object</code> to be compared with this
                 * <code>Arc2D</code>.
                 * @return  <code>true</code> if <code>obj</code> is an instance
                 * of <code>Arc2D</code> and has the same values;
                 * <code>false</code> otherwise.
                 * @since 1.6
                 */
                Arc2D.prototype.equals = function (obj) {
                    if (obj === this) {
                        return true;
                    }
                    if (obj != null && obj instanceof java.awt.geom.Arc2D) {
                        var a2d = obj;
                        return ((this.getX() === a2d.getX()) && (this.getY() === a2d.getY()) && (this.getWidth() === a2d.getWidth()) && (this.getHeight() === a2d.getHeight()) && (this.getAngleStart() === a2d.getAngleStart()) && (this.getAngleExtent() === a2d.getAngleExtent()) && (this.getArcType() === a2d.getArcType()));
                    }
                    return false;
                };
                /**
                 * The closure type for an open arc with no path segments
                 * connecting the two ends of the arc segment.
                 * @since 1.2
                 */
                Arc2D.OPEN = 0;
                /**
                 * The closure type for an arc closed by drawing a straight
                 * line segment from the start of the arc segment to the end of the
                 * arc segment.
                 * @since 1.2
                 */
                Arc2D.CHORD = 1;
                /**
                 * The closure type for an arc closed by drawing straight line
                 * segments from the start of the arc segment to the center
                 * of the full ellipse and from that point to the end of the arc segment.
                 * @since 1.2
                 */
                Arc2D.PIE = 2;
                return Arc2D;
            }(java.awt.geom.RectangularShape));
            geom.Arc2D = Arc2D;
            Arc2D["__class"] = "java.awt.geom.Arc2D";
            Arc2D["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
            var Arc2D;
            (function (Arc2D) {
                /**
                 * This class defines an arc specified in {@code float} precision.
                 * @since 1.2
                 */
                var Float = (function (_super) {
                    __extends(Float, _super);
                    /**
                     * Constructs a new arc, initialized to the specified location,
                     * size, angular extents, and closure type.
                     *
                     * @param x The X coordinate of the upper-left corner of
                     * the arc's framing rectangle.
                     * @param y The Y coordinate of the upper-left corner of
                     * the arc's framing rectangle.
                     * @param w The overall width of the full ellipse of which
                     * this arc is a partial section.
                     * @param h The overall height of the full ellipse of which this
                     * arc is a partial section.
                     * @param start The starting angle of the arc in degrees.
                     * @param extent The angular extent of the arc in degrees.
                     * @param type The closure type for the arc:
                     * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
                     * @since 1.2
                     */
                    function Float(x, y, w, h, start, extent, type) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof start === 'number') || start === null) && ((typeof extent === 'number') || extent === null) && ((typeof type === 'number') || type === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this, type);
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            this.start = 0;
                            this.extent = 0;
                            (function () {
                                _this.x = x;
                                _this.y = y;
                                _this.width = w;
                                _this.height = h;
                                _this.start = start;
                                _this.extent = extent;
                            })();
                        }
                        else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && start === undefined && extent === undefined && type === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            var ellipseBounds_1 = __args[0];
                            var start_1 = __args[1];
                            var extent_1 = __args[2];
                            var type_2 = __args[3];
                            _super.call(this, type_2);
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            this.start = 0;
                            this.extent = 0;
                            (function () {
                                _this.x = ellipseBounds_1.getX();
                                _this.y = ellipseBounds_1.getY();
                                _this.width = ellipseBounds_1.getWidth();
                                _this.height = ellipseBounds_1.getHeight();
                                _this.start = start_1;
                                _this.extent = extent_1;
                            })();
                        }
                        else if (((typeof x === 'number') || x === null) && y === undefined && w === undefined && h === undefined && start === undefined && extent === undefined && type === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            var type_3 = __args[0];
                            _super.call(this, type_3);
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            this.start = 0;
                            this.extent = 0;
                        }
                        else if (x === undefined && y === undefined && w === undefined && h === undefined && start === undefined && extent === undefined && type === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this, java.awt.geom.Arc2D.OPEN);
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            this.start = 0;
                            this.extent = 0;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     * Note that the arc
                     * <a href="Arc2D.html#inscribes">partially inscribes</a>
                     * the framing rectangle of this {@code RectangularShape}.
                     *
                     * @since 1.2
                     */
                    Float.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     * Note that the arc
                     * <a href="Arc2D.html#inscribes">partially inscribes</a>
                     * the framing rectangle of this {@code RectangularShape}.
                     *
                     * @since 1.2
                     */
                    Float.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     * Note that the arc
                     * <a href="Arc2D.html#inscribes">partially inscribes</a>
                     * the framing rectangle of this {@code RectangularShape}.
                     *
                     * @since 1.2
                     */
                    Float.prototype.getWidth = function () {
                        return this.width;
                    };
                    /**
                     * {@inheritDoc}
                     * Note that the arc
                     * <a href="Arc2D.html#inscribes">partially inscribes</a>
                     * the framing rectangle of this {@code RectangularShape}.
                     *
                     * @since 1.2
                     */
                    Float.prototype.getHeight = function () {
                        return this.height;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Float.prototype.getAngleStart = function () {
                        return this.start;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Float.prototype.getAngleExtent = function () {
                        return this.extent;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Float.prototype.isEmpty = function () {
                        return (this.width <= 0.0 || this.height <= 0.0);
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Float.prototype.setArc = function (x, y, w, h, angSt, angExt, closure) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof angSt === 'number') || angSt === null) && ((typeof angExt === 'number') || angExt === null) && ((typeof closure === 'number') || closure === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            return (function () {
                                _this.setArcType(closure);
                                _this.x = x;
                                _this.y = y;
                                _this.width = w;
                                _this.height = h;
                                _this.start = angSt;
                                _this.extent = angExt;
                            })();
                        }
                        else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof angSt === 'number') || angSt === null) && angExt === undefined && closure === undefined) {
                            return this.setArc$java_awt_geom_Point2D$java_awt_geom_Dimension2D$double$double$int(x, y, w, h, angSt);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && angSt === undefined && angExt === undefined && closure === undefined) {
                            return this.setArc$java_awt_geom_Rectangle2D$double$double$int(x, y, w, h);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Arc2D) || x === null) && y === undefined && w === undefined && h === undefined && angSt === undefined && angExt === undefined && closure === undefined) {
                            return this.setArc$java_awt_geom_Arc2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Float.prototype.setAngleStart$double = function (angSt) {
                        this.start = angSt;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Float.prototype.setAngleExtent = function (angExt) {
                        this.extent = angExt;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Float.prototype.makeBounds = function (x, y, w, h) {
                        return new java.awt.geom.Rectangle2D.Float(x, y, w, h);
                    };
                    Float.serialVersionUID = 9130893014586380278;
                    return Float;
                }(java.awt.geom.Arc2D));
                Arc2D.Float = Float;
                Float["__class"] = "java.awt.geom.Arc2D.Float";
                Float["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
                /**
                 * This class defines an arc specified in {@code double} precision.
                 * @since 1.2
                 */
                var Double = (function (_super) {
                    __extends(Double, _super);
                    /**
                     * Constructs a new arc, initialized to the specified location,
                     * size, angular extents, and closure type.
                     *
                     * @param x The X coordinate of the upper-left corner
                     * of the arc's framing rectangle.
                     * @param y The Y coordinate of the upper-left corner
                     * of the arc's framing rectangle.
                     * @param w The overall width of the full ellipse of which this
                     * arc is a partial section.
                     * @param h The overall height of the full ellipse of which this
                     * arc is a partial section.
                     * @param start The starting angle of the arc in degrees.
                     * @param extent The angular extent of the arc in degrees.
                     * @param type The closure type for the arc:
                     * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
                     * @since 1.2
                     */
                    function Double(x, y, w, h, start, extent, type) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof start === 'number') || start === null) && ((typeof extent === 'number') || extent === null) && ((typeof type === 'number') || type === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this, type);
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            this.start = 0;
                            this.extent = 0;
                            (function () {
                                _this.x = x;
                                _this.y = y;
                                _this.width = w;
                                _this.height = h;
                                _this.start = start;
                                _this.extent = extent;
                            })();
                        }
                        else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && start === undefined && extent === undefined && type === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            var ellipseBounds_2 = __args[0];
                            var start_2 = __args[1];
                            var extent_2 = __args[2];
                            var type_4 = __args[3];
                            _super.call(this, type_4);
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            this.start = 0;
                            this.extent = 0;
                            (function () {
                                _this.x = ellipseBounds_2.getX();
                                _this.y = ellipseBounds_2.getY();
                                _this.width = ellipseBounds_2.getWidth();
                                _this.height = ellipseBounds_2.getHeight();
                                _this.start = start_2;
                                _this.extent = extent_2;
                            })();
                        }
                        else if (((typeof x === 'number') || x === null) && y === undefined && w === undefined && h === undefined && start === undefined && extent === undefined && type === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            var type_5 = __args[0];
                            _super.call(this, type_5);
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            this.start = 0;
                            this.extent = 0;
                        }
                        else if (x === undefined && y === undefined && w === undefined && h === undefined && start === undefined && extent === undefined && type === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this, java.awt.geom.Arc2D.OPEN);
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            this.start = 0;
                            this.extent = 0;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     * Note that the arc
                     * <a href="Arc2D.html#inscribes">partially inscribes</a>
                     * the framing rectangle of this {@code RectangularShape}.
                     *
                     * @since 1.2
                     */
                    Double.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     * Note that the arc
                     * <a href="Arc2D.html#inscribes">partially inscribes</a>
                     * the framing rectangle of this {@code RectangularShape}.
                     *
                     * @since 1.2
                     */
                    Double.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     * Note that the arc
                     * <a href="Arc2D.html#inscribes">partially inscribes</a>
                     * the framing rectangle of this {@code RectangularShape}.
                     *
                     * @since 1.2
                     */
                    Double.prototype.getWidth = function () {
                        return this.width;
                    };
                    /**
                     * {@inheritDoc}
                     * Note that the arc
                     * <a href="Arc2D.html#inscribes">partially inscribes</a>
                     * the framing rectangle of this {@code RectangularShape}.
                     *
                     * @since 1.2
                     */
                    Double.prototype.getHeight = function () {
                        return this.height;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Double.prototype.getAngleStart = function () {
                        return this.start;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Double.prototype.getAngleExtent = function () {
                        return this.extent;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Double.prototype.isEmpty = function () {
                        return (this.width <= 0.0 || this.height <= 0.0);
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Double.prototype.setArc = function (x, y, w, h, angSt, angExt, closure) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof angSt === 'number') || angSt === null) && ((typeof angExt === 'number') || angExt === null) && ((typeof closure === 'number') || closure === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            return (function () {
                                _this.setArcType(closure);
                                _this.x = x;
                                _this.y = y;
                                _this.width = w;
                                _this.height = h;
                                _this.start = angSt;
                                _this.extent = angExt;
                            })();
                        }
                        else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof angSt === 'number') || angSt === null) && angExt === undefined && closure === undefined) {
                            return this.setArc$java_awt_geom_Point2D$java_awt_geom_Dimension2D$double$double$int(x, y, w, h, angSt);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && angSt === undefined && angExt === undefined && closure === undefined) {
                            return this.setArc$java_awt_geom_Rectangle2D$double$double$int(x, y, w, h);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Arc2D) || x === null) && y === undefined && w === undefined && h === undefined && angSt === undefined && angExt === undefined && closure === undefined) {
                            return this.setArc$java_awt_geom_Arc2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Double.prototype.setAngleStart$double = function (angSt) {
                        this.start = angSt;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Double.prototype.setAngleExtent = function (angExt) {
                        this.extent = angExt;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     */
                    Double.prototype.makeBounds = function (x, y, w, h) {
                        return new java.awt.geom.Rectangle2D.Double(x, y, w, h);
                    };
                    Double.serialVersionUID = 728264085846882001;
                    return Double;
                }(java.awt.geom.Arc2D));
                Arc2D.Double = Double;
                Double["__class"] = "java.awt.geom.Arc2D.Double";
                Double["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
            })(Arc2D = geom.Arc2D || (geom.Arc2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>Ellipse2D</code> class describes an ellipse that is defined by a
             * framing rectangle.
             * <p>
             * This class is only the abstract superclass for all objects which store a 2D
             * ellipse. The actual storage representation of the coordinates is left to the
             * subclass.
             *
             * @author Jim Graham
             * @since 1.2
             */
            var Ellipse2D = (function (_super) {
                __extends(Ellipse2D, _super);
                /**
                 * This is an abstract class that cannot be instantiated directly.
                 * Type-specific implementation subclasses are available for instantiation
                 * and provide a number of formats for storing the information necessary to
                 * satisfy the various accessor methods below.
                 *
                 * @see java.awt.geom.Ellipse2D.Float
                 * @see java.awt.geom.Ellipse2D.Double
                 * @since 1.2
                 */
                function Ellipse2D() {
                    _super.call(this);
                }
                Ellipse2D.prototype.contains = function (x, y, w, h, origrect) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && origrect === undefined) {
                        return this.contains$double$double$double$double(x, y, w, h);
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Ellipse2D.prototype.contains$double$double = function (x, y) {
                    var ellw = this.getWidth();
                    if (ellw <= 0.0) {
                        return false;
                    }
                    var normx = (x - this.getX()) / ellw - 0.5;
                    var ellh = this.getHeight();
                    if (ellh <= 0.0) {
                        return false;
                    }
                    var normy = (y - this.getY()) / ellh - 0.5;
                    return (normx * normx + normy * normy) < 0.25;
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Ellipse2D.prototype.intersects = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (w <= 0.0 || h <= 0.0) {
                                return false;
                            }
                            var ellw = _this.getWidth();
                            if (ellw <= 0.0) {
                                return false;
                            }
                            var normx0 = (x - _this.getX()) / ellw - 0.5;
                            var normx1 = normx0 + w / ellw;
                            var ellh = _this.getHeight();
                            if (ellh <= 0.0) {
                                return false;
                            }
                            var normy0 = (y - _this.getY()) / ellh - 0.5;
                            var normy1 = normy0 + h / ellh;
                            var nearx;
                            var neary;
                            if (normx0 > 0.0) {
                                nearx = normx0;
                            }
                            else if (normx1 < 0.0) {
                                nearx = normx1;
                            }
                            else {
                                nearx = 0.0;
                            }
                            if (normy0 > 0.0) {
                                neary = normy0;
                            }
                            else if (normy1 < 0.0) {
                                neary = normy1;
                            }
                            else {
                                neary = 0.0;
                            }
                            return (nearx * nearx + neary * neary) < 0.25;
                        })();
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Ellipse2D.prototype.contains$double$double$double$double = function (x, y, w, h) {
                    return (this.contains(x, y) && this.contains(x + w, y) && this.contains(x, y + h) && this.contains(x + w, y + h));
                };
                /**
                 * Returns an iteration object that defines the boundary of this
                 * <code>Ellipse2D</code>. The iterator for this class is multi-threaded
                 * safe, which means that this <code>Ellipse2D</code> class guarantees that
                 * modifications to the geometry of this <code>Ellipse2D</code> object do
                 * not affect any iterations of that geometry that are already in process.
                 *
                 * @param at
                 * an optional <code>AffineTransform</code> to be applied to the
                 * coordinates as they are returned in the iteration, or
                 * <code>null</code> if untransformed coordinates are desired
                 * @return the <code>PathIterator</code> object that returns the geometry of
                 * the outline of this <code>Ellipse2D</code>, one segment at a
                 * time.
                 * @since 1.2
                 */
                Ellipse2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                    return new java.awt.geom.EllipseIterator(this, at);
                };
                /**
                 * Returns the hashcode for this <code>Ellipse2D</code>.
                 *
                 * @return the hashcode for this <code>Ellipse2D</code>.
                 * @since 1.6
                 */
                Ellipse2D.prototype.hashCode = function () {
                    var bits = javaemul.internal.DoubleHelper.doubleToLongBits(this.getX());
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getY()) * 37;
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getWidth()) * 43;
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getHeight()) * 47;
                    return (((bits | 0)) ^ (((bits >> 32) | 0)));
                };
                /**
                 * Determines whether or not the specified <code>Object</code> is equal to
                 * this <code>Ellipse2D</code>. The specified <code>Object</code> is equal
                 * to this <code>Ellipse2D</code> if it is an instance of
                 * <code>Ellipse2D</code> and if its location and size are the same as this
                 * <code>Ellipse2D</code>.
                 *
                 * @param obj
                 * an <code>Object</code> to be compared with this
                 * <code>Ellipse2D</code>.
                 * @return <code>true</code> if <code>obj</code> is an instance of
                 * <code>Ellipse2D</code> and has the same values;
                 * <code>false</code> otherwise.
                 * @since 1.6
                 */
                Ellipse2D.prototype.equals = function (obj) {
                    if (obj === this) {
                        return true;
                    }
                    if (obj != null && obj instanceof java.awt.geom.Ellipse2D) {
                        var e2d = obj;
                        return ((this.getX() === e2d.getX()) && (this.getY() === e2d.getY()) && (this.getWidth() === e2d.getWidth()) && (this.getHeight() === e2d.getHeight()));
                    }
                    return false;
                };
                return Ellipse2D;
            }(java.awt.geom.RectangularShape));
            geom.Ellipse2D = Ellipse2D;
            Ellipse2D["__class"] = "java.awt.geom.Ellipse2D";
            Ellipse2D["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
            var Ellipse2D;
            (function (Ellipse2D) {
                /**
                 * The <code>Float</code> class defines an ellipse specified in
                 * <code>float</code> precision.
                 *
                 * @since 1.2
                 */
                var Float = (function (_super) {
                    __extends(Float, _super);
                    /**
                     * Constructs and initializes an <code>Ellipse2D</code> from the
                     * specified coordinates.
                     *
                     * @param x
                     * the X coordinate of the upper-left corner of the framing
                     * rectangle
                     * @param y
                     * the Y coordinate of the upper-left corner of the framing
                     * rectangle
                     * @param w
                     * the width of the framing rectangle
                     * @param h
                     * the height of the framing rectangle
                     * @since 1.2
                     */
                    function Float(x, y, w, h) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            (function () {
                                _this.setFrame(x, y, w, h);
                            })();
                        }
                        else if (x === undefined && y === undefined && w === undefined && h === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getWidth = function () {
                        return this.width;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getHeight = function () {
                        return this.height;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.isEmpty = function () {
                        return (this.width <= 0.0 || this.height <= 0.0);
                    };
                    /**
                     * Sets the location and size of the framing rectangle of this
                     * <code>Shape</code> to the specified rectangular values.
                     *
                     * @param x
                     * the X coordinate of the upper-left corner of the specified
                     * rectangular shape
                     * @param y
                     * the Y coordinate of the upper-left corner of the specified
                     * rectangular shape
                     * @param w
                     * the width of the specified rectangular shape
                     * @param h
                     * the height of the specified rectangular shape
                     * @since 1.2
                     */
                    Float.prototype.setFrame = function (x, y, w, h) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            return (function () {
                                _this.x = x;
                                _this.y = y;
                                _this.width = w;
                                _this.height = h;
                            })();
                        }
                        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            return this.setFrame$double$double$double$double(x, y, w, h);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && w === undefined && h === undefined) {
                            return this.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D(x, y);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                            return this.setFrame$java_awt_geom_Rectangle2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.setFrame$double$double$double$double = function (x, y, w, h) {
                        this.x = x;
                        this.y = y;
                        this.width = w;
                        this.height = h;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getBounds2D = function () {
                        return new java.awt.geom.Rectangle2D.Float(this.x, this.y, this.width, this.height);
                    };
                    Float.serialVersionUID = -6633761252372475977;
                    return Float;
                }(java.awt.geom.Ellipse2D));
                Ellipse2D.Float = Float;
                Float["__class"] = "java.awt.geom.Ellipse2D.Float";
                Float["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
                /**
                 * The <code>Double</code> class defines an ellipse specified in
                 * <code>double</code> precision.
                 *
                 * @since 1.2
                 */
                var Double = (function (_super) {
                    __extends(Double, _super);
                    /**
                     * Constructs and initializes an <code>Ellipse2D</code> from the
                     * specified coordinates.
                     *
                     * @param x
                     * the X coordinate of the upper-left corner of the framing
                     * rectangle
                     * @param y
                     * the Y coordinate of the upper-left corner of the framing
                     * rectangle
                     * @param w
                     * the width of the framing rectangle
                     * @param h
                     * the height of the framing rectangle
                     * @since 1.2
                     */
                    function Double(x, y, w, h) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            (function () {
                                _this.setFrame(x, y, w, h);
                            })();
                        }
                        else if (x === undefined && y === undefined && w === undefined && h === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getWidth = function () {
                        return this.width;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getHeight = function () {
                        return this.height;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.isEmpty = function () {
                        return (this.width <= 0.0 || this.height <= 0.0);
                    };
                    /**
                     * Sets the location and size of the framing rectangle of this
                     * <code>Shape</code> to the specified rectangular values.
                     *
                     * @param x
                     * the X coordinate of the upper-left corner of the specified
                     * rectangular shape
                     * @param y
                     * the Y coordinate of the upper-left corner of the specified
                     * rectangular shape
                     * @param w
                     * the width of the specified rectangular shape
                     * @param h
                     * the height of the specified rectangular shape
                     * @since 1.2
                     */
                    Double.prototype.setFrame = function (x, y, w, h) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            return this.setFrame$double$double$double$double(x, y, w, h);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && w === undefined && h === undefined) {
                            return this.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D(x, y);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                            return this.setFrame$java_awt_geom_Rectangle2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.setFrame$double$double$double$double = function (x, y, w, h) {
                        this.x = x;
                        this.y = y;
                        this.width = w;
                        this.height = h;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getBounds2D = function () {
                        return new java.awt.geom.Rectangle2D.Double(this.x, this.y, this.width, this.height);
                    };
                    Double.serialVersionUID = 5555464816372320683;
                    return Double;
                }(java.awt.geom.Ellipse2D));
                Ellipse2D.Double = Double;
                Double["__class"] = "java.awt.geom.Ellipse2D.Double";
                Double["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
            })(Ellipse2D = geom.Ellipse2D || (geom.Ellipse2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>Rectangle2D</code> class describes a rectangle defined by a
             * location {@code (x,y)} and dimension {@code (w x h)}.
             * <p>
             * This class is only the abstract superclass for all objects that store a 2D
             * rectangle. The actual storage representation of the coordinates is left to
             * the subclass.
             *
             * @author Jim Graham
             * @since 1.2
             */
            var Rectangle2D = (function (_super) {
                __extends(Rectangle2D, _super);
                /**
                 * This is an abstract class that cannot be instantiated directly.
                 * Type-specific implementation subclasses are available for instantiation
                 * and provide a number of formats for storing the information necessary to
                 * satisfy the various accessor methods below.
                 *
                 * @see java.awt.geom.Rectangle2D.Float
                 * @see java.awt.geom.Rectangle2D.Double
                 * @see java.awt.Rectangle
                 * @since 1.2
                 */
                function Rectangle2D() {
                    _super.call(this);
                }
                /**
                 * Sets the location and size of this <code>Rectangle2D</code> to the
                 * specified <code>float</code> values.
                 *
                 * @param x
                 * the X coordinate of the upper-left corner of this
                 * <code>Rectangle2D</code>
                 * @param y
                 * the Y coordinate of the upper-left corner of this
                 * <code>Rectangle2D</code>
                 * @param w
                 * the width of this <code>Rectangle2D</code>
                 * @param h
                 * the height of this <code>Rectangle2D</code>
                 * @since 1.2
                 */
                Rectangle2D.prototype.setRect = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.setRect$double$double$double$double(x, y, w, h);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.setRect$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the location and size of this <code>Rectangle2D</code> to the
                 * specified <code>double</code> values.
                 *
                 * @param x
                 * the X coordinate of the upper-left corner of this
                 * <code>Rectangle2D</code>
                 * @param y
                 * the Y coordinate of the upper-left corner of this
                 * <code>Rectangle2D</code>
                 * @param w
                 * the width of this <code>Rectangle2D</code>
                 * @param h
                 * the height of this <code>Rectangle2D</code>
                 * @since 1.2
                 */
                Rectangle2D.prototype.setRect$double$double$double$double = function (x, y, w, h) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets this <code>Rectangle2D</code> to be the same as the specified
                 * <code>Rectangle2D</code>.
                 *
                 * @param r
                 * the specified <code>Rectangle2D</code>
                 * @since 1.2
                 */
                Rectangle2D.prototype.setRect$java_awt_geom_Rectangle2D = function (r) {
                    this.setRect(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                /**
                 * Tests if the specified line segment intersects the interior of this
                 * <code>Rectangle2D</code>.
                 *
                 * @param x1
                 * the X coordinate of the start point of the specified line
                 * segment
                 * @param y1
                 * the Y coordinate of the start point of the specified line
                 * segment
                 * @param x2
                 * the X coordinate of the end point of the specified line
                 * segment
                 * @param y2
                 * the Y coordinate of the end point of the specified line
                 * segment
                 * @return <code>true</code> if the specified line segment intersects the
                 * interior of this <code>Rectangle2D</code>; <code>false</code>
                 * otherwise.
                 * @since 1.2
                 */
                Rectangle2D.prototype.intersectsLine = function (x1, y1, x2, y2) {
                    var _this = this;
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            var out1;
                            var out2;
                            if ((out2 = _this.outcode(x2, y2)) === 0) {
                                return true;
                            }
                            while (((out1 = _this.outcode(x1, y1)) !== 0)) {
                                if ((out1 & out2) !== 0) {
                                    return false;
                                }
                                if ((out1 & (Rectangle2D.OUT_LEFT | Rectangle2D.OUT_RIGHT)) !== 0) {
                                    var x = _this.getX();
                                    if ((out1 & Rectangle2D.OUT_RIGHT) !== 0) {
                                        x += _this.getWidth();
                                    }
                                    y1 = y1 + (x - x1) * (y2 - y1) / (x2 - x1);
                                    x1 = x;
                                }
                                else {
                                    var y = _this.getY();
                                    if ((out1 & Rectangle2D.OUT_BOTTOM) !== 0) {
                                        y += _this.getHeight();
                                    }
                                    x1 = x1 + (y - y1) * (x2 - x1) / (y2 - y1);
                                    y1 = y;
                                }
                            }
                            ;
                            return true;
                        })();
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.Line2D) || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
                        return this.intersectsLine$java_awt_geom_Line2D(x1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Tests if the specified line segment intersects the interior of this
                 * <code>Rectangle2D</code>.
                 *
                 * @param l
                 * the specified {@link Line2D} to test for intersection with the
                 * interior of this <code>Rectangle2D</code>
                 * @return <code>true</code> if the specified <code>Line2D</code> intersects
                 * the interior of this <code>Rectangle2D</code>; <code>false</code>
                 * otherwise.
                 * @since 1.2
                 */
                Rectangle2D.prototype.intersectsLine$java_awt_geom_Line2D = function (l) {
                    return this.intersectsLine(l.getX1(), l.getY1(), l.getX2(), l.getY2());
                };
                /**
                 * Determines where the specified coordinates lie with respect to this
                 * <code>Rectangle2D</code>. This method computes a binary OR of the
                 * appropriate mask values indicating, for each side of this
                 * <code>Rectangle2D</code>, whether or not the specified coordinates are on
                 * the same side of the edge as the rest of this <code>Rectangle2D</code>.
                 *
                 * @param x
                 * the specified X coordinate
                 * @param y
                 * the specified Y coordinate
                 * @return the logical OR of all appropriate out codes.
                 * @see #OUT_LEFT
                 * @see #OUT_TOP
                 * @see #OUT_RIGHT
                 * @see #OUT_BOTTOM
                 * @since 1.2
                 */
                Rectangle2D.prototype.outcode = function (x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return 0;
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined) {
                        return this.outcode$java_awt_geom_Point2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Determines where the specified {@link Point2D} lies with respect to this
                 * <code>Rectangle2D</code>. This method computes a binary OR of the
                 * appropriate mask values indicating, for each side of this
                 * <code>Rectangle2D</code>, whether or not the specified
                 * <code>Point2D</code> is on the same side of the edge as the rest of this
                 * <code>Rectangle2D</code>.
                 *
                 * @param p
                 * the specified <code>Point2D</code>
                 * @return the logical OR of all appropriate out codes.
                 * @see #OUT_LEFT
                 * @see #OUT_TOP
                 * @see #OUT_RIGHT
                 * @see #OUT_BOTTOM
                 * @since 1.2
                 */
                Rectangle2D.prototype.outcode$java_awt_geom_Point2D = function (p) {
                    return this.outcode(p.getX(), p.getY());
                };
                Rectangle2D.prototype.setFrame = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.setFrame$double$double$double$double(x, y, w, h);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && w === undefined && h === undefined) {
                        return this.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.setFrame$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the location and size of the outer bounds of this
                 * <code>Rectangle2D</code> to the specified rectangular values.
                 *
                 * @param x
                 * the X coordinate of the upper-left corner of this
                 * <code>Rectangle2D</code>
                 * @param y
                 * the Y coordinate of the upper-left corner of this
                 * <code>Rectangle2D</code>
                 * @param w
                 * the width of this <code>Rectangle2D</code>
                 * @param h
                 * the height of this <code>Rectangle2D</code>
                 * @since 1.2
                 */
                Rectangle2D.prototype.setFrame$double$double$double$double = function (x, y, w, h) {
                    this.setRect(x, y, w, h);
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Rectangle2D.prototype.getBounds2D = function () {
                    return this.clone();
                };
                Rectangle2D.prototype.contains = function (x, y, w, h, origrect) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && origrect === undefined) {
                        return this.contains$double$double$double$double(x, y, w, h);
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Rectangle2D.prototype.contains$double$double = function (x, y) {
                    var x0 = this.getX();
                    var y0 = this.getY();
                    return (x >= x0 && y >= y0 && x < x0 + this.getWidth() && y < y0 + this.getHeight());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Rectangle2D.prototype.intersects = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (_this.isEmpty() || w <= 0 || h <= 0) {
                                return false;
                            }
                            var x0 = _this.getX();
                            var y0 = _this.getY();
                            return (x + w > x0 && y + h > y0 && x < x0 + _this.getWidth() && y < y0 + _this.getHeight());
                        })();
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                Rectangle2D.prototype.contains$double$double$double$double = function (x, y, w, h) {
                    if (this.isEmpty() || w <= 0 || h <= 0) {
                        return false;
                    }
                    var x0 = this.getX();
                    var y0 = this.getY();
                    return (x >= x0 && y >= y0 && (x + w) <= x0 + this.getWidth() && (y + h) <= y0 + this.getHeight());
                };
                /**
                 * Intersects the pair of specified source <code>Rectangle2D</code> objects
                 * and puts the result into the specified destination
                 * <code>Rectangle2D</code> object. One of the source rectangles can also be
                 * the destination to avoid creating a third Rectangle2D object, but in this
                 * case the original points of this source rectangle will be overwritten by
                 * this method.
                 *
                 * @param src1
                 * the first of a pair of <code>Rectangle2D</code> objects to be
                 * intersected with each other
                 * @param src2
                 * the second of a pair of <code>Rectangle2D</code> objects to be
                 * intersected with each other
                 * @param dest
                 * the <code>Rectangle2D</code> that holds the results of the
                 * intersection of <code>src1</code> and <code>src2</code>
                 * @since 1.2
                 */
                Rectangle2D.intersect = function (src1, src2, dest) {
                    var x1 = Math.max(src1.getMinX(), src2.getMinX());
                    var y1 = Math.max(src1.getMinY(), src2.getMinY());
                    var x2 = Math.min(src1.getMaxX(), src2.getMaxX());
                    var y2 = Math.min(src1.getMaxY(), src2.getMaxY());
                    dest.setFrame(x1, y1, x2 - x1, y2 - y1);
                };
                /**
                 * Unions the pair of source <code>Rectangle2D</code> objects and puts the
                 * result into the specified destination <code>Rectangle2D</code> object.
                 * One of the source rectangles can also be the destination to avoid
                 * creating a third Rectangle2D object, but in this case the original points
                 * of this source rectangle will be overwritten by this method.
                 *
                 * @param src1
                 * the first of a pair of <code>Rectangle2D</code> objects to be
                 * combined with each other
                 * @param src2
                 * the second of a pair of <code>Rectangle2D</code> objects to be
                 * combined with each other
                 * @param dest
                 * the <code>Rectangle2D</code> that holds the results of the
                 * union of <code>src1</code> and <code>src2</code>
                 * @since 1.2
                 */
                Rectangle2D.union = function (src1, src2, dest) {
                    var x1 = Math.min(src1.getMinX(), src2.getMinX());
                    var y1 = Math.min(src1.getMinY(), src2.getMinY());
                    var x2 = Math.max(src1.getMaxX(), src2.getMaxX());
                    var y2 = Math.max(src1.getMaxY(), src2.getMaxY());
                    dest.setFrameFromDiagonal(x1, y1, x2, y2);
                };
                Rectangle2D.prototype.add = function (newx, newy) {
                    if (((typeof newx === 'number') || newx === null) && ((typeof newy === 'number') || newy === null)) {
                        return this.add$double$double(newx, newy);
                    }
                    else if (((newx != null && newx instanceof java.awt.geom.Point2D) || newx === null) && newy === undefined) {
                        return this.add$java_awt_geom_Point2D(newx);
                    }
                    else if (((newx != null && newx instanceof java.awt.geom.Rectangle2D) || newx === null) && newy === undefined) {
                        return this.add$java_awt_geom_Rectangle2D(newx);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Adds a point, specified by the double precision arguments
                 * <code>newx</code> and <code>newy</code>, to this <code>Rectangle2D</code>
                 * . The resulting <code>Rectangle2D</code> is the smallest
                 * <code>Rectangle2D</code> that contains both the original
                 * <code>Rectangle2D</code> and the specified point.
                 * <p>
                 * After adding a point, a call to <code>contains</code> with the added
                 * point as an argument does not necessarily return <code>true</code>. The
                 * <code>contains</code> method does not return <code>true</code> for points
                 * on the right or bottom edges of a rectangle. Therefore, if the added
                 * point falls on the left or bottom edge of the enlarged rectangle,
                 * <code>contains</code> returns <code>false</code> for that point.
                 *
                 * @param newx
                 * the X coordinate of the new point
                 * @param newy
                 * the Y coordinate of the new point
                 * @since 1.2
                 */
                Rectangle2D.prototype.add$double$double = function (newx, newy) {
                    var x1 = Math.min(this.getMinX(), newx);
                    var x2 = Math.max(this.getMaxX(), newx);
                    var y1 = Math.min(this.getMinY(), newy);
                    var y2 = Math.max(this.getMaxY(), newy);
                    this.setRect(x1, y1, x2 - x1, y2 - y1);
                };
                /**
                 * Adds the <code>Point2D</code> object <code>pt</code> to this
                 * <code>Rectangle2D</code>. The resulting <code>Rectangle2D</code> is the
                 * smallest <code>Rectangle2D</code> that contains both the original
                 * <code>Rectangle2D</code> and the specified <code>Point2D</code>.
                 * <p>
                 * After adding a point, a call to <code>contains</code> with the added
                 * point as an argument does not necessarily return <code>true</code>. The
                 * <code>contains</code> method does not return <code>true</code> for points
                 * on the right or bottom edges of a rectangle. Therefore, if the added
                 * point falls on the left or bottom edge of the enlarged rectangle,
                 * <code>contains</code> returns <code>false</code> for that point.
                 *
                 * @param pt
                 * the new <code>Point2D</code> to add to this
                 * <code>Rectangle2D</code>.
                 * @since 1.2
                 */
                Rectangle2D.prototype.add$java_awt_geom_Point2D = function (pt) {
                    this.add(pt.getX(), pt.getY());
                };
                /**
                 * Adds a <code>Rectangle2D</code> object to this <code>Rectangle2D</code>.
                 * The resulting <code>Rectangle2D</code> is the union of the two
                 * <code>Rectangle2D</code> objects.
                 *
                 * @param r
                 * the <code>Rectangle2D</code> to add to this
                 * <code>Rectangle2D</code>.
                 * @since 1.2
                 */
                Rectangle2D.prototype.add$java_awt_geom_Rectangle2D = function (r) {
                    var x1 = Math.min(this.getMinX(), r.getMinX());
                    var x2 = Math.max(this.getMaxX(), r.getMaxX());
                    var y1 = Math.min(this.getMinY(), r.getMinY());
                    var y2 = Math.max(this.getMaxY(), r.getMaxY());
                    this.setRect(x1, y1, x2 - x1, y2 - y1);
                };
                /**
                 * Returns an iteration object that defines the boundary of this
                 * <code>Rectangle2D</code>. The iterator for this class is multi-threaded
                 * safe, which means that this <code>Rectangle2D</code> class guarantees
                 * that modifications to the geometry of this <code>Rectangle2D</code>
                 * object do not affect any iterations of that geometry that are already in
                 * process.
                 *
                 * @param at
                 * an optional <code>AffineTransform</code> to be applied to the
                 * coordinates as they are returned in the iteration, or
                 * <code>null</code> if untransformed coordinates are desired
                 * @return the <code>PathIterator</code> object that returns the geometry of
                 * the outline of this <code>Rectangle2D</code>, one segment at a
                 * time.
                 * @since 1.2
                 */
                Rectangle2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                    return new java.awt.geom.RectIterator(this, at);
                };
                /**
                 * Returns an iteration object that defines the boundary of the flattened
                 * <code>Rectangle2D</code>. Since rectangles are already flat, the
                 * <code>flatness</code> parameter is ignored. The iterator for this class
                 * is multi-threaded safe, which means that this <code>Rectangle2D</code>
                 * class guarantees that modifications to the geometry of this
                 * <code>Rectangle2D</code> object do not affect any iterations of that
                 * geometry that are already in process.
                 *
                 * @param at
                 * an optional <code>AffineTransform</code> to be applied to the
                 * coordinates as they are returned in the iteration, or
                 * <code>null</code> if untransformed coordinates are desired
                 * @param flatness
                 * the maximum distance that the line segments used to
                 * approximate the curved segments are allowed to deviate from
                 * any point on the original curve. Since rectangles are already
                 * flat, the <code>flatness</code> parameter is ignored.
                 * @return the <code>PathIterator</code> object that returns the geometry of
                 * the outline of this <code>Rectangle2D</code>, one segment at a
                 * time.
                 * @since 1.2
                 */
                Rectangle2D.prototype.getPathIterator = function (at, flatness) {
                    var _this = this;
                    if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            return new java.awt.geom.RectIterator(_this, at);
                        })();
                    }
                    else if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && flatness === undefined) {
                        return this.getPathIterator$java_awt_geom_AffineTransform(at);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the hashcode for this <code>Rectangle2D</code>.
                 *
                 * @return the hashcode for this <code>Rectangle2D</code>.
                 * @since 1.2
                 */
                Rectangle2D.prototype.hashCode = function () {
                    var bits = javaemul.internal.DoubleHelper.doubleToLongBits(this.getX());
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getY()) * 37;
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getWidth()) * 43;
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getHeight()) * 47;
                    return (((bits | 0)) ^ (((bits >> 32) | 0)));
                };
                /**
                 * Determines whether or not the specified <code>Object</code> is equal to
                 * this <code>Rectangle2D</code>. The specified <code>Object</code> is equal
                 * to this <code>Rectangle2D</code> if it is an instance of
                 * <code>Rectangle2D</code> and if its location and size are the same as
                 * this <code>Rectangle2D</code>.
                 *
                 * @param obj
                 * an <code>Object</code> to be compared with this
                 * <code>Rectangle2D</code>.
                 * @return <code>true</code> if <code>obj</code> is an instance of
                 * <code>Rectangle2D</code> and has the same values;
                 * <code>false</code> otherwise.
                 * @since 1.2
                 */
                Rectangle2D.prototype.equals = function (obj) {
                    if (obj === this) {
                        return true;
                    }
                    if (obj != null && obj instanceof java.awt.geom.Rectangle2D) {
                        var r2d = obj;
                        return ((this.getX() === r2d.getX()) && (this.getY() === r2d.getY()) && (this.getWidth() === r2d.getWidth()) && (this.getHeight() === r2d.getHeight()));
                    }
                    return false;
                };
                /**
                 * The bitmask that indicates that a point lies to the left of this
                 * <code>Rectangle2D</code>.
                 *
                 * @since 1.2
                 */
                Rectangle2D.OUT_LEFT = 1;
                /**
                 * The bitmask that indicates that a point lies above this
                 * <code>Rectangle2D</code>.
                 *
                 * @since 1.2
                 */
                Rectangle2D.OUT_TOP = 2;
                /**
                 * The bitmask that indicates that a point lies to the right of this
                 * <code>Rectangle2D</code>.
                 *
                 * @since 1.2
                 */
                Rectangle2D.OUT_RIGHT = 4;
                /**
                 * The bitmask that indicates that a point lies below this
                 * <code>Rectangle2D</code>.
                 *
                 * @since 1.2
                 */
                Rectangle2D.OUT_BOTTOM = 8;
                return Rectangle2D;
            }(java.awt.geom.RectangularShape));
            geom.Rectangle2D = Rectangle2D;
            Rectangle2D["__class"] = "java.awt.geom.Rectangle2D";
            Rectangle2D["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
            var Rectangle2D;
            (function (Rectangle2D) {
                /**
                 * The <code>Float</code> class defines a rectangle specified in float
                 * coordinates.
                 *
                 * @since 1.2
                 */
                var Float = (function (_super) {
                    __extends(Float, _super);
                    /**
                     * Constructs and initializes a <code>Rectangle2D</code> from the
                     * specified <code>float</code> coordinates.
                     *
                     * @param x
                     * the X coordinate of the upper-left corner of the newly
                     * constructed <code>Rectangle2D</code>
                     * @param y
                     * the Y coordinate of the upper-left corner of the newly
                     * constructed <code>Rectangle2D</code>
                     * @param w
                     * the width of the newly constructed
                     * <code>Rectangle2D</code>
                     * @param h
                     * the height of the newly constructed
                     * <code>Rectangle2D</code>
                     * @since 1.2
                     */
                    function Float(x, y, w, h) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            (function () {
                                _this.setRect(x, y, w, h);
                            })();
                        }
                        else if (x === undefined && y === undefined && w === undefined && h === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getWidth = function () {
                        return this.width;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getHeight = function () {
                        return this.height;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.isEmpty = function () {
                        return (this.width <= 0.0) || (this.height <= 0.0);
                    };
                    /**
                     * Sets the location and size of this <code>Rectangle2D</code> to the
                     * specified <code>float</code> values.
                     *
                     * @param x
                     * the X coordinate of the upper-left corner of this
                     * <code>Rectangle2D</code>
                     * @param y
                     * the Y coordinate of the upper-left corner of this
                     * <code>Rectangle2D</code>
                     * @param w
                     * the width of this <code>Rectangle2D</code>
                     * @param h
                     * the height of this <code>Rectangle2D</code>
                     * @since 1.2
                     */
                    Float.prototype.setRect = function (x, y, w, h) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            return (function () {
                                _this.x = x;
                                _this.y = y;
                                _this.width = w;
                                _this.height = h;
                            })();
                        }
                        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            return this.setRect$double$double$double$double(x, y, w, h);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                            return this.setRect$java_awt_geom_Rectangle2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.setRect$double$double$double$double = function (x, y, w, h) {
                        this.x = x;
                        this.y = y;
                        this.width = w;
                        this.height = h;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.setRect$java_awt_geom_Rectangle2D = function (r) {
                        this.x = r.getX();
                        this.y = r.getY();
                        this.width = r.getWidth();
                        this.height = r.getHeight();
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.outcode = function (x, y) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            return (function () {
                                var out = 0;
                                if (_this.width <= 0) {
                                    out |= java.awt.geom.Rectangle2D.OUT_LEFT | java.awt.geom.Rectangle2D.OUT_RIGHT;
                                }
                                else if (x < _this.x) {
                                    out |= java.awt.geom.Rectangle2D.OUT_LEFT;
                                }
                                else if (x > _this.x + _this.width) {
                                    out |= java.awt.geom.Rectangle2D.OUT_RIGHT;
                                }
                                if (_this.height <= 0) {
                                    out |= java.awt.geom.Rectangle2D.OUT_TOP | java.awt.geom.Rectangle2D.OUT_BOTTOM;
                                }
                                else if (y < _this.y) {
                                    out |= java.awt.geom.Rectangle2D.OUT_TOP;
                                }
                                else if (y > _this.y + _this.height) {
                                    out |= java.awt.geom.Rectangle2D.OUT_BOTTOM;
                                }
                                return out;
                            })();
                        }
                        else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined) {
                            return this.outcode$java_awt_geom_Point2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getBounds2D = function () {
                        return new Rectangle2D.Float(this.x, this.y, this.width, this.height);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.createIntersection = function (r) {
                        var dest;
                        if (r != null && r instanceof java.awt.geom.Rectangle2D.Float) {
                            dest = new java.awt.geom.Rectangle2D.Float();
                        }
                        else {
                            dest = new java.awt.geom.Rectangle2D.Double();
                        }
                        java.awt.geom.Rectangle2D.intersect(this, r, dest);
                        return dest;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.createUnion = function (r) {
                        var dest;
                        if (r != null && r instanceof java.awt.geom.Rectangle2D.Float) {
                            dest = new java.awt.geom.Rectangle2D.Float();
                        }
                        else {
                            dest = new java.awt.geom.Rectangle2D.Double();
                        }
                        java.awt.geom.Rectangle2D.union(this, r, dest);
                        return dest;
                    };
                    /**
                     * Returns the <code>String</code> representation of this
                     * <code>Rectangle2D</code>.
                     *
                     * @return a <code>String</code> representing this
                     * <code>Rectangle2D</code>.
                     * @since 1.2
                     */
                    Float.prototype.toString = function () {
                        return (function (c) { return c["__class"] ? c["__class"] : c.name; })(Rectangle2D.Float) + "[x=" + this.x + ",y=" + this.y + ",w=" + this.width + ",h=" + this.height + "]";
                    };
                    Float.serialVersionUID = 3798716824173675777;
                    return Float;
                }(java.awt.geom.Rectangle2D));
                Rectangle2D.Float = Float;
                Float["__class"] = "java.awt.geom.Rectangle2D.Float";
                Float["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
                /**
                 * The <code>Double</code> class defines a rectangle specified in double
                 * coordinates.
                 *
                 * @since 1.2
                 */
                var Double = (function (_super) {
                    __extends(Double, _super);
                    /**
                     * Constructs and initializes a <code>Rectangle2D</code> from the
                     * specified <code>double</code> coordinates.
                     *
                     * @param x
                     * the X coordinate of the upper-left corner of the newly
                     * constructed <code>Rectangle2D</code>
                     * @param y
                     * the Y coordinate of the upper-left corner of the newly
                     * constructed <code>Rectangle2D</code>
                     * @param w
                     * the width of the newly constructed
                     * <code>Rectangle2D</code>
                     * @param h
                     * the height of the newly constructed
                     * <code>Rectangle2D</code>
                     * @since 1.2
                     */
                    function Double(x, y, w, h) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            (function () {
                                _this.setRect(x, y, w, h);
                            })();
                        }
                        else if (x === undefined && y === undefined && w === undefined && h === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getWidth = function () {
                        return this.width;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getHeight = function () {
                        return this.height;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.isEmpty = function () {
                        return (this.width <= 0.0) || (this.height <= 0.0);
                    };
                    /**
                     * Sets the location and size of this <code>Rectangle2D</code> to the
                     * specified <code>float</code> values.
                     *
                     * @param x
                     * the X coordinate of the upper-left corner of this
                     * <code>Rectangle2D</code>
                     * @param y
                     * the Y coordinate of the upper-left corner of this
                     * <code>Rectangle2D</code>
                     * @param w
                     * the width of this <code>Rectangle2D</code>
                     * @param h
                     * the height of this <code>Rectangle2D</code>
                     * @since 1.2
                     */
                    Double.prototype.setRect = function (x, y, w, h) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            return this.setRect$double$double$double$double(x, y, w, h);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                            return this.setRect$java_awt_geom_Rectangle2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.setRect$double$double$double$double = function (x, y, w, h) {
                        this.x = x;
                        this.y = y;
                        this.width = w;
                        this.height = h;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.setRect$java_awt_geom_Rectangle2D = function (r) {
                        this.x = r.getX();
                        this.y = r.getY();
                        this.width = r.getWidth();
                        this.height = r.getHeight();
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.outcode = function (x, y) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            return (function () {
                                var out = 0;
                                if (_this.width <= 0) {
                                    out |= java.awt.geom.Rectangle2D.OUT_LEFT | java.awt.geom.Rectangle2D.OUT_RIGHT;
                                }
                                else if (x < _this.x) {
                                    out |= java.awt.geom.Rectangle2D.OUT_LEFT;
                                }
                                else if (x > _this.x + _this.width) {
                                    out |= java.awt.geom.Rectangle2D.OUT_RIGHT;
                                }
                                if (_this.height <= 0) {
                                    out |= java.awt.geom.Rectangle2D.OUT_TOP | java.awt.geom.Rectangle2D.OUT_BOTTOM;
                                }
                                else if (y < _this.y) {
                                    out |= java.awt.geom.Rectangle2D.OUT_TOP;
                                }
                                else if (y > _this.y + _this.height) {
                                    out |= java.awt.geom.Rectangle2D.OUT_BOTTOM;
                                }
                                return out;
                            })();
                        }
                        else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined) {
                            return this.outcode$java_awt_geom_Point2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getBounds2D = function () {
                        return new Rectangle2D.Double(this.x, this.y, this.width, this.height);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.createIntersection = function (r) {
                        var dest = new java.awt.geom.Rectangle2D.Double();
                        java.awt.geom.Rectangle2D.intersect(this, r, dest);
                        return dest;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.createUnion = function (r) {
                        var dest = new java.awt.geom.Rectangle2D.Double();
                        java.awt.geom.Rectangle2D.union(this, r, dest);
                        return dest;
                    };
                    /**
                     * Returns the <code>String</code> representation of this
                     * <code>Rectangle2D</code>.
                     *
                     * @return a <code>String</code> representing this
                     * <code>Rectangle2D</code>.
                     * @since 1.2
                     */
                    Double.prototype.toString = function () {
                        return (function (c) { return c["__class"] ? c["__class"] : c.name; })(Rectangle2D.Double) + "[x=" + this.x + ",y=" + this.y + ",w=" + this.width + ",h=" + this.height + "]";
                    };
                    Double.serialVersionUID = 7771313791441850493;
                    return Double;
                }(java.awt.geom.Rectangle2D));
                Rectangle2D.Double = Double;
                Double["__class"] = "java.awt.geom.Rectangle2D.Double";
                Double["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
            })(Rectangle2D = geom.Rectangle2D || (geom.Rectangle2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>RoundRectangle2D</code> class defines a rectangle with rounded
             * corners defined by a location {@code (x,y)}, a dimension {@code (w x h)}, and
             * the width and height of an arc with which to round the corners.
             * <p>
             * This class is the abstract superclass for all objects that store a 2D rounded
             * rectangle. The actual storage representation of the coordinates is left to
             * the subclass.
             *
             * @author Jim Graham
             * @since 1.2
             */
            var RoundRectangle2D = (function (_super) {
                __extends(RoundRectangle2D, _super);
                /**
                 * This is an abstract class that cannot be instantiated directly.
                 * Type-specific implementation subclasses are available for instantiation
                 * and provide a number of formats for storing the information necessary to
                 * satisfy the various accessor methods below.
                 *
                 * @see java.awt.geom.RoundRectangle2D.Float
                 * @see java.awt.geom.RoundRectangle2D.Double
                 * @since 1.2
                 */
                function RoundRectangle2D() {
                    _super.call(this);
                }
                /**
                 * Sets the location, size, and corner radii of this
                 * <code>RoundRectangle2D</code> to the specified <code>float</code>
                 * values.
                 *
                 * @param x
                 * the X coordinate to which to set the location of this
                 * <code>RoundRectangle2D</code>
                 * @param y
                 * the Y coordinate to which to set the location of this
                 * <code>RoundRectangle2D</code>
                 * @param w
                 * the width to which to set this
                 * <code>RoundRectangle2D</code>
                 * @param h
                 * the height to which to set this
                 * <code>RoundRectangle2D</code>
                 * @param arcw
                 * the width to which to set the arc of this
                 * <code>RoundRectangle2D</code>
                 * @param arch
                 * the height to which to set the arc of this
                 * <code>RoundRectangle2D</code>
                 * @since 1.2
                 */
                RoundRectangle2D.prototype.setRoundRect = function (x, y, w, h, arcw, arch) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof arcw === 'number') || arcw === null) && ((typeof arch === 'number') || arch === null)) {
                        return this.setRoundRect$double$double$double$double$double$double(x, y, w, h, arcw, arch);
                    }
                    else if (((x != null && x instanceof java.awt.geom.RoundRectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && arcw === undefined && arch === undefined) {
                        return this.setRoundRect$java_awt_geom_RoundRectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the location, size, and corner radii of this
                 * <code>RoundRectangle2D</code> to the specified <code>double</code>
                 * values.
                 *
                 * @param x
                 * the X coordinate to which to set the location of this
                 * <code>RoundRectangle2D</code>
                 * @param y
                 * the Y coordinate to which to set the location of this
                 * <code>RoundRectangle2D</code>
                 * @param w
                 * the width to which to set this <code>RoundRectangle2D</code>
                 * @param h
                 * the height to which to set this <code>RoundRectangle2D</code>
                 * @param arcWidth
                 * the width to which to set the arc of this
                 * <code>RoundRectangle2D</code>
                 * @param arcHeight
                 * the height to which to set the arc of this
                 * <code>RoundRectangle2D</code>
                 * @since 1.2
                 */
                RoundRectangle2D.prototype.setRoundRect$double$double$double$double$double$double = function (x, y, w, h, arcWidth, arcHeight) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets this <code>RoundRectangle2D</code> to be the same as the specified
                 * <code>RoundRectangle2D</code>.
                 *
                 * @param rr
                 * the specified <code>RoundRectangle2D</code>
                 * @since 1.2
                 */
                RoundRectangle2D.prototype.setRoundRect$java_awt_geom_RoundRectangle2D = function (rr) {
                    this.setRoundRect(rr.getX(), rr.getY(), rr.getWidth(), rr.getHeight(), rr.getArcWidth(), rr.getArcHeight());
                };
                RoundRectangle2D.prototype.setFrame = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.setFrame$double$double$double$double(x, y, w, h);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && w === undefined && h === undefined) {
                        return this.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.setFrame$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                RoundRectangle2D.prototype.setFrame$double$double$double$double = function (x, y, w, h) {
                    this.setRoundRect(x, y, w, h, this.getArcWidth(), this.getArcHeight());
                };
                RoundRectangle2D.prototype.contains = function (x, y, w, h, origrect) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && origrect === undefined) {
                        return this.contains$double$double$double$double(x, y, w, h);
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                RoundRectangle2D.prototype.contains$double$double = function (x, y) {
                    if (this.isEmpty()) {
                        return false;
                    }
                    var rrx0 = this.getX();
                    var rry0 = this.getY();
                    var rrx1 = rrx0 + this.getWidth();
                    var rry1 = rry0 + this.getHeight();
                    if (x < rrx0 || y < rry0 || x >= rrx1 || y >= rry1) {
                        return false;
                    }
                    var aw = Math.min(this.getWidth(), Math.abs(this.getArcWidth())) / 2.0;
                    var ah = Math.min(this.getHeight(), Math.abs(this.getArcHeight())) / 2.0;
                    if (x >= (rrx0 += aw) && x < (rrx0 = rrx1 - aw)) {
                        return true;
                    }
                    if (y >= (rry0 += ah) && y < (rry0 = rry1 - ah)) {
                        return true;
                    }
                    x = (x - rrx0) / aw;
                    y = (y - rry0) / ah;
                    return (x * x + y * y <= 1.0);
                };
                RoundRectangle2D.prototype.classify = function (coord, left, right, arcsize) {
                    if (coord < left) {
                        return 0;
                    }
                    else if (coord < left + arcsize) {
                        return 1;
                    }
                    else if (coord < right - arcsize) {
                        return 2;
                    }
                    else if (coord < right) {
                        return 3;
                    }
                    else {
                        return 4;
                    }
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                RoundRectangle2D.prototype.intersects = function (x, y, w, h) {
                    var _this = this;
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (_this.isEmpty() || w <= 0 || h <= 0) {
                                return false;
                            }
                            var rrx0 = _this.getX();
                            var rry0 = _this.getY();
                            var rrx1 = rrx0 + _this.getWidth();
                            var rry1 = rry0 + _this.getHeight();
                            if (x + w <= rrx0 || x >= rrx1 || y + h <= rry0 || y >= rry1) {
                                return false;
                            }
                            var aw = Math.min(_this.getWidth(), Math.abs(_this.getArcWidth())) / 2.0;
                            var ah = Math.min(_this.getHeight(), Math.abs(_this.getArcHeight())) / 2.0;
                            var x0class = _this.classify(x, rrx0, rrx1, aw);
                            var x1class = _this.classify(x + w, rrx0, rrx1, aw);
                            var y0class = _this.classify(y, rry0, rry1, ah);
                            var y1class = _this.classify(y + h, rry0, rry1, ah);
                            if (x0class === 2 || x1class === 2 || y0class === 2 || y1class === 2) {
                                return true;
                            }
                            if ((x0class < 2 && x1class > 2) || (y0class < 2 && y1class > 2)) {
                                return true;
                            }
                            x = (x1class === 1) ? (x = x + w - (rrx0 + aw)) : (x = x - (rrx1 - aw));
                            y = (y1class === 1) ? (y = y + h - (rry0 + ah)) : (y = y - (rry1 - ah));
                            x = x / aw;
                            y = y / ah;
                            return (x * x + y * y <= 1.0);
                        })();
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 */
                RoundRectangle2D.prototype.contains$double$double$double$double = function (x, y, w, h) {
                    if (this.isEmpty() || w <= 0 || h <= 0) {
                        return false;
                    }
                    return (this.contains(x, y) && this.contains(x + w, y) && this.contains(x, y + h) && this.contains(x + w, y + h));
                };
                /**
                 * Returns an iteration object that defines the boundary of this
                 * <code>RoundRectangle2D</code>. The iterator for this class is
                 * multi-threaded safe, which means that this <code>RoundRectangle2D</code>
                 * class guarantees that modifications to the geometry of this
                 * <code>RoundRectangle2D</code> object do not affect any iterations of that
                 * geometry that are already in process.
                 *
                 * @param at
                 * an optional <code>AffineTransform</code> to be applied to the
                 * coordinates as they are returned in the iteration, or
                 * <code>null</code> if untransformed coordinates are desired
                 * @return the <code>PathIterator</code> object that returns the geometry of
                 * the outline of this <code>RoundRectangle2D</code>, one segment at
                 * a time.
                 * @since 1.2
                 */
                RoundRectangle2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                    return new java.awt.geom.RoundRectIterator(this, at);
                };
                /**
                 * Returns the hashcode for this <code>RoundRectangle2D</code>.
                 *
                 * @return the hashcode for this <code>RoundRectangle2D</code>.
                 * @since 1.6
                 */
                RoundRectangle2D.prototype.hashCode = function () {
                    var bits = javaemul.internal.DoubleHelper.doubleToLongBits(this.getX());
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getY()) * 37;
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getWidth()) * 43;
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getHeight()) * 47;
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getArcWidth()) * 53;
                    bits += javaemul.internal.DoubleHelper.doubleToLongBits(this.getArcHeight()) * 59;
                    return (((bits | 0)) ^ (((bits >> 32) | 0)));
                };
                /**
                 * Determines whether or not the specified <code>Object</code> is equal to
                 * this <code>RoundRectangle2D</code>. The specified <code>Object</code> is
                 * equal to this <code>RoundRectangle2D</code> if it is an instance of
                 * <code>RoundRectangle2D</code> and if its location, size, and corner arc
                 * dimensions are the same as this <code>RoundRectangle2D</code>.
                 *
                 * @param obj
                 * an <code>Object</code> to be compared with this
                 * <code>RoundRectangle2D</code>.
                 * @return <code>true</code> if <code>obj</code> is an instance of
                 * <code>RoundRectangle2D</code> and has the same values;
                 * <code>false</code> otherwise.
                 * @since 1.6
                 */
                RoundRectangle2D.prototype.equals = function (obj) {
                    if (obj === this) {
                        return true;
                    }
                    if (obj != null && obj instanceof java.awt.geom.RoundRectangle2D) {
                        var rr2d = obj;
                        return ((this.getX() === rr2d.getX()) && (this.getY() === rr2d.getY()) && (this.getWidth() === rr2d.getWidth()) && (this.getHeight() === rr2d.getHeight()) && (this.getArcWidth() === rr2d.getArcWidth()) && (this.getArcHeight() === rr2d.getArcHeight()));
                    }
                    return false;
                };
                return RoundRectangle2D;
            }(java.awt.geom.RectangularShape));
            geom.RoundRectangle2D = RoundRectangle2D;
            RoundRectangle2D["__class"] = "java.awt.geom.RoundRectangle2D";
            RoundRectangle2D["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
            var RoundRectangle2D;
            (function (RoundRectangle2D) {
                /**
                 * The <code>Float</code> class defines a rectangle with rounded corners all
                 * specified in <code>float</code> coordinates.
                 *
                 * @since 1.2
                 */
                var Float = (function (_super) {
                    __extends(Float, _super);
                    /**
                     * Constructs and initializes a <code>RoundRectangle2D</code> from the
                     * specified <code>float</code> coordinates.
                     *
                     * @param x
                     * the X coordinate of the newly constructed
                     * <code>RoundRectangle2D</code>
                     * @param y
                     * the Y coordinate of the newly constructed
                     * <code>RoundRectangle2D</code>
                     * @param w
                     * the width to which to set the newly constructed
                     * <code>RoundRectangle2D</code>
                     * @param h
                     * the height to which to set the newly constructed
                     * <code>RoundRectangle2D</code>
                     * @param arcw
                     * the width of the arc to use to round off the corners of
                     * the newly constructed <code>RoundRectangle2D</code>
                     * @param arch
                     * the height of the arc to use to round off the corners of
                     * the newly constructed <code>RoundRectangle2D</code>
                     * @since 1.2
                     */
                    function Float(x, y, w, h, arcw, arch) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof arcw === 'number') || arcw === null) && ((typeof arch === 'number') || arch === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            this.arcwidth = 0;
                            this.archeight = 0;
                            (function () {
                                _this.setRoundRect(x, y, w, h, arcw, arch);
                            })();
                        }
                        else if (x === undefined && y === undefined && w === undefined && h === undefined && arcw === undefined && arch === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            this.arcwidth = 0;
                            this.archeight = 0;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getWidth = function () {
                        return this.width;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getHeight = function () {
                        return this.height;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getArcWidth = function () {
                        return this.arcwidth;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getArcHeight = function () {
                        return this.archeight;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.isEmpty = function () {
                        return (this.width <= 0.0) || (this.height <= 0.0);
                    };
                    /**
                     * Sets the location, size, and corner radii of this
                     * <code>RoundRectangle2D</code> to the specified <code>float</code>
                     * values.
                     *
                     * @param x
                     * the X coordinate to which to set the location of this
                     * <code>RoundRectangle2D</code>
                     * @param y
                     * the Y coordinate to which to set the location of this
                     * <code>RoundRectangle2D</code>
                     * @param w
                     * the width to which to set this
                     * <code>RoundRectangle2D</code>
                     * @param h
                     * the height to which to set this
                     * <code>RoundRectangle2D</code>
                     * @param arcw
                     * the width to which to set the arc of this
                     * <code>RoundRectangle2D</code>
                     * @param arch
                     * the height to which to set the arc of this
                     * <code>RoundRectangle2D</code>
                     * @since 1.2
                     */
                    Float.prototype.setRoundRect = function (x, y, w, h, arcw, arch) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof arcw === 'number') || arcw === null) && ((typeof arch === 'number') || arch === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            return (function () {
                                _this.x = x;
                                _this.y = y;
                                _this.width = w;
                                _this.height = h;
                                _this.arcwidth = arcw;
                                _this.archeight = arch;
                            })();
                        }
                        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof arcw === 'number') || arcw === null) && ((typeof arch === 'number') || arch === null)) {
                            return this.setRoundRect$double$double$double$double$double$double(x, y, w, h, arcw, arch);
                        }
                        else if (((x != null && x instanceof java.awt.geom.RoundRectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && arcw === undefined && arch === undefined) {
                            return this.setRoundRect$java_awt_geom_RoundRectangle2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.setRoundRect$double$double$double$double$double$double = function (x, y, w, h, arcw, arch) {
                        this.x = x;
                        this.y = y;
                        this.width = w;
                        this.height = h;
                        this.arcwidth = arcw;
                        this.archeight = arch;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.setRoundRect$java_awt_geom_RoundRectangle2D = function (rr) {
                        this.x = rr.getX();
                        this.y = rr.getY();
                        this.width = rr.getWidth();
                        this.height = rr.getHeight();
                        this.arcwidth = rr.getArcWidth();
                        this.archeight = rr.getArcHeight();
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Float.prototype.getBounds2D = function () {
                        return new java.awt.geom.Rectangle2D.Float(this.x, this.y, this.width, this.height);
                    };
                    Float.serialVersionUID = -3423150618393866922;
                    return Float;
                }(java.awt.geom.RoundRectangle2D));
                RoundRectangle2D.Float = Float;
                Float["__class"] = "java.awt.geom.RoundRectangle2D.Float";
                Float["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
                /**
                 * The <code>Double</code> class defines a rectangle with rounded corners
                 * all specified in <code>double</code> coordinates.
                 *
                 * @since 1.2
                 */
                var Double = (function (_super) {
                    __extends(Double, _super);
                    /**
                     * Constructs and initializes a <code>RoundRectangle2D</code> from the
                     * specified <code>double</code> coordinates.
                     *
                     * @param x
                     * the X coordinate of the newly constructed
                     * <code>RoundRectangle2D</code>
                     * @param y
                     * the Y coordinate of the newly constructed
                     * <code>RoundRectangle2D</code>
                     * @param w
                     * the width to which to set the newly constructed
                     * <code>RoundRectangle2D</code>
                     * @param h
                     * the height to which to set the newly constructed
                     * <code>RoundRectangle2D</code>
                     * @param arcw
                     * the width of the arc to use to round off the corners of
                     * the newly constructed <code>RoundRectangle2D</code>
                     * @param arch
                     * the height of the arc to use to round off the corners of
                     * the newly constructed <code>RoundRectangle2D</code>
                     * @since 1.2
                     */
                    function Double(x, y, w, h, arcw, arch) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof arcw === 'number') || arcw === null) && ((typeof arch === 'number') || arch === null)) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            this.arcwidth = 0;
                            this.archeight = 0;
                            (function () {
                                _this.setRoundRect(x, y, w, h, arcw, arch);
                            })();
                        }
                        else if (x === undefined && y === undefined && w === undefined && h === undefined && arcw === undefined && arch === undefined) {
                            var __args = Array.prototype.slice.call(arguments);
                            _super.call(this);
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            this.arcwidth = 0;
                            this.archeight = 0;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getWidth = function () {
                        return this.width;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getHeight = function () {
                        return this.height;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getArcWidth = function () {
                        return this.arcwidth;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getArcHeight = function () {
                        return this.archeight;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.isEmpty = function () {
                        return (this.width <= 0.0) || (this.height <= 0.0);
                    };
                    /**
                     * Sets the location, size, and corner radii of this
                     * <code>RoundRectangle2D</code> to the specified <code>float</code>
                     * values.
                     *
                     * @param x
                     * the X coordinate to which to set the location of this
                     * <code>RoundRectangle2D</code>
                     * @param y
                     * the Y coordinate to which to set the location of this
                     * <code>RoundRectangle2D</code>
                     * @param w
                     * the width to which to set this
                     * <code>RoundRectangle2D</code>
                     * @param h
                     * the height to which to set this
                     * <code>RoundRectangle2D</code>
                     * @param arcw
                     * the width to which to set the arc of this
                     * <code>RoundRectangle2D</code>
                     * @param arch
                     * the height to which to set the arc of this
                     * <code>RoundRectangle2D</code>
                     * @since 1.2
                     */
                    Double.prototype.setRoundRect = function (x, y, w, h, arcw, arch) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof arcw === 'number') || arcw === null) && ((typeof arch === 'number') || arch === null)) {
                            return this.setRoundRect$double$double$double$double$double$double(x, y, w, h, arcw, arch);
                        }
                        else if (((x != null && x instanceof java.awt.geom.RoundRectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && arcw === undefined && arch === undefined) {
                            return this.setRoundRect$java_awt_geom_RoundRectangle2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.setRoundRect$double$double$double$double$double$double = function (x, y, w, h, arcw, arch) {
                        this.x = x;
                        this.y = y;
                        this.width = w;
                        this.height = h;
                        this.arcwidth = arcw;
                        this.archeight = arch;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.setRoundRect$java_awt_geom_RoundRectangle2D = function (rr) {
                        this.x = rr.getX();
                        this.y = rr.getY();
                        this.width = rr.getWidth();
                        this.height = rr.getHeight();
                        this.arcwidth = rr.getArcWidth();
                        this.archeight = rr.getArcHeight();
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     */
                    Double.prototype.getBounds2D = function () {
                        return new java.awt.geom.Rectangle2D.Double(this.x, this.y, this.width, this.height);
                    };
                    Double.serialVersionUID = 1048939333485206117;
                    return Double;
                }(java.awt.geom.RoundRectangle2D));
                RoundRectangle2D.Double = Double;
                Double["__class"] = "java.awt.geom.RoundRectangle2D.Double";
                Double["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
            })(RoundRectangle2D = geom.RoundRectangle2D || (geom.RoundRectangle2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var Graphics2D = (function (_super) {
            __extends(Graphics2D, _super);
            function Graphics2D() {
                _super.call(this);
            }
            Graphics2D.prototype.draw3DRect = function (x, y, width, height, raised) {
                var p = this.getPaint();
                var c = this.getColor();
                var brighter = c.brighter();
                var darker = c.darker();
                this.setColor(raised ? brighter : darker);
                this.fillRect(x, y, 1, height + 1);
                this.fillRect(x + 1, y, width - 1, 1);
                this.setColor(raised ? darker : brighter);
                this.fillRect(x + 1, y + height, width, 1);
                this.fillRect(x + width, y, 1, height);
                this.setPaint(p);
            };
            Graphics2D.prototype.fill3DRect = function (x, y, width, height, raised) {
                var p = this.getPaint();
                var c = this.getColor();
                var brighter = c.brighter();
                var darker = c.darker();
                if (!raised) {
                    this.setColor(darker);
                }
                else if (p !== c) {
                    this.setColor(c);
                }
                this.fillRect(x + 1, y + 1, width - 2, height - 2);
                this.setColor(raised ? brighter : darker);
                this.fillRect(x, y, 1, height);
                this.fillRect(x + 1, y, width - 2, 1);
                this.setColor(raised ? darker : brighter);
                this.fillRect(x + 1, y + height - 1, width - 1, 1);
                this.fillRect(x + width - 1, y, 1, height - 1);
                this.setPaint(p);
            };
            Graphics2D.prototype.drawImage$java_awt_Image$java_awt_geom_AffineTransform$java_awt_image_ImageObserver = function (img, xform, obs) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
            Graphics2D.prototype.drawString = function (str, x, y) {
                if (((typeof str === 'string') || str === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                }
                else if (((typeof str === 'string') || str === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return this.drawString$java_lang_String$float$float(str, x, y);
                }
                else
                    throw new Error('invalid overload');
            };
            Graphics2D.prototype.drawString$java_lang_String$float$float = function (str, x, y) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
            Graphics2D.prototype.translate = function (x, y) {
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return this.translate$double$double(x, y);
                }
                else
                    throw new Error('invalid overload');
            };
            Graphics2D.prototype.translate$double$double = function (tx, ty) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
            Graphics2D.prototype.rotate$double = function (theta) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
            Graphics2D.prototype.rotate = function (theta, x, y) {
                if (((typeof theta === 'number') || theta === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                }
                else if (((typeof theta === 'number') || theta === null) && x === undefined && y === undefined) {
                    return this.rotate$double(theta);
                }
                else
                    throw new Error('invalid overload');
            };
            return Graphics2D;
        }(java.awt.Graphics));
        awt.Graphics2D = Graphics2D;
        Graphics2D["__class"] = "java.awt.Graphics2D";
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var image;
        (function (image) {
            var BufferedImage = (function (_super) {
                __extends(BufferedImage, _super);
                function BufferedImage(src) {
                    _super.call(this, src);
                }
                BufferedImage.prototype.getWidth$ = function () {
                    return _super.prototype.getWidth.call(this, null);
                };
                BufferedImage.prototype.getHeight$ = function () {
                    return _super.prototype.getHeight.call(this, null);
                };
                return BufferedImage;
            }(java.awt.Image));
            image.BufferedImage = BufferedImage;
            BufferedImage["__class"] = "java.awt.image.BufferedImage";
            BufferedImage["__interfaces"] = ["java.awt.image.RenderedImage"];
        })(image = awt.image || (awt.image = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var RenderedImage = (function (_super) {
            __extends(RenderedImage, _super);
            function RenderedImage(src) {
                _super.call(this, src);
            }
            return RenderedImage;
        }(java.awt.Image));
        awt.RenderedImage = RenderedImage;
        RenderedImage["__class"] = "java.awt.RenderedImage";
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var beans;
    (function (beans) {
        var PropertyChangeSupport = (function () {
            function PropertyChangeSupport(sourceBean) {
                this.map = new PropertyChangeSupport.PropertyChangeListenerMap();
                if (sourceBean == null) {
                    throw new java.lang.NullPointerException();
                }
                this.source = sourceBean;
            }
            PropertyChangeSupport.prototype.addPropertyChangeListener$java_beans_PropertyChangeListener = function (listener) {
                if (listener == null) {
                    return;
                }
                if (listener != null && listener instanceof java.beans.PropertyChangeListenerProxy) {
                    var proxy = listener;
                    this.addPropertyChangeListener(proxy.getPropertyName(), proxy.getListener());
                }
                else {
                    this.map.add(null, listener);
                }
            };
            PropertyChangeSupport.prototype.removePropertyChangeListener$java_beans_PropertyChangeListener = function (listener) {
                if (listener == null) {
                    return;
                }
                if (listener != null && listener instanceof java.beans.PropertyChangeListenerProxy) {
                    var proxy = listener;
                    this.removePropertyChangeListener(proxy.getPropertyName(), proxy.getListener());
                }
                else {
                    this.map.remove(null, listener);
                }
            };
            PropertyChangeSupport.prototype.getPropertyChangeListeners$ = function () {
                return this.map.getListeners();
            };
            PropertyChangeSupport.prototype.addPropertyChangeListener = function (propertyName, listener) {
                var _this = this;
                if (((typeof propertyName === 'string') || propertyName === null) && ((listener != null && (listener["__interfaces"] != null && listener["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0 || listener.constructor != null && listener.constructor["__interfaces"] != null && listener.constructor["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0)) || listener === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        if (listener == null || propertyName == null) {
                            return;
                        }
                        listener = _this.map.extract(listener);
                        if (listener != null) {
                            _this.map.add(propertyName, listener);
                        }
                    })();
                }
                else if (((propertyName != null && (propertyName["__interfaces"] != null && propertyName["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0 || propertyName.constructor != null && propertyName.constructor["__interfaces"] != null && propertyName.constructor["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0)) || propertyName === null) && listener === undefined) {
                    return this.addPropertyChangeListener$java_beans_PropertyChangeListener(propertyName);
                }
                else
                    throw new Error('invalid overload');
            };
            PropertyChangeSupport.prototype.removePropertyChangeListener = function (propertyName, listener) {
                var _this = this;
                if (((typeof propertyName === 'string') || propertyName === null) && ((listener != null && (listener["__interfaces"] != null && listener["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0 || listener.constructor != null && listener.constructor["__interfaces"] != null && listener.constructor["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0)) || listener === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        if (listener == null || propertyName == null) {
                            return;
                        }
                        listener = _this.map.extract(listener);
                        if (listener != null) {
                            _this.map.remove(propertyName, listener);
                        }
                    })();
                }
                else if (((propertyName != null && (propertyName["__interfaces"] != null && propertyName["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0 || propertyName.constructor != null && propertyName.constructor["__interfaces"] != null && propertyName.constructor["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0)) || propertyName === null) && listener === undefined) {
                    return this.removePropertyChangeListener$java_beans_PropertyChangeListener(propertyName);
                }
                else
                    throw new Error('invalid overload');
            };
            PropertyChangeSupport.prototype.getPropertyChangeListeners = function (propertyName) {
                var _this = this;
                if (((typeof propertyName === 'string') || propertyName === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        return _this.map.getListeners(propertyName);
                    })();
                }
                else if (propertyName === undefined) {
                    return this.getPropertyChangeListeners$();
                }
                else
                    throw new Error('invalid overload');
            };
            PropertyChangeSupport.prototype.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object = function (propertyName, oldValue, newValue) {
                if (oldValue == null || newValue == null || !(oldValue === newValue)) {
                    this.firePropertyChange(new java.beans.PropertyChangeEvent(this.source, propertyName, oldValue, newValue));
                }
            };
            PropertyChangeSupport.prototype.firePropertyChange = function (propertyName, oldValue, newValue) {
                var _this = this;
                if (((typeof propertyName === 'string') || propertyName === null) && ((typeof oldValue === 'number') || oldValue === null) && ((typeof newValue === 'number') || newValue === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        if (oldValue !== newValue) {
                            _this.firePropertyChange(propertyName, javaemul.internal.IntegerHelper.valueOf(oldValue), javaemul.internal.IntegerHelper.valueOf(newValue));
                        }
                    })();
                }
                else if (((typeof propertyName === 'string') || propertyName === null) && ((typeof oldValue === 'boolean') || oldValue === null) && ((typeof newValue === 'boolean') || newValue === null)) {
                    return this.firePropertyChange$java_lang_String$boolean$boolean(propertyName, oldValue, newValue);
                }
                else if (((typeof propertyName === 'string') || propertyName === null) && ((oldValue != null) || oldValue === null) && ((newValue != null) || newValue === null)) {
                    return this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object(propertyName, oldValue, newValue);
                }
                else if (((propertyName != null && propertyName instanceof java.beans.PropertyChangeEvent) || propertyName === null) && oldValue === undefined && newValue === undefined) {
                    return this.firePropertyChange$java_beans_PropertyChangeEvent(propertyName);
                }
                else
                    throw new Error('invalid overload');
            };
            PropertyChangeSupport.prototype.firePropertyChange$java_lang_String$boolean$boolean = function (propertyName, oldValue, newValue) {
                if (oldValue !== newValue) {
                    this.firePropertyChange(propertyName, javaemul.internal.BooleanHelper.valueOf(oldValue), javaemul.internal.BooleanHelper.valueOf(newValue));
                }
            };
            PropertyChangeSupport.prototype.firePropertyChange$java_beans_PropertyChangeEvent = function (event) {
                var oldValue = event.getOldValue();
                var newValue = event.getNewValue();
                if (oldValue == null || newValue == null || !(oldValue === newValue)) {
                    var name_2 = event.getPropertyName();
                    var common = this.map.get(null);
                    var named = (name_2 != null) ? this.map.get(name_2) : null;
                    PropertyChangeSupport.fire(common, event);
                    PropertyChangeSupport.fire(named, event);
                }
            };
            PropertyChangeSupport.fire = function (listeners, event) {
                if (listeners != null) {
                    for (var index131 = 0; index131 < listeners.length; index131++) {
                        var listener = listeners[index131];
                        {
                            listener.propertyChange(event);
                        }
                    }
                }
            };
            PropertyChangeSupport.prototype.fireIndexedPropertyChange$java_lang_String$int$java_lang_Object$java_lang_Object = function (propertyName, index, oldValue, newValue) {
                if (oldValue == null || newValue == null || !(oldValue === newValue)) {
                    this.firePropertyChange(new java.beans.IndexedPropertyChangeEvent(this.source, propertyName, oldValue, newValue, index));
                }
            };
            PropertyChangeSupport.prototype.fireIndexedPropertyChange = function (propertyName, index, oldValue, newValue) {
                var _this = this;
                if (((typeof propertyName === 'string') || propertyName === null) && ((typeof index === 'number') || index === null) && ((typeof oldValue === 'number') || oldValue === null) && ((typeof newValue === 'number') || newValue === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        if (oldValue !== newValue) {
                            _this.fireIndexedPropertyChange(propertyName, index, javaemul.internal.IntegerHelper.valueOf(oldValue), javaemul.internal.IntegerHelper.valueOf(newValue));
                        }
                    })();
                }
                else if (((typeof propertyName === 'string') || propertyName === null) && ((typeof index === 'number') || index === null) && ((typeof oldValue === 'boolean') || oldValue === null) && ((typeof newValue === 'boolean') || newValue === null)) {
                    return this.fireIndexedPropertyChange$java_lang_String$int$boolean$boolean(propertyName, index, oldValue, newValue);
                }
                else if (((typeof propertyName === 'string') || propertyName === null) && ((typeof index === 'number') || index === null) && ((oldValue != null) || oldValue === null) && ((newValue != null) || newValue === null)) {
                    return this.fireIndexedPropertyChange$java_lang_String$int$java_lang_Object$java_lang_Object(propertyName, index, oldValue, newValue);
                }
                else
                    throw new Error('invalid overload');
            };
            PropertyChangeSupport.prototype.fireIndexedPropertyChange$java_lang_String$int$boolean$boolean = function (propertyName, index, oldValue, newValue) {
                if (oldValue !== newValue) {
                    this.fireIndexedPropertyChange(propertyName, index, javaemul.internal.BooleanHelper.valueOf(oldValue), javaemul.internal.BooleanHelper.valueOf(newValue));
                }
            };
            PropertyChangeSupport.prototype.hasListeners = function (propertyName) {
                return this.map.hasListeners(propertyName);
            };
            PropertyChangeSupport.serialVersionUID = 6401253773779951803;
            return PropertyChangeSupport;
        }());
        beans.PropertyChangeSupport = PropertyChangeSupport;
        PropertyChangeSupport["__class"] = "java.beans.PropertyChangeSupport";
        PropertyChangeSupport["__interfaces"] = ["java.io.Serializable"];
        var PropertyChangeSupport;
        (function (PropertyChangeSupport) {
            var PropertyChangeListenerMap = (function (_super) {
                __extends(PropertyChangeListenerMap, _super);
                function PropertyChangeListenerMap() {
                    _super.apply(this, arguments);
                }
                PropertyChangeListenerMap.EMPTY_$LI$ = function () { if (PropertyChangeListenerMap.EMPTY == null)
                    PropertyChangeListenerMap.EMPTY = []; return PropertyChangeListenerMap.EMPTY; };
                ;
                PropertyChangeListenerMap.prototype.newArray = function (length) {
                    return (0 < length) ? new Array(length) : PropertyChangeListenerMap.EMPTY_$LI$();
                };
                PropertyChangeListenerMap.prototype.newProxy = function (name, listener) {
                    if (((typeof name === 'string') || name === null) && ((listener != null && (listener["__interfaces"] != null && listener["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0 || listener.constructor != null && listener.constructor["__interfaces"] != null && listener.constructor["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0)) || listener === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            return new java.beans.PropertyChangeListenerProxy(name, listener);
                        })();
                    }
                    else if (((typeof name === 'string') || name === null) && ((listener != null) || listener === null)) {
                        return this.newProxy$java_lang_String$java_util_EventListener(name, listener);
                    }
                    else
                        throw new Error('invalid overload');
                };
                PropertyChangeListenerMap.prototype.extract = function (listener) {
                    if (((listener != null && (listener["__interfaces"] != null && listener["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0 || listener.constructor != null && listener.constructor["__interfaces"] != null && listener.constructor["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0)) || listener === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            while ((listener != null && listener instanceof java.beans.PropertyChangeListenerProxy)) {
                                listener = listener.getListener();
                            }
                            ;
                            return listener;
                        })();
                    }
                    else if (((listener != null) || listener === null)) {
                        return this.extract$java_util_EventListener(listener);
                    }
                    else
                        throw new Error('invalid overload');
                };
                return PropertyChangeListenerMap;
            }(java.beans.ChangeListenerMap));
            PropertyChangeSupport.PropertyChangeListenerMap = PropertyChangeListenerMap;
            PropertyChangeListenerMap["__class"] = "java.beans.PropertyChangeSupport.PropertyChangeListenerMap";
        })(PropertyChangeSupport = beans.PropertyChangeSupport || (beans.PropertyChangeSupport = {}));
    })(beans = java.beans || (java.beans = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var beans;
    (function (beans) {
        /**
         * An "IndexedPropertyChange" event gets delivered whenever a component that
         * conforms to the JavaBeans&trade; specification (a "bean") changes a bound
         * indexed property. This class is an extension of <code>PropertyChangeEvent</code>
         * but contains the index of the property that has changed.
         * <P>
         * Null values may be provided for the old and the new values if their
         * true values are not known.
         * <P>
         * An event source may send a null object as the name to indicate that an
         * arbitrary set of if its properties have changed.  In this case the
         * old and new values should also be null.
         *
         * @since 1.5
         * @author Mark Davidson
         */
        var IndexedPropertyChangeEvent = (function (_super) {
            __extends(IndexedPropertyChangeEvent, _super);
            /**
             * Constructs a new <code>IndexedPropertyChangeEvent</code> object.
             *
             * @param source  The bean that fired the event.
             * @param propertyName  The programmatic name of the property that
             * was changed.
             * @param oldValue      The old value of the property.
             * @param newValue      The new value of the property.
             * @param index index of the property element that was changed.
             */
            function IndexedPropertyChangeEvent(source, propertyName, oldValue, newValue, index) {
                _super.call(this, source, propertyName, oldValue, newValue);
                this.index = 0;
                this.index = index;
            }
            /**
             * Gets the index of the property that was changed.
             *
             * @return The index specifying the property element that was
             * changed.
             */
            IndexedPropertyChangeEvent.prototype.getIndex = function () {
                return this.index;
            };
            IndexedPropertyChangeEvent.prototype.appendTo = function (sb) {
                sb.append("; index=").append(this.getIndex());
            };
            IndexedPropertyChangeEvent.serialVersionUID = -320227448495806870;
            return IndexedPropertyChangeEvent;
        }(java.beans.PropertyChangeEvent));
        beans.IndexedPropertyChangeEvent = IndexedPropertyChangeEvent;
        IndexedPropertyChangeEvent["__class"] = "java.beans.IndexedPropertyChangeEvent";
        IndexedPropertyChangeEvent["__interfaces"] = ["java.io.Serializable"];
    })(beans = java.beans || (java.beans = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        /**
         * The default model for combo boxes.
         *
         * @param <E> the type of the elements of this model
         *
         * @author Arnaud Weber
         * @author Tom Santos
         */
        var DefaultComboBoxModel = (function (_super) {
            __extends(DefaultComboBoxModel, _super);
            /**
             * Constructs a DefaultComboBoxModel object initialized with
             * an array of objects.
             *
             * @param items  an array of Object objects
             */
            function DefaultComboBoxModel(items) {
                var _this = this;
                if (((items != null && items instanceof Array) || items === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this);
                    (function () {
                        _this.objects = (new java.util.Vector(items.length));
                        var i;
                        var c;
                        for (i = 0, c = items.length; i < c; i++)
                            _this.objects.addElement(items[i]);
                        if (_this.getSize() > 0) {
                            _this.selectedObject = _this.getElementAt(0);
                        }
                    })();
                }
                else if (((items != null && items instanceof java.util.Vector) || items === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    var v_1 = __args[0];
                    _super.call(this);
                    (function () {
                        _this.objects = v_1;
                        if (_this.getSize() > 0) {
                            _this.selectedObject = _this.getElementAt(0);
                        }
                    })();
                }
                else if (items === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this);
                    (function () {
                        _this.objects = (new java.util.Vector());
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Set the value of the selected item. The selected item may be null.
             *
             * @param anObject The combo box value or null for no selection.
             */
            DefaultComboBoxModel.prototype.setSelectedItem = function (anObject) {
                if ((this.selectedObject != null && !(this.selectedObject === anObject)) || this.selectedObject == null && anObject != null) {
                    this.selectedObject = anObject;
                    this.fireContentsChanged(this, -1, -1);
                }
            };
            DefaultComboBoxModel.prototype.getSelectedItem = function () {
                return this.selectedObject;
            };
            DefaultComboBoxModel.prototype.getSize = function () {
                return this.objects.size();
            };
            DefaultComboBoxModel.prototype.getElementAt = function (index) {
                if (index >= 0 && index < this.objects.size())
                    return this.objects.elementAt(index);
                else
                    return null;
            };
            /**
             * Returns the index-position of the specified object in the list.
             *
             * @param anObject
             * @return an int representing the index position, where 0 is
             * the first position
             */
            DefaultComboBoxModel.prototype.getIndexOf = function (anObject) {
                return this.objects.indexOf(anObject);
            };
            DefaultComboBoxModel.prototype.addElement = function (anObject) {
                this.objects.addElement(anObject);
                this.fireIntervalAdded(this, this.objects.size() - 1, this.objects.size() - 1);
                if (this.objects.size() === 1 && this.selectedObject == null && anObject != null) {
                    this.setSelectedItem(anObject);
                }
            };
            DefaultComboBoxModel.prototype.insertElementAt = function (anObject, index) {
                this.objects.insertElementAt(anObject, index);
                this.fireIntervalAdded(this, index, index);
            };
            DefaultComboBoxModel.prototype.removeElementAt = function (index) {
                if (this.getElementAt(index) === this.selectedObject) {
                    if (index === 0) {
                        this.setSelectedItem(this.getSize() === 1 ? null : this.getElementAt(index + 1));
                    }
                    else {
                        this.setSelectedItem(this.getElementAt(index - 1));
                    }
                }
                this.objects.removeElementAt(index);
                this.fireIntervalRemoved(this, index, index);
            };
            DefaultComboBoxModel.prototype.removeElement = function (anObject) {
                var index = this.objects.indexOf(anObject);
                if (index !== -1) {
                    this.removeElementAt(index);
                }
            };
            /**
             * Empties the list.
             */
            DefaultComboBoxModel.prototype.removeAllElements = function () {
                if (this.objects.size() > 0) {
                    var firstIndex = 0;
                    var lastIndex = this.objects.size() - 1;
                    this.objects.removeAllElements();
                    this.selectedObject = null;
                    this.fireIntervalRemoved(this, firstIndex, lastIndex);
                }
                else {
                    this.selectedObject = null;
                }
            };
            return DefaultComboBoxModel;
        }(javax.swing.AbstractListModel));
        swing.DefaultComboBoxModel = DefaultComboBoxModel;
        DefaultComboBoxModel["__class"] = "javax.swing.DefaultComboBoxModel";
        DefaultComboBoxModel["__interfaces"] = ["javax.swing.MutableComboBoxModel", "javax.swing.ComboBoxModel", "javax.swing.ListModel", "java.io.Serializable"];
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var undo;
        (function (undo) {
            /**
             * A concrete subclass of AbstractUndoableEdit, used to assemble little
             * UndoableEdits into great big ones.
             *
             * @author Ray Ryan
             */
            var CompoundEdit = (function (_super) {
                __extends(CompoundEdit, _super);
                function CompoundEdit() {
                    _super.call(this);
                    this.inProgress = false;
                    this.inProgress = true;
                    this.edits = (new java.util.Vector());
                }
                /**
                 * Sends <code>undo</code> to all contained
                 * <code>UndoableEdits</code> in the reverse of
                 * the order in which they were added.
                 */
                CompoundEdit.prototype.undo = function () {
                    _super.prototype.undo.call(this);
                    var i = this.edits.size();
                    while ((i-- > 0)) {
                        var e = this.edits.elementAt(i);
                        e.undo();
                    }
                    ;
                };
                /**
                 * Sends <code>redo</code> to all contained
                 * <code>UndoableEdit</code>s in the order in
                 * which they were added.
                 */
                CompoundEdit.prototype.redo = function () {
                    _super.prototype.redo.call(this);
                    var cursor = this.edits.elements();
                    while ((cursor.hasMoreElements())) {
                        cursor.nextElement().redo();
                    }
                    ;
                };
                /**
                 * Returns the last <code>UndoableEdit</code> in
                 * <code>edits</code>, or <code>null</code>
                 * if <code>edits</code> is empty.
                 */
                CompoundEdit.prototype.lastEdit = function () {
                    var count = this.edits.size();
                    if (count > 0)
                        return this.edits.elementAt(count - 1);
                    else
                        return null;
                };
                /**
                 * Sends <code>die</code> to each subedit,
                 * in the reverse of the order that they were added.
                 */
                CompoundEdit.prototype.die = function () {
                    var size = this.edits.size();
                    for (var i = size - 1; i >= 0; i--) {
                        var e = this.edits.elementAt(i);
                        e.die();
                    }
                    _super.prototype.die.call(this);
                };
                /**
                 * If this edit is <code>inProgress</code>,
                 * accepts <code>anEdit</code> and returns true.
                 *
                 * <p>The last edit added to this <code>CompoundEdit</code>
                 * is given a chance to <code>addEdit(anEdit)</code>.
                 * If it refuses (returns false), <code>anEdit</code> is
                 * given a chance to <code>replaceEdit</code> the last edit.
                 * If <code>anEdit</code> returns false here,
                 * it is added to <code>edits</code>.
                 *
                 * @param anEdit the edit to be added
                 * @return true if the edit is <code>inProgress</code>;
                 * otherwise returns false
                 */
                CompoundEdit.prototype.addEdit = function (anEdit) {
                    if (!this.inProgress) {
                        return false;
                    }
                    else {
                        var last = this.lastEdit();
                        if (last == null) {
                            this.edits.addElement(anEdit);
                        }
                        else if (!last.addEdit(anEdit)) {
                            if (anEdit.replaceEdit(last)) {
                                this.edits.removeElementAt(this.edits.size() - 1);
                            }
                            this.edits.addElement(anEdit);
                        }
                        return true;
                    }
                };
                /**
                 * Sets <code>inProgress</code> to false.
                 *
                 * @see #canUndo
                 * @see #canRedo
                 */
                CompoundEdit.prototype.end = function () {
                    this.inProgress = false;
                };
                /**
                 * Returns false if <code>isInProgress</code> or if super
                 * returns false.
                 *
                 * @see     #isInProgress
                 */
                CompoundEdit.prototype.canUndo = function () {
                    return !this.isInProgress() && _super.prototype.canUndo.call(this);
                };
                /**
                 * Returns false if <code>isInProgress</code> or if super
                 * returns false.
                 *
                 * @see     #isInProgress
                 */
                CompoundEdit.prototype.canRedo = function () {
                    return !this.isInProgress() && _super.prototype.canRedo.call(this);
                };
                /**
                 * Returns true if this edit is in progress--that is, it has not
                 * received end. This generally means that edits are still being
                 * added to it.
                 *
                 * @see     #end
                 */
                CompoundEdit.prototype.isInProgress = function () {
                    return this.inProgress;
                };
                /**
                 * Returns true if any of the <code>UndoableEdit</code>s
                 * in <code>edits</code> do.
                 * Returns false if they all return false.
                 */
                CompoundEdit.prototype.isSignificant = function () {
                    var cursor = this.edits.elements();
                    while ((cursor.hasMoreElements())) {
                        if (cursor.nextElement().isSignificant()) {
                            return true;
                        }
                    }
                    ;
                    return false;
                };
                /**
                 * Returns <code>getPresentationName</code> from the
                 * last <code>UndoableEdit</code> added to
                 * <code>edits</code>. If <code>edits</code> is empty,
                 * calls super.
                 */
                CompoundEdit.prototype.getPresentationName = function () {
                    var last = this.lastEdit();
                    if (last != null) {
                        return last.getPresentationName();
                    }
                    else {
                        return _super.prototype.getPresentationName.call(this);
                    }
                };
                /**
                 * Returns <code>getUndoPresentationName</code>
                 * from the last <code>UndoableEdit</code>
                 * added to <code>edits</code>.
                 * If <code>edits</code> is empty, calls super.
                 */
                CompoundEdit.prototype.getUndoPresentationName = function () {
                    var last = this.lastEdit();
                    if (last != null) {
                        return last.getUndoPresentationName();
                    }
                    else {
                        return _super.prototype.getUndoPresentationName.call(this);
                    }
                };
                /**
                 * Returns <code>getRedoPresentationName</code>
                 * from the last <code>UndoableEdit</code>
                 * added to <code>edits</code>.
                 * If <code>edits</code> is empty, calls super.
                 */
                CompoundEdit.prototype.getRedoPresentationName = function () {
                    var last = this.lastEdit();
                    if (last != null) {
                        return last.getRedoPresentationName();
                    }
                    else {
                        return _super.prototype.getRedoPresentationName.call(this);
                    }
                };
                /**
                 * Returns a string that displays and identifies this
                 * object's properties.
                 *
                 * @return a String representation of this object
                 */
                CompoundEdit.prototype.toString = function () {
                    return _super.prototype.toString.call(this) + " inProgress: " + this.inProgress + " edits: " + this.edits;
                };
                return CompoundEdit;
            }(javax.swing.undo.AbstractUndoableEdit));
            undo.CompoundEdit = CompoundEdit;
            CompoundEdit["__class"] = "javax.swing.undo.CompoundEdit";
            CompoundEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit", "java.io.Serializable"];
        })(undo = swing.undo || (swing.undo = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var undo;
        (function (undo) {
            /**
             * <P>StateEdit is a general edit for objects that change state.
             * Objects being edited must conform to the StateEditable interface.</P>
             *
             * <P>This edit class works by asking an object to store it's state in
             * Hashtables before and after editing occurs.  Upon undo or redo the
             * object is told to restore it's state from these Hashtables.</P>
             *
             * A state edit is used as follows:
             * <PRE>
             * // Create the edit during the "before" state of the object
             * StateEdit newEdit = new StateEdit(myObject);
             * // Modify the object
             * myObject.someStateModifyingMethod();
             * // "end" the edit when you are done modifying the object
             * newEdit.end();
             * </PRE>
             *
             * <P><EM>Note that when a StateEdit ends, it removes redundant state from
             * the Hashtables - A state Hashtable is not guaranteed to contain all
             * keys/values placed into it when the state is stored!</EM></P>
             *
             * @see StateEditable
             *
             * @author Ray Ryan
             */
            var StateEdit = (function (_super) {
                __extends(StateEdit, _super);
                /**
                 * Create and return a new StateEdit with a presentation name.
                 *
                 * @param anObject The object to watch for changing state
                 * @param name The presentation name to be used for this edit
                 *
                 * @see StateEdit
                 */
                function StateEdit(anObject, name) {
                    var _this = this;
                    if (((anObject != null && (anObject["__interfaces"] != null && anObject["__interfaces"].indexOf("javax.swing.undo.StateEditable") >= 0 || anObject.constructor != null && anObject.constructor["__interfaces"] != null && anObject.constructor["__interfaces"].indexOf("javax.swing.undo.StateEditable") >= 0)) || anObject === null) && ((typeof name === 'string') || name === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        _super.call(this);
                        (function () {
                            _this.init(anObject, name);
                        })();
                    }
                    else if (((anObject != null && (anObject["__interfaces"] != null && anObject["__interfaces"].indexOf("javax.swing.undo.StateEditable") >= 0 || anObject.constructor != null && anObject.constructor["__interfaces"] != null && anObject.constructor["__interfaces"].indexOf("javax.swing.undo.StateEditable") >= 0)) || anObject === null) && name === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        _super.call(this);
                        (function () {
                            _this.init(anObject, null);
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                StateEdit.prototype.init = function (anObject, name) {
                    this.object = anObject;
                    this.preState = (new java.util.Hashtable(11));
                    this.object.storeState(this.preState);
                    this.postState = null;
                    this.undoRedoName = name;
                };
                /**
                 * Gets the post-edit state of the StateEditable object and
                 * ends the edit.
                 */
                StateEdit.prototype.end = function () {
                    this.postState = (new java.util.Hashtable(11));
                    this.object.storeState(this.postState);
                    this.removeRedundantState();
                };
                /**
                 * Tells the edited object to apply the state prior to the edit
                 */
                StateEdit.prototype.undo = function () {
                    _super.prototype.undo.call(this);
                    this.object.restoreState(this.preState);
                };
                /**
                 * Tells the edited object to apply the state after the edit
                 */
                StateEdit.prototype.redo = function () {
                    _super.prototype.redo.call(this);
                    this.object.restoreState(this.postState);
                };
                /**
                 * Gets the presentation name for this edit
                 */
                StateEdit.prototype.getPresentationName = function () {
                    return this.undoRedoName;
                };
                /**
                 * Remove redundant key/values in state hashtables.
                 */
                StateEdit.prototype.removeRedundantState = function () {
                    var uselessKeys = (new java.util.Vector());
                    var myKeys = this.preState.keys();
                    while ((myKeys.hasMoreElements())) {
                        var myKey = myKeys.nextElement();
                        if (this.postState.containsKey(myKey) && (this.postState.get(myKey) === this.preState.get(myKey))) {
                            uselessKeys.addElement(myKey);
                        }
                    }
                    ;
                    for (var i = uselessKeys.size() - 1; i >= 0; i--) {
                        var myKey = uselessKeys.elementAt(i);
                        this.preState.remove(myKey);
                        this.postState.remove(myKey);
                    }
                };
                StateEdit.RCSID = "$Id: StateEdit.java,v 1.6 1997/10/01 20:05:51 sandipc Exp $";
                return StateEdit;
            }(javax.swing.undo.AbstractUndoableEdit));
            undo.StateEdit = StateEdit;
            StateEdit["__class"] = "javax.swing.undo.StateEdit";
            StateEdit["__interfaces"] = ["javax.swing.undo.UndoableEdit", "java.io.Serializable"];
        })(undo = swing.undo || (swing.undo = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var sun;
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Order0 = (function (_super) {
                __extends(Order0, _super);
                function Order0(x, y) {
                    _super.call(this, sun.awt.geom.Curve.INCREASING);
                    this.x = 0;
                    this.y = 0;
                    this.x = x;
                    this.y = y;
                }
                Order0.prototype.getOrder = function () {
                    return 0;
                };
                Order0.prototype.getXTop = function () {
                    return this.x;
                };
                Order0.prototype.getYTop = function () {
                    return this.y;
                };
                Order0.prototype.getXBot = function () {
                    return this.x;
                };
                Order0.prototype.getYBot = function () {
                    return this.y;
                };
                Order0.prototype.getXMin = function () {
                    return this.x;
                };
                Order0.prototype.getXMax = function () {
                    return this.x;
                };
                Order0.prototype.getX0 = function () {
                    return this.x;
                };
                Order0.prototype.getY0 = function () {
                    return this.y;
                };
                Order0.prototype.getX1 = function () {
                    return this.x;
                };
                Order0.prototype.getY1 = function () {
                    return this.y;
                };
                Order0.prototype.XforY = function (y) {
                    return y;
                };
                Order0.prototype.TforY = function (y) {
                    return 0;
                };
                Order0.prototype.XforT = function (t) {
                    return this.x;
                };
                Order0.prototype.YforT = function (t) {
                    return this.y;
                };
                Order0.prototype.dXforT = function (t, deriv) {
                    return 0;
                };
                Order0.prototype.dYforT = function (t, deriv) {
                    return 0;
                };
                Order0.prototype.nextVertical = function (t0, t1) {
                    return t1;
                };
                Order0.prototype.crossingsFor = function (x, y) {
                    return 0;
                };
                Order0.prototype.accumulateCrossings = function (c) {
                    return (this.x > c.getXLo() && this.x < c.getXHi() && this.y > c.getYLo() && this.y < c.getYHi());
                };
                Order0.prototype.enlarge = function (r) {
                    r.add(this.x, this.y);
                };
                Order0.prototype.getSubCurve = function (ystart, yend, dir) {
                    var _this = this;
                    if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && ((typeof dir === 'number') || dir === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            return _this;
                        })();
                    }
                    else if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && dir === undefined) {
                        return this.getSubCurve$double$double(ystart, yend);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Order0.prototype.getReversedCurve = function () {
                    return this;
                };
                Order0.prototype.getSegment = function (coords) {
                    coords[0] = this.x;
                    coords[1] = this.y;
                    return java.awt.geom.PathIterator.SEG_MOVETO;
                };
                return Order0;
            }(sun.awt.geom.Curve));
            geom.Order0 = Order0;
            Order0["__class"] = "sun.awt.geom.Order0";
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var sun;
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Order1 = (function (_super) {
                __extends(Order1, _super);
                function Order1(x0, y0, x1, y1, direction) {
                    _super.call(this, direction);
                    this.x0 = 0;
                    this.y0 = 0;
                    this.x1 = 0;
                    this.y1 = 0;
                    this.xmin = 0;
                    this.xmax = 0;
                    this.x0 = x0;
                    this.y0 = y0;
                    this.x1 = x1;
                    this.y1 = y1;
                    if (x0 < x1) {
                        this.xmin = x0;
                        this.xmax = x1;
                    }
                    else {
                        this.xmin = x1;
                        this.xmax = x0;
                    }
                }
                Order1.prototype.getOrder = function () {
                    return 1;
                };
                Order1.prototype.getXTop = function () {
                    return this.x0;
                };
                Order1.prototype.getYTop = function () {
                    return this.y0;
                };
                Order1.prototype.getXBot = function () {
                    return this.x1;
                };
                Order1.prototype.getYBot = function () {
                    return this.y1;
                };
                Order1.prototype.getXMin = function () {
                    return this.xmin;
                };
                Order1.prototype.getXMax = function () {
                    return this.xmax;
                };
                Order1.prototype.getX0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.x0 : this.x1;
                };
                Order1.prototype.getY0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.y0 : this.y1;
                };
                Order1.prototype.getX1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.x0 : this.x1;
                };
                Order1.prototype.getY1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.y0 : this.y1;
                };
                Order1.prototype.XforY = function (y) {
                    if (this.x0 === this.x1 || y <= this.y0) {
                        return this.x0;
                    }
                    if (y >= this.y1) {
                        return this.x1;
                    }
                    return (this.x0 + (y - this.y0) * (this.x1 - this.x0) / (this.y1 - this.y0));
                };
                Order1.prototype.TforY = function (y) {
                    if (y <= this.y0) {
                        return 0;
                    }
                    if (y >= this.y1) {
                        return 1;
                    }
                    return (y - this.y0) / (this.y1 - this.y0);
                };
                Order1.prototype.XforT = function (t) {
                    return this.x0 + t * (this.x1 - this.x0);
                };
                Order1.prototype.YforT = function (t) {
                    return this.y0 + t * (this.y1 - this.y0);
                };
                Order1.prototype.dXforT = function (t, deriv) {
                    switch ((deriv)) {
                        case 0:
                            return this.x0 + t * (this.x1 - this.x0);
                        case 1:
                            return (this.x1 - this.x0);
                        default:
                            return 0;
                    }
                };
                Order1.prototype.dYforT = function (t, deriv) {
                    switch ((deriv)) {
                        case 0:
                            return this.y0 + t * (this.y1 - this.y0);
                        case 1:
                            return (this.y1 - this.y0);
                        default:
                            return 0;
                    }
                };
                Order1.prototype.nextVertical = function (t0, t1) {
                    return t1;
                };
                Order1.prototype.accumulateCrossings = function (c) {
                    var xlo = c.getXLo();
                    var ylo = c.getYLo();
                    var xhi = c.getXHi();
                    var yhi = c.getYHi();
                    if (this.xmin >= xhi) {
                        return false;
                    }
                    var xstart;
                    var ystart;
                    var xend;
                    var yend;
                    if (this.y0 < ylo) {
                        if (this.y1 <= ylo) {
                            return false;
                        }
                        ystart = ylo;
                        xstart = this.XforY(ylo);
                    }
                    else {
                        if (this.y0 >= yhi) {
                            return false;
                        }
                        ystart = this.y0;
                        xstart = this.x0;
                    }
                    if (this.y1 > yhi) {
                        yend = yhi;
                        xend = this.XforY(yhi);
                    }
                    else {
                        yend = this.y1;
                        xend = this.x1;
                    }
                    if (xstart >= xhi && xend >= xhi) {
                        return false;
                    }
                    if (xstart > xlo || xend > xlo) {
                        return true;
                    }
                    c.record(ystart, yend, this.direction);
                    return false;
                };
                Order1.prototype.enlarge = function (r) {
                    r.add(this.x0, this.y0);
                    r.add(this.x1, this.y1);
                };
                Order1.prototype.getSubCurve = function (ystart, yend, dir) {
                    var _this = this;
                    if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && ((typeof dir === 'number') || dir === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (ystart === _this.y0 && yend === _this.y1) {
                                return _this.getWithDirection(dir);
                            }
                            if (_this.x0 === _this.x1) {
                                return new Order1(_this.x0, ystart, _this.x1, yend, dir);
                            }
                            var num = _this.x0 - _this.x1;
                            var denom = _this.y0 - _this.y1;
                            var xstart = (_this.x0 + (ystart - _this.y0) * num / denom);
                            var xend = (_this.x0 + (yend - _this.y0) * num / denom);
                            return new Order1(xstart, ystart, xend, yend, dir);
                        })();
                    }
                    else if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && dir === undefined) {
                        return this.getSubCurve$double$double(ystart, yend);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Order1.prototype.getReversedCurve = function () {
                    return new Order1(this.x0, this.y0, this.x1, this.y1, -this.direction);
                };
                Order1.prototype.compareTo = function (other, yrange) {
                    if (!(other != null && other instanceof sun.awt.geom.Order1)) {
                        return _super.prototype.compareTo.call(this, other, yrange);
                    }
                    var c1 = other;
                    if (yrange[1] <= yrange[0]) {
                        throw new java.lang.InternalError("yrange already screwed up...");
                    }
                    yrange[1] = Math.min(Math.min(yrange[1], this.y1), c1.y1);
                    if (yrange[1] <= yrange[0]) {
                        throw new java.lang.InternalError("backstepping from " + yrange[0] + " to " + yrange[1]);
                    }
                    if (this.xmax <= c1.xmin) {
                        return (this.xmin === c1.xmax) ? 0 : -1;
                    }
                    if (this.xmin >= c1.xmax) {
                        return 1;
                    }
                    var dxa = this.x1 - this.x0;
                    var dya = this.y1 - this.y0;
                    var dxb = c1.x1 - c1.x0;
                    var dyb = c1.y1 - c1.y0;
                    var denom = dxb * dya - dxa * dyb;
                    var y;
                    if (denom !== 0) {
                        var num = ((this.x0 - c1.x0) * dya * dyb - this.y0 * dxa * dyb + c1.y0 * dxb * dya);
                        y = num / denom;
                        if (y <= yrange[0]) {
                            y = Math.min(this.y1, c1.y1);
                        }
                        else {
                            if (y < yrange[1]) {
                                yrange[1] = y;
                            }
                            y = Math.max(this.y0, c1.y0);
                        }
                    }
                    else {
                        y = Math.max(this.y0, c1.y0);
                    }
                    return geom.Curve.orderof(this.XforY(y), c1.XforY(y));
                };
                Order1.prototype.getSegment = function (coords) {
                    if (this.direction === sun.awt.geom.Curve.INCREASING) {
                        coords[0] = this.x1;
                        coords[1] = this.y1;
                    }
                    else {
                        coords[0] = this.x0;
                        coords[1] = this.y0;
                    }
                    return java.awt.geom.PathIterator.SEG_LINETO;
                };
                return Order1;
            }(sun.awt.geom.Curve));
            geom.Order1 = Order1;
            Order1["__class"] = "sun.awt.geom.Order1";
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var sun;
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Order2 = (function (_super) {
                __extends(Order2, _super);
                function Order2(x0, y0, cx0, cy0, x1, y1, direction) {
                    _super.call(this, direction);
                    this.x0 = 0;
                    this.y0 = 0;
                    this.cx0 = 0;
                    this.cy0 = 0;
                    this.x1 = 0;
                    this.y1 = 0;
                    this.xmin = 0;
                    this.xmax = 0;
                    this.xcoeff0 = 0;
                    this.xcoeff1 = 0;
                    this.xcoeff2 = 0;
                    this.ycoeff0 = 0;
                    this.ycoeff1 = 0;
                    this.ycoeff2 = 0;
                    if (cy0 < y0) {
                        cy0 = y0;
                    }
                    else if (cy0 > y1) {
                        cy0 = y1;
                    }
                    this.x0 = x0;
                    this.y0 = y0;
                    this.cx0 = cx0;
                    this.cy0 = cy0;
                    this.x1 = x1;
                    this.y1 = y1;
                    this.xmin = Math.min(Math.min(x0, x1), cx0);
                    this.xmax = Math.max(Math.max(x0, x1), cx0);
                    this.xcoeff0 = x0;
                    this.xcoeff1 = cx0 + cx0 - x0 - x0;
                    this.xcoeff2 = x0 - cx0 - cx0 + x1;
                    this.ycoeff0 = y0;
                    this.ycoeff1 = cy0 + cy0 - y0 - y0;
                    this.ycoeff2 = y0 - cy0 - cy0 + y1;
                }
                Order2.insert = function (curves, tmp, x0, y0, cx0, cy0, x1, y1, direction) {
                    var numparams = Order2.getHorizontalParams(y0, cy0, y1, tmp);
                    if (numparams === 0) {
                        Order2.addInstance(curves, x0, y0, cx0, cy0, x1, y1, direction);
                        return;
                    }
                    var t = tmp[0];
                    tmp[0] = x0;
                    tmp[1] = y0;
                    tmp[2] = cx0;
                    tmp[3] = cy0;
                    tmp[4] = x1;
                    tmp[5] = y1;
                    Order2.split(tmp, 0, t);
                    var i0 = (direction === sun.awt.geom.Curve.INCREASING) ? 0 : 4;
                    var i1 = 4 - i0;
                    Order2.addInstance(curves, tmp[i0], tmp[i0 + 1], tmp[i0 + 2], tmp[i0 + 3], tmp[i0 + 4], tmp[i0 + 5], direction);
                    Order2.addInstance(curves, tmp[i1], tmp[i1 + 1], tmp[i1 + 2], tmp[i1 + 3], tmp[i1 + 4], tmp[i1 + 5], direction);
                };
                Order2.addInstance = function (curves, x0, y0, cx0, cy0, x1, y1, direction) {
                    if (y0 > y1) {
                        curves.add(new Order2(x1, y1, cx0, cy0, x0, y0, -direction));
                    }
                    else if (y1 > y0) {
                        curves.add(new Order2(x0, y0, cx0, cy0, x1, y1, direction));
                    }
                };
                Order2.getHorizontalParams = function (c0, cp, c1, ret) {
                    if (c0 <= cp && cp <= c1) {
                        return 0;
                    }
                    c0 -= cp;
                    c1 -= cp;
                    var denom = c0 + c1;
                    if (denom === 0) {
                        return 0;
                    }
                    var t = c0 / denom;
                    if (t <= 0 || t >= 1) {
                        return 0;
                    }
                    ret[0] = t;
                    return 1;
                };
                Order2.split = function (coords, pos, t) {
                    var x0;
                    var y0;
                    var cx;
                    var cy;
                    var x1;
                    var y1;
                    coords[pos + 8] = x1 = coords[pos + 4];
                    coords[pos + 9] = y1 = coords[pos + 5];
                    cx = coords[pos + 2];
                    cy = coords[pos + 3];
                    x1 = cx + (x1 - cx) * t;
                    y1 = cy + (y1 - cy) * t;
                    x0 = coords[pos + 0];
                    y0 = coords[pos + 1];
                    x0 = x0 + (cx - x0) * t;
                    y0 = y0 + (cy - y0) * t;
                    cx = x0 + (x1 - x0) * t;
                    cy = y0 + (y1 - y0) * t;
                    coords[pos + 2] = x0;
                    coords[pos + 3] = y0;
                    coords[pos + 4] = cx;
                    coords[pos + 5] = cy;
                    coords[pos + 6] = x1;
                    coords[pos + 7] = y1;
                };
                Order2.prototype.getOrder = function () {
                    return 2;
                };
                Order2.prototype.getXTop = function () {
                    return this.x0;
                };
                Order2.prototype.getYTop = function () {
                    return this.y0;
                };
                Order2.prototype.getXBot = function () {
                    return this.x1;
                };
                Order2.prototype.getYBot = function () {
                    return this.y1;
                };
                Order2.prototype.getXMin = function () {
                    return this.xmin;
                };
                Order2.prototype.getXMax = function () {
                    return this.xmax;
                };
                Order2.prototype.getX0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.x0 : this.x1;
                };
                Order2.prototype.getY0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.y0 : this.y1;
                };
                Order2.prototype.getCX0 = function () {
                    return this.cx0;
                };
                Order2.prototype.getCY0 = function () {
                    return this.cy0;
                };
                Order2.prototype.getX1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.x0 : this.x1;
                };
                Order2.prototype.getY1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.y0 : this.y1;
                };
                Order2.prototype.XforY = function (y) {
                    if (y <= this.y0) {
                        return this.x0;
                    }
                    if (y >= this.y1) {
                        return this.x1;
                    }
                    return this.XforT(this.TforY(y));
                };
                Order2.prototype.TforY = function (y) {
                    if (y <= this.y0) {
                        return 0;
                    }
                    if (y >= this.y1) {
                        return 1;
                    }
                    return Order2.TforY(y, this.ycoeff0, this.ycoeff1, this.ycoeff2);
                };
                Order2.TforY = function (y, ycoeff0, ycoeff1, ycoeff2) {
                    ycoeff0 -= y;
                    if (ycoeff2 === 0.0) {
                        var root = -ycoeff0 / ycoeff1;
                        if (root >= 0 && root <= 1) {
                            return root;
                        }
                    }
                    else {
                        var d = ycoeff1 * ycoeff1 - 4.0 * ycoeff2 * ycoeff0;
                        if (d >= 0.0) {
                            d = Math.sqrt(d);
                            if (ycoeff1 < 0.0) {
                                d = -d;
                            }
                            var q = (ycoeff1 + d) / -2.0;
                            var root = q / ycoeff2;
                            if (root >= 0 && root <= 1) {
                                return root;
                            }
                            if (q !== 0.0) {
                                root = ycoeff0 / q;
                                if (root >= 0 && root <= 1) {
                                    return root;
                                }
                            }
                        }
                    }
                    var y0 = ycoeff0;
                    var y1 = ycoeff0 + ycoeff1 + ycoeff2;
                    return (0 < (y0 + y1) / 2) ? 0.0 : 1.0;
                };
                Order2.prototype.XforT = function (t) {
                    return (this.xcoeff2 * t + this.xcoeff1) * t + this.xcoeff0;
                };
                Order2.prototype.YforT = function (t) {
                    return (this.ycoeff2 * t + this.ycoeff1) * t + this.ycoeff0;
                };
                Order2.prototype.dXforT = function (t, deriv) {
                    switch ((deriv)) {
                        case 0:
                            return (this.xcoeff2 * t + this.xcoeff1) * t + this.xcoeff0;
                        case 1:
                            return 2 * this.xcoeff2 * t + this.xcoeff1;
                        case 2:
                            return 2 * this.xcoeff2;
                        default:
                            return 0;
                    }
                };
                Order2.prototype.dYforT = function (t, deriv) {
                    switch ((deriv)) {
                        case 0:
                            return (this.ycoeff2 * t + this.ycoeff1) * t + this.ycoeff0;
                        case 1:
                            return 2 * this.ycoeff2 * t + this.ycoeff1;
                        case 2:
                            return 2 * this.ycoeff2;
                        default:
                            return 0;
                    }
                };
                Order2.prototype.nextVertical = function (t0, t1) {
                    var t = -this.xcoeff1 / (2 * this.xcoeff2);
                    if (t > t0 && t < t1) {
                        return t;
                    }
                    return t1;
                };
                Order2.prototype.enlarge = function (r) {
                    r.add(this.x0, this.y0);
                    var t = -this.xcoeff1 / (2 * this.xcoeff2);
                    if (t > 0 && t < 1) {
                        r.add(this.XforT(t), this.YforT(t));
                    }
                    r.add(this.x1, this.y1);
                };
                Order2.prototype.getSubCurve = function (ystart, yend, dir) {
                    var _this = this;
                    if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && ((typeof dir === 'number') || dir === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            var t0;
                            var t1;
                            if (ystart <= _this.y0) {
                                if (yend >= _this.y1) {
                                    return _this.getWithDirection(dir);
                                }
                                t0 = 0;
                            }
                            else {
                                t0 = Order2.TforY(ystart, _this.ycoeff0, _this.ycoeff1, _this.ycoeff2);
                            }
                            if (yend >= _this.y1) {
                                t1 = 1;
                            }
                            else {
                                t1 = Order2.TforY(yend, _this.ycoeff0, _this.ycoeff1, _this.ycoeff2);
                            }
                            var eqn = new Array(10);
                            eqn[0] = _this.x0;
                            eqn[1] = _this.y0;
                            eqn[2] = _this.cx0;
                            eqn[3] = _this.cy0;
                            eqn[4] = _this.x1;
                            eqn[5] = _this.y1;
                            if (t1 < 1) {
                                Order2.split(eqn, 0, t1);
                            }
                            var i;
                            if (t0 <= 0) {
                                i = 0;
                            }
                            else {
                                Order2.split(eqn, 0, t0 / t1);
                                i = 4;
                            }
                            return new Order2(eqn[i + 0], ystart, eqn[i + 2], eqn[i + 3], eqn[i + 4], yend, dir);
                        })();
                    }
                    else if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && dir === undefined) {
                        return this.getSubCurve$double$double(ystart, yend);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Order2.prototype.getReversedCurve = function () {
                    return new Order2(this.x0, this.y0, this.cx0, this.cy0, this.x1, this.y1, -this.direction);
                };
                Order2.prototype.getSegment = function (coords) {
                    coords[0] = this.cx0;
                    coords[1] = this.cy0;
                    if (this.direction === sun.awt.geom.Curve.INCREASING) {
                        coords[2] = this.x1;
                        coords[3] = this.y1;
                    }
                    else {
                        coords[2] = this.x0;
                        coords[3] = this.y0;
                    }
                    return java.awt.geom.PathIterator.SEG_QUADTO;
                };
                Order2.prototype.controlPointString = function () {
                    return ("(" + geom.Curve.round(this.cx0) + ", " + geom.Curve.round(this.cy0) + "), ");
                };
                return Order2;
            }(sun.awt.geom.Curve));
            geom.Order2 = Order2;
            Order2["__class"] = "sun.awt.geom.Order2";
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var sun;
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Order3 = (function (_super) {
                __extends(Order3, _super);
                function Order3(x0, y0, cx0, cy0, cx1, cy1, x1, y1, direction) {
                    _super.call(this, direction);
                    this.x0 = 0;
                    this.y0 = 0;
                    this.cx0 = 0;
                    this.cy0 = 0;
                    this.cx1 = 0;
                    this.cy1 = 0;
                    this.x1 = 0;
                    this.y1 = 0;
                    this.xmin = 0;
                    this.xmax = 0;
                    this.xcoeff0 = 0;
                    this.xcoeff1 = 0;
                    this.xcoeff2 = 0;
                    this.xcoeff3 = 0;
                    this.ycoeff0 = 0;
                    this.ycoeff1 = 0;
                    this.ycoeff2 = 0;
                    this.ycoeff3 = 0;
                    this.TforY1 = 0;
                    this.YforT1 = 0;
                    this.TforY2 = 0;
                    this.YforT2 = 0;
                    this.TforY3 = 0;
                    this.YforT3 = 0;
                    if (cy0 < y0)
                        cy0 = y0;
                    if (cy1 > y1)
                        cy1 = y1;
                    this.x0 = x0;
                    this.y0 = y0;
                    this.cx0 = cx0;
                    this.cy0 = cy0;
                    this.cx1 = cx1;
                    this.cy1 = cy1;
                    this.x1 = x1;
                    this.y1 = y1;
                    this.xmin = Math.min(Math.min(x0, x1), Math.min(cx0, cx1));
                    this.xmax = Math.max(Math.max(x0, x1), Math.max(cx0, cx1));
                    this.xcoeff0 = x0;
                    this.xcoeff1 = (cx0 - x0) * 3.0;
                    this.xcoeff2 = (cx1 - cx0 - cx0 + x0) * 3.0;
                    this.xcoeff3 = x1 - (cx1 - cx0) * 3.0 - x0;
                    this.ycoeff0 = y0;
                    this.ycoeff1 = (cy0 - y0) * 3.0;
                    this.ycoeff2 = (cy1 - cy0 - cy0 + y0) * 3.0;
                    this.ycoeff3 = y1 - (cy1 - cy0) * 3.0 - y0;
                    this.YforT1 = this.YforT2 = this.YforT3 = y0;
                }
                Order3.insert = function (curves, tmp, x0, y0, cx0, cy0, cx1, cy1, x1, y1, direction) {
                    var numparams = Order3.getHorizontalParams(y0, cy0, cy1, y1, tmp);
                    if (numparams === 0) {
                        Order3.addInstance(curves, x0, y0, cx0, cy0, cx1, cy1, x1, y1, direction);
                        return;
                    }
                    tmp[3] = x0;
                    tmp[4] = y0;
                    tmp[5] = cx0;
                    tmp[6] = cy0;
                    tmp[7] = cx1;
                    tmp[8] = cy1;
                    tmp[9] = x1;
                    tmp[10] = y1;
                    var t = tmp[0];
                    if (numparams > 1 && t > tmp[1]) {
                        tmp[0] = tmp[1];
                        tmp[1] = t;
                        t = tmp[0];
                    }
                    Order3.split(tmp, 3, t);
                    if (numparams > 1) {
                        t = (tmp[1] - t) / (1 - t);
                        Order3.split(tmp, 9, t);
                    }
                    var index = 3;
                    if (direction === sun.awt.geom.Curve.DECREASING) {
                        index += numparams * 6;
                    }
                    while ((numparams >= 0)) {
                        Order3.addInstance(curves, tmp[index + 0], tmp[index + 1], tmp[index + 2], tmp[index + 3], tmp[index + 4], tmp[index + 5], tmp[index + 6], tmp[index + 7], direction);
                        numparams--;
                        if (direction === sun.awt.geom.Curve.INCREASING) {
                            index += 6;
                        }
                        else {
                            index -= 6;
                        }
                    }
                    ;
                };
                Order3.addInstance = function (curves, x0, y0, cx0, cy0, cx1, cy1, x1, y1, direction) {
                    if (y0 > y1) {
                        curves.add(new Order3(x1, y1, cx1, cy1, cx0, cy0, x0, y0, -direction));
                    }
                    else if (y1 > y0) {
                        curves.add(new Order3(x0, y0, cx0, cy0, cx1, cy1, x1, y1, direction));
                    }
                };
                Order3.getHorizontalParams = function (c0, cp0, cp1, c1, ret) {
                    if (c0 <= cp0 && cp0 <= cp1 && cp1 <= c1) {
                        return 0;
                    }
                    c1 -= cp1;
                    cp1 -= cp0;
                    cp0 -= c0;
                    ret[0] = cp0;
                    ret[1] = (cp1 - cp0) * 2;
                    ret[2] = (c1 - cp1 - cp1 + cp0);
                    var numroots = java.awt.geom.QuadCurve2D.solveQuadratic(ret, ret);
                    var j = 0;
                    for (var i = 0; i < numroots; i++) {
                        var t = ret[i];
                        if (t > 0 && t < 1) {
                            if (j < i) {
                                ret[j] = t;
                            }
                            j++;
                        }
                    }
                    return j;
                };
                Order3.split = function (coords, pos, t) {
                    var x0;
                    var y0;
                    var cx0;
                    var cy0;
                    var cx1;
                    var cy1;
                    var x1;
                    var y1;
                    coords[pos + 12] = x1 = coords[pos + 6];
                    coords[pos + 13] = y1 = coords[pos + 7];
                    cx1 = coords[pos + 4];
                    cy1 = coords[pos + 5];
                    x1 = cx1 + (x1 - cx1) * t;
                    y1 = cy1 + (y1 - cy1) * t;
                    x0 = coords[pos + 0];
                    y0 = coords[pos + 1];
                    cx0 = coords[pos + 2];
                    cy0 = coords[pos + 3];
                    x0 = x0 + (cx0 - x0) * t;
                    y0 = y0 + (cy0 - y0) * t;
                    cx0 = cx0 + (cx1 - cx0) * t;
                    cy0 = cy0 + (cy1 - cy0) * t;
                    cx1 = cx0 + (x1 - cx0) * t;
                    cy1 = cy0 + (y1 - cy0) * t;
                    cx0 = x0 + (cx0 - x0) * t;
                    cy0 = y0 + (cy0 - y0) * t;
                    coords[pos + 2] = x0;
                    coords[pos + 3] = y0;
                    coords[pos + 4] = cx0;
                    coords[pos + 5] = cy0;
                    coords[pos + 6] = cx0 + (cx1 - cx0) * t;
                    coords[pos + 7] = cy0 + (cy1 - cy0) * t;
                    coords[pos + 8] = cx1;
                    coords[pos + 9] = cy1;
                    coords[pos + 10] = x1;
                    coords[pos + 11] = y1;
                };
                Order3.prototype.getOrder = function () {
                    return 3;
                };
                Order3.prototype.getXTop = function () {
                    return this.x0;
                };
                Order3.prototype.getYTop = function () {
                    return this.y0;
                };
                Order3.prototype.getXBot = function () {
                    return this.x1;
                };
                Order3.prototype.getYBot = function () {
                    return this.y1;
                };
                Order3.prototype.getXMin = function () {
                    return this.xmin;
                };
                Order3.prototype.getXMax = function () {
                    return this.xmax;
                };
                Order3.prototype.getX0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.x0 : this.x1;
                };
                Order3.prototype.getY0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.y0 : this.y1;
                };
                Order3.prototype.getCX0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.cx0 : this.cx1;
                };
                Order3.prototype.getCY0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.cy0 : this.cy1;
                };
                Order3.prototype.getCX1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.cx0 : this.cx1;
                };
                Order3.prototype.getCY1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.cy0 : this.cy1;
                };
                Order3.prototype.getX1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.x0 : this.x1;
                };
                Order3.prototype.getY1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.y0 : this.y1;
                };
                Order3.prototype.TforY = function (y) {
                    if (y <= this.y0)
                        return 0;
                    if (y >= this.y1)
                        return 1;
                    if (y === this.YforT1)
                        return this.TforY1;
                    if (y === this.YforT2)
                        return this.TforY2;
                    if (y === this.YforT3)
                        return this.TforY3;
                    if (this.ycoeff3 === 0.0) {
                        return sun.awt.geom.Order2.TforY(y, this.ycoeff0, this.ycoeff1, this.ycoeff2);
                    }
                    var a = this.ycoeff2 / this.ycoeff3;
                    var b = this.ycoeff1 / this.ycoeff3;
                    var c = (this.ycoeff0 - y) / this.ycoeff3;
                    var roots = 0;
                    var Q = (a * a - 3.0 * b) / 9.0;
                    var R = (2.0 * a * a * a - 9.0 * a * b + 27.0 * c) / 54.0;
                    var R2 = R * R;
                    var Q3 = Q * Q * Q;
                    var a_3 = a / 3.0;
                    var t;
                    if (R2 < Q3) {
                        var theta = Math.acos(R / Math.sqrt(Q3));
                        Q = -2.0 * Math.sqrt(Q);
                        t = this.refine(a, b, c, y, Q * Math.cos(theta / 3.0) - a_3);
                        if (t < 0) {
                            t = this.refine(a, b, c, y, Q * Math.cos((theta + Math.PI * 2.0) / 3.0) - a_3);
                        }
                        if (t < 0) {
                            t = this.refine(a, b, c, y, Q * Math.cos((theta - Math.PI * 2.0) / 3.0) - a_3);
                        }
                    }
                    else {
                        var neg = (R < 0.0);
                        var S = Math.sqrt(R2 - Q3);
                        if (neg) {
                            R = -R;
                        }
                        var A = Math.pow(R + S, 1.0 / 3.0);
                        if (!neg) {
                            A = -A;
                        }
                        var B = (A === 0.0) ? 0.0 : (Q / A);
                        t = this.refine(a, b, c, y, (A + B) - a_3);
                    }
                    if (t < 0) {
                        var t0 = 0;
                        var t1 = 1;
                        while ((true)) {
                            t = (t0 + t1) / 2;
                            if (t === t0 || t === t1) {
                                break;
                            }
                            var yt = this.YforT(t);
                            if (yt < y) {
                                t0 = t;
                            }
                            else if (yt > y) {
                                t1 = t;
                            }
                            else {
                                break;
                            }
                        }
                        ;
                    }
                    if (t >= 0) {
                        this.TforY3 = this.TforY2;
                        this.YforT3 = this.YforT2;
                        this.TforY2 = this.TforY1;
                        this.YforT2 = this.YforT1;
                        this.TforY1 = t;
                        this.YforT1 = y;
                    }
                    return t;
                };
                Order3.prototype.refine = function (a, b, c, target, t) {
                    if (t < -0.1 || t > 1.1) {
                        return -1;
                    }
                    var y = this.YforT(t);
                    var t0;
                    var t1;
                    if (y < target) {
                        t0 = t;
                        t1 = 1;
                    }
                    else {
                        t0 = 0;
                        t1 = t;
                    }
                    var origt = t;
                    var origy = y;
                    var useslope = true;
                    while ((y !== target)) {
                        if (!useslope) {
                            var t2 = (t0 + t1) / 2;
                            if (t2 === t0 || t2 === t1) {
                                break;
                            }
                            t = t2;
                        }
                        else {
                            var slope = this.dYforT(t, 1);
                            if (slope === 0) {
                                useslope = false;
                                continue;
                            }
                            var t2 = t + ((target - y) / slope);
                            if (t2 === t || t2 <= t0 || t2 >= t1) {
                                useslope = false;
                                continue;
                            }
                            t = t2;
                        }
                        y = this.YforT(t);
                        if (y < target) {
                            t0 = t;
                        }
                        else if (y > target) {
                            t1 = t;
                        }
                        else {
                            break;
                        }
                    }
                    ;
                    var verbose = false;
                    if (false && t >= 0 && t <= 1) {
                        y = this.YforT(t);
                        var tdiff = geom.Curve.diffbits(t, origt);
                        var ydiff = geom.Curve.diffbits(y, origy);
                        var yerr = geom.Curve.diffbits(y, target);
                        if (yerr > 0 || (verbose && tdiff > 0)) {
                            console.info("target was y = " + target);
                            console.info("original was y = " + origy + ", t = " + origt);
                            console.info("final was y = " + y + ", t = " + t);
                            console.info("t diff is " + tdiff);
                            console.info("y diff is " + ydiff);
                            console.info("y error is " + yerr);
                            var tlow = geom.Curve.prev(t);
                            var ylow = this.YforT(tlow);
                            var thi = geom.Curve.next(t);
                            var yhi = this.YforT(thi);
                            if (Math.abs(target - ylow) < Math.abs(target - y) || Math.abs(target - yhi) < Math.abs(target - y)) {
                                console.info("adjacent y\'s = [" + ylow + ", " + yhi + "]");
                            }
                        }
                    }
                    return (t > 1) ? -1 : t;
                };
                Order3.prototype.XforY = function (y) {
                    if (y <= this.y0) {
                        return this.x0;
                    }
                    if (y >= this.y1) {
                        return this.x1;
                    }
                    return this.XforT(this.TforY(y));
                };
                Order3.prototype.XforT = function (t) {
                    return (((this.xcoeff3 * t) + this.xcoeff2) * t + this.xcoeff1) * t + this.xcoeff0;
                };
                Order3.prototype.YforT = function (t) {
                    return (((this.ycoeff3 * t) + this.ycoeff2) * t + this.ycoeff1) * t + this.ycoeff0;
                };
                Order3.prototype.dXforT = function (t, deriv) {
                    switch ((deriv)) {
                        case 0:
                            return (((this.xcoeff3 * t) + this.xcoeff2) * t + this.xcoeff1) * t + this.xcoeff0;
                        case 1:
                            return ((3 * this.xcoeff3 * t) + 2 * this.xcoeff2) * t + this.xcoeff1;
                        case 2:
                            return (6 * this.xcoeff3 * t) + 2 * this.xcoeff2;
                        case 3:
                            return 6 * this.xcoeff3;
                        default:
                            return 0;
                    }
                };
                Order3.prototype.dYforT = function (t, deriv) {
                    switch ((deriv)) {
                        case 0:
                            return (((this.ycoeff3 * t) + this.ycoeff2) * t + this.ycoeff1) * t + this.ycoeff0;
                        case 1:
                            return ((3 * this.ycoeff3 * t) + 2 * this.ycoeff2) * t + this.ycoeff1;
                        case 2:
                            return (6 * this.ycoeff3 * t) + 2 * this.ycoeff2;
                        case 3:
                            return 6 * this.ycoeff3;
                        default:
                            return 0;
                    }
                };
                Order3.prototype.nextVertical = function (t0, t1) {
                    var eqn = [this.xcoeff1, 2 * this.xcoeff2, 3 * this.xcoeff3];
                    var numroots = java.awt.geom.QuadCurve2D.solveQuadratic(eqn, eqn);
                    for (var i = 0; i < numroots; i++) {
                        if (eqn[i] > t0 && eqn[i] < t1) {
                            t1 = eqn[i];
                        }
                    }
                    return t1;
                };
                Order3.prototype.enlarge = function (r) {
                    r.add(this.x0, this.y0);
                    var eqn = [this.xcoeff1, 2 * this.xcoeff2, 3 * this.xcoeff3];
                    var numroots = java.awt.geom.QuadCurve2D.solveQuadratic(eqn, eqn);
                    for (var i = 0; i < numroots; i++) {
                        var t = eqn[i];
                        if (t > 0 && t < 1) {
                            r.add(this.XforT(t), this.YforT(t));
                        }
                    }
                    r.add(this.x1, this.y1);
                };
                Order3.prototype.getSubCurve = function (ystart, yend, dir) {
                    var _this = this;
                    if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && ((typeof dir === 'number') || dir === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            if (ystart <= _this.y0 && yend >= _this.y1) {
                                return _this.getWithDirection(dir);
                            }
                            var eqn = new Array(14);
                            var t0;
                            var t1;
                            t0 = _this.TforY(ystart);
                            t1 = _this.TforY(yend);
                            eqn[0] = _this.x0;
                            eqn[1] = _this.y0;
                            eqn[2] = _this.cx0;
                            eqn[3] = _this.cy0;
                            eqn[4] = _this.cx1;
                            eqn[5] = _this.cy1;
                            eqn[6] = _this.x1;
                            eqn[7] = _this.y1;
                            if (t0 > t1) {
                                var t = t0;
                                t0 = t1;
                                t1 = t;
                            }
                            if (t1 < 1) {
                                Order3.split(eqn, 0, t1);
                            }
                            var i;
                            if (t0 <= 0) {
                                i = 0;
                            }
                            else {
                                Order3.split(eqn, 0, t0 / t1);
                                i = 6;
                            }
                            return new Order3(eqn[i + 0], ystart, eqn[i + 2], eqn[i + 3], eqn[i + 4], eqn[i + 5], eqn[i + 6], yend, dir);
                        })();
                    }
                    else if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && dir === undefined) {
                        return this.getSubCurve$double$double(ystart, yend);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Order3.prototype.getReversedCurve = function () {
                    return new Order3(this.x0, this.y0, this.cx0, this.cy0, this.cx1, this.cy1, this.x1, this.y1, -this.direction);
                };
                Order3.prototype.getSegment = function (coords) {
                    if (this.direction === sun.awt.geom.Curve.INCREASING) {
                        coords[0] = this.cx0;
                        coords[1] = this.cy0;
                        coords[2] = this.cx1;
                        coords[3] = this.cy1;
                        coords[4] = this.x1;
                        coords[5] = this.y1;
                    }
                    else {
                        coords[0] = this.cx1;
                        coords[1] = this.cy1;
                        coords[2] = this.cx0;
                        coords[3] = this.cy0;
                        coords[4] = this.x0;
                        coords[5] = this.y0;
                    }
                    return java.awt.geom.PathIterator.SEG_CUBICTO;
                };
                Order3.prototype.controlPointString = function () {
                    return (("(" + geom.Curve.round(this.getCX0()) + ", " + geom.Curve.round(this.getCY0()) + "), ") + ("(" + geom.Curve.round(this.getCX1()) + ", " + geom.Curve.round(this.getCY1()) + "), "));
                };
                return Order3;
            }(sun.awt.geom.Curve));
            geom.Order3 = Order3;
            Order3["__class"] = "sun.awt.geom.Order3";
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var sun;
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var AreaOp = (function () {
                function AreaOp() {
                    this.verbose = false;
                }
                AreaOp.prototype.calculate = function (left, right) {
                    var edges = (new java.util.Vector());
                    AreaOp.addEdges(edges, left, AreaOp.CTAG_LEFT);
                    AreaOp.addEdges(edges, right, AreaOp.CTAG_RIGHT);
                    edges = this.pruneEdges(edges);
                    if (this.verbose) {
                        console.info("result: ");
                        var numcurves = edges.size();
                        var curvelist = edges.toArray(new Array(numcurves));
                        for (var i = 0; i < numcurves; i++) {
                            console.info("curvelist[" + i + "] = " + curvelist[i]);
                        }
                    }
                    return edges;
                };
                AreaOp.addEdges = function (edges, curves, curvetag) {
                    var enum_ = curves.elements();
                    while ((enum_.hasMoreElements())) {
                        var c = enum_.nextElement();
                        if (c.getOrder() > 0) {
                            edges.add(new sun.awt.geom.Edge(c, curvetag));
                        }
                    }
                    ;
                };
                AreaOp.YXTopComparator_$LI$ = function () { if (AreaOp.YXTopComparator == null)
                    AreaOp.YXTopComparator = new AreaOp.AreaOp$0(); return AreaOp.YXTopComparator; };
                ;
                AreaOp.prototype.pruneEdges = function (edges) {
                    var numedges = edges.size();
                    if (numedges < 2) {
                        return edges;
                    }
                    var edgelist = edges.toArray(new Array(numedges));
                    java.util.Arrays.sort(edgelist, AreaOp.YXTopComparator_$LI$());
                    if (this.verbose) {
                        console.info("pruning: ");
                        for (var i = 0; i < numedges; i++) {
                            console.info("edgelist[" + i + "] = " + edgelist[i]);
                        }
                    }
                    var e;
                    var left = 0;
                    var right = 0;
                    var cur = 0;
                    var next = 0;
                    var yrange = new Array(2);
                    var subcurves = (new java.util.Vector());
                    var chains = (new java.util.Vector());
                    var links = (new java.util.Vector());
                    while ((left < numedges)) {
                        var y = yrange[0];
                        for (cur = next = right - 1; cur >= left; cur--) {
                            e = edgelist[cur];
                            if (e.getCurve().getYBot() > y) {
                                if (next > cur) {
                                    edgelist[next] = e;
                                }
                                next--;
                            }
                        }
                        left = next + 1;
                        if (left >= right) {
                            if (right >= numedges) {
                                break;
                            }
                            y = edgelist[right].getCurve().getYTop();
                            if (y > yrange[0]) {
                                AreaOp.finalizeSubCurves(subcurves, chains);
                            }
                            yrange[0] = y;
                        }
                        while ((right < numedges)) {
                            e = edgelist[right];
                            if (e.getCurve().getYTop() > y) {
                                break;
                            }
                            right++;
                        }
                        ;
                        yrange[1] = edgelist[left].getCurve().getYBot();
                        if (right < numedges) {
                            y = edgelist[right].getCurve().getYTop();
                            if (yrange[1] > y) {
                                yrange[1] = y;
                            }
                        }
                        if (this.verbose) {
                            console.info("current line: y = [" + yrange[0] + ", " + yrange[1] + "]");
                            for (cur = left; cur < right; cur++) {
                                console.info("  " + edgelist[cur]);
                            }
                        }
                        var nexteq = 1;
                        for (cur = left; cur < right; cur++) {
                            e = edgelist[cur];
                            e.setEquivalence(0);
                            for (next = cur; next > left; next--) {
                                var prevedge = edgelist[next - 1];
                                var ordering = e.compareTo(prevedge, yrange);
                                if (yrange[1] <= yrange[0]) {
                                    throw new java.lang.InternalError("backstepping to " + yrange[1] + " from " + yrange[0]);
                                }
                                if (ordering >= 0) {
                                    if (ordering === 0) {
                                        var eq = prevedge.getEquivalence();
                                        if (eq === 0) {
                                            eq = nexteq++;
                                            prevedge.setEquivalence(eq);
                                        }
                                        e.setEquivalence(eq);
                                    }
                                    break;
                                }
                                edgelist[next] = prevedge;
                            }
                            edgelist[next] = e;
                        }
                        if (this.verbose) {
                            console.info("current sorted line: y = [" + yrange[0] + ", " + yrange[1] + "]");
                            for (cur = left; cur < right; cur++) {
                                console.info("  " + edgelist[cur]);
                            }
                        }
                        this.newRow();
                        var ystart = yrange[0];
                        var yend = yrange[1];
                        for (cur = left; cur < right; cur++) {
                            e = edgelist[cur];
                            var etag = void 0;
                            var eq = e.getEquivalence();
                            if (eq !== 0) {
                                var origstate = this.getState();
                                etag = (origstate === AreaOp.RSTAG_INSIDE ? AreaOp.ETAG_EXIT : AreaOp.ETAG_ENTER);
                                var activematch = null;
                                var longestmatch = e;
                                var furthesty = yend;
                                do {
                                    this.classify(e);
                                    if (activematch == null && e.isActiveFor(ystart, etag)) {
                                        activematch = e;
                                    }
                                    y = e.getCurve().getYBot();
                                    if (y > furthesty) {
                                        longestmatch = e;
                                        furthesty = y;
                                    }
                                } while ((++cur < right && (e = edgelist[cur]).getEquivalence() === eq));
                                --cur;
                                if (this.getState() === origstate) {
                                    etag = AreaOp.ETAG_IGNORE;
                                }
                                else {
                                    e = (activematch != null ? activematch : longestmatch);
                                }
                            }
                            else {
                                etag = this.classify(e);
                            }
                            if (etag !== AreaOp.ETAG_IGNORE) {
                                e.record(yend, etag);
                                links.add(new sun.awt.geom.CurveLink(e.getCurve(), ystart, yend, etag));
                            }
                        }
                        if (this.getState() !== AreaOp.RSTAG_OUTSIDE) {
                            console.info("Still inside at end of active edge list!");
                            console.info("num curves = " + (right - left));
                            console.info("num links = " + links.size());
                            console.info("y top = " + yrange[0]);
                            if (right < numedges) {
                                console.info("y top of next curve = " + edgelist[right].getCurve().getYTop());
                            }
                            else {
                                console.info("no more curves");
                            }
                            for (cur = left; cur < right; cur++) {
                                e = edgelist[cur];
                                console.info(e);
                                var eq = e.getEquivalence();
                                if (eq !== 0) {
                                    console.info("  was equal to " + eq + "...");
                                }
                            }
                        }
                        if (this.verbose) {
                            console.info("new links:");
                            for (var i = 0; i < links.size(); i++) {
                                var link = links.elementAt(i);
                                console.info("  " + link.getSubCurve());
                            }
                        }
                        AreaOp.resolveLinks(subcurves, chains, links);
                        links.clear();
                        yrange[0] = yend;
                    }
                    ;
                    AreaOp.finalizeSubCurves(subcurves, chains);
                    var ret = (new java.util.Vector());
                    var enum_ = subcurves.elements();
                    while ((enum_.hasMoreElements())) {
                        var link = enum_.nextElement();
                        ret.add(link.getMoveto());
                        var nextlink = link;
                        while (((nextlink = nextlink.getNext()) != null)) {
                            if (!link.absorb(nextlink)) {
                                ret.add(link.getSubCurve());
                                link = nextlink;
                            }
                        }
                        ;
                        ret.add(link.getSubCurve());
                    }
                    ;
                    return ret;
                };
                AreaOp.finalizeSubCurves = function (subcurves, chains) {
                    var numchains = chains.size();
                    if (numchains === 0) {
                        return;
                    }
                    if ((numchains & 1) !== 0) {
                        throw new java.lang.InternalError("Odd number of chains!");
                    }
                    var endlist = new Array(numchains);
                    chains.toArray(endlist);
                    for (var i = 1; i < numchains; i += 2) {
                        var open_1 = endlist[i - 1];
                        var close_1 = endlist[i];
                        var subcurve = open_1.linkTo(close_1);
                        if (subcurve != null) {
                            subcurves.add(subcurve);
                        }
                    }
                    chains.clear();
                };
                AreaOp.EmptyLinkList_$LI$ = function () { if (AreaOp.EmptyLinkList == null)
                    AreaOp.EmptyLinkList = new Array(2); return AreaOp.EmptyLinkList; };
                ;
                AreaOp.EmptyChainList_$LI$ = function () { if (AreaOp.EmptyChainList == null)
                    AreaOp.EmptyChainList = new Array(2); return AreaOp.EmptyChainList; };
                ;
                AreaOp.resolveLinks = function (subcurves, chains, links) {
                    var numlinks = links.size();
                    var linklist;
                    if (numlinks === 0) {
                        linklist = AreaOp.EmptyLinkList_$LI$();
                    }
                    else {
                        if ((numlinks & 1) !== 0) {
                            throw new java.lang.InternalError("Odd number of new curves!");
                        }
                        linklist = new Array(numlinks + 2);
                        links.toArray(linklist);
                    }
                    var numchains = chains.size();
                    var endlist;
                    if (numchains === 0) {
                        endlist = AreaOp.EmptyChainList_$LI$();
                    }
                    else {
                        if ((numchains & 1) !== 0) {
                            throw new java.lang.InternalError("Odd number of chains!");
                        }
                        endlist = new Array(numchains + 2);
                        chains.toArray(endlist);
                    }
                    var curchain = 0;
                    var curlink = 0;
                    chains.clear();
                    var chain = endlist[0];
                    var nextchain = endlist[1];
                    var link = linklist[0];
                    var nextlink = linklist[1];
                    while ((chain != null || link != null)) {
                        var connectchains = (link == null);
                        var connectlinks = (chain == null);
                        if (!connectchains && !connectlinks) {
                            connectchains = ((curchain & 1) === 0 && chain.getX() === nextchain.getX());
                            connectlinks = ((curlink & 1) === 0 && link.getX() === nextlink.getX());
                            if (!connectchains && !connectlinks) {
                                var cx = chain.getX();
                                var lx = link.getX();
                                connectchains = (nextchain != null && cx < lx && AreaOp.obstructs(nextchain.getX(), lx, curchain));
                                connectlinks = (nextlink != null && lx < cx && AreaOp.obstructs(nextlink.getX(), cx, curlink));
                            }
                        }
                        if (connectchains) {
                            var subcurve = chain.linkTo(nextchain);
                            if (subcurve != null) {
                                subcurves.add(subcurve);
                            }
                            curchain += 2;
                            chain = endlist[curchain];
                            nextchain = endlist[curchain + 1];
                        }
                        if (connectlinks) {
                            var openend = new sun.awt.geom.ChainEnd(link, null);
                            var closeend = new sun.awt.geom.ChainEnd(nextlink, openend);
                            openend.setOtherEnd(closeend);
                            chains.add(openend);
                            chains.add(closeend);
                            curlink += 2;
                            link = linklist[curlink];
                            nextlink = linklist[curlink + 1];
                        }
                        if (!connectchains && !connectlinks) {
                            chain.addLink(link);
                            chains.add(chain);
                            curchain++;
                            chain = nextchain;
                            nextchain = endlist[curchain + 1];
                            curlink++;
                            link = nextlink;
                            nextlink = linklist[curlink + 1];
                        }
                    }
                    ;
                    if ((chains.size() & 1) !== 0) {
                        console.info("Odd number of chains!");
                    }
                };
                AreaOp.obstructs = function (v1, v2, phase) {
                    return (((phase & 1) === 0) ? (v1 <= v2) : (v1 < v2));
                };
                AreaOp.CTAG_LEFT = 0;
                AreaOp.CTAG_RIGHT = 1;
                AreaOp.ETAG_IGNORE = 0;
                AreaOp.ETAG_ENTER = 1;
                AreaOp.ETAG_EXIT = -1;
                AreaOp.RSTAG_INSIDE = 1;
                AreaOp.RSTAG_OUTSIDE = -1;
                return AreaOp;
            }());
            geom.AreaOp = AreaOp;
            AreaOp["__class"] = "sun.awt.geom.AreaOp";
            var AreaOp;
            (function (AreaOp) {
                var CAGOp = (function (_super) {
                    __extends(CAGOp, _super);
                    function CAGOp() {
                        _super.call(this);
                        this.inLeft = false;
                        this.inRight = false;
                        this.inResult = false;
                    }
                    CAGOp.prototype.newRow = function () {
                        this.inLeft = false;
                        this.inRight = false;
                        this.inResult = false;
                    };
                    CAGOp.prototype.classify = function (e) {
                        if (e.getCurveTag() === sun.awt.geom.AreaOp.CTAG_LEFT) {
                            this.inLeft = !this.inLeft;
                        }
                        else {
                            this.inRight = !this.inRight;
                        }
                        var newClass = this.newClassification(this.inLeft, this.inRight);
                        if (this.inResult === newClass) {
                            return sun.awt.geom.AreaOp.ETAG_IGNORE;
                        }
                        this.inResult = newClass;
                        return (newClass ? sun.awt.geom.AreaOp.ETAG_ENTER : sun.awt.geom.AreaOp.ETAG_EXIT);
                    };
                    CAGOp.prototype.getState = function () {
                        return (this.inResult ? sun.awt.geom.AreaOp.RSTAG_INSIDE : sun.awt.geom.AreaOp.RSTAG_OUTSIDE);
                    };
                    return CAGOp;
                }(sun.awt.geom.AreaOp));
                AreaOp.CAGOp = CAGOp;
                CAGOp["__class"] = "sun.awt.geom.AreaOp.CAGOp";
                var AddOp = (function (_super) {
                    __extends(AddOp, _super);
                    function AddOp() {
                        _super.apply(this, arguments);
                    }
                    AddOp.prototype.newClassification = function (inLeft, inRight) {
                        return (inLeft || inRight);
                    };
                    return AddOp;
                }(AreaOp.CAGOp));
                AreaOp.AddOp = AddOp;
                AddOp["__class"] = "sun.awt.geom.AreaOp.AddOp";
                var SubOp = (function (_super) {
                    __extends(SubOp, _super);
                    function SubOp() {
                        _super.apply(this, arguments);
                    }
                    SubOp.prototype.newClassification = function (inLeft, inRight) {
                        return (inLeft && !inRight);
                    };
                    return SubOp;
                }(AreaOp.CAGOp));
                AreaOp.SubOp = SubOp;
                SubOp["__class"] = "sun.awt.geom.AreaOp.SubOp";
                var IntOp = (function (_super) {
                    __extends(IntOp, _super);
                    function IntOp() {
                        _super.apply(this, arguments);
                    }
                    IntOp.prototype.newClassification = function (inLeft, inRight) {
                        return (inLeft && inRight);
                    };
                    return IntOp;
                }(AreaOp.CAGOp));
                AreaOp.IntOp = IntOp;
                IntOp["__class"] = "sun.awt.geom.AreaOp.IntOp";
                var XorOp = (function (_super) {
                    __extends(XorOp, _super);
                    function XorOp() {
                        _super.apply(this, arguments);
                    }
                    XorOp.prototype.newClassification = function (inLeft, inRight) {
                        return (inLeft !== inRight);
                    };
                    return XorOp;
                }(AreaOp.CAGOp));
                AreaOp.XorOp = XorOp;
                XorOp["__class"] = "sun.awt.geom.AreaOp.XorOp";
                var NZWindOp = (function (_super) {
                    __extends(NZWindOp, _super);
                    function NZWindOp() {
                        _super.call(this);
                        this.count = 0;
                    }
                    NZWindOp.prototype.newRow = function () {
                        this.count = 0;
                    };
                    NZWindOp.prototype.classify = function (e) {
                        var newCount = this.count;
                        var type = (newCount === 0 ? sun.awt.geom.AreaOp.ETAG_ENTER : sun.awt.geom.AreaOp.ETAG_IGNORE);
                        newCount += e.getCurve().getDirection();
                        this.count = newCount;
                        return (newCount === 0 ? sun.awt.geom.AreaOp.ETAG_EXIT : type);
                    };
                    NZWindOp.prototype.getState = function () {
                        return ((this.count === 0) ? sun.awt.geom.AreaOp.RSTAG_OUTSIDE : sun.awt.geom.AreaOp.RSTAG_INSIDE);
                    };
                    return NZWindOp;
                }(sun.awt.geom.AreaOp));
                AreaOp.NZWindOp = NZWindOp;
                NZWindOp["__class"] = "sun.awt.geom.AreaOp.NZWindOp";
                var EOWindOp = (function (_super) {
                    __extends(EOWindOp, _super);
                    function EOWindOp() {
                        _super.call(this);
                        this.inside = false;
                    }
                    EOWindOp.prototype.newRow = function () {
                        this.inside = false;
                    };
                    EOWindOp.prototype.classify = function (e) {
                        var newInside = !this.inside;
                        this.inside = newInside;
                        return (newInside ? sun.awt.geom.AreaOp.ETAG_ENTER : sun.awt.geom.AreaOp.ETAG_EXIT);
                    };
                    EOWindOp.prototype.getState = function () {
                        return (this.inside ? sun.awt.geom.AreaOp.RSTAG_INSIDE : sun.awt.geom.AreaOp.RSTAG_OUTSIDE);
                    };
                    return EOWindOp;
                }(sun.awt.geom.AreaOp));
                AreaOp.EOWindOp = EOWindOp;
                EOWindOp["__class"] = "sun.awt.geom.AreaOp.EOWindOp";
                var AreaOp$0 = (function () {
                    function AreaOp$0() {
                    }
                    AreaOp$0.prototype.compare = function (o1, o2) {
                        var c1 = o1.getCurve();
                        var c2 = o2.getCurve();
                        var v1;
                        var v2;
                        if ((v1 = c1.getYTop()) === (v2 = c2.getYTop())) {
                            if ((v1 = c1.getXTop()) === (v2 = c2.getXTop())) {
                                return 0;
                            }
                        }
                        if (v1 < v2) {
                            return -1;
                        }
                        return 1;
                    };
                    return AreaOp$0;
                }());
                AreaOp.AreaOp$0 = AreaOp$0;
            })(AreaOp = geom.AreaOp || (geom.AreaOp = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var event;
        (function (event) {
            /**
             * A low-level event which indicates that a container's contents
             * changed because a component was added or removed.
             * <P>
             * Container events are provided for notification purposes ONLY;
             * The AWT will automatically handle changes to the containers
             * contents internally so that the program works properly regardless of
             * whether the program is receiving these events or not.
             * <P>
             * This low-level event is generated by a container object (such as a
             * Panel) when a component is added to it or removed from it.
             * The event is passed to every <code>ContainerListener</code>
             * or <code>ContainerAdapter</code> object which registered to receive such
             * events using the component's <code>addContainerListener</code> method.
             * (<code>ContainerAdapter</code> objects implement the
             * <code>ContainerListener</code> interface.) Each such listener object
             * gets this <code>ContainerEvent</code> when the event occurs.
             * <p>
             * An unspecified behavior will be caused if the {@code id} parameter
             * of any particular {@code ContainerEvent} instance is not
             * in the range from {@code CONTAINER_FIRST} to {@code CONTAINER_LAST}.
             *
             * @see ContainerAdapter
             * @see ContainerListener
             * @see <a href="http://docs.oracle.com/javase/tutorial/uiswing/events/containerlistener.html">Tutorial: Writing a Container Listener</a>
             *
             * @author Tim Prinzing
             * @author Amy Fowler
             * @since 1.1
             */
            var ContainerEvent = (function (_super) {
                __extends(ContainerEvent, _super);
                /**
                 * Constructs a <code>ContainerEvent</code> object.
                 * <p> This method throws an
                 * <code>IllegalArgumentException</code> if <code>source</code>
                 * is <code>null</code>.
                 *
                 * @param source The <code>Component</code> object (container)
                 * that originated the event
                 * @param id     An integer indicating the type of event.
                 * For information on allowable values, see
                 * the class description for {@link ContainerEvent}
                 * @param child  the component that was added or removed
                 * @throws IllegalArgumentException if <code>source</code> is null
                 * @see #getContainer()
                 * @see #getID()
                 * @see #getChild()
                 */
                function ContainerEvent(source, id, child) {
                    _super.call(this, source, id);
                    this.child = child;
                }
                ContainerEvent.COMPONENT_ADDED_$LI$ = function () { if (ContainerEvent.COMPONENT_ADDED == null)
                    ContainerEvent.COMPONENT_ADDED = ContainerEvent.CONTAINER_FIRST; return ContainerEvent.COMPONENT_ADDED; };
                ;
                ContainerEvent.COMPONENT_REMOVED_$LI$ = function () { if (ContainerEvent.COMPONENT_REMOVED == null)
                    ContainerEvent.COMPONENT_REMOVED = 1 + ContainerEvent.CONTAINER_FIRST; return ContainerEvent.COMPONENT_REMOVED; };
                ;
                /**
                 * Returns the originator of the event.
                 *
                 * @return the <code>Container</code> object that originated
                 * the event, or <code>null</code> if the object is not a
                 * <code>Container</code>.
                 */
                ContainerEvent.prototype.getContainer = function () {
                    return (this.source != null && this.source instanceof java.awt.Container) ? this.source : null;
                };
                /**
                 * Returns the component that was affected by the event.
                 *
                 * @return the Component object that was added or removed
                 */
                ContainerEvent.prototype.getChild = function () {
                    return this.child;
                };
                /**
                 * Returns a parameter string identifying this event.
                 * This method is useful for event-logging and for debugging.
                 *
                 * @return a string identifying the event and its attributes
                 */
                ContainerEvent.prototype.paramString = function () {
                    var typeStr;
                    switch ((this.id)) {
                        case ContainerEvent.COMPONENT_ADDED_$LI$():
                            typeStr = "COMPONENT_ADDED";
                            break;
                        case ContainerEvent.COMPONENT_REMOVED_$LI$():
                            typeStr = "COMPONENT_REMOVED";
                            break;
                        default:
                            typeStr = "unknown type";
                    }
                    return typeStr + ",child=" + this.child.getName();
                };
                /**
                 * The first number in the range of ids used for container events.
                 */
                ContainerEvent.CONTAINER_FIRST = 300;
                /**
                 * The last number in the range of ids used for container events.
                 */
                ContainerEvent.CONTAINER_LAST = 301;
                ContainerEvent.serialVersionUID = -4114942250539772041;
                return ContainerEvent;
            }(java.awt.event.ComponentEvent));
            event.ContainerEvent = ContainerEvent;
            ContainerEvent["__class"] = "java.awt.event.ContainerEvent";
            ContainerEvent["__interfaces"] = ["java.io.Serializable"];
        })(event = awt.event || (awt.event = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var event;
        (function (event) {
            /**
             * A low-level event which indicates that a Component has gained or lost the
             * input focus. This low-level event is generated by a Component (such as a
             * TextField). The event is passed to every <code>FocusListener</code> or
             * <code>FocusAdapter</code> object which registered to receive such events
             * using the Component's <code>addFocusListener</code> method. (<code>
             * FocusAdapter</code> objects implement the <code>FocusListener</code>
             * interface.) Each such listener object gets this <code>FocusEvent</code> when
             * the event occurs.
             * <p>
             * There are two levels of focus events: permanent and temporary. Permanent
             * focus change events occur when focus is directly moved from one Component to
             * another, such as through a call to requestFocus() or as the user uses the
             * TAB key to traverse Components. Temporary focus change events occur when
             * focus is temporarily lost for a Component as the indirect result of another
             * operation, such as Window deactivation or a Scrollbar drag. In this case,
             * the original focus state will automatically be restored once that operation
             * is finished, or, for the case of Window deactivation, when the Window is
             * reactivated. Both permanent and temporary focus events are delivered using
             * the FOCUS_GAINED and FOCUS_LOST event ids; the level may be distinguished in
             * the event using the isTemporary() method.
             * <p>
             * An unspecified behavior will be caused if the {@code id} parameter
             * of any particular {@code FocusEvent} instance is not
             * in the range from {@code FOCUS_FIRST} to {@code FOCUS_LAST}.
             *
             * @see FocusAdapter
             * @see FocusListener
             * @see <a href="http://docs.oracle.com/javase/tutorial/uiswing/events/focuslistener.html">Tutorial: Writing a Focus Listener</a>
             *
             * @author Carl Quinn
             * @author Amy Fowler
             * @since 1.1
             */
            var FocusEvent = (function (_super) {
                __extends(FocusEvent, _super);
                /**
                 * Constructs a <code>FocusEvent</code> object with the
                 * specified temporary state and opposite <code>Component</code>.
                 * The opposite <code>Component</code> is the other
                 * <code>Component</code> involved in this focus change.
                 * For a <code>FOCUS_GAINED</code> event, this is the
                 * <code>Component</code> that lost focus. For a
                 * <code>FOCUS_LOST</code> event, this is the <code>Component</code>
                 * that gained focus. If this focus change occurs with a native
                 * application, with a Java application in a different VM,
                 * or with no other <code>Component</code>, then the opposite
                 * <code>Component</code> is <code>null</code>.
                 * <p> This method throws an
                 * <code>IllegalArgumentException</code> if <code>source</code>
                 * is <code>null</code>.
                 *
                 * @param source     The <code>Component</code> that originated the event
                 * @param id         An integer indicating the type of event.
                 * For information on allowable values, see
                 * the class description for {@link FocusEvent}
                 * @param temporary  Equals <code>true</code> if the focus change is temporary;
                 * <code>false</code> otherwise
                 * @param opposite   The other Component involved in the focus change,
                 * or <code>null</code>
                 * @throws IllegalArgumentException if <code>source</code> equals {@code null}
                 * @see #getSource()
                 * @see #getID()
                 * @see #isTemporary()
                 * @see #getOppositeComponent()
                 * @since 1.4
                 */
                function FocusEvent(source, id, temporary, opposite) {
                    if (temporary === void 0) { temporary = false; }
                    if (opposite === void 0) { opposite = null; }
                    _super.call(this, source, id);
                    this.temporary = false;
                    this.temporary = temporary;
                    this.opposite = opposite;
                }
                FocusEvent.FOCUS_GAINED_$LI$ = function () { if (FocusEvent.FOCUS_GAINED == null)
                    FocusEvent.FOCUS_GAINED = FocusEvent.FOCUS_FIRST; return FocusEvent.FOCUS_GAINED; };
                ;
                FocusEvent.FOCUS_LOST_$LI$ = function () { if (FocusEvent.FOCUS_LOST == null)
                    FocusEvent.FOCUS_LOST = 1 + FocusEvent.FOCUS_FIRST; return FocusEvent.FOCUS_LOST; };
                ;
                /**
                 * Identifies the focus change event as temporary or permanent.
                 *
                 * @return <code>true</code> if the focus change is temporary;
                 * <code>false</code> otherwise
                 */
                FocusEvent.prototype.isTemporary = function () {
                    return this.temporary;
                };
                /**
                 * Returns the other Component involved in this focus change. For a
                 * FOCUS_GAINED event, this is the Component that lost focus. For a
                 * FOCUS_LOST event, this is the Component that gained focus. If this
                 * focus change occurs with a native application, with a Java application
                 * in a different VM or context, or with no other Component, then null is
                 * returned.
                 *
                 * @return the other Component involved in the focus change, or null
                 * @since 1.4
                 */
                FocusEvent.prototype.getOppositeComponent = function () {
                    return this.opposite;
                };
                /**
                 * Returns a parameter string identifying this event.
                 * This method is useful for event-logging and for debugging.
                 *
                 * @return a string identifying the event and its attributes
                 */
                FocusEvent.prototype.paramString = function () {
                    var typeStr;
                    switch ((this.id)) {
                        case FocusEvent.FOCUS_GAINED_$LI$():
                            typeStr = "FOCUS_GAINED";
                            break;
                        case FocusEvent.FOCUS_LOST_$LI$():
                            typeStr = "FOCUS_LOST";
                            break;
                        default:
                            typeStr = "unknown type";
                    }
                    return typeStr + (this.temporary ? ",temporary" : ",permanent") + ",opposite=" + this.getOppositeComponent();
                };
                /**
                 * The first number in the range of ids used for focus events.
                 */
                FocusEvent.FOCUS_FIRST = 1004;
                /**
                 * The last number in the range of ids used for focus events.
                 */
                FocusEvent.FOCUS_LAST = 1005;
                FocusEvent.serialVersionUID = 523753786457416396;
                return FocusEvent;
            }(java.awt.event.ComponentEvent));
            event.FocusEvent = FocusEvent;
            FocusEvent["__class"] = "java.awt.event.FocusEvent";
            FocusEvent["__interfaces"] = ["java.io.Serializable"];
        })(event = awt.event || (awt.event = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var event;
        (function (event) {
            var InputEvent = (function (_super) {
                __extends(InputEvent, _super);
                function InputEvent(source, id, when, modifiers) {
                    _super.call(this, source, id);
                    this.when = 0;
                    this.modifiers = 0;
                    this.when = when;
                    this.modifiers = modifiers;
                }
                InputEvent.SHIFT_MASK_$LI$ = function () { if (InputEvent.SHIFT_MASK == null)
                    InputEvent.SHIFT_MASK = java.awt.Event.SHIFT_MASK_$LI$(); return InputEvent.SHIFT_MASK; };
                ;
                InputEvent.CTRL_MASK_$LI$ = function () { if (InputEvent.CTRL_MASK == null)
                    InputEvent.CTRL_MASK = java.awt.Event.CTRL_MASK_$LI$(); return InputEvent.CTRL_MASK; };
                ;
                InputEvent.META_MASK_$LI$ = function () { if (InputEvent.META_MASK == null)
                    InputEvent.META_MASK = java.awt.Event.META_MASK_$LI$(); return InputEvent.META_MASK; };
                ;
                InputEvent.ALT_MASK_$LI$ = function () { if (InputEvent.ALT_MASK == null)
                    InputEvent.ALT_MASK = java.awt.Event.ALT_MASK_$LI$(); return InputEvent.ALT_MASK; };
                ;
                InputEvent.ALT_GRAPH_MASK_$LI$ = function () { if (InputEvent.ALT_GRAPH_MASK == null)
                    InputEvent.ALT_GRAPH_MASK = 1 << 5; return InputEvent.ALT_GRAPH_MASK; };
                ;
                InputEvent.BUTTON1_MASK_$LI$ = function () { if (InputEvent.BUTTON1_MASK == null)
                    InputEvent.BUTTON1_MASK = 1 << 4; return InputEvent.BUTTON1_MASK; };
                ;
                InputEvent.BUTTON2_MASK_$LI$ = function () { if (InputEvent.BUTTON2_MASK == null)
                    InputEvent.BUTTON2_MASK = java.awt.Event.ALT_MASK_$LI$(); return InputEvent.BUTTON2_MASK; };
                ;
                InputEvent.BUTTON3_MASK_$LI$ = function () { if (InputEvent.BUTTON3_MASK == null)
                    InputEvent.BUTTON3_MASK = java.awt.Event.META_MASK_$LI$(); return InputEvent.BUTTON3_MASK; };
                ;
                InputEvent.SHIFT_DOWN_MASK_$LI$ = function () { if (InputEvent.SHIFT_DOWN_MASK == null)
                    InputEvent.SHIFT_DOWN_MASK = 1 << 6; return InputEvent.SHIFT_DOWN_MASK; };
                ;
                InputEvent.CTRL_DOWN_MASK_$LI$ = function () { if (InputEvent.CTRL_DOWN_MASK == null)
                    InputEvent.CTRL_DOWN_MASK = 1 << 7; return InputEvent.CTRL_DOWN_MASK; };
                ;
                InputEvent.META_DOWN_MASK_$LI$ = function () { if (InputEvent.META_DOWN_MASK == null)
                    InputEvent.META_DOWN_MASK = 1 << 8; return InputEvent.META_DOWN_MASK; };
                ;
                InputEvent.ALT_DOWN_MASK_$LI$ = function () { if (InputEvent.ALT_DOWN_MASK == null)
                    InputEvent.ALT_DOWN_MASK = 1 << 9; return InputEvent.ALT_DOWN_MASK; };
                ;
                InputEvent.BUTTON1_DOWN_MASK_$LI$ = function () { if (InputEvent.BUTTON1_DOWN_MASK == null)
                    InputEvent.BUTTON1_DOWN_MASK = 1 << 10; return InputEvent.BUTTON1_DOWN_MASK; };
                ;
                InputEvent.BUTTON2_DOWN_MASK_$LI$ = function () { if (InputEvent.BUTTON2_DOWN_MASK == null)
                    InputEvent.BUTTON2_DOWN_MASK = 1 << 11; return InputEvent.BUTTON2_DOWN_MASK; };
                ;
                InputEvent.BUTTON3_DOWN_MASK_$LI$ = function () { if (InputEvent.BUTTON3_DOWN_MASK == null)
                    InputEvent.BUTTON3_DOWN_MASK = 1 << 12; return InputEvent.BUTTON3_DOWN_MASK; };
                ;
                InputEvent.ALT_GRAPH_DOWN_MASK_$LI$ = function () { if (InputEvent.ALT_GRAPH_DOWN_MASK == null)
                    InputEvent.ALT_GRAPH_DOWN_MASK = 1 << 13; return InputEvent.ALT_GRAPH_DOWN_MASK; };
                ;
                InputEvent.BUTTON_DOWN_MASK_$LI$ = function () { if (InputEvent.BUTTON_DOWN_MASK == null)
                    InputEvent.BUTTON_DOWN_MASK = [InputEvent.BUTTON1_DOWN_MASK_$LI$(), InputEvent.BUTTON2_DOWN_MASK_$LI$(), InputEvent.BUTTON3_DOWN_MASK_$LI$(), 1 << 14, 1 << 15, 1 << 16, 1 << 17, 1 << 18, 1 << 19, 1 << 20, 1 << 21, 1 << 22, 1 << 23, 1 << 24, 1 << 25, 1 << 26, 1 << 27, 1 << 28, 1 << 29, 1 << 30]; return InputEvent.BUTTON_DOWN_MASK; };
                ;
                InputEvent.getMaskForButton = function (button) {
                    if (button <= 0 || button > InputEvent.BUTTON_DOWN_MASK_$LI$().length) {
                        throw new java.lang.IllegalArgumentException("button doesn\'t exist " + button);
                    }
                    return InputEvent.BUTTON_DOWN_MASK_$LI$()[button - 1];
                };
                InputEvent.FIRST_HIGH_BIT_$LI$ = function () { if (InputEvent.FIRST_HIGH_BIT == null)
                    InputEvent.FIRST_HIGH_BIT = 1 << 31; return InputEvent.FIRST_HIGH_BIT; };
                ;
                InputEvent.JDK_1_3_MODIFIERS_$LI$ = function () { if (InputEvent.JDK_1_3_MODIFIERS == null)
                    InputEvent.JDK_1_3_MODIFIERS = InputEvent.SHIFT_DOWN_MASK_$LI$() - 1; return InputEvent.JDK_1_3_MODIFIERS; };
                ;
                InputEvent.HIGH_MODIFIERS_$LI$ = function () { if (InputEvent.HIGH_MODIFIERS == null)
                    InputEvent.HIGH_MODIFIERS = ~(InputEvent.FIRST_HIGH_BIT_$LI$() - 1); return InputEvent.HIGH_MODIFIERS; };
                ;
                InputEvent.prototype.isShiftDown = function () {
                    return (this.modifiers & InputEvent.SHIFT_MASK_$LI$()) !== 0;
                };
                InputEvent.prototype.isControlDown = function () {
                    return (this.modifiers & InputEvent.CTRL_MASK_$LI$()) !== 0;
                };
                InputEvent.prototype.isMetaDown = function () {
                    return (this.modifiers & InputEvent.META_MASK_$LI$()) !== 0;
                };
                InputEvent.prototype.isAltDown = function () {
                    return (this.modifiers & InputEvent.ALT_MASK_$LI$()) !== 0;
                };
                InputEvent.prototype.isAltGraphDown = function () {
                    return (this.modifiers & InputEvent.ALT_GRAPH_MASK_$LI$()) !== 0;
                };
                InputEvent.prototype.getWhen = function () {
                    return this.when;
                };
                InputEvent.prototype.getModifiers = function () {
                    return this.modifiers & (InputEvent.JDK_1_3_MODIFIERS_$LI$() | InputEvent.HIGH_MODIFIERS_$LI$());
                };
                InputEvent.prototype.getModifiersEx = function () {
                    return this.modifiers & ~InputEvent.JDK_1_3_MODIFIERS_$LI$();
                };
                InputEvent.prototype.consume = function () {
                    this.consumed = true;
                };
                InputEvent.prototype.isConsumed = function () {
                    return this.consumed;
                };
                InputEvent.getModifiersExText = function (modifiers) {
                    var buf = new java.lang.StringBuilder();
                    if ((modifiers & InputEvent.META_DOWN_MASK_$LI$()) !== 0) {
                        buf.append("Meta");
                        buf.append("+");
                    }
                    if ((modifiers & InputEvent.CTRL_DOWN_MASK_$LI$()) !== 0) {
                        buf.append("Ctrl");
                        buf.append("+");
                    }
                    if ((modifiers & InputEvent.ALT_DOWN_MASK_$LI$()) !== 0) {
                        buf.append("Alt");
                        buf.append("+");
                    }
                    if ((modifiers & InputEvent.SHIFT_DOWN_MASK_$LI$()) !== 0) {
                        buf.append("Shift");
                        buf.append("+");
                    }
                    if ((modifiers & InputEvent.ALT_GRAPH_DOWN_MASK_$LI$()) !== 0) {
                        buf.append("Alt Graph");
                        buf.append("+");
                    }
                    var buttonNumber = 1;
                    for (var index132 = 0; index132 < InputEvent.BUTTON_DOWN_MASK_$LI$().length; index132++) {
                        var mask = InputEvent.BUTTON_DOWN_MASK_$LI$()[index132];
                        {
                            if ((modifiers & mask) !== 0) {
                                buf.append("Button" + buttonNumber);
                                buf.append("+");
                            }
                            buttonNumber++;
                        }
                    }
                    if (buf.length() > 0) {
                        buf.setLength(buf.length() - 1);
                    }
                    return buf.toString();
                };
                InputEvent.serialVersionUID = -2482525981698309786;
                return InputEvent;
            }(java.awt.event.ComponentEvent));
            event.InputEvent = InputEvent;
            InputEvent["__class"] = "java.awt.event.InputEvent";
            InputEvent["__interfaces"] = ["java.io.Serializable"];
        })(event = awt.event || (awt.event = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var event;
        (function (event) {
            /**
             * A low-level event that indicates that a window has changed its status. This
             * low-level event is generated by a Window object when it is opened, closed,
             * activated, deactivated, iconified, or deiconified, or when focus is
             * transfered into or out of the Window.
             * <P>
             * The event is passed to every <code>WindowListener</code>
             * or <code>WindowAdapter</code> object which registered to receive such
             * events using the window's <code>addWindowListener</code> method.
             * (<code>WindowAdapter</code> objects implement the
             * <code>WindowListener</code> interface.) Each such listener object
             * gets this <code>WindowEvent</code> when the event occurs.
             * <p>
             * An unspecified behavior will be caused if the {@code id} parameter
             * of any particular {@code WindowEvent} instance is not
             * in the range from {@code WINDOW_FIRST} to {@code WINDOW_LAST}.
             *
             * @author Carl Quinn
             * @author Amy Fowler
             *
             * @see WindowAdapter
             * @see WindowListener
             * @see <a href="http://docs.oracle.com/javase/tutorial/uiswing/events/windowlistener.html">Tutorial: Writing a Window Listener</a>
             *
             * @since JDK1.1
             */
            var WindowEvent = (function (_super) {
                __extends(WindowEvent, _super);
                /**
                 * Constructs a <code>WindowEvent</code> object.
                 * <p>This method throws an
                 * <code>IllegalArgumentException</code> if <code>source</code>
                 * is <code>null</code>.
                 *
                 * @param source    The <code>Window</code> object
                 * that originated the event
                 * @param id        An integer indicating the type of event.
                 * For information on allowable values, see
                 * the class description for {@link WindowEvent}
                 * @param opposite  The other window involved in the focus or activation
                 * change, or <code>null</code>
                 * @param oldState  Previous state of the window for window state change event.
                 * See {@code #getOldState()} for allowable values
                 * @param newState  New state of the window for window state change event.
                 * See {@code #getNewState()} for allowable values
                 * @throws IllegalArgumentException if <code>source</code> is null
                 * @see #getWindow()
                 * @see #getID()
                 * @see #getOppositeWindow()
                 * @see #getOldState()
                 * @see #getNewState()
                 * @since 1.4
                 */
                function WindowEvent(source, id, opposite, oldState, newState) {
                    var _this = this;
                    if (((source != null && source instanceof java.awt.Window) || source === null) && ((typeof id === 'number') || id === null) && ((opposite != null && opposite instanceof java.awt.Window) || opposite === null) && ((typeof oldState === 'number') || oldState === null) && ((typeof newState === 'number') || newState === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        _super.call(this, source, id);
                        this.oldState = 0;
                        this.newState = 0;
                        (function () {
                            _this.opposite = opposite;
                            _this.oldState = oldState;
                            _this.newState = newState;
                        })();
                    }
                    else if (((source != null && source instanceof java.awt.Window) || source === null) && ((typeof id === 'number') || id === null) && ((typeof opposite === 'number') || opposite === null) && ((typeof oldState === 'number') || oldState === null) && newState === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        var oldState_1 = __args[2];
                        var newState_1 = __args[3];
                        {
                            var __args_28 = Array.prototype.slice.call(arguments);
                            var opposite_1 = null;
                            _super.call(this, source, id);
                            this.oldState = 0;
                            this.newState = 0;
                            (function () {
                                _this.opposite = opposite_1;
                                _this.oldState = oldState_1;
                                _this.newState = newState_1;
                            })();
                        }
                    }
                    else if (((source != null && source instanceof java.awt.Window) || source === null) && ((typeof id === 'number') || id === null) && ((opposite != null && opposite instanceof java.awt.Window) || opposite === null) && oldState === undefined && newState === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        {
                            var __args_29 = Array.prototype.slice.call(arguments);
                            var oldState_2 = 0;
                            var newState_2 = 0;
                            _super.call(this, source, id);
                            this.oldState = 0;
                            this.newState = 0;
                            (function () {
                                _this.opposite = opposite;
                                _this.oldState = oldState_2;
                                _this.newState = newState_2;
                            })();
                        }
                    }
                    else if (((source != null && source instanceof java.awt.Window) || source === null) && ((typeof id === 'number') || id === null) && opposite === undefined && oldState === undefined && newState === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        {
                            var __args_30 = Array.prototype.slice.call(arguments);
                            var opposite_2 = null;
                            var oldState_3 = 0;
                            var newState_3 = 0;
                            _super.call(this, source, id);
                            this.oldState = 0;
                            this.newState = 0;
                            (function () {
                                _this.opposite = opposite_2;
                                _this.oldState = oldState_3;
                                _this.newState = newState_3;
                            })();
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                WindowEvent.WINDOW_OPENED_$LI$ = function () { if (WindowEvent.WINDOW_OPENED == null)
                    WindowEvent.WINDOW_OPENED = WindowEvent.WINDOW_FIRST; return WindowEvent.WINDOW_OPENED; };
                ;
                WindowEvent.WINDOW_CLOSING_$LI$ = function () { if (WindowEvent.WINDOW_CLOSING == null)
                    WindowEvent.WINDOW_CLOSING = 1 + WindowEvent.WINDOW_FIRST; return WindowEvent.WINDOW_CLOSING; };
                ;
                WindowEvent.WINDOW_CLOSED_$LI$ = function () { if (WindowEvent.WINDOW_CLOSED == null)
                    WindowEvent.WINDOW_CLOSED = 2 + WindowEvent.WINDOW_FIRST; return WindowEvent.WINDOW_CLOSED; };
                ;
                WindowEvent.WINDOW_ICONIFIED_$LI$ = function () { if (WindowEvent.WINDOW_ICONIFIED == null)
                    WindowEvent.WINDOW_ICONIFIED = 3 + WindowEvent.WINDOW_FIRST; return WindowEvent.WINDOW_ICONIFIED; };
                ;
                WindowEvent.WINDOW_DEICONIFIED_$LI$ = function () { if (WindowEvent.WINDOW_DEICONIFIED == null)
                    WindowEvent.WINDOW_DEICONIFIED = 4 + WindowEvent.WINDOW_FIRST; return WindowEvent.WINDOW_DEICONIFIED; };
                ;
                WindowEvent.WINDOW_ACTIVATED_$LI$ = function () { if (WindowEvent.WINDOW_ACTIVATED == null)
                    WindowEvent.WINDOW_ACTIVATED = 5 + WindowEvent.WINDOW_FIRST; return WindowEvent.WINDOW_ACTIVATED; };
                ;
                WindowEvent.WINDOW_DEACTIVATED_$LI$ = function () { if (WindowEvent.WINDOW_DEACTIVATED == null)
                    WindowEvent.WINDOW_DEACTIVATED = 6 + WindowEvent.WINDOW_FIRST; return WindowEvent.WINDOW_DEACTIVATED; };
                ;
                WindowEvent.WINDOW_GAINED_FOCUS_$LI$ = function () { if (WindowEvent.WINDOW_GAINED_FOCUS == null)
                    WindowEvent.WINDOW_GAINED_FOCUS = 7 + WindowEvent.WINDOW_FIRST; return WindowEvent.WINDOW_GAINED_FOCUS; };
                ;
                WindowEvent.WINDOW_LOST_FOCUS_$LI$ = function () { if (WindowEvent.WINDOW_LOST_FOCUS == null)
                    WindowEvent.WINDOW_LOST_FOCUS = 8 + WindowEvent.WINDOW_FIRST; return WindowEvent.WINDOW_LOST_FOCUS; };
                ;
                WindowEvent.WINDOW_STATE_CHANGED_$LI$ = function () { if (WindowEvent.WINDOW_STATE_CHANGED == null)
                    WindowEvent.WINDOW_STATE_CHANGED = 9 + WindowEvent.WINDOW_FIRST; return WindowEvent.WINDOW_STATE_CHANGED; };
                ;
                WindowEvent.WINDOW_LAST_$LI$ = function () { if (WindowEvent.WINDOW_LAST == null)
                    WindowEvent.WINDOW_LAST = WindowEvent.WINDOW_STATE_CHANGED_$LI$(); return WindowEvent.WINDOW_LAST; };
                ;
                /**
                 * Returns the originator of the event.
                 *
                 * @return the Window object that originated the event
                 */
                WindowEvent.prototype.getWindow = function () {
                    return (this.source != null && this.source instanceof java.awt.Window) ? this.source : null;
                };
                /**
                 * Returns the other Window involved in this focus or activation change.
                 * For a WINDOW_ACTIVATED or WINDOW_GAINED_FOCUS event, this is the Window
                 * that lost activation or focus. For a WINDOW_DEACTIVATED or
                 * WINDOW_LOST_FOCUS event, this is the Window that gained activation or
                 * focus. For any other type of WindowEvent, or if the focus or activation
                 * change occurs with a native application, with a Java application in a
                 * different VM or context, or with no other Window, null is returned.
                 *
                 * @return the other Window involved in the focus or activation change, or
                 * null
                 * @since 1.4
                 */
                WindowEvent.prototype.getOppositeWindow = function () {
                    return this.opposite;
                };
                /**
                 * For <code>WINDOW_STATE_CHANGED</code> events returns the
                 * previous state of the window. The state is
                 * represented as a bitwise mask.
                 * <ul>
                 * <li><code>NORMAL</code>
                 * <br>Indicates that no state bits are set.
                 * <li><code>ICONIFIED</code>
                 * <li><code>MAXIMIZED_HORIZ</code>
                 * <li><code>MAXIMIZED_VERT</code>
                 * <li><code>MAXIMIZED_BOTH</code>
                 * <br>Concatenates <code>MAXIMIZED_HORIZ</code>
                 * and <code>MAXIMIZED_VERT</code>.
                 * </ul>
                 *
                 * @return a bitwise mask of the previous window state
                 * @see java.awt.Frame#getExtendedState()
                 * @since 1.4
                 */
                WindowEvent.prototype.getOldState = function () {
                    return this.oldState;
                };
                /**
                 * For <code>WINDOW_STATE_CHANGED</code> events returns the
                 * new state of the window. The state is
                 * represented as a bitwise mask.
                 * <ul>
                 * <li><code>NORMAL</code>
                 * <br>Indicates that no state bits are set.
                 * <li><code>ICONIFIED</code>
                 * <li><code>MAXIMIZED_HORIZ</code>
                 * <li><code>MAXIMIZED_VERT</code>
                 * <li><code>MAXIMIZED_BOTH</code>
                 * <br>Concatenates <code>MAXIMIZED_HORIZ</code>
                 * and <code>MAXIMIZED_VERT</code>.
                 * </ul>
                 *
                 * @return a bitwise mask of the new window state
                 * @see java.awt.Frame#getExtendedState()
                 * @since 1.4
                 */
                WindowEvent.prototype.getNewState = function () {
                    return this.newState;
                };
                /**
                 * Returns a parameter string identifying this event.
                 * This method is useful for event-logging and for debugging.
                 *
                 * @return a string identifying the event and its attributes
                 */
                WindowEvent.prototype.paramString = function () {
                    var typeStr;
                    switch ((this.id)) {
                        case WindowEvent.WINDOW_OPENED_$LI$():
                            typeStr = "WINDOW_OPENED";
                            break;
                        case WindowEvent.WINDOW_CLOSING_$LI$():
                            typeStr = "WINDOW_CLOSING";
                            break;
                        case WindowEvent.WINDOW_CLOSED_$LI$():
                            typeStr = "WINDOW_CLOSED";
                            break;
                        case WindowEvent.WINDOW_ICONIFIED_$LI$():
                            typeStr = "WINDOW_ICONIFIED";
                            break;
                        case WindowEvent.WINDOW_DEICONIFIED_$LI$():
                            typeStr = "WINDOW_DEICONIFIED";
                            break;
                        case WindowEvent.WINDOW_ACTIVATED_$LI$():
                            typeStr = "WINDOW_ACTIVATED";
                            break;
                        case WindowEvent.WINDOW_DEACTIVATED_$LI$():
                            typeStr = "WINDOW_DEACTIVATED";
                            break;
                        case WindowEvent.WINDOW_GAINED_FOCUS_$LI$():
                            typeStr = "WINDOW_GAINED_FOCUS";
                            break;
                        case WindowEvent.WINDOW_LOST_FOCUS_$LI$():
                            typeStr = "WINDOW_LOST_FOCUS";
                            break;
                        case WindowEvent.WINDOW_STATE_CHANGED_$LI$():
                            typeStr = "WINDOW_STATE_CHANGED";
                            break;
                        default:
                            typeStr = "unknown type";
                    }
                    typeStr += ",opposite=" + this.getOppositeWindow() + ",oldState=" + this.oldState + ",newState=" + this.newState;
                    return typeStr;
                };
                /**
                 * The first number in the range of ids used for window events.
                 */
                WindowEvent.WINDOW_FIRST = 200;
                WindowEvent.serialVersionUID = -1567959133147912127;
                return WindowEvent;
            }(java.awt.event.ComponentEvent));
            event.WindowEvent = WindowEvent;
            WindowEvent["__class"] = "java.awt.event.WindowEvent";
            WindowEvent["__interfaces"] = ["java.io.Serializable"];
        })(event = awt.event || (awt.event = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var Panel = (function (_super) {
            __extends(Panel, _super);
            function Panel(layout) {
                var _this = this;
                if (((layout != null && (layout["__interfaces"] != null && layout["__interfaces"].indexOf("java.awt.LayoutManager") >= 0 || layout.constructor != null && layout.constructor["__interfaces"] != null && layout.constructor["__interfaces"].indexOf("java.awt.LayoutManager") >= 0)) || layout === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this);
                    (function () {
                        _this.setLayout(layout);
                    })();
                }
                else if (layout === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_31 = Array.prototype.slice.call(arguments);
                        var layout_1 = new java.awt.FlowLayout();
                        _super.call(this);
                        (function () {
                            _this.setLayout(layout_1);
                        })();
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            Panel.prototype.createHTML = function () {
                if (this.htmlElement != null) {
                    return;
                }
                this.htmlElement = document.createElement("div");
            };
            Panel.prototype.getGraphics = function () {
                return new java.awt.WebGraphics2D(this.htmlCanvas);
            };
            Panel.prototype.setBackground = function (background) {
                _super.prototype.setBackground.call(this, background);
                if (this.htmlElement != null) {
                    this.htmlElement.style.backgroundColor = null;
                }
                if (this.htmlCanvas != null) {
                    if (background != null) {
                        this.htmlCanvas.style.backgroundColor = background.toHTML();
                    }
                }
            };
            Panel.prototype.doPaintInternal = function () {
                if (this.htmlCanvas.width === 0 && this.htmlCanvas.height === 0) {
                    this.htmlCanvas.width = this.htmlElement.offsetWidth;
                    this.htmlCanvas.height = this.htmlElement.offsetHeight;
                }
                _super.prototype.doPaintInternal.call(this);
            };
            Panel.prototype.initHTML = function () {
                var _this = this;
                _super.prototype.initHTML.call(this);
                console.info("INIT PANEL");
                if (this.htmlCanvas == null) {
                    this.htmlCanvas = document.createElement("canvas");
                    this.htmlElement.appendChild(this.htmlCanvas);
                    window.onresize = function (e) {
                        console.info("resizing");
                        _this.htmlCanvas.width = _this.htmlElement.offsetWidth;
                        _this.htmlCanvas.height = _this.htmlElement.offsetHeight;
                        return e;
                    };
                }
                if (this.background != null) {
                    this.htmlElement.style.backgroundColor = null;
                    this.htmlCanvas.style.backgroundColor = this.background.toHTML();
                }
                this.htmlCanvas.width = this.htmlElement.offsetWidth;
                this.htmlCanvas.height = this.htmlElement.offsetHeight;
                this.htmlCanvas.style.position = "absolute";
                this.htmlCanvas.style.zIndex = "-1";
            };
            return Panel;
        }(java.awt.Container));
        awt.Panel = Panel;
        Panel["__class"] = "java.awt.Panel";
        Panel["__interfaces"] = ["java.awt.HTMLComponent"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var Window = (function (_super) {
            __extends(Window, _super);
            function Window(owner) {
                var _this = this;
                if (((owner != null && owner instanceof java.awt.Frame) || owner === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this);
                    this.focusableWindowState = true;
                    this.autoRequestFocus = true;
                    this.isInShow = false;
                    this.opacity = 1.0;
                    this.shape = null;
                    this.isTrayIconWindow = false;
                    this.windowListeners = new Array();
                    this.windowStateListeners = new Array();
                    this.windowFocusListeners = new Array();
                    this.type = Window.Type.NORMAL;
                    this.state = 0;
                    this.alwaysOnTop = false;
                    (function () {
                        _this.ownedInit(owner);
                    })();
                }
                else if (((owner != null && owner instanceof java.awt.Window) || owner === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this);
                    this.focusableWindowState = true;
                    this.autoRequestFocus = true;
                    this.isInShow = false;
                    this.opacity = 1.0;
                    this.shape = null;
                    this.isTrayIconWindow = false;
                    this.windowListeners = new Array();
                    this.windowStateListeners = new Array();
                    this.windowFocusListeners = new Array();
                    this.type = Window.Type.NORMAL;
                    this.state = 0;
                    this.alwaysOnTop = false;
                    (function () {
                        _this.ownedInit(owner);
                    })();
                }
                else if (owner === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this);
                    this.focusableWindowState = true;
                    this.autoRequestFocus = true;
                    this.isInShow = false;
                    this.opacity = 1.0;
                    this.shape = null;
                    this.isTrayIconWindow = false;
                    this.windowListeners = new Array();
                    this.windowStateListeners = new Array();
                    this.windowFocusListeners = new Array();
                    this.type = Window.Type.NORMAL;
                    this.state = 0;
                    this.alwaysOnTop = false;
                }
                else
                    throw new Error('invalid overload');
            }
            Window.prototype.getElement = function () {
                return this.htmlElement;
            };
            Window.prototype.createHTML = function () {
                var _this = this;
                this.htmlElement = document.createElement("div");
                this.htmlElement.style.display = "none";
                window.addEventListener("load", function (e) {
                    console.info("window onload hook");
                    if (document.body == null) {
                        throw new Error("no body found");
                    }
                    document.body.appendChild(_this.htmlElement);
                    _this.doPaintInternal();
                    return null;
                });
            };
            Window.prototype.initHTML = function () {
                _super.prototype.initHTML.call(this);
                if (this.width == null) {
                    this.htmlElement.style.width = "100%";
                }
                if (this.height == null) {
                    this.htmlElement.style.height = "100%";
                }
            };
            Window.prototype.ownedInit = function (owner) {
                this.parent = owner;
                if (owner != null) {
                    if (owner.isAlwaysOnTop()) {
                        try {
                            this.setAlwaysOnTop(true);
                        }
                        catch (ignore) {
                        }
                        ;
                    }
                }
            };
            Window.prototype.constructComponentName = function () {
                {
                    return Window.base + Window.nameCounter++;
                }
                ;
            };
            Window.prototype.getIconImages = function () {
                var icons = this.icons;
                if (icons == null || icons.size() === 0) {
                    return (new java.util.ArrayList());
                }
                return (new java.util.ArrayList(icons));
            };
            Window.prototype.setIconImages = function (icons) {
                this.icons = (icons == null) ? new java.util.ArrayList() : new java.util.ArrayList(icons);
                this.firePropertyChange("iconImage", null, null);
            };
            Window.prototype.setIconImage = function (image) {
                var imageList = (new java.util.ArrayList());
                if (image != null) {
                    imageList.add(image);
                }
                this.setIconImages(imageList);
            };
            Window.prototype.pack = function () {
            };
            Window.prototype.setMinimumSize = function (minimumSize) {
                _super.prototype.setMinimumSize.call(this, minimumSize);
                var size = this.getSize();
                if (size.width < minimumSize.width || size.height < minimumSize.height) {
                    var nw = Math.max(this.width, minimumSize.width);
                    var nh = Math.max(this.height, minimumSize.height);
                    this.setSize(nw, nh);
                }
            };
            Window.prototype.setVisible = function (visible) {
                this.visible = visible;
                if (this.htmlElement != null) {
                    this.htmlElement.style.display = visible ? "block" : "none";
                }
            };
            Window.prototype.dispose = function () {
            };
            Window.prototype.toFront = function () {
            };
            Window.prototype.toBack = function () {
            };
            Window.prototype.getToolkit = function () {
                return java.awt.Toolkit.getDefaultToolkit();
            };
            Window.prototype.getWarningString = function () {
                return this.warningString;
            };
            Window.prototype.setCursor = function (cursor) {
                if (cursor == null) {
                    cursor = java.awt.Cursor.getPredefinedCursor(java.awt.Cursor.DEFAULT_CURSOR);
                }
                _super.prototype.setCursor.call(this, cursor);
            };
            Window.prototype.addWindowListener = function (l) {
                if (l == null) {
                    return;
                }
                this.windowListeners.push(l);
            };
            Window.prototype.addWindowStateListener = function (l) {
                if (l == null) {
                    return;
                }
                this.windowStateListeners.push(l);
            };
            Window.prototype.addWindowFocusListener = function (l) {
                if (l == null) {
                    return;
                }
                this.windowFocusListeners.push(l);
            };
            Window.prototype.removeWindowListener = function (l) {
                if (l == null) {
                    return;
                }
                this.windowListeners.splice(this.windowListeners.indexOf(l), 1);
            };
            Window.prototype.removeWindowStateListener = function (l) {
                if (l == null) {
                    return;
                }
                this.windowStateListeners.splice(this.windowStateListeners.indexOf(l), 1);
            };
            Window.prototype.removeWindowFocusListener = function (l) {
                if (l == null) {
                    return;
                }
                this.windowFocusListeners.splice(this.windowFocusListeners.indexOf(l), 1);
            };
            Window.prototype.getWindowListeners = function () {
                return this.windowListeners;
            };
            Window.prototype.getWindowFocusListeners = function () {
                return this.windowFocusListeners;
            };
            Window.prototype.getWindowStateListeners = function () {
                return this.windowStateListeners;
            };
            Window.prototype.getListeners = function (listenerType) {
                if (listenerType === "java.awt.event.WindowFocusListener") {
                    return this.windowFocusListeners;
                }
                else if (listenerType === "java.awt.event.WindowStateListener") {
                    return this.windowStateListeners;
                }
                else if (listenerType === "java.awt.event.WindowListener") {
                    return this.windowListeners;
                }
                return null;
            };
            Window.prototype.processWindowEvent = function (e) {
                for (var index133 = 0; index133 < this.windowListeners.length; index133++) {
                    var listener = this.windowListeners[index133];
                    {
                        switch ((e.getID())) {
                            case java.awt.event.WindowEvent.WINDOW_OPENED_$LI$():
                                listener.windowOpened(e);
                                break;
                            case java.awt.event.WindowEvent.WINDOW_CLOSING_$LI$():
                                listener.windowClosing(e);
                                break;
                            case java.awt.event.WindowEvent.WINDOW_CLOSED_$LI$():
                                listener.windowClosed(e);
                                break;
                            case java.awt.event.WindowEvent.WINDOW_ICONIFIED_$LI$():
                                listener.windowIconified(e);
                                break;
                            case java.awt.event.WindowEvent.WINDOW_DEICONIFIED_$LI$():
                                listener.windowDeiconified(e);
                                break;
                            case java.awt.event.WindowEvent.WINDOW_ACTIVATED_$LI$():
                                listener.windowActivated(e);
                                break;
                            case java.awt.event.WindowEvent.WINDOW_DEACTIVATED_$LI$():
                                listener.windowDeactivated(e);
                                break;
                            default:
                                break;
                        }
                    }
                }
            };
            Window.prototype.processWindowFocusEvent = function (e) {
                for (var index134 = 0; index134 < this.windowFocusListeners.length; index134++) {
                    var listener = this.windowFocusListeners[index134];
                    {
                        switch ((e.getID())) {
                            case java.awt.event.WindowEvent.WINDOW_GAINED_FOCUS_$LI$():
                                listener.windowGainedFocus(e);
                                break;
                            case java.awt.event.WindowEvent.WINDOW_LOST_FOCUS_$LI$():
                                listener.windowLostFocus(e);
                                break;
                            default:
                                break;
                        }
                    }
                }
            };
            Window.prototype.processWindowStateEvent = function (e) {
                for (var index135 = 0; index135 < this.windowStateListeners.length; index135++) {
                    var listener = this.windowStateListeners[index135];
                    {
                        switch ((e.getID())) {
                            case java.awt.event.WindowEvent.WINDOW_STATE_CHANGED_$LI$():
                                listener.windowStateChanged(e);
                                break;
                            default:
                                break;
                        }
                    }
                }
            };
            Window.prototype.setAlwaysOnTop = function (alwaysOnTop) {
            };
            Window.prototype.isAlwaysOnTopSupported = function () {
                return false;
            };
            Window.prototype.isAlwaysOnTop = function () {
                return this.alwaysOnTop;
            };
            Window.prototype.isActive = function () {
                return true;
            };
            Window.prototype.isFocused = function () {
                return true;
            };
            Window.prototype.setFocusCycleRoot = function (focusCycleRoot) {
            };
            Window.prototype.isFocusCycleRoot = function () {
                return true;
            };
            Window.prototype.getFocusCycleRootAncestor = function () {
                return null;
            };
            Window.prototype.isFocusableWindow = function () {
                return false;
            };
            Window.prototype.getFocusableWindowState = function () {
                return this.focusableWindowState;
            };
            Window.prototype.setFocusableWindowState = function (focusableWindowState) {
                this.focusableWindowState = focusableWindowState;
            };
            Window.prototype.setAutoRequestFocus = function (autoRequestFocus) {
                this.autoRequestFocus = autoRequestFocus;
            };
            Window.prototype.isAutoRequestFocus = function () {
                return this.autoRequestFocus;
            };
            Window.prototype.addPropertyChangeListener$java_beans_PropertyChangeListener = function (listener) {
                _super.prototype.addPropertyChangeListener.call(this, listener);
            };
            Window.prototype.addPropertyChangeListener = function (propertyName, listener) {
                var _this = this;
                if (((typeof propertyName === 'string') || propertyName === null) && ((listener != null && (listener["__interfaces"] != null && listener["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0 || listener.constructor != null && listener.constructor["__interfaces"] != null && listener.constructor["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0)) || listener === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        _super.prototype.addPropertyChangeListener.call(_this, propertyName, listener);
                    })();
                }
                else if (((propertyName != null && (propertyName["__interfaces"] != null && propertyName["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0 || propertyName.constructor != null && propertyName.constructor["__interfaces"] != null && propertyName.constructor["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0)) || propertyName === null) && listener === undefined) {
                    return this.addPropertyChangeListener$java_beans_PropertyChangeListener(propertyName);
                }
                else
                    throw new Error('invalid overload');
            };
            Window.prototype.isShowing = function () {
                return this.visible;
            };
            Window.prototype.setType = function (type) {
                this.type = type;
            };
            Window.prototype.getType = function () {
                return this.type;
            };
            Window.prototype.getOpacity = function () {
                return this.opacity;
            };
            Window.prototype.setOpacity = function (opacity) {
                if (opacity < 0.0 || opacity > 1.0) {
                    throw new java.lang.IllegalArgumentException("The value of opacity should be in the range [0.0f .. 1.0f].");
                }
                this.opacity = opacity;
            };
            Window.prototype.getShape = function () {
                return this.shape == null ? null : new java.awt.geom.Path2D.Float(this.shape);
            };
            Window.prototype.setShape = function (shape) {
                this.shape = (shape == null) ? null : new java.awt.geom.Path2D.Float(shape);
            };
            Window.OPENED = 1;
            Window.base = "win";
            Window.nameCounter = 0;
            return Window;
        }(java.awt.Container));
        awt.Window = Window;
        Window["__class"] = "java.awt.Window";
        Window["__interfaces"] = ["java.awt.HTMLComponent"];
        var Window;
        (function (Window) {
            (function (Type) {
                Type[Type["NORMAL"] = 0] = "NORMAL";
                Type[Type["UTILITY"] = 1] = "UTILITY";
                Type[Type["POPUP"] = 2] = "POPUP";
            })(Window.Type || (Window.Type = {}));
            var Type = Window.Type;
        })(Window = awt.Window || (awt.Window = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var JComponent = (function (_super) {
            __extends(JComponent, _super);
            function JComponent() {
                _super.call(this);
                this.listenerList = new javax.swing.event.EventListenerList();
            }
            return JComponent;
        }(java.awt.Container));
        swing.JComponent = JComponent;
        JComponent["__class"] = "javax.swing.JComponent";
        JComponent["__interfaces"] = ["java.awt.HTMLComponent", "java.io.Serializable"];
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The {@code GeneralPath} class represents a geometric path constructed from
             * straight lines, and quadratic and cubic (B&eacute;zier) curves. It can
             * contain multiple subpaths.
             * <p>
             * {@code GeneralPath} is a legacy final class which exactly implements the
             * behavior of its superclass {@link Path2D.Float}. Together with
             * {@link Path2D.Double}, the {@link Path2D} classes provide full
             * implementations of a general geometric path that support all of the
             * functionality of the {@link Shape} and {@link PathIterator} interfaces with
             * the ability to explicitly select different levels of internal coordinate
             * precision.
             * <p>
             * Use {@code Path2D.Float} (or this legacy {@code GeneralPath} subclass) when
             * dealing with data that can be represented and used with floating point
             * precision. Use {@code Path2D.Double} for data that requires the accuracy or
             * range of double precision.
             *
             * @author Jim Graham
             * @since 1.2
             */
            var GeneralPath = (function (_super) {
                __extends(GeneralPath, _super);
                function GeneralPath(windingRule, pointTypes, numTypes, pointCoords, numCoords) {
                    var _this = this;
                    if (((typeof windingRule === 'number') || windingRule === null) && ((pointTypes != null && pointTypes instanceof Array) || pointTypes === null) && ((typeof numTypes === 'number') || numTypes === null) && ((pointCoords != null && pointCoords instanceof Array) || pointCoords === null) && ((typeof numCoords === 'number') || numCoords === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        _super.call(this);
                        (function () {
                            _this.windingRule = windingRule;
                            _this.pointTypes = pointTypes;
                            _this.numTypes = numTypes;
                            _this.floatCoords = pointCoords;
                            _this.numCoords = numCoords;
                        })();
                    }
                    else if (((typeof windingRule === 'number') || windingRule === null) && ((typeof pointTypes === 'number') || pointTypes === null) && numTypes === undefined && pointCoords === undefined && numCoords === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        var rule = __args[0];
                        var initialCapacity = __args[1];
                        _super.call(this, rule, initialCapacity);
                    }
                    else if (((windingRule != null && (windingRule["__interfaces"] != null && windingRule["__interfaces"].indexOf("java.awt.Shape") >= 0 || windingRule.constructor != null && windingRule.constructor["__interfaces"] != null && windingRule.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || windingRule === null) && pointTypes === undefined && numTypes === undefined && pointCoords === undefined && numCoords === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        var s = __args[0];
                        _super.call(this, s, null);
                    }
                    else if (((typeof windingRule === 'number') || windingRule === null) && pointTypes === undefined && numTypes === undefined && pointCoords === undefined && numCoords === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        var rule = __args[0];
                        _super.call(this, rule, java.awt.geom.Path2D.INIT_SIZE);
                    }
                    else if (windingRule === undefined && pointTypes === undefined && numTypes === undefined && pointCoords === undefined && numCoords === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        _super.call(this, java.awt.geom.Path2D.WIND_NON_ZERO_$LI$(), java.awt.geom.Path2D.INIT_SIZE);
                    }
                    else
                        throw new Error('invalid overload');
                }
                GeneralPath.serialVersionUID = -8327096662768731142;
                return GeneralPath;
            }(java.awt.geom.Path2D.Float));
            geom.GeneralPath = GeneralPath;
            GeneralPath["__class"] = "java.awt.geom.GeneralPath";
            GeneralPath["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        /**
         * A <code>Rectangle</code> specifies an area in a coordinate space that is
         * enclosed by the <code>Rectangle</code> object's upper-left point
         * {@code (x,y)}
         * in the coordinate space, its width, and its height.
         * <p>
         * A <code>Rectangle</code> object's <code>width</code> and
         * <code>height</code> are <code>public</code> fields. The constructors
         * that create a <code>Rectangle</code>, and the methods that can modify
         * one, do not prevent setting a negative value for width or height.
         * <p>
         * <a name="Empty">
         * A {@code Rectangle} whose width or height is exactly zero has location
         * along those axes with zero dimension, but is otherwise considered empty.
         * The {@link #isEmpty} method will return true for such a {@code Rectangle}.
         * Methods which test if an empty {@code Rectangle} contains or intersects
         * a point or rectangle will always return false if either dimension is zero.
         * Methods which combine such a {@code Rectangle} with a point or rectangle
         * will include the location of the {@code Rectangle} on that axis in the
         * result as if the {@link #add(Point)} method were being called.
         * </a>
         * <p>
         * <a name="NonExistant">
         * A {@code Rectangle} whose width or height is negative has neither
         * location nor dimension along those axes with negative dimensions.
         * Such a {@code Rectangle} is treated as non-existant along those axes.
         * Such a {@code Rectangle} is also empty with respect to containment
         * calculations and methods which test if it contains or intersects a
         * point or rectangle will always return false.
         * Methods which combine such a {@code Rectangle} with a point or rectangle
         * will ignore the {@code Rectangle} entirely in generating the result.
         * If two {@code Rectangle} objects are combined and each has a negative
         * dimension, the result will have at least one negative dimension.
         * </a>
         * <p>
         * Methods which affect only the location of a {@code Rectangle} will
         * operate on its location regardless of whether or not it has a negative
         * or zero dimension along either axis.
         * <p>
         * Note that a {@code Rectangle} constructed with the default no-argument
         * constructor will have dimensions of {@code 0x0} and therefore be empty.
         * That {@code Rectangle} will still have a location of {@code (0,0)} and
         * will contribute that location to the union and add operations.
         * Code attempting to accumulate the bounds of a set of points should
         * therefore initially construct the {@code Rectangle} with a specifically
         * negative width and height or it should use the first point in the set
         * to construct the {@code Rectangle}.
         * For example:
         * <pre>{@code
         * Rectangle bounds = new Rectangle(0, 0, -1, -1);
         * for (int i = 0; i < points.length; i++) {
         * bounds.add(points[i]);
         * }
         * }</pre>
         * or if we know that the points array contains at least one point:
         * <pre>{@code
         * Rectangle bounds = new Rectangle(points[0]);
         * for (int i = 1; i < points.length; i++) {
         * bounds.add(points[i]);
         * }
         * }</pre>
         * <p>
         * This class uses 32-bit integers to store its location and dimensions.
         * Frequently operations may produce a result that exceeds the range of
         * a 32-bit integer.
         * The methods will calculate their results in a way that avoids any
         * 32-bit overflow for intermediate results and then choose the best
         * representation to store the final results back into the 32-bit fields
         * which hold the location and dimensions.
         * The location of the result will be stored into the {@link #x} and
         * {@link #y} fields by clipping the true result to the nearest 32-bit value.
         * The values stored into the {@link #width} and {@link #height} dimension
         * fields will be chosen as the 32-bit values that encompass the largest
         * part of the true result as possible.
         * Generally this means that the dimension will be clipped independently
         * to the range of 32-bit integers except that if the location had to be
         * moved to store it into its pair of 32-bit fields then the dimensions
         * will be adjusted relative to the "best representation" of the location.
         * If the true result had a negative dimension and was therefore
         * non-existant along one or both axes, the stored dimensions will be
         * negative numbers in those axes.
         * If the true result had a location that could be represented within
         * the range of 32-bit integers, but zero dimension along one or both
         * axes, then the stored dimensions will be zero in those axes.
         *
         * @author      Sami Shaio
         * @since 1.0
         */
        var Rectangle = (function (_super) {
            __extends(Rectangle, _super);
            /**
             * Constructs a new <code>Rectangle</code> whose upper-left corner is
             * specified as
             * {@code (x,y)} and whose width and height
             * are specified by the arguments of the same name.
             * @param     x the specified X coordinate
             * @param     y the specified Y coordinate
             * @param     width    the width of the <code>Rectangle</code>
             * @param     height   the height of the <code>Rectangle</code>
             * @since 1.0
             */
            function Rectangle(x, y, width, height) {
                var _this = this;
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this);
                    this.x = 0;
                    this.y = 0;
                    this.width = 0;
                    this.height = 0;
                    (function () {
                        _this.x = x;
                        _this.y = y;
                        _this.width = width;
                        _this.height = height;
                    })();
                }
                else if (((x != null && x instanceof java.awt.Point) || x === null) && ((y != null && y instanceof java.awt.Dimension) || y === null) && width === undefined && height === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var p = __args[0];
                    var d = __args[1];
                    {
                        var __args_32 = Array.prototype.slice.call(arguments);
                        var x_4 = p.x;
                        var y_4 = p.y;
                        var width_3 = d.width;
                        var height_3 = d.height;
                        _super.call(this);
                        this.x = 0;
                        this.y = 0;
                        this.width = 0;
                        this.height = 0;
                        (function () {
                            _this.x = x_4;
                            _this.y = y_4;
                            _this.width = width_3;
                            _this.height = height_3;
                        })();
                    }
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && width === undefined && height === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var width_4 = __args[0];
                    var height_4 = __args[1];
                    {
                        var __args_33 = Array.prototype.slice.call(arguments);
                        var x_5 = 0;
                        var y_5 = 0;
                        _super.call(this);
                        this.x = 0;
                        this.y = 0;
                        this.width = 0;
                        this.height = 0;
                        (function () {
                            _this.x = x_5;
                            _this.y = y_5;
                            _this.width = width_4;
                            _this.height = height_4;
                        })();
                    }
                }
                else if (((x != null && x instanceof java.awt.Rectangle) || x === null) && y === undefined && width === undefined && height === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var r = __args[0];
                    {
                        var __args_34 = Array.prototype.slice.call(arguments);
                        var x_6 = r.x;
                        var y_6 = r.y;
                        var width_5 = r.width;
                        var height_5 = r.height;
                        _super.call(this);
                        this.x = 0;
                        this.y = 0;
                        this.width = 0;
                        this.height = 0;
                        (function () {
                            _this.x = x_6;
                            _this.y = y_6;
                            _this.width = width_5;
                            _this.height = height_5;
                        })();
                    }
                }
                else if (((x != null && x instanceof java.awt.Point) || x === null) && y === undefined && width === undefined && height === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var p = __args[0];
                    {
                        var __args_35 = Array.prototype.slice.call(arguments);
                        var x_7 = p.x;
                        var y_7 = p.y;
                        var width_6 = 0;
                        var height_6 = 0;
                        _super.call(this);
                        this.x = 0;
                        this.y = 0;
                        this.width = 0;
                        this.height = 0;
                        (function () {
                            _this.x = x_7;
                            _this.y = y_7;
                            _this.width = width_6;
                            _this.height = height_6;
                        })();
                    }
                }
                else if (((x != null && x instanceof java.awt.Dimension) || x === null) && y === undefined && width === undefined && height === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var d = __args[0];
                    {
                        var __args_36 = Array.prototype.slice.call(arguments);
                        var x_8 = 0;
                        var y_8 = 0;
                        var width_7 = d.width;
                        var height_7 = d.height;
                        _super.call(this);
                        this.x = 0;
                        this.y = 0;
                        this.width = 0;
                        this.height = 0;
                        (function () {
                            _this.x = x_8;
                            _this.y = y_8;
                            _this.width = width_7;
                            _this.height = height_7;
                        })();
                    }
                }
                else if (x === undefined && y === undefined && width === undefined && height === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_37 = Array.prototype.slice.call(arguments);
                        var x_9 = 0;
                        var y_9 = 0;
                        var width_8 = 0;
                        var height_8 = 0;
                        _super.call(this);
                        this.x = 0;
                        this.y = 0;
                        this.width = 0;
                        this.height = 0;
                        (function () {
                            _this.x = x_9;
                            _this.y = y_9;
                            _this.width = width_8;
                            _this.height = height_8;
                        })();
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Returns the X coordinate of the bounding <code>Rectangle</code> in
             * <code>double</code> precision.
             * @return the X coordinate of the bounding <code>Rectangle</code>.
             */
            Rectangle.prototype.getX = function () {
                return this.x;
            };
            /**
             * Returns the Y coordinate of the bounding <code>Rectangle</code> in
             * <code>double</code> precision.
             * @return the Y coordinate of the bounding <code>Rectangle</code>.
             */
            Rectangle.prototype.getY = function () {
                return this.y;
            };
            /**
             * Returns the width of the bounding <code>Rectangle</code> in
             * <code>double</code> precision.
             * @return the width of the bounding <code>Rectangle</code>.
             */
            Rectangle.prototype.getWidth = function () {
                return this.width;
            };
            /**
             * Returns the height of the bounding <code>Rectangle</code> in
             * <code>double</code> precision.
             * @return the height of the bounding <code>Rectangle</code>.
             */
            Rectangle.prototype.getHeight = function () {
                return this.height;
            };
            /**
             * Gets the bounding <code>Rectangle</code> of this <code>Rectangle</code>.
             * <p>
             * This method is included for completeness, to parallel the
             * <code>getBounds</code> method of
             * {@link Component}.
             * @return    a new <code>Rectangle</code>, equal to the
             * bounding <code>Rectangle</code> for this <code>Rectangle</code>.
             * @see       java.awt.Component#getBounds
             * @see       #setBounds(Rectangle)
             * @see       #setBounds(int, int, int, int)
             * @since     1.1
             */
            Rectangle.prototype.getBounds = function () {
                return new Rectangle(this.x, this.y, this.width, this.height);
            };
            /**
             * {@inheritDoc}
             * @since 1.2
             */
            Rectangle.prototype.getBounds2D = function () {
                return new Rectangle(this.x, this.y, this.width, this.height);
            };
            /**
             * Sets the bounding <code>Rectangle</code> of this <code>Rectangle</code>
             * to match the specified <code>Rectangle</code>.
             * <p>
             * This method is included for completeness, to parallel the
             * <code>setBounds</code> method of <code>Component</code>.
             * @param r the specified <code>Rectangle</code>
             * @see       #getBounds
             * @see       java.awt.Component#setBounds(java.awt.Rectangle)
             * @since     1.1
             */
            Rectangle.prototype.setBounds$java_awt_Rectangle = function (r) {
                this.setBounds(r.x, r.y, r.width, r.height);
            };
            /**
             * Sets the bounding <code>Rectangle</code> of this
             * <code>Rectangle</code> to the specified
             * <code>x</code>, <code>y</code>, <code>width</code>,
             * and <code>height</code>.
             * <p>
             * This method is included for completeness, to parallel the
             * <code>setBounds</code> method of <code>Component</code>.
             * @param x the new X coordinate for the upper-left
             * corner of this <code>Rectangle</code>
             * @param y the new Y coordinate for the upper-left
             * corner of this <code>Rectangle</code>
             * @param width the new width for this <code>Rectangle</code>
             * @param height the new height for this <code>Rectangle</code>
             * @see       #getBounds
             * @see       java.awt.Component#setBounds(int, int, int, int)
             * @since     1.1
             */
            Rectangle.prototype.setBounds = function (x, y, width, height) {
                var _this = this;
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        _this.reshape(x, y, width, height);
                    })();
                }
                else if (((x != null && x instanceof java.awt.Rectangle) || x === null) && y === undefined && width === undefined && height === undefined) {
                    return this.setBounds$java_awt_Rectangle(x);
                }
                else
                    throw new Error('invalid overload');
            };
            Rectangle.prototype.setRect = function (x, y, w, h) {
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                    return this.setRect$double$double$double$double(x, y, w, h);
                }
                else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                    return this.setRect$java_awt_geom_Rectangle2D(x);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Sets the bounds of this {@code Rectangle} to the integer bounds
             * which encompass the specified {@code x}, {@code y}, {@code width},
             * and {@code height}.
             * If the parameters specify a {@code Rectangle} that exceeds the
             * maximum range of integers, the result will be the best
             * representation of the specified {@code Rectangle} intersected
             * with the maximum integer bounds.
             * @param x the X coordinate of the upper-left corner of
             * the specified rectangle
             * @param y the Y coordinate of the upper-left corner of
             * the specified rectangle
             * @param width the width of the specified rectangle
             * @param height the new height of the specified rectangle
             */
            Rectangle.prototype.setRect$double$double$double$double = function (x, y, width, height) {
                var newx;
                var newy;
                var neww;
                var newh;
                if (x > 2.0 * javaemul.internal.IntegerHelper.MAX_VALUE) {
                    newx = javaemul.internal.IntegerHelper.MAX_VALUE;
                    neww = -1;
                }
                else {
                    newx = Rectangle.clip(x, false);
                    if (width >= 0)
                        width += x - newx;
                    neww = Rectangle.clip(width, width >= 0);
                }
                if (y > 2.0 * javaemul.internal.IntegerHelper.MAX_VALUE) {
                    newy = javaemul.internal.IntegerHelper.MAX_VALUE;
                    newh = -1;
                }
                else {
                    newy = Rectangle.clip(y, false);
                    if (height >= 0)
                        height += y - newy;
                    newh = Rectangle.clip(height, height >= 0);
                }
                this.reshape(newx, newy, neww, newh);
            };
            Rectangle.clip = function (v, doceil) {
                if (v <= javaemul.internal.IntegerHelper.MIN_VALUE) {
                    return javaemul.internal.IntegerHelper.MIN_VALUE;
                }
                if (v >= javaemul.internal.IntegerHelper.MAX_VALUE) {
                    return javaemul.internal.IntegerHelper.MAX_VALUE;
                }
                return ((doceil ? Math.ceil(v) : Math.floor(v)) | 0);
            };
            /**
             * Sets the bounding <code>Rectangle</code> of this
             * <code>Rectangle</code> to the specified
             * <code>x</code>, <code>y</code>, <code>width</code>,
             * and <code>height</code>.
             * <p>
             * @param x the new X coordinate for the upper-left
             * corner of this <code>Rectangle</code>
             * @param y the new Y coordinate for the upper-left
             * corner of this <code>Rectangle</code>
             * @param width the new width for this <code>Rectangle</code>
             * @param height the new height for this <code>Rectangle</code>
             * @deprecated As of JDK version 1.1,
             * replaced by <code>setBounds(int, int, int, int)</code>.
             */
            Rectangle.prototype.reshape = function (x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            };
            /**
             * Returns the location of this <code>Rectangle</code>.
             * <p>
             * This method is included for completeness, to parallel the
             * <code>getLocation</code> method of <code>Component</code>.
             * @return the <code>Point</code> that is the upper-left corner of
             * this <code>Rectangle</code>.
             * @see       java.awt.Component#getLocation
             * @see       #setLocation(Point)
             * @see       #setLocation(int, int)
             * @since     1.1
             */
            Rectangle.prototype.getLocation = function () {
                return new java.awt.Point(this.x, this.y);
            };
            /**
             * Moves this <code>Rectangle</code> to the specified location.
             * <p>
             * This method is included for completeness, to parallel the
             * <code>setLocation</code> method of <code>Component</code>.
             * @param p the <code>Point</code> specifying the new location
             * for this <code>Rectangle</code>
             * @see       java.awt.Component#setLocation(java.awt.Point)
             * @see       #getLocation
             * @since     1.1
             */
            Rectangle.prototype.setLocation$java_awt_Point = function (p) {
                this.setLocation(p.x, p.y);
            };
            /**
             * Moves this <code>Rectangle</code> to the specified location.
             * <p>
             * This method is included for completeness, to parallel the
             * <code>setLocation</code> method of <code>Component</code>.
             * @param x the X coordinate of the new location
             * @param y the Y coordinate of the new location
             * @see       #getLocation
             * @see       java.awt.Component#setLocation(int, int)
             * @since     1.1
             */
            Rectangle.prototype.setLocation = function (x, y) {
                var _this = this;
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        _this.move(x, y);
                    })();
                }
                else if (((x != null && x instanceof java.awt.Point) || x === null) && y === undefined) {
                    return this.setLocation$java_awt_Point(x);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Moves this <code>Rectangle</code> to the specified location.
             * <p>
             * @param x the X coordinate of the new location
             * @param y the Y coordinate of the new location
             * @deprecated As of JDK version 1.1,
             * replaced by <code>setLocation(int, int)</code>.
             */
            Rectangle.prototype.move = function (x, y) {
                this.x = x;
                this.y = y;
            };
            /**
             * Translates this <code>Rectangle</code> the indicated distance,
             * to the right along the X coordinate axis, and
             * downward along the Y coordinate axis.
             * @param dx the distance to move this <code>Rectangle</code>
             * along the X axis
             * @param dy the distance to move this <code>Rectangle</code>
             * along the Y axis
             * @see       java.awt.Rectangle#setLocation(int, int)
             * @see       java.awt.Rectangle#setLocation(java.awt.Point)
             */
            Rectangle.prototype.translate = function (dx, dy) {
                var oldv = this.x;
                var newv = oldv + dx;
                if (dx < 0) {
                    if (newv > oldv) {
                        if (this.width >= 0) {
                            this.width += newv - javaemul.internal.IntegerHelper.MIN_VALUE;
                        }
                        newv = javaemul.internal.IntegerHelper.MIN_VALUE;
                    }
                }
                else {
                    if (newv < oldv) {
                        if (this.width >= 0) {
                            this.width += newv - javaemul.internal.IntegerHelper.MAX_VALUE;
                            if (this.width < 0)
                                this.width = javaemul.internal.IntegerHelper.MAX_VALUE;
                        }
                        newv = javaemul.internal.IntegerHelper.MAX_VALUE;
                    }
                }
                this.x = newv;
                oldv = this.y;
                newv = oldv + dy;
                if (dy < 0) {
                    if (newv > oldv) {
                        if (this.height >= 0) {
                            this.height += newv - javaemul.internal.IntegerHelper.MIN_VALUE;
                        }
                        newv = javaemul.internal.IntegerHelper.MIN_VALUE;
                    }
                }
                else {
                    if (newv < oldv) {
                        if (this.height >= 0) {
                            this.height += newv - javaemul.internal.IntegerHelper.MAX_VALUE;
                            if (this.height < 0)
                                this.height = javaemul.internal.IntegerHelper.MAX_VALUE;
                        }
                        newv = javaemul.internal.IntegerHelper.MAX_VALUE;
                    }
                }
                this.y = newv;
            };
            /**
             * Gets the size of this <code>Rectangle</code>, represented by
             * the returned <code>Dimension</code>.
             * <p>
             * This method is included for completeness, to parallel the
             * <code>getSize</code> method of <code>Component</code>.
             * @return a <code>Dimension</code>, representing the size of
             * this <code>Rectangle</code>.
             * @see       java.awt.Component#getSize
             * @see       #setSize(Dimension)
             * @see       #setSize(int, int)
             * @since     1.1
             */
            Rectangle.prototype.getSize = function () {
                return new java.awt.Dimension(this.width, this.height);
            };
            /**
             * Sets the size of this <code>Rectangle</code> to match the
             * specified <code>Dimension</code>.
             * <p>
             * This method is included for completeness, to parallel the
             * <code>setSize</code> method of <code>Component</code>.
             * @param d the new size for the <code>Dimension</code> object
             * @see       java.awt.Component#setSize(java.awt.Dimension)
             * @see       #getSize
             * @since     1.1
             */
            Rectangle.prototype.setSize$java_awt_Dimension = function (d) {
                this.setSize(d.width, d.height);
            };
            /**
             * Sets the size of this <code>Rectangle</code> to the specified
             * width and height.
             * <p>
             * This method is included for completeness, to parallel the
             * <code>setSize</code> method of <code>Component</code>.
             * @param width the new width for this <code>Rectangle</code>
             * @param height the new height for this <code>Rectangle</code>
             * @see       java.awt.Component#setSize(int, int)
             * @see       #getSize
             * @since     1.1
             */
            Rectangle.prototype.setSize = function (width, height) {
                var _this = this;
                if (((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        _this.resize(width, height);
                    })();
                }
                else if (((width != null && width instanceof java.awt.Dimension) || width === null) && height === undefined) {
                    return this.setSize$java_awt_Dimension(width);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Sets the size of this <code>Rectangle</code> to the specified
             * width and height.
             * <p>
             * @param width the new width for this <code>Rectangle</code>
             * @param height the new height for this <code>Rectangle</code>
             * @deprecated As of JDK version 1.1,
             * replaced by <code>setSize(int, int)</code>.
             */
            Rectangle.prototype.resize = function (width, height) {
                this.width = width;
                this.height = height;
            };
            Rectangle.prototype.contains = function (x, y, w, h, origrect) {
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && origrect === undefined) {
                    return this.contains$int$int$int$int(x, y, w, h);
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && origrect === undefined) {
                    return this.contains$double$double$double$double(x, y, w, h);
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined && origrect === undefined) {
                    return this.contains$int$int(x, y);
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined && origrect === undefined) {
                    return this.contains$double$double(x, y);
                }
                else if (((x != null && x instanceof java.awt.Point) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                    return this.contains$java_awt_Point(x);
                }
                else if (((x != null && x instanceof java.awt.Rectangle) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                    return this.contains$java_awt_Rectangle(x);
                }
                else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                    return this.contains$java_awt_geom_Point2D(x);
                }
                else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                    return this.contains$java_awt_geom_Rectangle2D(x);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Checks whether or not this <code>Rectangle</code> contains the
             * specified <code>Point</code>.
             * @param p the <code>Point</code> to test
             * @return    <code>true</code> if the specified <code>Point</code>
             * is inside this <code>Rectangle</code>;
             * <code>false</code> otherwise.
             * @since     1.1
             */
            Rectangle.prototype.contains$java_awt_Point = function (p) {
                return this.contains(p.x, p.y);
            };
            /**
             * Checks whether or not this <code>Rectangle</code> contains the
             * point at the specified location {@code (x,y)}.
             *
             * @param  x the specified X coordinate
             * @param  y the specified Y coordinate
             * @return    <code>true</code> if the point
             * {@code (x,y)} is inside this
             * <code>Rectangle</code>;
             * <code>false</code> otherwise.
             * @since     1.1
             */
            Rectangle.prototype.contains$int$int = function (x, y) {
                return this.inside(x, y);
            };
            /**
             * Checks whether or not this <code>Rectangle</code> entirely contains
             * the specified <code>Rectangle</code>.
             *
             * @param     r   the specified <code>Rectangle</code>
             * @return    <code>true</code> if the <code>Rectangle</code>
             * is contained entirely inside this <code>Rectangle</code>;
             * <code>false</code> otherwise
             * @since     1.2
             */
            Rectangle.prototype.contains$java_awt_Rectangle = function (r) {
                return this.contains(r.x, r.y, r.width, r.height);
            };
            /**
             * Checks whether this <code>Rectangle</code> entirely contains
             * the <code>Rectangle</code>
             * at the specified location {@code (X,Y)} with the
             * specified dimensions {@code (W,H)}.
             * @param     X the specified X coordinate
             * @param     Y the specified Y coordinate
             * @param     W   the width of the <code>Rectangle</code>
             * @param     H   the height of the <code>Rectangle</code>
             * @return    <code>true</code> if the <code>Rectangle</code> specified by
             * {@code (X, Y, W, H)}
             * is entirely enclosed inside this <code>Rectangle</code>;
             * <code>false</code> otherwise.
             * @since     1.1
             */
            Rectangle.prototype.contains$int$int$int$int = function (X, Y, W, H) {
                var w = this.width;
                var h = this.height;
                if ((w | h | W | H) < 0) {
                    return false;
                }
                var x = this.x;
                var y = this.y;
                if (X < x || Y < y) {
                    return false;
                }
                w += x;
                W += X;
                if (W <= X) {
                    if (w >= x || W > w)
                        return false;
                }
                else {
                    if (w >= x && W > w)
                        return false;
                }
                h += y;
                H += Y;
                if (H <= Y) {
                    if (h >= y || H > h)
                        return false;
                }
                else {
                    if (h >= y && H > h)
                        return false;
                }
                return true;
            };
            /**
             * Checks whether or not this <code>Rectangle</code> contains the
             * point at the specified location {@code (X,Y)}.
             *
             * @param  X the specified X coordinate
             * @param  Y the specified Y coordinate
             * @return    <code>true</code> if the point
             * {@code (X,Y)} is inside this
             * <code>Rectangle</code>;
             * <code>false</code> otherwise.
             * @deprecated As of JDK version 1.1,
             * replaced by <code>contains(int, int)</code>.
             */
            Rectangle.prototype.inside = function (X, Y) {
                var w = this.width;
                var h = this.height;
                if ((w | h) < 0) {
                    return false;
                }
                var x = this.x;
                var y = this.y;
                if (X < x || Y < y) {
                    return false;
                }
                w += x;
                h += y;
                return ((w < x || w > X) && (h < y || h > Y));
            };
            /**
             * Determines whether or not this <code>Rectangle</code> and the specified
             * <code>Rectangle</code> intersect. Two rectangles intersect if
             * their intersection is nonempty.
             *
             * @param r the specified <code>Rectangle</code>
             * @return    <code>true</code> if the specified <code>Rectangle</code>
             * and this <code>Rectangle</code> intersect;
             * <code>false</code> otherwise.
             */
            Rectangle.prototype.intersects$java_awt_Rectangle = function (r) {
                var tw = this.width;
                var th = this.height;
                var rw = r.width;
                var rh = r.height;
                if (rw <= 0 || rh <= 0 || tw <= 0 || th <= 0) {
                    return false;
                }
                var tx = this.x;
                var ty = this.y;
                var rx = r.x;
                var ry = r.y;
                rw += rx;
                rh += ry;
                tw += tx;
                th += ty;
                return ((rw < rx || rw > tx) && (rh < ry || rh > ty) && (tw < tx || tw > rx) && (th < ty || th > ry));
            };
            /**
             * Computes the intersection of this <code>Rectangle</code> with the
             * specified <code>Rectangle</code>. Returns a new <code>Rectangle</code>
             * that represents the intersection of the two rectangles.
             * If the two rectangles do not intersect, the result will be
             * an empty rectangle.
             *
             * @param     r   the specified <code>Rectangle</code>
             * @return    the largest <code>Rectangle</code> contained in both the
             * specified <code>Rectangle</code> and in
             * this <code>Rectangle</code>; or if the rectangles
             * do not intersect, an empty rectangle.
             */
            Rectangle.prototype.intersection = function (r) {
                var tx1 = this.x;
                var ty1 = this.y;
                var rx1 = r.x;
                var ry1 = r.y;
                var tx2 = tx1;
                tx2 += this.width;
                var ty2 = ty1;
                ty2 += this.height;
                var rx2 = rx1;
                rx2 += r.width;
                var ry2 = ry1;
                ry2 += r.height;
                if (tx1 < rx1)
                    tx1 = rx1;
                if (ty1 < ry1)
                    ty1 = ry1;
                if (tx2 > rx2)
                    tx2 = rx2;
                if (ty2 > ry2)
                    ty2 = ry2;
                tx2 -= tx1;
                ty2 -= ty1;
                if (tx2 < javaemul.internal.IntegerHelper.MIN_VALUE)
                    tx2 = javaemul.internal.IntegerHelper.MIN_VALUE;
                if (ty2 < javaemul.internal.IntegerHelper.MIN_VALUE)
                    ty2 = javaemul.internal.IntegerHelper.MIN_VALUE;
                return new Rectangle(tx1, ty1, (tx2 | 0), (ty2 | 0));
            };
            /**
             * Computes the union of this <code>Rectangle</code> with the
             * specified <code>Rectangle</code>. Returns a new
             * <code>Rectangle</code> that
             * represents the union of the two rectangles.
             * <p>
             * If either {@code Rectangle} has any dimension less than zero
             * the rules for <a href=#NonExistant>non-existant</a> rectangles
             * apply.
             * If only one has a dimension less than zero, then the result
             * will be a copy of the other {@code Rectangle}.
             * If both have dimension less than zero, then the result will
             * have at least one dimension less than zero.
             * <p>
             * If the resulting {@code Rectangle} would have a dimension
             * too large to be expressed as an {@code int}, the result
             * will have a dimension of {@code Integer.MAX_VALUE} along
             * that dimension.
             * @param r the specified <code>Rectangle</code>
             * @return    the smallest <code>Rectangle</code> containing both
             * the specified <code>Rectangle</code> and this
             * <code>Rectangle</code>.
             */
            Rectangle.prototype.union = function (r) {
                var tx2 = this.width;
                var ty2 = this.height;
                if ((tx2 | ty2) < 0) {
                    return new Rectangle(r);
                }
                var rx2 = r.width;
                var ry2 = r.height;
                if ((rx2 | ry2) < 0) {
                    return new Rectangle(this);
                }
                var tx1 = this.x;
                var ty1 = this.y;
                tx2 += tx1;
                ty2 += ty1;
                var rx1 = r.x;
                var ry1 = r.y;
                rx2 += rx1;
                ry2 += ry1;
                if (tx1 > rx1)
                    tx1 = rx1;
                if (ty1 > ry1)
                    ty1 = ry1;
                if (tx2 < rx2)
                    tx2 = rx2;
                if (ty2 < ry2)
                    ty2 = ry2;
                tx2 -= tx1;
                ty2 -= ty1;
                if (tx2 > javaemul.internal.IntegerHelper.MAX_VALUE)
                    tx2 = javaemul.internal.IntegerHelper.MAX_VALUE;
                if (ty2 > javaemul.internal.IntegerHelper.MAX_VALUE)
                    ty2 = javaemul.internal.IntegerHelper.MAX_VALUE;
                return new Rectangle(tx1, ty1, (tx2 | 0), (ty2 | 0));
            };
            /**
             * Adds a point, specified by the integer arguments {@code newx,newy}
             * to the bounds of this {@code Rectangle}.
             * <p>
             * If this {@code Rectangle} has any dimension less than zero,
             * the rules for <a href=#NonExistant>non-existant</a>
             * rectangles apply.
             * In that case, the new bounds of this {@code Rectangle} will
             * have a location equal to the specified coordinates and
             * width and height equal to zero.
             * <p>
             * After adding a point, a call to <code>contains</code> with the
             * added point as an argument does not necessarily return
             * <code>true</code>. The <code>contains</code> method does not
             * return <code>true</code> for points on the right or bottom
             * edges of a <code>Rectangle</code>. Therefore, if the added point
             * falls on the right or bottom edge of the enlarged
             * <code>Rectangle</code>, <code>contains</code> returns
             * <code>false</code> for that point.
             * If the specified point must be contained within the new
             * {@code Rectangle}, a 1x1 rectangle should be added instead:
             * <pre>
             * r.add(newx, newy, 1, 1);
             * </pre>
             * @param newx the X coordinate of the new point
             * @param newy the Y coordinate of the new point
             */
            Rectangle.prototype.add = function (newx, newy) {
                var _this = this;
                if (((typeof newx === 'number') || newx === null) && ((typeof newy === 'number') || newy === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        if ((_this.width | _this.height) < 0) {
                            _this.x = newx;
                            _this.y = newy;
                            _this.width = _this.height = 0;
                            return;
                        }
                        var x1 = _this.x;
                        var y1 = _this.y;
                        var x2 = _this.width;
                        var y2 = _this.height;
                        x2 += x1;
                        y2 += y1;
                        if (x1 > newx)
                            x1 = newx;
                        if (y1 > newy)
                            y1 = newy;
                        if (x2 < newx)
                            x2 = newx;
                        if (y2 < newy)
                            y2 = newy;
                        x2 -= x1;
                        y2 -= y1;
                        if (x2 > javaemul.internal.IntegerHelper.MAX_VALUE)
                            x2 = javaemul.internal.IntegerHelper.MAX_VALUE;
                        if (y2 > javaemul.internal.IntegerHelper.MAX_VALUE)
                            y2 = javaemul.internal.IntegerHelper.MAX_VALUE;
                        _this.reshape(x1, y1, (x2 | 0), (y2 | 0));
                    })();
                }
                else if (((typeof newx === 'number') || newx === null) && ((typeof newy === 'number') || newy === null)) {
                    return this.add$double$double(newx, newy);
                }
                else if (((newx != null && newx instanceof java.awt.Point) || newx === null) && newy === undefined) {
                    return this.add$java_awt_Point(newx);
                }
                else if (((newx != null && newx instanceof java.awt.Rectangle) || newx === null) && newy === undefined) {
                    return this.add$java_awt_Rectangle(newx);
                }
                else if (((newx != null && newx instanceof java.awt.geom.Point2D) || newx === null) && newy === undefined) {
                    return this.add$java_awt_geom_Point2D(newx);
                }
                else if (((newx != null && newx instanceof java.awt.geom.Rectangle2D) || newx === null) && newy === undefined) {
                    return this.add$java_awt_geom_Rectangle2D(newx);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Adds the specified {@code Point} to the bounds of this
             * {@code Rectangle}.
             * <p>
             * If this {@code Rectangle} has any dimension less than zero,
             * the rules for <a href=#NonExistant>non-existant</a>
             * rectangles apply.
             * In that case, the new bounds of this {@code Rectangle} will
             * have a location equal to the coordinates of the specified
             * {@code Point} and width and height equal to zero.
             * <p>
             * After adding a <code>Point</code>, a call to <code>contains</code>
             * with the added <code>Point</code> as an argument does not
             * necessarily return <code>true</code>. The <code>contains</code>
             * method does not return <code>true</code> for points on the right
             * or bottom edges of a <code>Rectangle</code>. Therefore if the added
             * <code>Point</code> falls on the right or bottom edge of the
             * enlarged <code>Rectangle</code>, <code>contains</code> returns
             * <code>false</code> for that <code>Point</code>.
             * If the specified point must be contained within the new
             * {@code Rectangle}, a 1x1 rectangle should be added instead:
             * <pre>
             * r.add(pt.x, pt.y, 1, 1);
             * </pre>
             * @param pt the new <code>Point</code> to add to this
             * <code>Rectangle</code>
             */
            Rectangle.prototype.add$java_awt_Point = function (pt) {
                this.add(pt.x, pt.y);
            };
            /**
             * Adds a <code>Rectangle</code> to this <code>Rectangle</code>.
             * The resulting <code>Rectangle</code> is the union of the two
             * rectangles.
             * <p>
             * If either {@code Rectangle} has any dimension less than 0, the
             * result will have the dimensions of the other {@code Rectangle}.
             * If both {@code Rectangle}s have at least one dimension less
             * than 0, the result will have at least one dimension less than 0.
             * <p>
             * If either {@code Rectangle} has one or both dimensions equal
             * to 0, the result along those axes with 0 dimensions will be
             * equivalent to the results obtained by adding the corresponding
             * origin coordinate to the result rectangle along that axis,
             * similar to the operation of the {@link #add(Point)} method,
             * but contribute no further dimension beyond that.
             * <p>
             * If the resulting {@code Rectangle} would have a dimension
             * too large to be expressed as an {@code int}, the result
             * will have a dimension of {@code Integer.MAX_VALUE} along
             * that dimension.
             * @param  r the specified <code>Rectangle</code>
             */
            Rectangle.prototype.add$java_awt_Rectangle = function (r) {
                var tx2 = this.width;
                var ty2 = this.height;
                if ((tx2 | ty2) < 0) {
                    this.reshape(r.x, r.y, r.width, r.height);
                }
                var rx2 = r.width;
                var ry2 = r.height;
                if ((rx2 | ry2) < 0) {
                    return;
                }
                var tx1 = this.x;
                var ty1 = this.y;
                tx2 += tx1;
                ty2 += ty1;
                var rx1 = r.x;
                var ry1 = r.y;
                rx2 += rx1;
                ry2 += ry1;
                if (tx1 > rx1)
                    tx1 = rx1;
                if (ty1 > ry1)
                    ty1 = ry1;
                if (tx2 < rx2)
                    tx2 = rx2;
                if (ty2 < ry2)
                    ty2 = ry2;
                tx2 -= tx1;
                ty2 -= ty1;
                if (tx2 > javaemul.internal.IntegerHelper.MAX_VALUE)
                    tx2 = javaemul.internal.IntegerHelper.MAX_VALUE;
                if (ty2 > javaemul.internal.IntegerHelper.MAX_VALUE)
                    ty2 = javaemul.internal.IntegerHelper.MAX_VALUE;
                this.reshape(tx1, ty1, (tx2 | 0), (ty2 | 0));
            };
            /**
             * Resizes the <code>Rectangle</code> both horizontally and vertically.
             * <p>
             * This method modifies the <code>Rectangle</code> so that it is
             * <code>h</code> units larger on both the left and right side,
             * and <code>v</code> units larger at both the top and bottom.
             * <p>
             * The new <code>Rectangle</code> has {@code (x - h, y - v)}
             * as its upper-left corner,
             * width of {@code (width + 2h)},
             * and a height of {@code (height + 2v)}.
             * <p>
             * If negative values are supplied for <code>h</code> and
             * <code>v</code>, the size of the <code>Rectangle</code>
             * decreases accordingly.
             * The {@code grow} method will check for integer overflow
             * and underflow, but does not check whether the resulting
             * values of {@code width} and {@code height} grow
             * from negative to non-negative or shrink from non-negative
             * to negative.
             * @param h the horizontal expansion
             * @param v the vertical expansion
             */
            Rectangle.prototype.grow = function (h, v) {
                var x0 = this.x;
                var y0 = this.y;
                var x1 = this.width;
                var y1 = this.height;
                x1 += x0;
                y1 += y0;
                x0 -= h;
                y0 -= v;
                x1 += h;
                y1 += v;
                if (x1 < x0) {
                    x1 -= x0;
                    if (x1 < javaemul.internal.IntegerHelper.MIN_VALUE)
                        x1 = javaemul.internal.IntegerHelper.MIN_VALUE;
                    if (x0 < javaemul.internal.IntegerHelper.MIN_VALUE)
                        x0 = javaemul.internal.IntegerHelper.MIN_VALUE;
                    else if (x0 > javaemul.internal.IntegerHelper.MAX_VALUE)
                        x0 = javaemul.internal.IntegerHelper.MAX_VALUE;
                }
                else {
                    if (x0 < javaemul.internal.IntegerHelper.MIN_VALUE)
                        x0 = javaemul.internal.IntegerHelper.MIN_VALUE;
                    else if (x0 > javaemul.internal.IntegerHelper.MAX_VALUE)
                        x0 = javaemul.internal.IntegerHelper.MAX_VALUE;
                    x1 -= x0;
                    if (x1 < javaemul.internal.IntegerHelper.MIN_VALUE)
                        x1 = javaemul.internal.IntegerHelper.MIN_VALUE;
                    else if (x1 > javaemul.internal.IntegerHelper.MAX_VALUE)
                        x1 = javaemul.internal.IntegerHelper.MAX_VALUE;
                }
                if (y1 < y0) {
                    y1 -= y0;
                    if (y1 < javaemul.internal.IntegerHelper.MIN_VALUE)
                        y1 = javaemul.internal.IntegerHelper.MIN_VALUE;
                    if (y0 < javaemul.internal.IntegerHelper.MIN_VALUE)
                        y0 = javaemul.internal.IntegerHelper.MIN_VALUE;
                    else if (y0 > javaemul.internal.IntegerHelper.MAX_VALUE)
                        y0 = javaemul.internal.IntegerHelper.MAX_VALUE;
                }
                else {
                    if (y0 < javaemul.internal.IntegerHelper.MIN_VALUE)
                        y0 = javaemul.internal.IntegerHelper.MIN_VALUE;
                    else if (y0 > javaemul.internal.IntegerHelper.MAX_VALUE)
                        y0 = javaemul.internal.IntegerHelper.MAX_VALUE;
                    y1 -= y0;
                    if (y1 < javaemul.internal.IntegerHelper.MIN_VALUE)
                        y1 = javaemul.internal.IntegerHelper.MIN_VALUE;
                    else if (y1 > javaemul.internal.IntegerHelper.MAX_VALUE)
                        y1 = javaemul.internal.IntegerHelper.MAX_VALUE;
                }
                this.reshape((x0 | 0), (y0 | 0), (x1 | 0), (y1 | 0));
            };
            /**
             * {@inheritDoc}
             * @since 1.2
             */
            Rectangle.prototype.isEmpty = function () {
                return (this.width <= 0) || (this.height <= 0);
            };
            /**
             * {@inheritDoc}
             * @since 1.2
             */
            Rectangle.prototype.outcode = function (x, y) {
                var _this = this;
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        var out = 0;
                        if (_this.width <= 0) {
                            out |= java.awt.geom.Rectangle2D.OUT_LEFT | java.awt.geom.Rectangle2D.OUT_RIGHT;
                        }
                        else if (x < _this.x) {
                            out |= java.awt.geom.Rectangle2D.OUT_LEFT;
                        }
                        else if (x > _this.x + _this.width) {
                            out |= java.awt.geom.Rectangle2D.OUT_RIGHT;
                        }
                        if (_this.height <= 0) {
                            out |= java.awt.geom.Rectangle2D.OUT_TOP | java.awt.geom.Rectangle2D.OUT_BOTTOM;
                        }
                        else if (y < _this.y) {
                            out |= java.awt.geom.Rectangle2D.OUT_TOP;
                        }
                        else if (y > _this.y + _this.height) {
                            out |= java.awt.geom.Rectangle2D.OUT_BOTTOM;
                        }
                        return out;
                    })();
                }
                else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined) {
                    return this.outcode$java_awt_geom_Point2D(x);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * {@inheritDoc}
             * @since 1.2
             */
            Rectangle.prototype.createIntersection = function (r) {
                if (r != null && r instanceof java.awt.Rectangle) {
                    return this.intersection(r);
                }
                var dest = new java.awt.geom.Rectangle2D.Double();
                java.awt.geom.Rectangle2D.intersect(this, r, dest);
                return dest;
            };
            /**
             * {@inheritDoc}
             * @since 1.2
             */
            Rectangle.prototype.createUnion = function (r) {
                if (r != null && r instanceof java.awt.Rectangle) {
                    return r;
                }
                var dest = new java.awt.geom.Rectangle2D.Double();
                java.awt.geom.Rectangle2D.union(this, r, dest);
                return dest;
            };
            /**
             * Checks whether two rectangles are equal.
             * <p>
             * The result is <code>true</code> if and only if the argument is not
             * <code>null</code> and is a <code>Rectangle</code> object that has the
             * same upper-left corner, width, and height as
             * this <code>Rectangle</code>.
             * @param obj the <code>Object</code> to compare with
             * this <code>Rectangle</code>
             * @return    <code>true</code> if the objects are equal;
             * <code>false</code> otherwise.
             */
            Rectangle.prototype.equals = function (obj) {
                if (obj != null && obj instanceof java.awt.Rectangle) {
                    var r = obj;
                    return ((this.x === r.x) && (this.y === r.y) && (this.width === r.width) && (this.height === r.height));
                }
                return _super.prototype.equals.call(this, obj);
            };
            /**
             * Returns a <code>String</code> representing this
             * <code>Rectangle</code> and its values.
             * @return a <code>String</code> representing this
             * <code>Rectangle</code> object's coordinate and size values.
             */
            Rectangle.prototype.toString = function () {
                return (function (c) { return c["__class"] ? c["__class"] : c.name; })(Rectangle) + "[x=" + this.x + ",y=" + this.y + ",width=" + this.width + ",height=" + this.height + "]";
            };
            Rectangle.serialVersionUID = -4345857070255674764;
            return Rectangle;
        }(java.awt.geom.Rectangle2D));
        awt.Rectangle = Rectangle;
        Rectangle["__class"] = "java.awt.Rectangle";
        Rectangle["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var WebGraphics2D = (function (_super) {
            __extends(WebGraphics2D, _super);
            function WebGraphics2D(canvas) {
                _super.call(this);
                this.context = canvas.getContext("2d");
            }
            WebGraphics2D.prototype.drawString = function (s, x, y) {
                var _this = this;
                if (((typeof s === 'string') || s === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        _this.context.fillText(s, x, y);
                    })();
                }
                else if (((typeof s === 'string') || s === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return this.drawString$java_lang_String$float$float(s, x, y);
                }
                else
                    throw new Error('invalid overload');
            };
            WebGraphics2D.prototype.getContext = function () {
                return this.context;
            };
            WebGraphics2D.prototype.clearRect = function (x, y, width, height) {
                this.context.clearRect(x, y, width, height);
            };
            WebGraphics2D.prototype.create$ = function () {
                var canvas = new HTMLCanvasElement();
                var graphics = new WebGraphics2D(canvas);
                return graphics;
            };
            WebGraphics2D.prototype.drawArc = function (x, y, width, height, startAngle, arcAngle) {
                this.context.beginPath();
                this.context["ellipse"](x - (width / 2 | 0), y - (height / 2 | 0), (width / 2 | 0), (height / 2 | 0), 0, /* toRadians */ (function (x) { return x * Math.PI / 180; })(startAngle), /* toRadians */ (function (x) { return x * Math.PI / 180; })(startAngle) + (function (x) { return x * Math.PI / 180; })(arcAngle));
                this.context.stroke();
            };
            WebGraphics2D.prototype.drawLine = function (x1, y1, x2, y2) {
                this.context.beginPath();
                this.context.moveTo(x1, y1);
                this.context.lineTo(x2, y2);
                this.context.stroke();
            };
            WebGraphics2D.prototype.drawOval = function (x, y, width, height) {
                this.context.beginPath();
                this.context["ellipse"](x - (width / 2 | 0), y - (height / 2 | 0), (width / 2 | 0), (height / 2 | 0), 0, 0, Math.PI * 2);
                this.context.stroke();
            };
            WebGraphics2D.prototype.drawRoundRect = function (x, y, width, height, arcWidth, arcHeight) {
                this.drawRect(x, y, width, height);
            };
            WebGraphics2D.prototype.drawRect = function (x, y, width, height) {
                this.context.beginPath();
                this.context.rect(x, y, width, height);
                this.context.stroke();
            };
            WebGraphics2D.prototype.drawPolygon = function (xPoints, yPoints, nPoints) {
                var _this = this;
                if (((xPoints != null && xPoints instanceof Array) || xPoints === null) && ((yPoints != null && yPoints instanceof Array) || yPoints === null) && ((typeof nPoints === 'number') || nPoints === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        _this.context.beginPath();
                        if (nPoints <= 0) {
                            return;
                        }
                        _this.context.moveTo(xPoints[0], yPoints[0]);
                        for (var i = 0; i < nPoints; i++) {
                            _this.context.lineTo(xPoints[i], yPoints[i]);
                        }
                        _this.context.moveTo(xPoints[0], yPoints[0]);
                        _this.context.stroke();
                    })();
                }
                else if (((xPoints != null && xPoints instanceof java.awt.Polygon) || xPoints === null) && yPoints === undefined && nPoints === undefined) {
                    return this.drawPolygon$java_awt_Polygon(xPoints);
                }
                else
                    throw new Error('invalid overload');
            };
            WebGraphics2D.prototype.drawPolygon$java_awt_Polygon = function (p) {
                this.drawPolygon(p.xpoints, p.ypoints, p.npoints);
            };
            WebGraphics2D.prototype.fillPolygon$java_awt_Polygon = function (p) {
                this.fillPolygon(p.xpoints, p.ypoints, p.npoints);
            };
            WebGraphics2D.prototype.getClipBounds = function (r) {
                var _this = this;
                if (((r != null && r instanceof java.awt.Rectangle) || r === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        if (_this.clip == null) {
                            return r;
                        }
                        else {
                            return _this.clip.getBounds().createIntersection(r).getBounds();
                        }
                    })();
                }
                else if (r === undefined) {
                    return this.getClipBounds$();
                }
                else
                    throw new Error('invalid overload');
            };
            WebGraphics2D.prototype.draw3DRect = function (x, y, width, height, raised) {
                this.drawRect(x, y, width, height);
            };
            WebGraphics2D.prototype.hitClip = function (x, y, width, height) {
                return this.clip.getBounds().intersects(x, y, width, height);
            };
            WebGraphics2D.prototype.drawPolyline = function (xPoints, yPoints, nPoints) {
                this.context.beginPath();
                if (nPoints <= 0) {
                    return;
                }
                this.context.moveTo(xPoints[0], yPoints[0]);
                for (var i = 0; i < nPoints; i++) {
                    this.context.lineTo(xPoints[i], yPoints[i]);
                }
                this.context.stroke();
            };
            WebGraphics2D.prototype.draw = function (s) {
                var it = s.getPathIterator(java.awt.geom.AffineTransform.getTranslateInstance(0, 0));
                var coords = new Array(6);
                while ((it.isDone())) {
                    switch ((it.currentSegment(coords))) {
                        case java.awt.geom.PathIterator.SEG_MOVETO:
                            this.context.moveTo(coords[0], coords[1]);
                            break;
                        case java.awt.geom.PathIterator.SEG_LINETO:
                            this.context.lineTo(coords[0], coords[1]);
                            break;
                        case java.awt.geom.PathIterator.SEG_QUADTO:
                            break;
                        case java.awt.geom.PathIterator.SEG_CUBICTO:
                            break;
                        case java.awt.geom.PathIterator.SEG_CLOSE:
                            this.context.stroke();
                            break;
                        default:
                            break;
                    }
                }
                ;
                this.context.stroke();
            };
            WebGraphics2D.prototype.fill = function (s) {
                var it = s.getPathIterator(java.awt.geom.AffineTransform.getTranslateInstance(0, 0));
                var coords = new Array(6);
                while ((it.isDone())) {
                    switch ((it.currentSegment(coords))) {
                        case java.awt.geom.PathIterator.SEG_MOVETO:
                            this.context.moveTo(coords[0], coords[1]);
                            break;
                        case java.awt.geom.PathIterator.SEG_LINETO:
                            this.context.lineTo(coords[0], coords[1]);
                            break;
                        case java.awt.geom.PathIterator.SEG_QUADTO:
                            break;
                        case java.awt.geom.PathIterator.SEG_CUBICTO:
                            break;
                        case java.awt.geom.PathIterator.SEG_CLOSE:
                            this.context.stroke();
                            break;
                        default:
                            break;
                    }
                }
                ;
                this.context.fill();
            };
            WebGraphics2D.prototype.drawImage$java_awt_Image$java_awt_geom_AffineTransform$java_awt_image_ImageObserver = function (img, xform, obs) {
                return false;
            };
            WebGraphics2D.prototype.drawImage$java_awt_Image$int$int$java_awt_Color$java_awt_image_ImageObserver = function (img, x, y, bgcolor, observer) {
                this.context["drawImage"](img.source, x, y);
                return true;
            };
            WebGraphics2D.prototype.drawImage = function (img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, bgcolor, observer) {
                var _this = this;
                if (((img != null && img instanceof java.awt.Image) || img === null) && ((typeof dx1 === 'number') || dx1 === null) && ((typeof dy1 === 'number') || dy1 === null) && ((typeof dx2 === 'number') || dx2 === null) && ((typeof dy2 === 'number') || dy2 === null) && ((typeof sx1 === 'number') || sx1 === null) && ((typeof sy1 === 'number') || sy1 === null) && ((typeof sx2 === 'number') || sx2 === null) && ((typeof sy2 === 'number') || sy2 === null) && ((bgcolor != null && bgcolor instanceof java.awt.Color) || bgcolor === null) && ((observer != null && (observer["__interfaces"] != null && observer["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0 || observer.constructor != null && observer.constructor["__interfaces"] != null && observer.constructor["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0)) || observer === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        _this.context["drawImage"](img.source, Math.min(sx1, sx2), Math.min(sy1, sy2), Math.abs(sx2 - sx1), Math.abs(sy2 - sy1), Math.min(dx1, dx2), Math.min(dy1, dy2), Math.abs(dx2 - dx1), Math.abs(dy2 - dy1));
                        return true;
                    })();
                }
                else if (((img != null && img instanceof java.awt.Image) || img === null) && ((typeof dx1 === 'number') || dx1 === null) && ((typeof dy1 === 'number') || dy1 === null) && ((typeof dx2 === 'number') || dx2 === null) && ((typeof dy2 === 'number') || dy2 === null) && ((typeof sx1 === 'number') || sx1 === null) && ((typeof sy1 === 'number') || sy1 === null) && ((typeof sx2 === 'number') || sx2 === null) && ((typeof sy2 === 'number') || sy2 === null) && ((bgcolor != null && (bgcolor["__interfaces"] != null && bgcolor["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0 || bgcolor.constructor != null && bgcolor.constructor["__interfaces"] != null && bgcolor.constructor["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0)) || bgcolor === null) && observer === undefined) {
                    return this.drawImage$java_awt_Image$int$int$int$int$int$int$int$int$java_awt_image_ImageObserver(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, bgcolor);
                }
                else if (((img != null && img instanceof java.awt.Image) || img === null) && ((typeof dx1 === 'number') || dx1 === null) && ((typeof dy1 === 'number') || dy1 === null) && ((typeof dx2 === 'number') || dx2 === null) && ((typeof dy2 === 'number') || dy2 === null) && ((sx1 != null && sx1 instanceof java.awt.Color) || sx1 === null) && ((sy1 != null && (sy1["__interfaces"] != null && sy1["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0 || sy1.constructor != null && sy1.constructor["__interfaces"] != null && sy1.constructor["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0)) || sy1 === null) && sx2 === undefined && sy2 === undefined && bgcolor === undefined && observer === undefined) {
                    return this.drawImage$java_awt_Image$int$int$int$int$java_awt_Color$java_awt_image_ImageObserver(img, dx1, dy1, dx2, dy2, sx1, sy1);
                }
                else if (((img != null && img instanceof java.awt.Image) || img === null) && ((typeof dx1 === 'number') || dx1 === null) && ((typeof dy1 === 'number') || dy1 === null) && ((typeof dx2 === 'number') || dx2 === null) && ((typeof dy2 === 'number') || dy2 === null) && ((sx1 != null && (sx1["__interfaces"] != null && sx1["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0 || sx1.constructor != null && sx1.constructor["__interfaces"] != null && sx1.constructor["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0)) || sx1 === null) && sy1 === undefined && sx2 === undefined && sy2 === undefined && bgcolor === undefined && observer === undefined) {
                    return this.drawImage$java_awt_Image$int$int$int$int$java_awt_image_ImageObserver(img, dx1, dy1, dx2, dy2, sx1);
                }
                else if (((img != null && img instanceof java.awt.Image) || img === null) && ((typeof dx1 === 'number') || dx1 === null) && ((typeof dy1 === 'number') || dy1 === null) && ((dx2 != null && dx2 instanceof java.awt.Color) || dx2 === null) && ((dy2 != null && (dy2["__interfaces"] != null && dy2["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0 || dy2.constructor != null && dy2.constructor["__interfaces"] != null && dy2.constructor["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0)) || dy2 === null) && sx1 === undefined && sy1 === undefined && sx2 === undefined && sy2 === undefined && bgcolor === undefined && observer === undefined) {
                    return this.drawImage$java_awt_Image$int$int$java_awt_Color$java_awt_image_ImageObserver(img, dx1, dy1, dx2, dy2);
                }
                else if (((img != null && img instanceof java.awt.Image) || img === null) && ((typeof dx1 === 'number') || dx1 === null) && ((typeof dy1 === 'number') || dy1 === null) && ((dx2 != null && (dx2["__interfaces"] != null && dx2["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0 || dx2.constructor != null && dx2.constructor["__interfaces"] != null && dx2.constructor["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0)) || dx2 === null) && dy2 === undefined && sx1 === undefined && sy1 === undefined && sx2 === undefined && sy2 === undefined && bgcolor === undefined && observer === undefined) {
                    return this.drawImage$java_awt_Image$int$int$java_awt_image_ImageObserver(img, dx1, dy1, dx2);
                }
                else if (((img != null && img instanceof java.awt.Image) || img === null) && ((dx1 != null && dx1 instanceof java.awt.geom.AffineTransform) || dx1 === null) && ((dy1 != null && (dy1["__interfaces"] != null && dy1["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0 || dy1.constructor != null && dy1.constructor["__interfaces"] != null && dy1.constructor["__interfaces"].indexOf("java.awt.image.ImageObserver") >= 0)) || dy1 === null) && dx2 === undefined && dy2 === undefined && sx1 === undefined && sy1 === undefined && sx2 === undefined && sy2 === undefined && bgcolor === undefined && observer === undefined) {
                    return this.drawImage$java_awt_Image$java_awt_geom_AffineTransform$java_awt_image_ImageObserver(img, dx1, dy1);
                }
                else
                    throw new Error('invalid overload');
            };
            WebGraphics2D.prototype.drawImage$java_awt_Image$int$int$int$int$int$int$int$int$java_awt_image_ImageObserver = function (img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, observer) {
                this.context["drawImage"](img.source, Math.min(sx1, sx2), Math.min(sy1, sy2), Math.abs(sx2 - sx1), Math.abs(sy2 - sy1), Math.min(dx1, dx2), Math.min(dy1, dy2), Math.abs(dx2 - dx1), Math.abs(dy2 - dy1));
                return true;
            };
            WebGraphics2D.prototype.drawImage$java_awt_Image$int$int$java_awt_image_ImageObserver = function (img, x, y, observer) {
                this.context["drawImage"](img.source, x, y);
                return true;
            };
            WebGraphics2D.prototype.drawImage$java_awt_Image$int$int$int$int$java_awt_Color$java_awt_image_ImageObserver = function (img, x, y, width, height, bgcolor, observer) {
                this.context["drawImage"](img.source, x, y, width, height);
                return true;
            };
            WebGraphics2D.prototype.drawImage$java_awt_Image$int$int$int$int$java_awt_image_ImageObserver = function (img, x, y, width, height, observer) {
                this.context["drawImage"](img.source, x, y, width, height);
                return true;
            };
            WebGraphics2D.prototype.fillPolygon = function (xPoints, yPoints, nPoints) {
                var _this = this;
                if (((xPoints != null && xPoints instanceof Array) || xPoints === null) && ((yPoints != null && yPoints instanceof Array) || yPoints === null) && ((typeof nPoints === 'number') || nPoints === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        _this.context.beginPath();
                        if (nPoints <= 0) {
                            return;
                        }
                        _this.context.moveTo(xPoints[0], yPoints[0]);
                        for (var i = 0; i < nPoints; i++) {
                            _this.context.lineTo(xPoints[i], yPoints[i]);
                        }
                        _this.context.moveTo(xPoints[0], yPoints[0]);
                        _this.context.fill();
                    })();
                }
                else if (((xPoints != null && xPoints instanceof java.awt.Polygon) || xPoints === null) && yPoints === undefined && nPoints === undefined) {
                    return this.fillPolygon$java_awt_Polygon(xPoints);
                }
                else
                    throw new Error('invalid overload');
            };
            WebGraphics2D.prototype.getClip = function () {
                return this.clip;
            };
            WebGraphics2D.prototype.setClip$java_awt_Shape = function (clip) {
                this.clip = clip;
                if (clip != null) {
                    var it = clip.getPathIterator(java.awt.geom.AffineTransform.getTranslateInstance(0, 0));
                    var coords = new Array(6);
                    while ((it.isDone())) {
                        switch ((it.currentSegment(coords))) {
                            case java.awt.geom.PathIterator.SEG_MOVETO:
                                this.context.moveTo(coords[0], coords[1]);
                                break;
                            case java.awt.geom.PathIterator.SEG_LINETO:
                                this.context.lineTo(coords[0], coords[1]);
                                break;
                            case java.awt.geom.PathIterator.SEG_QUADTO:
                                break;
                            case java.awt.geom.PathIterator.SEG_CUBICTO:
                                break;
                            case java.awt.geom.PathIterator.SEG_CLOSE:
                                this.context.stroke();
                                break;
                            default:
                                break;
                        }
                    }
                    ;
                    this.context.clip();
                }
            };
            WebGraphics2D.prototype.setClip = function (x, y, width, height) {
                var _this = this;
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        _this.setClip(new java.awt.Rectangle(x, y, width, height));
                    })();
                }
                else if (((x != null && (x["__interfaces"] != null && x["__interfaces"].indexOf("java.awt.Shape") >= 0 || x.constructor != null && x.constructor["__interfaces"] != null && x.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || x === null) && y === undefined && width === undefined && height === undefined) {
                    return this.setClip$java_awt_Shape(x);
                }
                else
                    throw new Error('invalid overload');
            };
            WebGraphics2D.prototype.clipRect = function (x, y, width, height) {
                if (this.clip == null) {
                    this.setClip(x, y, width, height);
                }
                else {
                    this.setClip(this.clip.getBounds().createIntersection(new java.awt.geom.Rectangle2D.Double(x, y, width, height)));
                }
            };
            WebGraphics2D.prototype.getClipBounds$ = function () {
                return this.clip.getBounds();
            };
            WebGraphics2D.prototype.translate = function (x, y) {
                var _this = this;
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        _this.context.translate(x, y);
                    })();
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return this.translate$double$double(x, y);
                }
                else
                    throw new Error('invalid overload');
            };
            WebGraphics2D.prototype.drawString$java_lang_String$float$float = function (str, x, y) {
                this.context.strokeText(str, x, y);
            };
            WebGraphics2D.prototype.fillArc = function (x, y, width, height, startAngle, arcAngle) {
                this.context.beginPath();
                this.context["ellipse"](x - (width / 2 | 0), y - (height / 2 | 0), (width / 2 | 0), (height / 2 | 0), 0, /* toRadians */ (function (x) { return x * Math.PI / 180; })(startAngle), /* toRadians */ (function (x) { return x * Math.PI / 180; })(startAngle) + (function (x) { return x * Math.PI / 180; })(arcAngle));
                this.context.fill();
            };
            WebGraphics2D.prototype.fillOval = function (x, y, width, height) {
                this.context.beginPath();
                this.context["ellipse"](x - (width / 2 | 0), y - (height / 2 | 0), (width / 2 | 0), (height / 2 | 0), 0, 0, Math.PI * 2);
                this.context.fill();
            };
            WebGraphics2D.prototype.fillRect = function (x, y, width, height) {
                this.context.fillRect(x, y, width, height);
            };
            WebGraphics2D.prototype.fillRoundRect = function (x, y, width, height, arcWidth, arcHeight) {
                this.fillRect(x, y, width, height);
            };
            WebGraphics2D.prototype.setColor = function (c) {
                this.context.strokeStyle = c.toHTML();
            };
            WebGraphics2D.prototype.getColor = function () {
                return this.color;
            };
            WebGraphics2D.prototype.translate$double$double = function (tx, ty) {
                this.context.translate(tx, ty);
            };
            WebGraphics2D.prototype.rotate$double = function (theta) {
                this.context.rotate(theta);
            };
            WebGraphics2D.prototype.rotate = function (theta, x, y) {
                var _this = this;
                if (((typeof theta === 'number') || theta === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        _this.context.translate(-x, -y);
                        _this.context.rotate(theta);
                        _this.context.translate(x, y);
                    })();
                }
                else if (((typeof theta === 'number') || theta === null) && x === undefined && y === undefined) {
                    return this.rotate$double(theta);
                }
                else
                    throw new Error('invalid overload');
            };
            WebGraphics2D.prototype.scale = function (sx, sy) {
                this.context.scale(sx, sy);
            };
            WebGraphics2D.prototype.shear = function (shx, shy) {
                this.context.setTransform(0, shx, shy, 0, 0, 0);
            };
            WebGraphics2D.prototype.dispose = function () {
            };
            WebGraphics2D.prototype.setFont = function (font) {
                this.font = font;
                this.context.font = font.toHTML();
            };
            WebGraphics2D.prototype.getFont = function () {
                return this.font;
            };
            WebGraphics2D.prototype.setBackground = function (color) {
                this.background = color;
                this.context.fillStyle = color.toHTML();
            };
            WebGraphics2D.prototype.getBackground = function () {
                return this.background;
            };
            WebGraphics2D.prototype.setTransform = function (transform) {
                this.__transform = transform;
                this.context.setTransform(transform.getScaleX(), transform.getShearX(), transform.getShearY(), transform.getScaleY(), transform.getTranslateX(), transform.getTranslateY());
            };
            WebGraphics2D.prototype.getTransform = function () {
                return this.__transform;
            };
            WebGraphics2D.prototype.transform = function (Tx) {
                if (this.__transform == null) {
                    this.setTransform(Tx);
                }
                else {
                    this.__transform.concatenate(Tx);
                    this.setTransform(this.__transform);
                }
            };
            WebGraphics2D.prototype.setPaintMode = function () {
            };
            WebGraphics2D.prototype.getPaint = function () {
                return this.color;
            };
            WebGraphics2D.prototype.setPaint = function (paint) {
            };
            WebGraphics2D.prototype.setStroke = function (s) {
            };
            return WebGraphics2D;
        }(java.awt.Graphics2D));
        awt.WebGraphics2D = WebGraphics2D;
        WebGraphics2D["__class"] = "java.awt.WebGraphics2D";
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var event;
        (function (event) {
            /**
             * This subclass of {@code java.beans.PropertyChangeSupport} is almost identical
             * in functionality. The only difference is if constructed with
             * {@code SwingPropertyChangeSupport(sourceBean, true)} it ensures listeners are
             * only ever notified on the <i>Event Dispatch Thread</i>.
             *
             * @author Igor Kushnirskiy
             */
            var SwingPropertyChangeSupport = (function (_super) {
                __extends(SwingPropertyChangeSupport, _super);
                /**
                 * Constructs a SwingPropertyChangeSupport object.
                 *
                 * @param sourceBean
                 * the bean to be given as the source for any events
                 * @param notifyOnEDT
                 * whether to notify listeners on the <i>Event Dispatch
                 * Thread</i> only
                 *
                 * @throws NullPointerException
                 * if {@code sourceBean} is {@code null}
                 * @since 1.6
                 */
                function SwingPropertyChangeSupport(sourceBean, notifyOnEDT) {
                    if (notifyOnEDT === void 0) { notifyOnEDT = false; }
                    _super.call(this, sourceBean);
                    this.notifyOnEDT = false;
                    this.notifyOnEDT = notifyOnEDT;
                }
                /**
                 * {@inheritDoc}
                 *
                 * <p>
                 * If {@link #isNotifyOnEDT} is {@code true} and called off the <i>Event
                 * Dispatch Thread</i> this implementation uses
                 * {@code SwingUtilities.invokeLater} to send out the notification on the
                 * <i>Event Dispatch Thread</i>. This ensures listeners are only ever
                 * notified on the <i>Event Dispatch Thread</i>.
                 *
                 * @throws NullPointerException
                 * if {@code evt} is {@code null}
                 * @since 1.6
                 */
                SwingPropertyChangeSupport.prototype.firePropertyChange$java_beans_PropertyChangeEvent = function (evt) {
                    if (evt == null) {
                        throw new java.lang.NullPointerException();
                    }
                    _super.prototype.firePropertyChange.call(this, evt);
                };
                /**
                 * Returns {@code notifyOnEDT} property.
                 *
                 * @return {@code notifyOnEDT} property
                 * @see #SwingPropertyChangeSupport(Object sourceBean, boolean notifyOnEDT)
                 * @since 1.6
                 */
                SwingPropertyChangeSupport.prototype.isNotifyOnEDT = function () {
                    return this.notifyOnEDT;
                };
                SwingPropertyChangeSupport.serialVersionUID = 7162625831330845068;
                return SwingPropertyChangeSupport;
            }(java.beans.PropertyChangeSupport));
            event.SwingPropertyChangeSupport = SwingPropertyChangeSupport;
            SwingPropertyChangeSupport["__class"] = "javax.swing.event.SwingPropertyChangeSupport";
            SwingPropertyChangeSupport["__interfaces"] = ["java.io.Serializable"];
        })(event = swing.event || (swing.event = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var undo;
        (function (undo) {
            /**
             * {@code UndoManager} manages a list of {@code UndoableEdits},
             * providing a way to undo or redo the appropriate edits.  There are
             * two ways to add edits to an <code>UndoManager</code>.  Add the edit
             * directly using the <code>addEdit</code> method, or add the
             * <code>UndoManager</code> to a bean that supports
             * <code>UndoableEditListener</code>.  The following examples creates
             * an <code>UndoManager</code> and adds it as an
             * <code>UndoableEditListener</code> to a <code>JTextField</code>:
             * <pre>
             * UndoManager undoManager = new UndoManager();
             * JTextField tf = ...;
             * tf.getDocument().addUndoableEditListener(undoManager);
             * </pre>
             * <p>
             * <code>UndoManager</code> maintains an ordered list of edits and the
             * index of the next edit in that list. The index of the next edit is
             * either the size of the current list of edits, or if
             * <code>undo</code> has been invoked it corresponds to the index
             * of the last significant edit that was undone. When
             * <code>undo</code> is invoked all edits from the index of the next
             * edit to the last significant edit are undone, in reverse order.
             * For example, consider an <code>UndoManager</code> consisting of the
             * following edits: <b>A</b> <i>b</i> <i>c</i> <b>D</b>.  Edits with a
             * upper-case letter in bold are significant, those in lower-case
             * and italicized are insignificant.
             * <p>
             * <a name="figure1"></a>
             * <table border=0 summary="">
             * <tr><td>
             * <img src="doc-files/UndoManager-1.gif" alt="">
             * <tr><td align=center>Figure 1
             * </table>
             * <p>
             * As shown in <a href="#figure1">figure 1</a>, if <b>D</b> was just added, the
             * index of the next edit will be 4. Invoking <code>undo</code>
             * results in invoking <code>undo</code> on <b>D</b> and setting the
             * index of the next edit to 3 (edit <i>c</i>), as shown in the following
             * figure.
             * <p>
             * <a name="figure2"></a>
             * <table border=0 summary="">
             * <tr><td>
             * <img src="doc-files/UndoManager-2.gif" alt="">
             * <tr><td align=center>Figure 2
             * </table>
             * <p>
             * The last significant edit is <b>A</b>, so that invoking
             * <code>undo</code> again invokes <code>undo</code> on <i>c</i>,
             * <i>b</i>, and <b>A</b>, in that order, setting the index of the
             * next edit to 0, as shown in the following figure.
             * <p>
             * <a name="figure3"></a>
             * <table border=0 summary="">
             * <tr><td>
             * <img src="doc-files/UndoManager-3.gif" alt="">
             * <tr><td align=center>Figure 3
             * </table>
             * <p>
             * Invoking <code>redo</code> results in invoking <code>redo</code> on
             * all edits between the index of the next edit and the next
             * significant edit (or the end of the list).  Continuing with the previous
             * example if <code>redo</code> were invoked, <code>redo</code> would in
             * turn be invoked on <b>A</b>, <i>b</i> and <i>c</i>.  In addition
             * the index of the next edit is set to 3 (as shown in <a
             * href="#figure2">figure 2</a>).
             * <p>
             * Adding an edit to an <code>UndoManager</code> results in
             * removing all edits from the index of the next edit to the end of
             * the list.  Continuing with the previous example, if a new edit,
             * <i>e</i>, is added the edit <b>D</b> is removed from the list
             * (after having <code>die</code> invoked on it).  If <i>c</i> is not
             * incorporated by the next edit
             * (<code><i>c</i>.addEdit(<i>e</i>)</code> returns true), or replaced
             * by it (<code><i>e</i>.replaceEdit(<i>c</i>)</code> returns true),
             * the new edit is added after <i>c</i>, as shown in the following
             * figure.
             * <p>
             * <a name="figure4"></a>
             * <table border=0 summary="">
             * <tr><td>
             * <img src="doc-files/UndoManager-4.gif" alt="">
             * <tr><td align=center>Figure 4
             * </table>
             * <p>
             * Once <code>end</code> has been invoked on an <code>UndoManager</code>
             * the superclass behavior is used for all <code>UndoableEdit</code>
             * methods.  Refer to <code>CompoundEdit</code> for more details on its
             * behavior.
             * <p>
             * Unlike the rest of Swing, this class is thread safe.
             * <p>
             * <strong>Warning:</strong>
             * Serialized objects of this class will not be compatible with
             * future Swing releases. The current serialization support is
             * appropriate for short term storage or RMI between applications running
             * the same version of Swing.  As of 1.4, support for long term storage
             * of all JavaBeans&trade;
             * has been added to the <code>java.beans</code> package.
             * Please see {@link java.beans.XMLEncoder}.
             *
             * @author Ray Ryan
             */
            var UndoManager = (function (_super) {
                __extends(UndoManager, _super);
                /**
                 * Creates a new <code>UndoManager</code>.
                 */
                function UndoManager() {
                    _super.call(this);
                    this.indexOfNextAdd = 0;
                    this.limit = 0;
                    this.indexOfNextAdd = 0;
                    this.limit = 100;
                    this.edits.ensureCapacity(this.limit);
                }
                /**
                 * Returns the maximum number of edits this {@code UndoManager}
                 * holds. A value less than 0 indicates the number of edits is not
                 * limited.
                 *
                 * @return the maximum number of edits this {@code UndoManager} holds
                 * @see #addEdit
                 * @see #setLimit
                 */
                UndoManager.prototype.getLimit = function () {
                    return this.limit;
                };
                /**
                 * Empties the undo manager sending each edit a <code>die</code> message
                 * in the process.
                 *
                 * @see AbstractUndoableEdit#die
                 */
                UndoManager.prototype.discardAllEdits = function () {
                    for (var index136 = this.edits.iterator(); index136.hasNext();) {
                        var e = index136.next();
                        {
                            e.die();
                        }
                    }
                    this.edits = (new java.util.Vector());
                    this.indexOfNextAdd = 0;
                };
                /**
                 * Reduces the number of queued edits to a range of size limit,
                 * centered on the index of the next edit.
                 */
                UndoManager.prototype.trimForLimit = function () {
                    if (this.limit >= 0) {
                        var size = this.edits.size();
                        if (size > this.limit) {
                            var halfLimit = (this.limit / 2 | 0);
                            var keepFrom = this.indexOfNextAdd - 1 - halfLimit;
                            var keepTo = this.indexOfNextAdd - 1 + halfLimit;
                            if (keepTo - keepFrom + 1 > this.limit) {
                                keepFrom++;
                            }
                            if (keepFrom < 0) {
                                keepTo -= keepFrom;
                                keepFrom = 0;
                            }
                            if (keepTo >= size) {
                                var delta = size - keepTo - 1;
                                keepTo += delta;
                                keepFrom += delta;
                            }
                            this.trimEdits(keepTo + 1, size - 1);
                            this.trimEdits(0, keepFrom - 1);
                        }
                    }
                };
                /**
                 * Removes edits in the specified range.
                 * All edits in the given range (inclusive, and in reverse order)
                 * will have <code>die</code> invoked on them and are removed from
                 * the list of edits. This has no effect if
                 * <code>from</code> &gt; <code>to</code>.
                 *
                 * @param from the minimum index to remove
                 * @param to the maximum index to remove
                 */
                UndoManager.prototype.trimEdits = function (from, to) {
                    if (from <= to) {
                        for (var i = to; from <= i; i--) {
                            var e = this.edits.elementAt(i);
                            e.die();
                            this.edits.removeElementAt(i);
                        }
                        if (this.indexOfNextAdd > to) {
                            this.indexOfNextAdd -= to - from + 1;
                        }
                        else if (this.indexOfNextAdd >= from) {
                            this.indexOfNextAdd = from;
                        }
                    }
                };
                /**
                 * Sets the maximum number of edits this <code>UndoManager</code>
                 * holds. A value less than 0 indicates the number of edits is not
                 * limited. If edits need to be discarded to shrink the limit,
                 * <code>die</code> will be invoked on them in the reverse
                 * order they were added.  The default is 100.
                 *
                 * @param l the new limit
                 * @throws RuntimeException if this {@code UndoManager} is not in progress
                 * ({@code end} has been invoked)
                 * @see #isInProgress
                 * @see #end
                 * @see #addEdit
                 * @see #getLimit
                 */
                UndoManager.prototype.setLimit = function (l) {
                    if (!this.inProgress)
                        throw new Error("Attempt to call UndoManager.setLimit() after UndoManager.end() has been called");
                    this.limit = l;
                    this.trimForLimit();
                };
                /**
                 * Returns the the next significant edit to be undone if <code>undo</code>
                 * is invoked. This returns <code>null</code> if there are no edits
                 * to be undone.
                 *
                 * @return the next significant edit to be undone
                 */
                UndoManager.prototype.editToBeUndone = function () {
                    var i = this.indexOfNextAdd;
                    while ((i > 0)) {
                        var edit = this.edits.elementAt(--i);
                        if (edit.isSignificant()) {
                            return edit;
                        }
                    }
                    ;
                    return null;
                };
                /**
                 * Returns the the next significant edit to be redone if <code>redo</code>
                 * is invoked. This returns <code>null</code> if there are no edits
                 * to be redone.
                 *
                 * @return the next significant edit to be redone
                 */
                UndoManager.prototype.editToBeRedone = function () {
                    var count = this.edits.size();
                    var i = this.indexOfNextAdd;
                    while ((i < count)) {
                        var edit = this.edits.elementAt(i++);
                        if (edit.isSignificant()) {
                            return edit;
                        }
                    }
                    ;
                    return null;
                };
                /**
                 * Undoes all changes from the index of the next edit to
                 * <code>edit</code>, updating the index of the next edit appropriately.
                 *
                 * @throws CannotUndoException if one of the edits throws
                 * <code>CannotUndoException</code>
                 */
                UndoManager.prototype.undoTo = function (edit) {
                    var done = false;
                    while ((!done)) {
                        var next = this.edits.elementAt(--this.indexOfNextAdd);
                        next.undo();
                        done = next === edit;
                    }
                    ;
                };
                /**
                 * Redoes all changes from the index of the next edit to
                 * <code>edit</code>, updating the index of the next edit appropriately.
                 *
                 * @throws CannotRedoException if one of the edits throws
                 * <code>CannotRedoException</code>
                 */
                UndoManager.prototype.redoTo = function (edit) {
                    var done = false;
                    while ((!done)) {
                        var next = this.edits.elementAt(this.indexOfNextAdd++);
                        next.redo();
                        done = next === edit;
                    }
                    ;
                };
                /**
                 * Convenience method that invokes one of <code>undo</code> or
                 * <code>redo</code>. If any edits have been undone (the index of
                 * the next edit is less than the length of the edits list) this
                 * invokes <code>redo</code>, otherwise it invokes <code>undo</code>.
                 *
                 * @see #canUndoOrRedo
                 * @see #getUndoOrRedoPresentationName
                 * @throws CannotUndoException if one of the edits throws
                 * <code>CannotUndoException</code>
                 * @throws CannotRedoException if one of the edits throws
                 * <code>CannotRedoException</code>
                 */
                UndoManager.prototype.undoOrRedo = function () {
                    if (this.indexOfNextAdd === this.edits.size()) {
                        this.undo();
                    }
                    else {
                        this.redo();
                    }
                };
                /**
                 * Returns true if it is possible to invoke <code>undo</code> or
                 * <code>redo</code>.
                 *
                 * @return true if invoking <code>canUndoOrRedo</code> is valid
                 * @see #undoOrRedo
                 */
                UndoManager.prototype.canUndoOrRedo = function () {
                    if (this.indexOfNextAdd === this.edits.size()) {
                        return this.canUndo();
                    }
                    else {
                        return this.canRedo();
                    }
                };
                /**
                 * Undoes the appropriate edits.  If <code>end</code> has been
                 * invoked this calls through to the superclass, otherwise
                 * this invokes <code>undo</code> on all edits between the
                 * index of the next edit and the last significant edit, updating
                 * the index of the next edit appropriately.
                 *
                 * @throws CannotUndoException if one of the edits throws
                 * <code>CannotUndoException</code> or there are no edits
                 * to be undone
                 * @see CompoundEdit#end
                 * @see #canUndo
                 * @see #editToBeUndone
                 */
                UndoManager.prototype.undo = function () {
                    if (this.inProgress) {
                        var edit = this.editToBeUndone();
                        if (edit == null) {
                            throw new javax.swing.undo.CannotUndoException();
                        }
                        this.undoTo(edit);
                    }
                    else {
                        _super.prototype.undo.call(this);
                    }
                };
                /**
                 * Returns true if edits may be undone.  If <code>end</code> has
                 * been invoked, this returns the value from super.  Otherwise
                 * this returns true if there are any edits to be undone
                 * (<code>editToBeUndone</code> returns non-<code>null</code>).
                 *
                 * @return true if there are edits to be undone
                 * @see CompoundEdit#canUndo
                 * @see #editToBeUndone
                 */
                UndoManager.prototype.canUndo = function () {
                    if (this.inProgress) {
                        var edit = this.editToBeUndone();
                        return edit != null && edit.canUndo();
                    }
                    else {
                        return _super.prototype.canUndo.call(this);
                    }
                };
                /**
                 * Redoes the appropriate edits.  If <code>end</code> has been
                 * invoked this calls through to the superclass.  Otherwise
                 * this invokes <code>redo</code> on all edits between the
                 * index of the next edit and the next significant edit, updating
                 * the index of the next edit appropriately.
                 *
                 * @throws CannotRedoException if one of the edits throws
                 * <code>CannotRedoException</code> or there are no edits
                 * to be redone
                 * @see CompoundEdit#end
                 * @see #canRedo
                 * @see #editToBeRedone
                 */
                UndoManager.prototype.redo = function () {
                    if (this.inProgress) {
                        var edit = this.editToBeRedone();
                        if (edit == null) {
                            throw new javax.swing.undo.CannotRedoException();
                        }
                        this.redoTo(edit);
                    }
                    else {
                        _super.prototype.redo.call(this);
                    }
                };
                /**
                 * Returns true if edits may be redone.  If <code>end</code> has
                 * been invoked, this returns the value from super.  Otherwise,
                 * this returns true if there are any edits to be redone
                 * (<code>editToBeRedone</code> returns non-<code>null</code>).
                 *
                 * @return true if there are edits to be redone
                 * @see CompoundEdit#canRedo
                 * @see #editToBeRedone
                 */
                UndoManager.prototype.canRedo = function () {
                    if (this.inProgress) {
                        var edit = this.editToBeRedone();
                        return edit != null && edit.canRedo();
                    }
                    else {
                        return _super.prototype.canRedo.call(this);
                    }
                };
                /**
                 * Adds an <code>UndoableEdit</code> to this
                 * <code>UndoManager</code>, if it's possible.  This removes all
                 * edits from the index of the next edit to the end of the edits
                 * list.  If <code>end</code> has been invoked the edit is not added
                 * and <code>false</code> is returned.  If <code>end</code> hasn't
                 * been invoked this returns <code>true</code>.
                 *
                 * @param anEdit the edit to be added
                 * @return true if <code>anEdit</code> can be incorporated into this
                 * edit
                 * @see CompoundEdit#end
                 * @see CompoundEdit#addEdit
                 */
                UndoManager.prototype.addEdit = function (anEdit) {
                    var retVal;
                    this.trimEdits(this.indexOfNextAdd, this.edits.size() - 1);
                    retVal = _super.prototype.addEdit.call(this, anEdit);
                    if (this.inProgress) {
                        retVal = true;
                    }
                    this.indexOfNextAdd = this.edits.size();
                    this.trimForLimit();
                    return retVal;
                };
                /**
                 * Turns this <code>UndoManager</code> into a normal
                 * <code>CompoundEdit</code>.  This removes all edits that have
                 * been undone.
                 *
                 * @see CompoundEdit#end
                 */
                UndoManager.prototype.end = function () {
                    _super.prototype.end.call(this);
                    this.trimEdits(this.indexOfNextAdd, this.edits.size() - 1);
                };
                /**
                 * Convenience method that returns either
                 * <code>getUndoPresentationName</code> or
                 * <code>getRedoPresentationName</code>.  If the index of the next
                 * edit equals the size of the edits list,
                 * <code>getUndoPresentationName</code> is returned, otherwise
                 * <code>getRedoPresentationName</code> is returned.
                 *
                 * @return undo or redo name
                 */
                UndoManager.prototype.getUndoOrRedoPresentationName = function () {
                    if (this.indexOfNextAdd === this.edits.size()) {
                        return this.getUndoPresentationName();
                    }
                    else {
                        return this.getRedoPresentationName();
                    }
                };
                /**
                 * Returns a description of the undoable form of this edit.
                 * If <code>end</code> has been invoked this calls into super.
                 * Otherwise if there are edits to be undone, this returns
                 * the value from the next significant edit that will be undone.
                 * If there are no edits to be undone and <code>end</code> has not
                 * been invoked this returns the value from the <code>UIManager</code>
                 * property "AbstractUndoableEdit.undoText".
                 *
                 * @return a description of the undoable form of this edit
                 * @see     #undo
                 * @see     CompoundEdit#getUndoPresentationName
                 */
                UndoManager.prototype.getUndoPresentationName = function () {
                    if (this.inProgress) {
                        if (this.canUndo()) {
                            return this.editToBeUndone().getUndoPresentationName();
                        }
                        else {
                            return javax.swing.UIManager.getString("AbstractUndoableEdit.undoText");
                        }
                    }
                    else {
                        return _super.prototype.getUndoPresentationName.call(this);
                    }
                };
                /**
                 * Returns a description of the redoable form of this edit.
                 * If <code>end</code> has been invoked this calls into super.
                 * Otherwise if there are edits to be redone, this returns
                 * the value from the next significant edit that will be redone.
                 * If there are no edits to be redone and <code>end</code> has not
                 * been invoked this returns the value from the <code>UIManager</code>
                 * property "AbstractUndoableEdit.redoText".
                 *
                 * @return a description of the redoable form of this edit
                 * @see     #redo
                 * @see     CompoundEdit#getRedoPresentationName
                 */
                UndoManager.prototype.getRedoPresentationName = function () {
                    if (this.inProgress) {
                        if (this.canRedo()) {
                            return this.editToBeRedone().getRedoPresentationName();
                        }
                        else {
                            return javax.swing.UIManager.getString("AbstractUndoableEdit.redoText");
                        }
                    }
                    else {
                        return _super.prototype.getRedoPresentationName.call(this);
                    }
                };
                /**
                 * An <code>UndoableEditListener</code> method. This invokes
                 * <code>addEdit</code> with <code>e.getEdit()</code>.
                 *
                 * @param e the <code>UndoableEditEvent</code> the
                 * <code>UndoableEditEvent</code> will be added from
                 * @see #addEdit
                 */
                UndoManager.prototype.undoableEditHappened = function (e) {
                    this.addEdit(e.getEdit());
                };
                /**
                 * Returns a string that displays and identifies this
                 * object's properties.
                 *
                 * @return a String representation of this object
                 */
                UndoManager.prototype.toString = function () {
                    return _super.prototype.toString.call(this) + " limit: " + this.limit + " indexOfNextAdd: " + this.indexOfNextAdd;
                };
                return UndoManager;
            }(javax.swing.undo.CompoundEdit));
            undo.UndoManager = UndoManager;
            UndoManager["__class"] = "javax.swing.undo.UndoManager";
            UndoManager["__interfaces"] = ["java.util.EventListener", "javax.swing.event.UndoableEditListener", "javax.swing.undo.UndoableEdit", "java.io.Serializable"];
        })(undo = swing.undo || (swing.undo = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var event;
        (function (event) {
            var KeyEvent = (function (_super) {
                __extends(KeyEvent, _super);
                function KeyEvent(source, id, when, modifiers, keyCode, keyChar, keyLocation, isProxyActive) {
                    var _this = this;
                    if (((source != null && source instanceof java.awt.Component) || source === null) && ((typeof id === 'number') || id === null) && ((typeof when === 'number') || when === null) && ((typeof modifiers === 'number') || modifiers === null) && ((typeof keyCode === 'number') || keyCode === null) && ((typeof keyChar === 'string') || keyChar === null) && ((typeof keyLocation === 'number') || keyLocation === null) && ((typeof isProxyActive === 'boolean') || isProxyActive === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        {
                            var __args_38 = Array.prototype.slice.call(arguments);
                            _super.call(this, source, id, when, modifiers);
                            this.isProxyActive = false;
                            this.keyCode = 0;
                            this.keyChar = null;
                            this.keyLocation = 0;
                            (function () {
                                if (id === KeyEvent.KEY_TYPED_$LI$()) {
                                    if (keyChar === KeyEvent.CHAR_UNDEFINED) {
                                        throw new java.lang.IllegalArgumentException("invalid keyChar");
                                    }
                                    if (keyCode !== KeyEvent.VK_UNDEFINED) {
                                        throw new java.lang.IllegalArgumentException("invalid keyCode");
                                    }
                                    if (keyLocation !== KeyEvent.KEY_LOCATION_UNKNOWN) {
                                        throw new java.lang.IllegalArgumentException("invalid keyLocation");
                                    }
                                }
                                _this.keyCode = keyCode;
                                _this.keyChar = keyChar;
                                if ((keyLocation < KeyEvent.KEY_LOCATION_UNKNOWN) || (keyLocation > KeyEvent.KEY_LOCATION_NUMPAD)) {
                                    throw new java.lang.IllegalArgumentException("invalid keyLocation");
                                }
                                _this.keyLocation = keyLocation;
                                if ((_this.getModifiers() !== 0) && (_this.getModifiersEx() === 0)) {
                                    _this.setNewModifiers();
                                }
                                else if ((_this.getModifiers() === 0) && (_this.getModifiersEx() !== 0)) {
                                    _this.setOldModifiers();
                                }
                                _this.originalSource = source;
                            })();
                        }
                        (function () {
                            _this.isProxyActive = isProxyActive;
                        })();
                    }
                    else if (((source != null && source instanceof java.awt.Component) || source === null) && ((typeof id === 'number') || id === null) && ((typeof when === 'number') || when === null) && ((typeof modifiers === 'number') || modifiers === null) && ((typeof keyCode === 'number') || keyCode === null) && ((typeof keyChar === 'string') || keyChar === null) && ((typeof keyLocation === 'number') || keyLocation === null) && isProxyActive === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        _super.call(this, source, id, when, modifiers);
                        this.isProxyActive = false;
                        this.keyCode = 0;
                        this.keyChar = null;
                        this.keyLocation = 0;
                        (function () {
                            if (id === KeyEvent.KEY_TYPED_$LI$()) {
                                if (keyChar === KeyEvent.CHAR_UNDEFINED) {
                                    throw new java.lang.IllegalArgumentException("invalid keyChar");
                                }
                                if (keyCode !== KeyEvent.VK_UNDEFINED) {
                                    throw new java.lang.IllegalArgumentException("invalid keyCode");
                                }
                                if (keyLocation !== KeyEvent.KEY_LOCATION_UNKNOWN) {
                                    throw new java.lang.IllegalArgumentException("invalid keyLocation");
                                }
                            }
                            _this.keyCode = keyCode;
                            _this.keyChar = keyChar;
                            if ((keyLocation < KeyEvent.KEY_LOCATION_UNKNOWN) || (keyLocation > KeyEvent.KEY_LOCATION_NUMPAD)) {
                                throw new java.lang.IllegalArgumentException("invalid keyLocation");
                            }
                            _this.keyLocation = keyLocation;
                            if ((_this.getModifiers() !== 0) && (_this.getModifiersEx() === 0)) {
                                _this.setNewModifiers();
                            }
                            else if ((_this.getModifiers() === 0) && (_this.getModifiersEx() !== 0)) {
                                _this.setOldModifiers();
                            }
                            _this.originalSource = source;
                        })();
                    }
                    else if (((source != null && source instanceof java.awt.Component) || source === null) && ((typeof id === 'number') || id === null) && ((typeof when === 'number') || when === null) && ((typeof modifiers === 'number') || modifiers === null) && ((typeof keyCode === 'number') || keyCode === null) && ((typeof keyChar === 'string') || keyChar === null) && keyLocation === undefined && isProxyActive === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        {
                            var __args_39 = Array.prototype.slice.call(arguments);
                            var keyLocation_1 = KeyEvent.KEY_LOCATION_UNKNOWN;
                            _super.call(this, source, id, when, modifiers);
                            this.isProxyActive = false;
                            this.keyCode = 0;
                            this.keyChar = null;
                            this.keyLocation = 0;
                            (function () {
                                if (id === KeyEvent.KEY_TYPED_$LI$()) {
                                    if (keyChar === KeyEvent.CHAR_UNDEFINED) {
                                        throw new java.lang.IllegalArgumentException("invalid keyChar");
                                    }
                                    if (keyCode !== KeyEvent.VK_UNDEFINED) {
                                        throw new java.lang.IllegalArgumentException("invalid keyCode");
                                    }
                                    if (keyLocation_1 !== KeyEvent.KEY_LOCATION_UNKNOWN) {
                                        throw new java.lang.IllegalArgumentException("invalid keyLocation");
                                    }
                                }
                                _this.keyCode = keyCode;
                                _this.keyChar = keyChar;
                                if ((keyLocation_1 < KeyEvent.KEY_LOCATION_UNKNOWN) || (keyLocation_1 > KeyEvent.KEY_LOCATION_NUMPAD)) {
                                    throw new java.lang.IllegalArgumentException("invalid keyLocation");
                                }
                                _this.keyLocation = keyLocation_1;
                                if ((_this.getModifiers() !== 0) && (_this.getModifiersEx() === 0)) {
                                    _this.setNewModifiers();
                                }
                                else if ((_this.getModifiers() === 0) && (_this.getModifiersEx() !== 0)) {
                                    _this.setOldModifiers();
                                }
                                _this.originalSource = source;
                            })();
                        }
                    }
                    else if (((source != null && source instanceof java.awt.Component) || source === null) && ((typeof id === 'number') || id === null) && ((typeof when === 'number') || when === null) && ((typeof modifiers === 'number') || modifiers === null) && ((typeof keyCode === 'number') || keyCode === null) && keyChar === undefined && keyLocation === undefined && isProxyActive === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        {
                            var __args_40 = Array.prototype.slice.call(arguments);
                            var keyChar_1 = String.fromCharCode(__args_40[4]);
                            {
                                var __args_41 = Array.prototype.slice.call(arguments);
                                var keyLocation_2 = KeyEvent.KEY_LOCATION_UNKNOWN;
                                _super.call(this, source, id, when, modifiers);
                                this.isProxyActive = false;
                                this.keyCode = 0;
                                this.keyChar = null;
                                this.keyLocation = 0;
                                (function () {
                                    if (id === KeyEvent.KEY_TYPED_$LI$()) {
                                        if (keyChar_1 === KeyEvent.CHAR_UNDEFINED) {
                                            throw new java.lang.IllegalArgumentException("invalid keyChar");
                                        }
                                        if (keyCode !== KeyEvent.VK_UNDEFINED) {
                                            throw new java.lang.IllegalArgumentException("invalid keyCode");
                                        }
                                        if (keyLocation_2 !== KeyEvent.KEY_LOCATION_UNKNOWN) {
                                            throw new java.lang.IllegalArgumentException("invalid keyLocation");
                                        }
                                    }
                                    _this.keyCode = keyCode;
                                    _this.keyChar = keyChar_1;
                                    if ((keyLocation_2 < KeyEvent.KEY_LOCATION_UNKNOWN) || (keyLocation_2 > KeyEvent.KEY_LOCATION_NUMPAD)) {
                                        throw new java.lang.IllegalArgumentException("invalid keyLocation");
                                    }
                                    _this.keyLocation = keyLocation_2;
                                    if ((_this.getModifiers() !== 0) && (_this.getModifiersEx() === 0)) {
                                        _this.setNewModifiers();
                                    }
                                    else if ((_this.getModifiers() === 0) && (_this.getModifiersEx() !== 0)) {
                                        _this.setOldModifiers();
                                    }
                                    _this.originalSource = source;
                                })();
                            }
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                KeyEvent.KEY_TYPED_$LI$ = function () { if (KeyEvent.KEY_TYPED == null)
                    KeyEvent.KEY_TYPED = KeyEvent.KEY_FIRST; return KeyEvent.KEY_TYPED; };
                ;
                KeyEvent.KEY_PRESSED_$LI$ = function () { if (KeyEvent.KEY_PRESSED == null)
                    KeyEvent.KEY_PRESSED = 1 + KeyEvent.KEY_FIRST; return KeyEvent.KEY_PRESSED; };
                ;
                KeyEvent.KEY_RELEASED_$LI$ = function () { if (KeyEvent.KEY_RELEASED == null)
                    KeyEvent.KEY_RELEASED = 2 + KeyEvent.KEY_FIRST; return KeyEvent.KEY_RELEASED; };
                ;
                KeyEvent.VK_SEPARATOR_$LI$ = function () { if (KeyEvent.VK_SEPARATOR == null)
                    KeyEvent.VK_SEPARATOR = KeyEvent.VK_SEPARATER; return KeyEvent.VK_SEPARATOR; };
                ;
                KeyEvent.prototype.getKeyCode = function () {
                    return this.keyCode;
                };
                KeyEvent.prototype.setKeyCode = function (keyCode) {
                    this.keyCode = keyCode;
                };
                KeyEvent.prototype.getKeyChar = function () {
                    return this.keyChar;
                };
                KeyEvent.prototype.setKeyChar = function (keyChar) {
                    this.keyChar = keyChar;
                };
                KeyEvent.prototype.setModifiers = function (modifiers) {
                    this.modifiers = modifiers;
                    if ((this.getModifiers() !== 0) && (this.getModifiersEx() === 0)) {
                        this.setNewModifiers();
                    }
                    else if ((this.getModifiers() === 0) && (this.getModifiersEx() !== 0)) {
                        this.setOldModifiers();
                    }
                };
                KeyEvent.prototype.getKeyLocation = function () {
                    return this.keyLocation;
                };
                KeyEvent.getKeyText = function (keyCode) {
                    if (keyCode >= KeyEvent.VK_0 && keyCode <= KeyEvent.VK_9 || keyCode >= KeyEvent.VK_A && keyCode <= KeyEvent.VK_Z) {
                        return new String(String.fromCharCode(keyCode)).toString();
                    }
                    switch ((keyCode)) {
                        case KeyEvent.VK_ENTER:
                            return "Enter";
                        case KeyEvent.VK_BACK_SPACE:
                            return java.awt.Toolkit.getProperty("AWT.backSpace", "Backspace");
                        case KeyEvent.VK_TAB:
                            return java.awt.Toolkit.getProperty("AWT.tab", "Tab");
                        case KeyEvent.VK_CANCEL:
                            return java.awt.Toolkit.getProperty("AWT.cancel", "Cancel");
                        case KeyEvent.VK_CLEAR:
                            return java.awt.Toolkit.getProperty("AWT.clear", "Clear");
                        case KeyEvent.VK_COMPOSE:
                            return java.awt.Toolkit.getProperty("AWT.compose", "Compose");
                        case KeyEvent.VK_PAUSE:
                            return java.awt.Toolkit.getProperty("AWT.pause", "Pause");
                        case KeyEvent.VK_CAPS_LOCK:
                            return java.awt.Toolkit.getProperty("AWT.capsLock", "Caps Lock");
                        case KeyEvent.VK_ESCAPE:
                            return java.awt.Toolkit.getProperty("AWT.escape", "Escape");
                        case KeyEvent.VK_SPACE:
                            return java.awt.Toolkit.getProperty("AWT.space", "Space");
                        case KeyEvent.VK_PAGE_UP:
                            return java.awt.Toolkit.getProperty("AWT.pgup", "Page Up");
                        case KeyEvent.VK_PAGE_DOWN:
                            return java.awt.Toolkit.getProperty("AWT.pgdn", "Page Down");
                        case KeyEvent.VK_END:
                            return java.awt.Toolkit.getProperty("AWT.end", "End");
                        case KeyEvent.VK_HOME:
                            return java.awt.Toolkit.getProperty("AWT.home", "Home");
                        case KeyEvent.VK_LEFT:
                            return java.awt.Toolkit.getProperty("AWT.left", "Left");
                        case KeyEvent.VK_UP:
                            return java.awt.Toolkit.getProperty("AWT.up", "Up");
                        case KeyEvent.VK_RIGHT:
                            return java.awt.Toolkit.getProperty("AWT.right", "Right");
                        case KeyEvent.VK_DOWN:
                            return java.awt.Toolkit.getProperty("AWT.down", "Down");
                        case KeyEvent.VK_BEGIN:
                            return java.awt.Toolkit.getProperty("AWT.begin", "Begin");
                        case KeyEvent.VK_SHIFT:
                            return java.awt.Toolkit.getProperty("AWT.shift", "Shift");
                        case KeyEvent.VK_CONTROL:
                            return java.awt.Toolkit.getProperty("AWT.control", "Control");
                        case KeyEvent.VK_ALT:
                            return java.awt.Toolkit.getProperty("AWT.alt", "Alt");
                        case KeyEvent.VK_META:
                            return java.awt.Toolkit.getProperty("AWT.meta", "Meta");
                        case KeyEvent.VK_ALT_GRAPH:
                            return java.awt.Toolkit.getProperty("AWT.altGraph", "Alt Graph");
                        case KeyEvent.VK_COMMA:
                            return java.awt.Toolkit.getProperty("AWT.comma", "Comma");
                        case KeyEvent.VK_PERIOD:
                            return java.awt.Toolkit.getProperty("AWT.period", "Period");
                        case KeyEvent.VK_SLASH:
                            return java.awt.Toolkit.getProperty("AWT.slash", "Slash");
                        case KeyEvent.VK_SEMICOLON:
                            return java.awt.Toolkit.getProperty("AWT.semicolon", "Semicolon");
                        case KeyEvent.VK_EQUALS:
                            return java.awt.Toolkit.getProperty("AWT.equals", "Equals");
                        case KeyEvent.VK_OPEN_BRACKET:
                            return java.awt.Toolkit.getProperty("AWT.openBracket", "Open Bracket");
                        case KeyEvent.VK_BACK_SLASH:
                            return java.awt.Toolkit.getProperty("AWT.backSlash", "Back Slash");
                        case KeyEvent.VK_CLOSE_BRACKET:
                            return java.awt.Toolkit.getProperty("AWT.closeBracket", "Close Bracket");
                        case KeyEvent.VK_MULTIPLY:
                            return java.awt.Toolkit.getProperty("AWT.multiply", "NumPad *");
                        case KeyEvent.VK_ADD:
                            return java.awt.Toolkit.getProperty("AWT.add", "NumPad +");
                        case KeyEvent.VK_SEPARATOR_$LI$():
                            return java.awt.Toolkit.getProperty("AWT.separator", "NumPad ,");
                        case KeyEvent.VK_SUBTRACT:
                            return java.awt.Toolkit.getProperty("AWT.subtract", "NumPad -");
                        case KeyEvent.VK_DECIMAL:
                            return java.awt.Toolkit.getProperty("AWT.decimal", "NumPad .");
                        case KeyEvent.VK_DIVIDE:
                            return java.awt.Toolkit.getProperty("AWT.divide", "NumPad /");
                        case KeyEvent.VK_DELETE:
                            return java.awt.Toolkit.getProperty("AWT.delete", "Delete");
                        case KeyEvent.VK_NUM_LOCK:
                            return java.awt.Toolkit.getProperty("AWT.numLock", "Num Lock");
                        case KeyEvent.VK_SCROLL_LOCK:
                            return java.awt.Toolkit.getProperty("AWT.scrollLock", "Scroll Lock");
                        case KeyEvent.VK_WINDOWS:
                            return java.awt.Toolkit.getProperty("AWT.windows", "Windows");
                        case KeyEvent.VK_CONTEXT_MENU:
                            return java.awt.Toolkit.getProperty("AWT.context", "Context Menu");
                        case KeyEvent.VK_F1:
                            return java.awt.Toolkit.getProperty("AWT.f1", "F1");
                        case KeyEvent.VK_F2:
                            return java.awt.Toolkit.getProperty("AWT.f2", "F2");
                        case KeyEvent.VK_F3:
                            return java.awt.Toolkit.getProperty("AWT.f3", "F3");
                        case KeyEvent.VK_F4:
                            return java.awt.Toolkit.getProperty("AWT.f4", "F4");
                        case KeyEvent.VK_F5:
                            return java.awt.Toolkit.getProperty("AWT.f5", "F5");
                        case KeyEvent.VK_F6:
                            return java.awt.Toolkit.getProperty("AWT.f6", "F6");
                        case KeyEvent.VK_F7:
                            return java.awt.Toolkit.getProperty("AWT.f7", "F7");
                        case KeyEvent.VK_F8:
                            return java.awt.Toolkit.getProperty("AWT.f8", "F8");
                        case KeyEvent.VK_F9:
                            return java.awt.Toolkit.getProperty("AWT.f9", "F9");
                        case KeyEvent.VK_F10:
                            return java.awt.Toolkit.getProperty("AWT.f10", "F10");
                        case KeyEvent.VK_F11:
                            return java.awt.Toolkit.getProperty("AWT.f11", "F11");
                        case KeyEvent.VK_F12:
                            return java.awt.Toolkit.getProperty("AWT.f12", "F12");
                        case KeyEvent.VK_F13:
                            return java.awt.Toolkit.getProperty("AWT.f13", "F13");
                        case KeyEvent.VK_F14:
                            return java.awt.Toolkit.getProperty("AWT.f14", "F14");
                        case KeyEvent.VK_F15:
                            return java.awt.Toolkit.getProperty("AWT.f15", "F15");
                        case KeyEvent.VK_F16:
                            return java.awt.Toolkit.getProperty("AWT.f16", "F16");
                        case KeyEvent.VK_F17:
                            return java.awt.Toolkit.getProperty("AWT.f17", "F17");
                        case KeyEvent.VK_F18:
                            return java.awt.Toolkit.getProperty("AWT.f18", "F18");
                        case KeyEvent.VK_F19:
                            return java.awt.Toolkit.getProperty("AWT.f19", "F19");
                        case KeyEvent.VK_F20:
                            return java.awt.Toolkit.getProperty("AWT.f20", "F20");
                        case KeyEvent.VK_F21:
                            return java.awt.Toolkit.getProperty("AWT.f21", "F21");
                        case KeyEvent.VK_F22:
                            return java.awt.Toolkit.getProperty("AWT.f22", "F22");
                        case KeyEvent.VK_F23:
                            return java.awt.Toolkit.getProperty("AWT.f23", "F23");
                        case KeyEvent.VK_F24:
                            return java.awt.Toolkit.getProperty("AWT.f24", "F24");
                        case KeyEvent.VK_PRINTSCREEN:
                            return java.awt.Toolkit.getProperty("AWT.printScreen", "Print Screen");
                        case KeyEvent.VK_INSERT:
                            return java.awt.Toolkit.getProperty("AWT.insert", "Insert");
                        case KeyEvent.VK_HELP:
                            return java.awt.Toolkit.getProperty("AWT.help", "Help");
                        case KeyEvent.VK_BACK_QUOTE:
                            return java.awt.Toolkit.getProperty("AWT.backQuote", "Back Quote");
                        case KeyEvent.VK_QUOTE:
                            return java.awt.Toolkit.getProperty("AWT.quote", "Quote");
                        case KeyEvent.VK_KP_UP:
                            return java.awt.Toolkit.getProperty("AWT.up", "Up");
                        case KeyEvent.VK_KP_DOWN:
                            return java.awt.Toolkit.getProperty("AWT.down", "Down");
                        case KeyEvent.VK_KP_LEFT:
                            return java.awt.Toolkit.getProperty("AWT.left", "Left");
                        case KeyEvent.VK_KP_RIGHT:
                            return java.awt.Toolkit.getProperty("AWT.right", "Right");
                        case KeyEvent.VK_DEAD_GRAVE:
                            return java.awt.Toolkit.getProperty("AWT.deadGrave", "Dead Grave");
                        case KeyEvent.VK_DEAD_ACUTE:
                            return java.awt.Toolkit.getProperty("AWT.deadAcute", "Dead Acute");
                        case KeyEvent.VK_DEAD_CIRCUMFLEX:
                            return java.awt.Toolkit.getProperty("AWT.deadCircumflex", "Dead Circumflex");
                        case KeyEvent.VK_DEAD_TILDE:
                            return java.awt.Toolkit.getProperty("AWT.deadTilde", "Dead Tilde");
                        case KeyEvent.VK_DEAD_MACRON:
                            return java.awt.Toolkit.getProperty("AWT.deadMacron", "Dead Macron");
                        case KeyEvent.VK_DEAD_BREVE:
                            return java.awt.Toolkit.getProperty("AWT.deadBreve", "Dead Breve");
                        case KeyEvent.VK_DEAD_ABOVEDOT:
                            return java.awt.Toolkit.getProperty("AWT.deadAboveDot", "Dead Above Dot");
                        case KeyEvent.VK_DEAD_DIAERESIS:
                            return java.awt.Toolkit.getProperty("AWT.deadDiaeresis", "Dead Diaeresis");
                        case KeyEvent.VK_DEAD_ABOVERING:
                            return java.awt.Toolkit.getProperty("AWT.deadAboveRing", "Dead Above Ring");
                        case KeyEvent.VK_DEAD_DOUBLEACUTE:
                            return java.awt.Toolkit.getProperty("AWT.deadDoubleAcute", "Dead Double Acute");
                        case KeyEvent.VK_DEAD_CARON:
                            return java.awt.Toolkit.getProperty("AWT.deadCaron", "Dead Caron");
                        case KeyEvent.VK_DEAD_CEDILLA:
                            return java.awt.Toolkit.getProperty("AWT.deadCedilla", "Dead Cedilla");
                        case KeyEvent.VK_DEAD_OGONEK:
                            return java.awt.Toolkit.getProperty("AWT.deadOgonek", "Dead Ogonek");
                        case KeyEvent.VK_DEAD_IOTA:
                            return java.awt.Toolkit.getProperty("AWT.deadIota", "Dead Iota");
                        case KeyEvent.VK_DEAD_VOICED_SOUND:
                            return java.awt.Toolkit.getProperty("AWT.deadVoicedSound", "Dead Voiced Sound");
                        case KeyEvent.VK_DEAD_SEMIVOICED_SOUND:
                            return java.awt.Toolkit.getProperty("AWT.deadSemivoicedSound", "Dead Semivoiced Sound");
                        case KeyEvent.VK_AMPERSAND:
                            return java.awt.Toolkit.getProperty("AWT.ampersand", "Ampersand");
                        case KeyEvent.VK_ASTERISK:
                            return java.awt.Toolkit.getProperty("AWT.asterisk", "Asterisk");
                        case KeyEvent.VK_QUOTEDBL:
                            return java.awt.Toolkit.getProperty("AWT.quoteDbl", "Double Quote");
                        case KeyEvent.VK_LESS:
                            return java.awt.Toolkit.getProperty("AWT.Less", "Less");
                        case KeyEvent.VK_GREATER:
                            return java.awt.Toolkit.getProperty("AWT.greater", "Greater");
                        case KeyEvent.VK_BRACELEFT:
                            return java.awt.Toolkit.getProperty("AWT.braceLeft", "Left Brace");
                        case KeyEvent.VK_BRACERIGHT:
                            return java.awt.Toolkit.getProperty("AWT.braceRight", "Right Brace");
                        case KeyEvent.VK_AT:
                            return java.awt.Toolkit.getProperty("AWT.at", "At");
                        case KeyEvent.VK_COLON:
                            return java.awt.Toolkit.getProperty("AWT.colon", "Colon");
                        case KeyEvent.VK_CIRCUMFLEX:
                            return java.awt.Toolkit.getProperty("AWT.circumflex", "Circumflex");
                        case KeyEvent.VK_DOLLAR:
                            return java.awt.Toolkit.getProperty("AWT.dollar", "Dollar");
                        case KeyEvent.VK_EURO_SIGN:
                            return java.awt.Toolkit.getProperty("AWT.euro", "Euro");
                        case KeyEvent.VK_EXCLAMATION_MARK:
                            return java.awt.Toolkit.getProperty("AWT.exclamationMark", "Exclamation Mark");
                        case KeyEvent.VK_INVERTED_EXCLAMATION_MARK:
                            return java.awt.Toolkit.getProperty("AWT.invertedExclamationMark", "Inverted Exclamation Mark");
                        case KeyEvent.VK_LEFT_PARENTHESIS:
                            return java.awt.Toolkit.getProperty("AWT.leftParenthesis", "Left Parenthesis");
                        case KeyEvent.VK_NUMBER_SIGN:
                            return java.awt.Toolkit.getProperty("AWT.numberSign", "Number Sign");
                        case KeyEvent.VK_MINUS:
                            return java.awt.Toolkit.getProperty("AWT.minus", "Minus");
                        case KeyEvent.VK_PLUS:
                            return java.awt.Toolkit.getProperty("AWT.plus", "Plus");
                        case KeyEvent.VK_RIGHT_PARENTHESIS:
                            return java.awt.Toolkit.getProperty("AWT.rightParenthesis", "Right Parenthesis");
                        case KeyEvent.VK_UNDERSCORE:
                            return java.awt.Toolkit.getProperty("AWT.underscore", "Underscore");
                        case KeyEvent.VK_FINAL:
                            return java.awt.Toolkit.getProperty("AWT.final", "Final");
                        case KeyEvent.VK_CONVERT:
                            return java.awt.Toolkit.getProperty("AWT.convert", "Convert");
                        case KeyEvent.VK_NONCONVERT:
                            return java.awt.Toolkit.getProperty("AWT.noconvert", "No Convert");
                        case KeyEvent.VK_ACCEPT:
                            return java.awt.Toolkit.getProperty("AWT.accept", "Accept");
                        case KeyEvent.VK_MODECHANGE:
                            return java.awt.Toolkit.getProperty("AWT.modechange", "Mode Change");
                        case KeyEvent.VK_KANA:
                            return java.awt.Toolkit.getProperty("AWT.kana", "Kana");
                        case KeyEvent.VK_KANJI:
                            return java.awt.Toolkit.getProperty("AWT.kanji", "Kanji");
                        case KeyEvent.VK_ALPHANUMERIC:
                            return java.awt.Toolkit.getProperty("AWT.alphanumeric", "Alphanumeric");
                        case KeyEvent.VK_KATAKANA:
                            return java.awt.Toolkit.getProperty("AWT.katakana", "Katakana");
                        case KeyEvent.VK_HIRAGANA:
                            return java.awt.Toolkit.getProperty("AWT.hiragana", "Hiragana");
                        case KeyEvent.VK_FULL_WIDTH:
                            return java.awt.Toolkit.getProperty("AWT.fullWidth", "Full-Width");
                        case KeyEvent.VK_HALF_WIDTH:
                            return java.awt.Toolkit.getProperty("AWT.halfWidth", "Half-Width");
                        case KeyEvent.VK_ROMAN_CHARACTERS:
                            return java.awt.Toolkit.getProperty("AWT.romanCharacters", "Roman Characters");
                        case KeyEvent.VK_ALL_CANDIDATES:
                            return java.awt.Toolkit.getProperty("AWT.allCandidates", "All Candidates");
                        case KeyEvent.VK_PREVIOUS_CANDIDATE:
                            return java.awt.Toolkit.getProperty("AWT.previousCandidate", "Previous Candidate");
                        case KeyEvent.VK_CODE_INPUT:
                            return java.awt.Toolkit.getProperty("AWT.codeInput", "Code Input");
                        case KeyEvent.VK_JAPANESE_KATAKANA:
                            return java.awt.Toolkit.getProperty("AWT.japaneseKatakana", "Japanese Katakana");
                        case KeyEvent.VK_JAPANESE_HIRAGANA:
                            return java.awt.Toolkit.getProperty("AWT.japaneseHiragana", "Japanese Hiragana");
                        case KeyEvent.VK_JAPANESE_ROMAN:
                            return java.awt.Toolkit.getProperty("AWT.japaneseRoman", "Japanese Roman");
                        case KeyEvent.VK_KANA_LOCK:
                            return java.awt.Toolkit.getProperty("AWT.kanaLock", "Kana Lock");
                        case KeyEvent.VK_INPUT_METHOD_ON_OFF:
                            return java.awt.Toolkit.getProperty("AWT.inputMethodOnOff", "Input Method On/Off");
                        case KeyEvent.VK_AGAIN:
                            return java.awt.Toolkit.getProperty("AWT.again", "Again");
                        case KeyEvent.VK_UNDO:
                            return java.awt.Toolkit.getProperty("AWT.undo", "Undo");
                        case KeyEvent.VK_COPY:
                            return java.awt.Toolkit.getProperty("AWT.copy", "Copy");
                        case KeyEvent.VK_PASTE:
                            return java.awt.Toolkit.getProperty("AWT.paste", "Paste");
                        case KeyEvent.VK_CUT:
                            return java.awt.Toolkit.getProperty("AWT.cut", "Cut");
                        case KeyEvent.VK_FIND:
                            return java.awt.Toolkit.getProperty("AWT.find", "Find");
                        case KeyEvent.VK_PROPS:
                            return java.awt.Toolkit.getProperty("AWT.props", "Props");
                        case KeyEvent.VK_STOP:
                            return java.awt.Toolkit.getProperty("AWT.stop", "Stop");
                    }
                    if (keyCode >= KeyEvent.VK_NUMPAD0 && keyCode <= KeyEvent.VK_NUMPAD9) {
                        var numpad = java.awt.Toolkit.getProperty("AWT.numpad", "NumPad");
                        var c = String.fromCharCode((keyCode - KeyEvent.VK_NUMPAD0 + ('0').charCodeAt(0)));
                        return numpad + "-" + c;
                    }
                    if ((keyCode & 16777216) !== 0) {
                        return new String(String.fromCharCode((keyCode ^ 16777216))).toString();
                    }
                    var unknown = java.awt.Toolkit.getProperty("AWT.unknown", "Unknown");
                    return unknown + " keyCode: 0x" + ('' + keyCode);
                };
                KeyEvent.getKeyModifiersText = function (modifiers) {
                    var buf = new java.lang.StringBuilder();
                    if ((modifiers & java.awt.event.InputEvent.META_MASK_$LI$()) !== 0) {
                        buf.append(java.awt.Toolkit.getProperty("AWT.meta", "Meta"));
                        buf.append("+");
                    }
                    if ((modifiers & java.awt.event.InputEvent.CTRL_MASK_$LI$()) !== 0) {
                        buf.append(java.awt.Toolkit.getProperty("AWT.control", "Ctrl"));
                        buf.append("+");
                    }
                    if ((modifiers & java.awt.event.InputEvent.ALT_MASK_$LI$()) !== 0) {
                        buf.append(java.awt.Toolkit.getProperty("AWT.alt", "Alt"));
                        buf.append("+");
                    }
                    if ((modifiers & java.awt.event.InputEvent.SHIFT_MASK_$LI$()) !== 0) {
                        buf.append(java.awt.Toolkit.getProperty("AWT.shift", "Shift"));
                        buf.append("+");
                    }
                    if ((modifiers & java.awt.event.InputEvent.ALT_GRAPH_MASK_$LI$()) !== 0) {
                        buf.append(java.awt.Toolkit.getProperty("AWT.altGraph", "Alt Graph"));
                        buf.append("+");
                    }
                    if ((modifiers & java.awt.event.InputEvent.BUTTON1_MASK_$LI$()) !== 0) {
                        buf.append(java.awt.Toolkit.getProperty("AWT.button1", "Button1"));
                        buf.append("+");
                    }
                    if (buf.length() > 0) {
                        buf.setLength(buf.length() - 1);
                    }
                    return buf.toString();
                };
                KeyEvent.prototype.isActionKey = function () {
                    switch ((this.keyCode)) {
                        case KeyEvent.VK_HOME:
                        case KeyEvent.VK_END:
                        case KeyEvent.VK_PAGE_UP:
                        case KeyEvent.VK_PAGE_DOWN:
                        case KeyEvent.VK_UP:
                        case KeyEvent.VK_DOWN:
                        case KeyEvent.VK_LEFT:
                        case KeyEvent.VK_RIGHT:
                        case KeyEvent.VK_BEGIN:
                        case KeyEvent.VK_KP_LEFT:
                        case KeyEvent.VK_KP_UP:
                        case KeyEvent.VK_KP_RIGHT:
                        case KeyEvent.VK_KP_DOWN:
                        case KeyEvent.VK_F1:
                        case KeyEvent.VK_F2:
                        case KeyEvent.VK_F3:
                        case KeyEvent.VK_F4:
                        case KeyEvent.VK_F5:
                        case KeyEvent.VK_F6:
                        case KeyEvent.VK_F7:
                        case KeyEvent.VK_F8:
                        case KeyEvent.VK_F9:
                        case KeyEvent.VK_F10:
                        case KeyEvent.VK_F11:
                        case KeyEvent.VK_F12:
                        case KeyEvent.VK_F13:
                        case KeyEvent.VK_F14:
                        case KeyEvent.VK_F15:
                        case KeyEvent.VK_F16:
                        case KeyEvent.VK_F17:
                        case KeyEvent.VK_F18:
                        case KeyEvent.VK_F19:
                        case KeyEvent.VK_F20:
                        case KeyEvent.VK_F21:
                        case KeyEvent.VK_F22:
                        case KeyEvent.VK_F23:
                        case KeyEvent.VK_F24:
                        case KeyEvent.VK_PRINTSCREEN:
                        case KeyEvent.VK_SCROLL_LOCK:
                        case KeyEvent.VK_CAPS_LOCK:
                        case KeyEvent.VK_NUM_LOCK:
                        case KeyEvent.VK_PAUSE:
                        case KeyEvent.VK_INSERT:
                        case KeyEvent.VK_FINAL:
                        case KeyEvent.VK_CONVERT:
                        case KeyEvent.VK_NONCONVERT:
                        case KeyEvent.VK_ACCEPT:
                        case KeyEvent.VK_MODECHANGE:
                        case KeyEvent.VK_KANA:
                        case KeyEvent.VK_KANJI:
                        case KeyEvent.VK_ALPHANUMERIC:
                        case KeyEvent.VK_KATAKANA:
                        case KeyEvent.VK_HIRAGANA:
                        case KeyEvent.VK_FULL_WIDTH:
                        case KeyEvent.VK_HALF_WIDTH:
                        case KeyEvent.VK_ROMAN_CHARACTERS:
                        case KeyEvent.VK_ALL_CANDIDATES:
                        case KeyEvent.VK_PREVIOUS_CANDIDATE:
                        case KeyEvent.VK_CODE_INPUT:
                        case KeyEvent.VK_JAPANESE_KATAKANA:
                        case KeyEvent.VK_JAPANESE_HIRAGANA:
                        case KeyEvent.VK_JAPANESE_ROMAN:
                        case KeyEvent.VK_KANA_LOCK:
                        case KeyEvent.VK_INPUT_METHOD_ON_OFF:
                        case KeyEvent.VK_AGAIN:
                        case KeyEvent.VK_UNDO:
                        case KeyEvent.VK_COPY:
                        case KeyEvent.VK_PASTE:
                        case KeyEvent.VK_CUT:
                        case KeyEvent.VK_FIND:
                        case KeyEvent.VK_PROPS:
                        case KeyEvent.VK_STOP:
                        case KeyEvent.VK_HELP:
                        case KeyEvent.VK_WINDOWS:
                        case KeyEvent.VK_CONTEXT_MENU:
                            return true;
                    }
                    return false;
                };
                KeyEvent.prototype.paramString = function () {
                    var str = new java.lang.StringBuilder(100);
                    switch ((this.id)) {
                        case KeyEvent.KEY_PRESSED_$LI$():
                            str.append("KEY_PRESSED");
                            break;
                        case KeyEvent.KEY_RELEASED_$LI$():
                            str.append("KEY_RELEASED");
                            break;
                        case KeyEvent.KEY_TYPED_$LI$():
                            str.append("KEY_TYPED");
                            break;
                        default:
                            str.append("unknown type");
                            break;
                    }
                    str.append(",keyCode=").append(this.keyCode);
                    str.append(",keyText=").append(KeyEvent.getKeyText(this.keyCode));
                    str.append(",keyChar=");
                    switch ((this.keyChar)) {
                        case '\b':
                            str.append(KeyEvent.getKeyText(KeyEvent.VK_BACK_SPACE));
                            break;
                        case '\t':
                            str.append(KeyEvent.getKeyText(KeyEvent.VK_TAB));
                            break;
                        case '\n':
                            str.append(KeyEvent.getKeyText(KeyEvent.VK_ENTER));
                            break;
                        case '\u0018':
                            str.append(KeyEvent.getKeyText(KeyEvent.VK_CANCEL));
                            break;
                        case '\u001b':
                            str.append(KeyEvent.getKeyText(KeyEvent.VK_ESCAPE));
                            break;
                        case '\u007f':
                            str.append(KeyEvent.getKeyText(KeyEvent.VK_DELETE));
                            break;
                        case KeyEvent.CHAR_UNDEFINED:
                            str.append(java.awt.Toolkit.getProperty("AWT.undefined", "Undefined"));
                            str.append(" keyChar");
                            break;
                        default:
                            str.append("\'").append(this.keyChar).append("\'");
                            break;
                    }
                    if (this.getModifiers() !== 0) {
                        str.append(",modifiers=").append(KeyEvent.getKeyModifiersText(this.modifiers));
                    }
                    if (this.getModifiersEx() !== 0) {
                        str.append(",extModifiers=").append(event.InputEvent.getModifiersExText(this.modifiers));
                    }
                    str.append(",keyLocation=");
                    switch ((this.keyLocation)) {
                        case KeyEvent.KEY_LOCATION_UNKNOWN:
                            str.append("KEY_LOCATION_UNKNOWN");
                            break;
                        case KeyEvent.KEY_LOCATION_STANDARD:
                            str.append("KEY_LOCATION_STANDARD");
                            break;
                        case KeyEvent.KEY_LOCATION_LEFT:
                            str.append("KEY_LOCATION_LEFT");
                            break;
                        case KeyEvent.KEY_LOCATION_RIGHT:
                            str.append("KEY_LOCATION_RIGHT");
                            break;
                        case KeyEvent.KEY_LOCATION_NUMPAD:
                            str.append("KEY_LOCATION_NUMPAD");
                            break;
                        default:
                            str.append("KEY_LOCATION_UNKNOWN");
                            break;
                    }
                    return str.toString();
                };
                KeyEvent.prototype.getExtendedKeyCode = function () {
                    return (KeyEvent.getExtendedKeyCodeForChar((this.keyChar).charCodeAt(0)) | 0);
                };
                /**
                 * Returns an extended key code for a unicode character.
                 *
                 * @return for a unicode character with a corresponding {@code VK_} constant
                 * -- this {@code VK_} constant; for a character appearing on the
                 * primary level of a known keyboard layout -- a unique integer. If
                 * a character does not appear on the primary level of a known
                 * keyboard, {@code VK_UNDEFINED} is returned.
                 *
                 * @since 1.7
                 */
                KeyEvent.getExtendedKeyCodeForChar = function (c) {
                    return sun.awt.ExtendedKeyCodes.getExtendedKeyCodeForChar(c);
                };
                /**
                 * Sets new modifiers by the old ones. The key modifiers override overlaping
                 * mouse modifiers.
                 */
                KeyEvent.prototype.setNewModifiers = function () {
                    if ((this.modifiers & java.awt.event.InputEvent.SHIFT_MASK_$LI$()) !== 0) {
                        this.modifiers |= java.awt.event.InputEvent.SHIFT_DOWN_MASK_$LI$();
                    }
                    if ((this.modifiers & java.awt.event.InputEvent.ALT_MASK_$LI$()) !== 0) {
                        this.modifiers |= java.awt.event.InputEvent.ALT_DOWN_MASK_$LI$();
                    }
                    if ((this.modifiers & java.awt.event.InputEvent.CTRL_MASK_$LI$()) !== 0) {
                        this.modifiers |= java.awt.event.InputEvent.CTRL_DOWN_MASK_$LI$();
                    }
                    if ((this.modifiers & java.awt.event.InputEvent.META_MASK_$LI$()) !== 0) {
                        this.modifiers |= java.awt.event.InputEvent.META_DOWN_MASK_$LI$();
                    }
                    if ((this.modifiers & java.awt.event.InputEvent.ALT_GRAPH_MASK_$LI$()) !== 0) {
                        this.modifiers |= java.awt.event.InputEvent.ALT_GRAPH_DOWN_MASK_$LI$();
                    }
                    if ((this.modifiers & java.awt.event.InputEvent.BUTTON1_MASK_$LI$()) !== 0) {
                        this.modifiers |= java.awt.event.InputEvent.BUTTON1_DOWN_MASK_$LI$();
                    }
                };
                KeyEvent.prototype.setOldModifiers = function () {
                    if ((this.modifiers & java.awt.event.InputEvent.SHIFT_DOWN_MASK_$LI$()) !== 0) {
                        this.modifiers |= java.awt.event.InputEvent.SHIFT_MASK_$LI$();
                    }
                    if ((this.modifiers & java.awt.event.InputEvent.ALT_DOWN_MASK_$LI$()) !== 0) {
                        this.modifiers |= java.awt.event.InputEvent.ALT_MASK_$LI$();
                    }
                    if ((this.modifiers & java.awt.event.InputEvent.CTRL_DOWN_MASK_$LI$()) !== 0) {
                        this.modifiers |= java.awt.event.InputEvent.CTRL_MASK_$LI$();
                    }
                    if ((this.modifiers & java.awt.event.InputEvent.META_DOWN_MASK_$LI$()) !== 0) {
                        this.modifiers |= java.awt.event.InputEvent.META_MASK_$LI$();
                    }
                    if ((this.modifiers & java.awt.event.InputEvent.ALT_GRAPH_DOWN_MASK_$LI$()) !== 0) {
                        this.modifiers |= java.awt.event.InputEvent.ALT_GRAPH_MASK_$LI$();
                    }
                    if ((this.modifiers & java.awt.event.InputEvent.BUTTON1_DOWN_MASK_$LI$()) !== 0) {
                        this.modifiers |= java.awt.event.InputEvent.BUTTON1_MASK_$LI$();
                    }
                };
                KeyEvent.KEY_FIRST = 400;
                KeyEvent.KEY_LAST = 402;
                KeyEvent.VK_ENTER = ('\n').charCodeAt(0);
                KeyEvent.VK_BACK_SPACE = ('\b').charCodeAt(0);
                KeyEvent.VK_TAB = ('\t').charCodeAt(0);
                KeyEvent.VK_CANCEL = 3;
                KeyEvent.VK_CLEAR = 12;
                KeyEvent.VK_SHIFT = 16;
                KeyEvent.VK_CONTROL = 17;
                KeyEvent.VK_ALT = 18;
                KeyEvent.VK_PAUSE = 19;
                KeyEvent.VK_CAPS_LOCK = 20;
                KeyEvent.VK_ESCAPE = 27;
                KeyEvent.VK_SPACE = 32;
                KeyEvent.VK_PAGE_UP = 33;
                KeyEvent.VK_PAGE_DOWN = 34;
                KeyEvent.VK_END = 35;
                KeyEvent.VK_HOME = 36;
                KeyEvent.VK_LEFT = 37;
                KeyEvent.VK_UP = 38;
                KeyEvent.VK_RIGHT = 39;
                KeyEvent.VK_DOWN = 40;
                KeyEvent.VK_COMMA = 44;
                KeyEvent.VK_MINUS = 45;
                KeyEvent.VK_PERIOD = 46;
                KeyEvent.VK_SLASH = 47;
                /**
                 * VK_0 thru VK_9 are the same as ASCII '0' thru '9' (0x30 - 0x39)
                 */
                KeyEvent.VK_0 = 48;
                KeyEvent.VK_1 = 49;
                KeyEvent.VK_2 = 50;
                KeyEvent.VK_3 = 51;
                KeyEvent.VK_4 = 52;
                KeyEvent.VK_5 = 53;
                KeyEvent.VK_6 = 54;
                KeyEvent.VK_7 = 55;
                KeyEvent.VK_8 = 56;
                KeyEvent.VK_9 = 57;
                KeyEvent.VK_SEMICOLON = 59;
                KeyEvent.VK_EQUALS = 61;
                /**
                 * VK_A thru VK_Z are the same as ASCII 'A' thru 'Z' (0x41 - 0x5A)
                 */
                KeyEvent.VK_A = 65;
                KeyEvent.VK_B = 66;
                KeyEvent.VK_C = 67;
                KeyEvent.VK_D = 68;
                KeyEvent.VK_E = 69;
                KeyEvent.VK_F = 70;
                KeyEvent.VK_G = 71;
                KeyEvent.VK_H = 72;
                KeyEvent.VK_I = 73;
                KeyEvent.VK_J = 74;
                KeyEvent.VK_K = 75;
                KeyEvent.VK_L = 76;
                KeyEvent.VK_M = 77;
                KeyEvent.VK_N = 78;
                KeyEvent.VK_O = 79;
                KeyEvent.VK_P = 80;
                KeyEvent.VK_Q = 81;
                KeyEvent.VK_R = 82;
                KeyEvent.VK_S = 83;
                KeyEvent.VK_T = 84;
                KeyEvent.VK_U = 85;
                KeyEvent.VK_V = 86;
                KeyEvent.VK_W = 87;
                KeyEvent.VK_X = 88;
                KeyEvent.VK_Y = 89;
                KeyEvent.VK_Z = 90;
                KeyEvent.VK_OPEN_BRACKET = 91;
                KeyEvent.VK_BACK_SLASH = 92;
                KeyEvent.VK_CLOSE_BRACKET = 93;
                KeyEvent.VK_NUMPAD0 = 96;
                KeyEvent.VK_NUMPAD1 = 97;
                KeyEvent.VK_NUMPAD2 = 98;
                KeyEvent.VK_NUMPAD3 = 99;
                KeyEvent.VK_NUMPAD4 = 100;
                KeyEvent.VK_NUMPAD5 = 101;
                KeyEvent.VK_NUMPAD6 = 102;
                KeyEvent.VK_NUMPAD7 = 103;
                KeyEvent.VK_NUMPAD8 = 104;
                KeyEvent.VK_NUMPAD9 = 105;
                KeyEvent.VK_MULTIPLY = 106;
                KeyEvent.VK_ADD = 107;
                KeyEvent.VK_SEPARATER = 108;
                KeyEvent.VK_SUBTRACT = 109;
                KeyEvent.VK_DECIMAL = 110;
                KeyEvent.VK_DIVIDE = 111;
                KeyEvent.VK_DELETE = 127;
                KeyEvent.VK_NUM_LOCK = 144;
                KeyEvent.VK_SCROLL_LOCK = 145;
                KeyEvent.VK_F1 = 112;
                KeyEvent.VK_F2 = 113;
                KeyEvent.VK_F3 = 114;
                KeyEvent.VK_F4 = 115;
                KeyEvent.VK_F5 = 116;
                KeyEvent.VK_F6 = 117;
                KeyEvent.VK_F7 = 118;
                KeyEvent.VK_F8 = 119;
                KeyEvent.VK_F9 = 120;
                KeyEvent.VK_F10 = 121;
                KeyEvent.VK_F11 = 122;
                KeyEvent.VK_F12 = 123;
                KeyEvent.VK_F13 = 61440;
                KeyEvent.VK_F14 = 61441;
                KeyEvent.VK_F15 = 61442;
                KeyEvent.VK_F16 = 61443;
                KeyEvent.VK_F17 = 61444;
                KeyEvent.VK_F18 = 61445;
                KeyEvent.VK_F19 = 61446;
                KeyEvent.VK_F20 = 61447;
                KeyEvent.VK_F21 = 61448;
                KeyEvent.VK_F22 = 61449;
                KeyEvent.VK_F23 = 61450;
                KeyEvent.VK_F24 = 61451;
                KeyEvent.VK_PRINTSCREEN = 154;
                KeyEvent.VK_INSERT = 155;
                KeyEvent.VK_HELP = 156;
                KeyEvent.VK_META = 157;
                KeyEvent.VK_BACK_QUOTE = 192;
                KeyEvent.VK_QUOTE = 222;
                KeyEvent.VK_KP_UP = 224;
                KeyEvent.VK_KP_DOWN = 225;
                KeyEvent.VK_KP_LEFT = 226;
                KeyEvent.VK_KP_RIGHT = 227;
                KeyEvent.VK_DEAD_GRAVE = 128;
                KeyEvent.VK_DEAD_ACUTE = 129;
                KeyEvent.VK_DEAD_CIRCUMFLEX = 130;
                KeyEvent.VK_DEAD_TILDE = 131;
                KeyEvent.VK_DEAD_MACRON = 132;
                KeyEvent.VK_DEAD_BREVE = 133;
                KeyEvent.VK_DEAD_ABOVEDOT = 134;
                KeyEvent.VK_DEAD_DIAERESIS = 135;
                KeyEvent.VK_DEAD_ABOVERING = 136;
                KeyEvent.VK_DEAD_DOUBLEACUTE = 137;
                KeyEvent.VK_DEAD_CARON = 138;
                KeyEvent.VK_DEAD_CEDILLA = 139;
                KeyEvent.VK_DEAD_OGONEK = 140;
                KeyEvent.VK_DEAD_IOTA = 141;
                KeyEvent.VK_DEAD_VOICED_SOUND = 142;
                KeyEvent.VK_DEAD_SEMIVOICED_SOUND = 143;
                KeyEvent.VK_AMPERSAND = 150;
                KeyEvent.VK_ASTERISK = 151;
                KeyEvent.VK_QUOTEDBL = 152;
                KeyEvent.VK_LESS = 153;
                KeyEvent.VK_GREATER = 160;
                KeyEvent.VK_BRACELEFT = 161;
                KeyEvent.VK_BRACERIGHT = 162;
                KeyEvent.VK_AT = 512;
                KeyEvent.VK_COLON = 513;
                KeyEvent.VK_CIRCUMFLEX = 514;
                KeyEvent.VK_DOLLAR = 515;
                KeyEvent.VK_EURO_SIGN = 516;
                KeyEvent.VK_EXCLAMATION_MARK = 517;
                KeyEvent.VK_INVERTED_EXCLAMATION_MARK = 518;
                KeyEvent.VK_LEFT_PARENTHESIS = 519;
                KeyEvent.VK_NUMBER_SIGN = 520;
                KeyEvent.VK_PLUS = 521;
                KeyEvent.VK_RIGHT_PARENTHESIS = 522;
                KeyEvent.VK_UNDERSCORE = 523;
                KeyEvent.VK_WINDOWS = 524;
                KeyEvent.VK_CONTEXT_MENU = 525;
                KeyEvent.VK_FINAL = 24;
                KeyEvent.VK_CONVERT = 28;
                KeyEvent.VK_NONCONVERT = 29;
                KeyEvent.VK_ACCEPT = 30;
                KeyEvent.VK_MODECHANGE = 31;
                KeyEvent.VK_KANA = 21;
                KeyEvent.VK_KANJI = 25;
                KeyEvent.VK_ALPHANUMERIC = 240;
                KeyEvent.VK_KATAKANA = 241;
                KeyEvent.VK_HIRAGANA = 242;
                KeyEvent.VK_FULL_WIDTH = 243;
                KeyEvent.VK_HALF_WIDTH = 244;
                KeyEvent.VK_ROMAN_CHARACTERS = 245;
                KeyEvent.VK_ALL_CANDIDATES = 256;
                KeyEvent.VK_PREVIOUS_CANDIDATE = 257;
                KeyEvent.VK_CODE_INPUT = 258;
                KeyEvent.VK_JAPANESE_KATAKANA = 259;
                KeyEvent.VK_JAPANESE_HIRAGANA = 260;
                KeyEvent.VK_JAPANESE_ROMAN = 261;
                KeyEvent.VK_KANA_LOCK = 262;
                KeyEvent.VK_INPUT_METHOD_ON_OFF = 263;
                KeyEvent.VK_CUT = 65489;
                KeyEvent.VK_COPY = 65485;
                KeyEvent.VK_PASTE = 65487;
                KeyEvent.VK_UNDO = 65483;
                KeyEvent.VK_AGAIN = 65481;
                KeyEvent.VK_FIND = 65488;
                KeyEvent.VK_PROPS = 65482;
                KeyEvent.VK_STOP = 65480;
                KeyEvent.VK_COMPOSE = 65312;
                KeyEvent.VK_ALT_GRAPH = 65406;
                KeyEvent.VK_BEGIN = 65368;
                KeyEvent.VK_UNDEFINED = 0;
                KeyEvent.CHAR_UNDEFINED = String.fromCharCode(65535);
                KeyEvent.KEY_LOCATION_UNKNOWN = 0;
                KeyEvent.KEY_LOCATION_STANDARD = 1;
                KeyEvent.KEY_LOCATION_LEFT = 2;
                KeyEvent.KEY_LOCATION_RIGHT = 3;
                KeyEvent.KEY_LOCATION_NUMPAD = 4;
                KeyEvent.serialVersionUID = -2352130953028126954;
                return KeyEvent;
            }(java.awt.event.InputEvent));
            event.KeyEvent = KeyEvent;
            KeyEvent["__class"] = "java.awt.event.KeyEvent";
            KeyEvent["__interfaces"] = ["java.io.Serializable"];
        })(event = awt.event || (awt.event = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var event;
        (function (event) {
            var MouseEvent = (function (_super) {
                __extends(MouseEvent, _super);
                function MouseEvent(source, id, when, modifiers, x, y, xAbs, yAbs, clickCount, popupTrigger, button) {
                    var _this = this;
                    if (((source != null && source instanceof java.awt.Component) || source === null) && ((typeof id === 'number') || id === null) && ((typeof when === 'number') || when === null) && ((typeof modifiers === 'number') || modifiers === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof xAbs === 'number') || xAbs === null) && ((typeof yAbs === 'number') || yAbs === null) && ((typeof clickCount === 'number') || clickCount === null) && ((typeof popupTrigger === 'boolean') || popupTrigger === null) && ((typeof button === 'number') || button === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        _super.call(this, source, id, when, modifiers);
                        this.x = 0;
                        this.y = 0;
                        this.xAbs = 0;
                        this.yAbs = 0;
                        this.clickCount = 0;
                        this.button = 0;
                        this.popupTrigger = false;
                        this.shouldExcludeButtonFromExtModifiers = false;
                        (function () {
                            _this.x = x;
                            _this.y = y;
                            _this.xAbs = xAbs;
                            _this.yAbs = yAbs;
                            _this.clickCount = clickCount;
                            _this.popupTrigger = popupTrigger;
                            _this.shouldExcludeButtonFromExtModifiers = false;
                            if (button < MouseEvent.NOBUTTON) {
                                throw new java.lang.IllegalArgumentException("Invalid button value :" + button);
                            }
                            if (button > MouseEvent.BUTTON3) {
                                if (_this.getModifiersEx() !== 0) {
                                    if (id === MouseEvent.MOUSE_RELEASED_$LI$() || id === MouseEvent.MOUSE_CLICKED_$LI$()) {
                                        _this.shouldExcludeButtonFromExtModifiers = true;
                                    }
                                }
                            }
                            _this.button = button;
                            if ((_this.getModifiers() !== 0) && (_this.getModifiersEx() === 0)) {
                                _this.setNewModifiers();
                            }
                            else if ((_this.getModifiers() === 0) && (_this.getModifiersEx() !== 0 || button !== MouseEvent.NOBUTTON) && (button <= MouseEvent.BUTTON3)) {
                                _this.setOldModifiers();
                            }
                        })();
                    }
                    else if (((source != null && source instanceof java.awt.Component) || source === null) && ((typeof id === 'number') || id === null) && ((typeof when === 'number') || when === null) && ((typeof modifiers === 'number') || modifiers === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof xAbs === 'number') || xAbs === null) && ((typeof yAbs === 'boolean') || yAbs === null) && ((typeof clickCount === 'number') || clickCount === null) && popupTrigger === undefined && button === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        var clickCount_1 = __args[6];
                        var popupTrigger_1 = __args[7];
                        var button_1 = __args[8];
                        {
                            var __args_42 = Array.prototype.slice.call(arguments);
                            var xAbs_1 = 0;
                            var yAbs_1 = 0;
                            _super.call(this, source, id, when, modifiers);
                            this.x = 0;
                            this.y = 0;
                            this.xAbs = 0;
                            this.yAbs = 0;
                            this.clickCount = 0;
                            this.button = 0;
                            this.popupTrigger = false;
                            this.shouldExcludeButtonFromExtModifiers = false;
                            (function () {
                                _this.x = x;
                                _this.y = y;
                                _this.xAbs = xAbs_1;
                                _this.yAbs = yAbs_1;
                                _this.clickCount = clickCount_1;
                                _this.popupTrigger = popupTrigger_1;
                                _this.shouldExcludeButtonFromExtModifiers = false;
                                if (button_1 < MouseEvent.NOBUTTON) {
                                    throw new java.lang.IllegalArgumentException("Invalid button value :" + button_1);
                                }
                                if (button_1 > MouseEvent.BUTTON3) {
                                    if (_this.getModifiersEx() !== 0) {
                                        if (id === MouseEvent.MOUSE_RELEASED_$LI$() || id === MouseEvent.MOUSE_CLICKED_$LI$()) {
                                            _this.shouldExcludeButtonFromExtModifiers = true;
                                        }
                                    }
                                }
                                _this.button = button_1;
                                if ((_this.getModifiers() !== 0) && (_this.getModifiersEx() === 0)) {
                                    _this.setNewModifiers();
                                }
                                else if ((_this.getModifiers() === 0) && (_this.getModifiersEx() !== 0 || button_1 !== MouseEvent.NOBUTTON) && (button_1 <= MouseEvent.BUTTON3)) {
                                    _this.setOldModifiers();
                                }
                            })();
                        }
                        (function () {
                            var eventLocationOnScreen = new java.awt.Point(0, 0);
                            try {
                                eventLocationOnScreen = source.getLocationOnScreen();
                                _this.xAbs = eventLocationOnScreen.x + x;
                                _this.yAbs = eventLocationOnScreen.y + y;
                            }
                            catch (e) {
                                _this.xAbs = 0;
                                _this.yAbs = 0;
                            }
                            ;
                        })();
                    }
                    else if (((source != null && source instanceof java.awt.Component) || source === null) && ((typeof id === 'number') || id === null) && ((typeof when === 'number') || when === null) && ((typeof modifiers === 'number') || modifiers === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof xAbs === 'number') || xAbs === null) && ((typeof yAbs === 'boolean') || yAbs === null) && clickCount === undefined && popupTrigger === undefined && button === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        var clickCount_2 = __args[6];
                        var popupTrigger_2 = __args[7];
                        {
                            var __args_43 = Array.prototype.slice.call(arguments);
                            var button_2 = MouseEvent.NOBUTTON;
                            {
                                var __args_44 = Array.prototype.slice.call(arguments);
                                var xAbs_2 = 0;
                                var yAbs_2 = 0;
                                _super.call(this, source, id, when, modifiers);
                                this.x = 0;
                                this.y = 0;
                                this.xAbs = 0;
                                this.yAbs = 0;
                                this.clickCount = 0;
                                this.button = 0;
                                this.popupTrigger = false;
                                this.shouldExcludeButtonFromExtModifiers = false;
                                (function () {
                                    _this.x = x;
                                    _this.y = y;
                                    _this.xAbs = xAbs_2;
                                    _this.yAbs = yAbs_2;
                                    _this.clickCount = clickCount_2;
                                    _this.popupTrigger = popupTrigger_2;
                                    _this.shouldExcludeButtonFromExtModifiers = false;
                                    if (button_2 < MouseEvent.NOBUTTON) {
                                        throw new java.lang.IllegalArgumentException("Invalid button value :" + button_2);
                                    }
                                    if (button_2 > MouseEvent.BUTTON3) {
                                        if (_this.getModifiersEx() !== 0) {
                                            if (id === MouseEvent.MOUSE_RELEASED_$LI$() || id === MouseEvent.MOUSE_CLICKED_$LI$()) {
                                                _this.shouldExcludeButtonFromExtModifiers = true;
                                            }
                                        }
                                    }
                                    _this.button = button_2;
                                    if ((_this.getModifiers() !== 0) && (_this.getModifiersEx() === 0)) {
                                        _this.setNewModifiers();
                                    }
                                    else if ((_this.getModifiers() === 0) && (_this.getModifiersEx() !== 0 || button_2 !== MouseEvent.NOBUTTON) && (button_2 <= MouseEvent.BUTTON3)) {
                                        _this.setOldModifiers();
                                    }
                                })();
                            }
                            (function () {
                                var eventLocationOnScreen = new java.awt.Point(0, 0);
                                try {
                                    eventLocationOnScreen = source.getLocationOnScreen();
                                    _this.xAbs = eventLocationOnScreen.x + x;
                                    _this.yAbs = eventLocationOnScreen.y + y;
                                }
                                catch (e) {
                                    _this.xAbs = 0;
                                    _this.yAbs = 0;
                                }
                                ;
                            })();
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                MouseEvent.MOUSE_CLICKED_$LI$ = function () { if (MouseEvent.MOUSE_CLICKED == null)
                    MouseEvent.MOUSE_CLICKED = MouseEvent.MOUSE_FIRST; return MouseEvent.MOUSE_CLICKED; };
                ;
                MouseEvent.MOUSE_PRESSED_$LI$ = function () { if (MouseEvent.MOUSE_PRESSED == null)
                    MouseEvent.MOUSE_PRESSED = 1 + MouseEvent.MOUSE_FIRST; return MouseEvent.MOUSE_PRESSED; };
                ;
                MouseEvent.MOUSE_RELEASED_$LI$ = function () { if (MouseEvent.MOUSE_RELEASED == null)
                    MouseEvent.MOUSE_RELEASED = 2 + MouseEvent.MOUSE_FIRST; return MouseEvent.MOUSE_RELEASED; };
                ;
                MouseEvent.MOUSE_MOVED_$LI$ = function () { if (MouseEvent.MOUSE_MOVED == null)
                    MouseEvent.MOUSE_MOVED = 3 + MouseEvent.MOUSE_FIRST; return MouseEvent.MOUSE_MOVED; };
                ;
                MouseEvent.MOUSE_ENTERED_$LI$ = function () { if (MouseEvent.MOUSE_ENTERED == null)
                    MouseEvent.MOUSE_ENTERED = 4 + MouseEvent.MOUSE_FIRST; return MouseEvent.MOUSE_ENTERED; };
                ;
                MouseEvent.MOUSE_EXITED_$LI$ = function () { if (MouseEvent.MOUSE_EXITED == null)
                    MouseEvent.MOUSE_EXITED = 5 + MouseEvent.MOUSE_FIRST; return MouseEvent.MOUSE_EXITED; };
                ;
                MouseEvent.MOUSE_DRAGGED_$LI$ = function () { if (MouseEvent.MOUSE_DRAGGED == null)
                    MouseEvent.MOUSE_DRAGGED = 6 + MouseEvent.MOUSE_FIRST; return MouseEvent.MOUSE_DRAGGED; };
                ;
                MouseEvent.MOUSE_WHEEL_$LI$ = function () { if (MouseEvent.MOUSE_WHEEL == null)
                    MouseEvent.MOUSE_WHEEL = 7 + MouseEvent.MOUSE_FIRST; return MouseEvent.MOUSE_WHEEL; };
                ;
                MouseEvent.prototype.getLocationOnScreen = function () {
                    return new java.awt.Point(this.xAbs, this.yAbs);
                };
                MouseEvent.prototype.getXOnScreen = function () {
                    return this.xAbs;
                };
                MouseEvent.prototype.getYOnScreen = function () {
                    return this.yAbs;
                };
                MouseEvent.prototype.getModifiersEx = function () {
                    var tmpModifiers = this.modifiers;
                    if (this.shouldExcludeButtonFromExtModifiers) {
                        tmpModifiers &= ~(java.awt.event.InputEvent.getMaskForButton(this.getButton()));
                    }
                    return tmpModifiers & ~java.awt.event.InputEvent.JDK_1_3_MODIFIERS_$LI$();
                };
                MouseEvent.prototype.getX = function () {
                    return this.x;
                };
                MouseEvent.prototype.getY = function () {
                    return this.y;
                };
                MouseEvent.prototype.getPoint = function () {
                    var x;
                    var y;
                    {
                        x = this.x;
                        y = this.y;
                    }
                    ;
                    return new java.awt.Point(x, y);
                };
                MouseEvent.prototype.translatePoint = function (x, y) {
                    this.x += x;
                    this.y += y;
                };
                MouseEvent.prototype.getClickCount = function () {
                    return this.clickCount;
                };
                MouseEvent.prototype.getButton = function () {
                    return this.button;
                };
                MouseEvent.prototype.isPopupTrigger = function () {
                    return this.popupTrigger;
                };
                MouseEvent.getMouseModifiersText = function (modifiers) {
                    var buf = new java.lang.StringBuilder();
                    if ((modifiers & java.awt.event.InputEvent.ALT_MASK_$LI$()) !== 0) {
                        buf.append(java.awt.Toolkit.getProperty("AWT.alt", "Alt"));
                        buf.append("+");
                    }
                    if ((modifiers & java.awt.event.InputEvent.META_MASK_$LI$()) !== 0) {
                        buf.append(java.awt.Toolkit.getProperty("AWT.meta", "Meta"));
                        buf.append("+");
                    }
                    if ((modifiers & java.awt.event.InputEvent.CTRL_MASK_$LI$()) !== 0) {
                        buf.append(java.awt.Toolkit.getProperty("AWT.control", "Ctrl"));
                        buf.append("+");
                    }
                    if ((modifiers & java.awt.event.InputEvent.SHIFT_MASK_$LI$()) !== 0) {
                        buf.append(java.awt.Toolkit.getProperty("AWT.shift", "Shift"));
                        buf.append("+");
                    }
                    if ((modifiers & java.awt.event.InputEvent.ALT_GRAPH_MASK_$LI$()) !== 0) {
                        buf.append(java.awt.Toolkit.getProperty("AWT.altGraph", "Alt Graph"));
                        buf.append("+");
                    }
                    if ((modifiers & java.awt.event.InputEvent.BUTTON1_MASK_$LI$()) !== 0) {
                        buf.append(java.awt.Toolkit.getProperty("AWT.button1", "Button1"));
                        buf.append("+");
                    }
                    if ((modifiers & java.awt.event.InputEvent.BUTTON2_MASK_$LI$()) !== 0) {
                        buf.append(java.awt.Toolkit.getProperty("AWT.button2", "Button2"));
                        buf.append("+");
                    }
                    if ((modifiers & java.awt.event.InputEvent.BUTTON3_MASK_$LI$()) !== 0) {
                        buf.append(java.awt.Toolkit.getProperty("AWT.button3", "Button3"));
                        buf.append("+");
                    }
                    var mask;
                    for (var i = 1; i <= MouseEvent.cachedNumberOfButtons; i++) {
                        mask = java.awt.event.InputEvent.getMaskForButton(i);
                        if ((modifiers & mask) !== 0 && buf.indexOf(java.awt.Toolkit.getProperty("AWT.button" + i, "Button" + i)) === -1) {
                            buf.append(java.awt.Toolkit.getProperty("AWT.button" + i, "Button" + i));
                            buf.append("+");
                        }
                    }
                    if (buf.length() > 0) {
                        buf.setLength(buf.length() - 1);
                    }
                    return buf.toString();
                };
                MouseEvent.prototype.paramString = function () {
                    var str = new java.lang.StringBuilder(80);
                    switch ((this.id)) {
                        case MouseEvent.MOUSE_PRESSED_$LI$():
                            str.append("MOUSE_PRESSED");
                            break;
                        case MouseEvent.MOUSE_RELEASED_$LI$():
                            str.append("MOUSE_RELEASED");
                            break;
                        case MouseEvent.MOUSE_CLICKED_$LI$():
                            str.append("MOUSE_CLICKED");
                            break;
                        case MouseEvent.MOUSE_ENTERED_$LI$():
                            str.append("MOUSE_ENTERED");
                            break;
                        case MouseEvent.MOUSE_EXITED_$LI$():
                            str.append("MOUSE_EXITED");
                            break;
                        case MouseEvent.MOUSE_MOVED_$LI$():
                            str.append("MOUSE_MOVED");
                            break;
                        case MouseEvent.MOUSE_DRAGGED_$LI$():
                            str.append("MOUSE_DRAGGED");
                            break;
                        case MouseEvent.MOUSE_WHEEL_$LI$():
                            str.append("MOUSE_WHEEL");
                            break;
                        default:
                            str.append("unknown type");
                    }
                    str.append(",(").append(this.x).append(",").append(this.y).append(")");
                    str.append(",absolute(").append(this.xAbs).append(",").append(this.yAbs).append(")");
                    if (this.id !== MouseEvent.MOUSE_DRAGGED_$LI$() && this.id !== MouseEvent.MOUSE_MOVED_$LI$()) {
                        str.append(",button=").append(this.getButton());
                    }
                    if (this.getModifiers() !== 0) {
                        str.append(",modifiers=").append(MouseEvent.getMouseModifiersText(this.modifiers));
                    }
                    if (this.getModifiersEx() !== 0) {
                        str.append(",extModifiers=").append(event.InputEvent.getModifiersExText(this.getModifiersEx()));
                    }
                    str.append(",clickCount=").append(this.clickCount);
                    return str.toString();
                };
                MouseEvent.prototype.setNewModifiers = function () {
                    if ((this.modifiers & java.awt.event.InputEvent.BUTTON1_MASK_$LI$()) !== 0) {
                        this.modifiers |= java.awt.event.InputEvent.BUTTON1_DOWN_MASK_$LI$();
                    }
                    if ((this.modifiers & java.awt.event.InputEvent.BUTTON2_MASK_$LI$()) !== 0) {
                        this.modifiers |= java.awt.event.InputEvent.BUTTON2_DOWN_MASK_$LI$();
                    }
                    if ((this.modifiers & java.awt.event.InputEvent.BUTTON3_MASK_$LI$()) !== 0) {
                        this.modifiers |= java.awt.event.InputEvent.BUTTON3_DOWN_MASK_$LI$();
                    }
                    if (this.id === MouseEvent.MOUSE_PRESSED_$LI$() || this.id === MouseEvent.MOUSE_RELEASED_$LI$() || this.id === MouseEvent.MOUSE_CLICKED_$LI$()) {
                        if ((this.modifiers & java.awt.event.InputEvent.BUTTON1_MASK_$LI$()) !== 0) {
                            this.button = MouseEvent.BUTTON1;
                            this.modifiers &= ~java.awt.event.InputEvent.BUTTON2_MASK_$LI$() & ~java.awt.event.InputEvent.BUTTON3_MASK_$LI$();
                            if (this.id !== MouseEvent.MOUSE_PRESSED_$LI$()) {
                                this.modifiers &= ~java.awt.event.InputEvent.BUTTON1_DOWN_MASK_$LI$();
                            }
                        }
                        else if ((this.modifiers & java.awt.event.InputEvent.BUTTON2_MASK_$LI$()) !== 0) {
                            this.button = MouseEvent.BUTTON2;
                            this.modifiers &= ~java.awt.event.InputEvent.BUTTON1_MASK_$LI$() & ~java.awt.event.InputEvent.BUTTON3_MASK_$LI$();
                            if (this.id !== MouseEvent.MOUSE_PRESSED_$LI$()) {
                                this.modifiers &= ~java.awt.event.InputEvent.BUTTON2_DOWN_MASK_$LI$();
                            }
                        }
                        else if ((this.modifiers & java.awt.event.InputEvent.BUTTON3_MASK_$LI$()) !== 0) {
                            this.button = MouseEvent.BUTTON3;
                            this.modifiers &= ~java.awt.event.InputEvent.BUTTON1_MASK_$LI$() & ~java.awt.event.InputEvent.BUTTON2_MASK_$LI$();
                            if (this.id !== MouseEvent.MOUSE_PRESSED_$LI$()) {
                                this.modifiers &= ~java.awt.event.InputEvent.BUTTON3_DOWN_MASK_$LI$();
                            }
                        }
                    }
                    if ((this.modifiers & java.awt.event.InputEvent.ALT_MASK_$LI$()) !== 0) {
                        this.modifiers |= java.awt.event.InputEvent.ALT_DOWN_MASK_$LI$();
                    }
                    if ((this.modifiers & java.awt.event.InputEvent.META_MASK_$LI$()) !== 0) {
                        this.modifiers |= java.awt.event.InputEvent.META_DOWN_MASK_$LI$();
                    }
                    if ((this.modifiers & java.awt.event.InputEvent.SHIFT_MASK_$LI$()) !== 0) {
                        this.modifiers |= java.awt.event.InputEvent.SHIFT_DOWN_MASK_$LI$();
                    }
                    if ((this.modifiers & java.awt.event.InputEvent.CTRL_MASK_$LI$()) !== 0) {
                        this.modifiers |= java.awt.event.InputEvent.CTRL_DOWN_MASK_$LI$();
                    }
                    if ((this.modifiers & java.awt.event.InputEvent.ALT_GRAPH_MASK_$LI$()) !== 0) {
                        this.modifiers |= java.awt.event.InputEvent.ALT_GRAPH_DOWN_MASK_$LI$();
                    }
                };
                MouseEvent.prototype.setOldModifiers = function () {
                    if (this.id === MouseEvent.MOUSE_PRESSED_$LI$() || this.id === MouseEvent.MOUSE_RELEASED_$LI$() || this.id === MouseEvent.MOUSE_CLICKED_$LI$()) {
                        switch ((this.button)) {
                            case MouseEvent.BUTTON1:
                                this.modifiers |= java.awt.event.InputEvent.BUTTON1_MASK_$LI$();
                                break;
                            case MouseEvent.BUTTON2:
                                this.modifiers |= java.awt.event.InputEvent.BUTTON2_MASK_$LI$();
                                break;
                            case MouseEvent.BUTTON3:
                                this.modifiers |= java.awt.event.InputEvent.BUTTON3_MASK_$LI$();
                                break;
                        }
                    }
                    else {
                        if ((this.modifiers & java.awt.event.InputEvent.BUTTON1_DOWN_MASK_$LI$()) !== 0) {
                            this.modifiers |= java.awt.event.InputEvent.BUTTON1_MASK_$LI$();
                        }
                        if ((this.modifiers & java.awt.event.InputEvent.BUTTON2_DOWN_MASK_$LI$()) !== 0) {
                            this.modifiers |= java.awt.event.InputEvent.BUTTON2_MASK_$LI$();
                        }
                        if ((this.modifiers & java.awt.event.InputEvent.BUTTON3_DOWN_MASK_$LI$()) !== 0) {
                            this.modifiers |= java.awt.event.InputEvent.BUTTON3_MASK_$LI$();
                        }
                    }
                    if ((this.modifiers & java.awt.event.InputEvent.ALT_DOWN_MASK_$LI$()) !== 0) {
                        this.modifiers |= java.awt.event.InputEvent.ALT_MASK_$LI$();
                    }
                    if ((this.modifiers & java.awt.event.InputEvent.META_DOWN_MASK_$LI$()) !== 0) {
                        this.modifiers |= java.awt.event.InputEvent.META_MASK_$LI$();
                    }
                    if ((this.modifiers & java.awt.event.InputEvent.SHIFT_DOWN_MASK_$LI$()) !== 0) {
                        this.modifiers |= java.awt.event.InputEvent.SHIFT_MASK_$LI$();
                    }
                    if ((this.modifiers & java.awt.event.InputEvent.CTRL_DOWN_MASK_$LI$()) !== 0) {
                        this.modifiers |= java.awt.event.InputEvent.CTRL_MASK_$LI$();
                    }
                    if ((this.modifiers & java.awt.event.InputEvent.ALT_GRAPH_DOWN_MASK_$LI$()) !== 0) {
                        this.modifiers |= java.awt.event.InputEvent.ALT_GRAPH_MASK_$LI$();
                    }
                };
                MouseEvent.MOUSE_FIRST = 500;
                MouseEvent.MOUSE_LAST = 507;
                MouseEvent.NOBUTTON = 0;
                MouseEvent.BUTTON1 = 1;
                MouseEvent.BUTTON2 = 2;
                MouseEvent.BUTTON3 = 3;
                MouseEvent.serialVersionUID = -991214153494842848;
                MouseEvent.cachedNumberOfButtons = 2;
                return MouseEvent;
            }(java.awt.event.InputEvent));
            event.MouseEvent = MouseEvent;
            MouseEvent["__class"] = "java.awt.event.MouseEvent";
            MouseEvent["__interfaces"] = ["java.io.Serializable"];
        })(event = awt.event || (awt.event = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var applet;
    (function (applet_1) {
        var Applet = (function (_super) {
            __extends(Applet, _super);
            function Applet() {
                _super.call(this);
            }
            Applet.__static_initialize = function () { if (!Applet.__static_initialized) {
                Applet.__static_initialized = true;
                Applet.__static_initializer_0();
            } };
            Applet.__static_initializer_0 = function () {
                console.info("installing applet onload hook");
                window.addEventListener("load", function (e) {
                    console.info("applet onload hook");
                    var divList = document.getElementsByClassName("applet");
                    if (divList.length === 0) {
                        return null;
                    }
                    var div = divList[0];
                    if (div.getAttribute("data-applet") != null) {
                        console.info("installing applet: " + div.getAttribute("data-applet"));
                        var names = div.getAttribute("data-applet").split(".");
                        var constructor = window;
                        for (var index137 = 0; index137 < names.length; index137++) {
                            var name_3 = names[index137];
                            {
                                constructor = constructor[name_3];
                                console.info("name: " + name_3 + " -> " + constructor);
                            }
                        }
                        var applet_2 = new constructor();
                        applet_2.setSize(javaemul.internal.IntegerHelper.parseInt(div.getAttribute("data-width")), javaemul.internal.IntegerHelper.parseInt(div.getAttribute("data-height")));
                        applet_2.bindHTML(div);
                        applet_2.init();
                        applet_2.doPaintInternal();
                    }
                    return null;
                });
            };
            Applet.prototype.init = function () {
            };
            Applet.__static_initialized = false;
            return Applet;
        }(java.awt.Panel));
        applet_1.Applet = Applet;
        Applet["__class"] = "java.applet.Applet";
        Applet["__interfaces"] = ["java.awt.HTMLComponent"];
    })(applet = java.applet || (java.applet = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var Frame = (function (_super) {
            __extends(Frame, _super);
            function Frame(title) {
                var _this = this;
                if (((typeof title === 'string') || title === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this);
                    this.title = "Untitled";
                    this.resizable = true;
                    this.undecorated = false;
                    this.mbManagement = false;
                    (function () {
                        _this._frameInit(title);
                        _this.state = Frame.NORMAL;
                    })();
                }
                else if (title === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_45 = Array.prototype.slice.call(arguments);
                        var title_1 = "";
                        _super.call(this);
                        this.title = "Untitled";
                        this.resizable = true;
                        this.undecorated = false;
                        this.mbManagement = false;
                        (function () {
                            _this._frameInit(title_1);
                            _this.state = Frame.NORMAL;
                        })();
                    }
                    (function () {
                        _this.state = Frame.NORMAL;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            Frame.DEFAULT_CURSOR_$LI$ = function () { if (Frame.DEFAULT_CURSOR == null)
                Frame.DEFAULT_CURSOR = java.awt.Cursor.DEFAULT_CURSOR; return Frame.DEFAULT_CURSOR; };
            ;
            Frame.CROSSHAIR_CURSOR_$LI$ = function () { if (Frame.CROSSHAIR_CURSOR == null)
                Frame.CROSSHAIR_CURSOR = java.awt.Cursor.CROSSHAIR_CURSOR; return Frame.CROSSHAIR_CURSOR; };
            ;
            Frame.TEXT_CURSOR_$LI$ = function () { if (Frame.TEXT_CURSOR == null)
                Frame.TEXT_CURSOR = java.awt.Cursor.TEXT_CURSOR; return Frame.TEXT_CURSOR; };
            ;
            Frame.WAIT_CURSOR_$LI$ = function () { if (Frame.WAIT_CURSOR == null)
                Frame.WAIT_CURSOR = java.awt.Cursor.WAIT_CURSOR; return Frame.WAIT_CURSOR; };
            ;
            Frame.SW_RESIZE_CURSOR_$LI$ = function () { if (Frame.SW_RESIZE_CURSOR == null)
                Frame.SW_RESIZE_CURSOR = java.awt.Cursor.SW_RESIZE_CURSOR; return Frame.SW_RESIZE_CURSOR; };
            ;
            Frame.SE_RESIZE_CURSOR_$LI$ = function () { if (Frame.SE_RESIZE_CURSOR == null)
                Frame.SE_RESIZE_CURSOR = java.awt.Cursor.SE_RESIZE_CURSOR; return Frame.SE_RESIZE_CURSOR; };
            ;
            Frame.NW_RESIZE_CURSOR_$LI$ = function () { if (Frame.NW_RESIZE_CURSOR == null)
                Frame.NW_RESIZE_CURSOR = java.awt.Cursor.NW_RESIZE_CURSOR; return Frame.NW_RESIZE_CURSOR; };
            ;
            Frame.NE_RESIZE_CURSOR_$LI$ = function () { if (Frame.NE_RESIZE_CURSOR == null)
                Frame.NE_RESIZE_CURSOR = java.awt.Cursor.NE_RESIZE_CURSOR; return Frame.NE_RESIZE_CURSOR; };
            ;
            Frame.N_RESIZE_CURSOR_$LI$ = function () { if (Frame.N_RESIZE_CURSOR == null)
                Frame.N_RESIZE_CURSOR = java.awt.Cursor.N_RESIZE_CURSOR; return Frame.N_RESIZE_CURSOR; };
            ;
            Frame.S_RESIZE_CURSOR_$LI$ = function () { if (Frame.S_RESIZE_CURSOR == null)
                Frame.S_RESIZE_CURSOR = java.awt.Cursor.S_RESIZE_CURSOR; return Frame.S_RESIZE_CURSOR; };
            ;
            Frame.W_RESIZE_CURSOR_$LI$ = function () { if (Frame.W_RESIZE_CURSOR == null)
                Frame.W_RESIZE_CURSOR = java.awt.Cursor.W_RESIZE_CURSOR; return Frame.W_RESIZE_CURSOR; };
            ;
            Frame.E_RESIZE_CURSOR_$LI$ = function () { if (Frame.E_RESIZE_CURSOR == null)
                Frame.E_RESIZE_CURSOR = java.awt.Cursor.E_RESIZE_CURSOR; return Frame.E_RESIZE_CURSOR; };
            ;
            Frame.HAND_CURSOR_$LI$ = function () { if (Frame.HAND_CURSOR == null)
                Frame.HAND_CURSOR = java.awt.Cursor.HAND_CURSOR; return Frame.HAND_CURSOR; };
            ;
            Frame.MOVE_CURSOR_$LI$ = function () { if (Frame.MOVE_CURSOR == null)
                Frame.MOVE_CURSOR = java.awt.Cursor.MOVE_CURSOR; return Frame.MOVE_CURSOR; };
            ;
            Frame.MAXIMIZED_BOTH_$LI$ = function () { if (Frame.MAXIMIZED_BOTH == null)
                Frame.MAXIMIZED_BOTH = Frame.MAXIMIZED_VERT | Frame.MAXIMIZED_HORIZ; return Frame.MAXIMIZED_BOTH; };
            ;
            Frame.prototype._frameInit = function (title) {
                this.title = title;
            };
            Frame.prototype.constructComponentName = function () {
                {
                    return Frame.base + Frame.nameCounter++;
                }
                ;
            };
            Frame.prototype.getTitle = function () {
                return this.title;
            };
            Frame.prototype.setTitle = function (title) {
                var oldTitle = this.title;
                if (title == null) {
                    title = "";
                }
                this.title = title;
                this.firePropertyChange("title", oldTitle, title);
            };
            Frame.prototype.getIconImage = function () {
                var icons = this.icons;
                if (icons != null) {
                    if (icons.size() > 0) {
                        return icons.get(0);
                    }
                }
                return null;
            };
            Frame.prototype.setIconImage = function (image) {
                _super.prototype.setIconImage.call(this, image);
            };
            Frame.prototype.isResizable = function () {
                return this.resizable;
            };
            Frame.prototype.setResizable = function (resizable) {
                var oldResizable = this.resizable;
                this.resizable = resizable;
                this.firePropertyChange("resizable", oldResizable, resizable);
            };
            Frame.prototype.setUndecorated = function (undecorated) {
                this.undecorated = undecorated;
            };
            Frame.prototype.isUndecorated = function () {
                return this.undecorated;
            };
            /**
             * Returns a string representing the state of this <code>Frame</code>. This
             * method is intended to be used only for debugging purposes, and the
             * content and format of the returned string may vary between
             * implementations. The returned string may be empty but may not be
             * <code>null</code>.
             *
             * @return the parameter string of this frame
             */
            Frame.prototype.paramString = function () {
                var str = _super.prototype.paramString.call(this);
                if (this.title != null) {
                    str += ",title=" + this.title;
                }
                if (this.resizable) {
                    str += ",resizable";
                }
                if (this.state === Frame.NORMAL) {
                    str += ",normal";
                }
                else {
                    if ((this.state & Frame.ICONIFIED) !== 0) {
                        str += ",iconified";
                    }
                    if ((this.state & Frame.MAXIMIZED_BOTH_$LI$()) === Frame.MAXIMIZED_BOTH_$LI$()) {
                        str += ",maximized";
                    }
                    else if ((this.state & Frame.MAXIMIZED_HORIZ) !== 0) {
                        str += ",maximized_horiz";
                    }
                    else if ((this.state & Frame.MAXIMIZED_VERT) !== 0) {
                        str += ",maximized_vert";
                    }
                }
                return str;
            };
            /**
             * Frame is in the "normal" state. This symbolic constant names a frame
             * state with all state bits cleared.
             *
             * @see #setExtendedState(int)
             * @see #getExtendedState
             */
            Frame.NORMAL = 0;
            /**
             * This state bit indicates that frame is iconified.
             *
             * @see #setExtendedState(int)
             * @see #getExtendedState
             */
            Frame.ICONIFIED = 1;
            /**
             * This state bit indicates that frame is maximized in the horizontal
             * direction.
             *
             * @see #setExtendedState(int)
             * @see #getExtendedState
             * @since 1.4
             */
            Frame.MAXIMIZED_HORIZ = 2;
            /**
             * This state bit indicates that frame is maximized in the vertical
             * direction.
             *
             * @see #setExtendedState(int)
             * @see #getExtendedState
             * @since 1.4
             */
            Frame.MAXIMIZED_VERT = 4;
            Frame.base = "frame";
            Frame.nameCounter = 0;
            return Frame;
        }(java.awt.Window));
        awt.Frame = Frame;
        Frame["__class"] = "java.awt.Frame";
        Frame["__interfaces"] = ["java.awt.HTMLComponent"];
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var AbstractButton = (function (_super) {
            __extends(AbstractButton, _super);
            function AbstractButton() {
                _super.call(this);
                this.text = "";
                this.margin = null;
                this.defaultMargin = null;
                this.defaultIcon = null;
                this.pressedIcon = null;
                this.disabledIcon = null;
                this.selectedIcon = null;
                this.disabledSelectedIcon = null;
                this.rolloverIcon = null;
                this.rolloverSelectedIcon = null;
                this.paintBorder = true;
                this.paintFocus = true;
                this.rolloverEnabled = false;
                this.contentAreaFilled = true;
                this.verticalAlignment = javax.swing.SwingConstants.CENTER;
                this.horizontalAlignment = javax.swing.SwingConstants.CENTER;
                this.verticalTextPosition = javax.swing.SwingConstants.CENTER;
                this.horizontalTextPosition = javax.swing.SwingConstants.TRAILING;
                this.iconTextGap = 4;
                this.mnemonicIndex = -1;
                this.multiClickThreshhold = 0;
                this.borderPaintedSet = false;
                this.rolloverEnabledSet = false;
                this.iconTextGapSet = false;
                this.contentAreaFilledSet = false;
                this.__setLayout = false;
                this.defaultCapable = true;
                /**
                 * The button model's <code>changeListener</code>.
                 */
                this.changeListener = null;
                /**
                 * The button model's <code>ActionListener</code>.
                 */
                this.actionListener = null;
                /**
                 * The button model's <code>ItemListener</code>.
                 */
                this.itemListener = null;
                this.hideActionText = false;
                this.mnemonic = 0;
            }
            /**
             * Returns the button's text.
             *
             * @return the buttons text
             * @see #setText
             */
            AbstractButton.prototype.getText = function () {
                return this.text;
            };
            AbstractButton.prototype.setText = function (text) {
                this.text = text;
                this.getHTMLElement().innerText = text;
            };
            AbstractButton.prototype.isSelected = function () {
                return false;
            };
            AbstractButton.prototype.setSelected = function (b) {
            };
            AbstractButton.prototype.doClick = function (pressTime) {
                if (pressTime === undefined) {
                    return this.doClick$();
                }
                else
                    throw new Error('invalid overload');
            };
            AbstractButton.prototype.doClick$ = function () {
                $(this.getHTMLElement()).click();
            };
            AbstractButton.prototype.setMargin = function (m) {
            };
            /**
             * Returns the margin between the button's border and the label.
             *
             * @return an <code>Insets</code> object specifying the margin between the
             * botton's border and the label
             * @see #setMargin
             */
            AbstractButton.prototype.getMargin = function () {
                return (this.margin == null) ? null : this.margin.clone();
            };
            /**
             * Returns the default icon.
             *
             * @return the default <code>Icon</code>
             * @see #setIcon
             */
            AbstractButton.prototype.getIcon = function () {
                return this.defaultIcon;
            };
            AbstractButton.prototype.setIcon = function (defaultIcon) {
                var oldValue = this.defaultIcon;
                this.defaultIcon = defaultIcon;
                if (defaultIcon !== oldValue) {
                    this.disabledIcon = null;
                }
                this.firePropertyChange(AbstractButton.ICON_CHANGED_PROPERTY, oldValue, defaultIcon);
            };
            AbstractButton.prototype.getPressedIcon = function () {
                return this.pressedIcon;
            };
            AbstractButton.prototype.setPressedIcon = function (pressedIcon) {
                var oldValue = this.pressedIcon;
                this.pressedIcon = pressedIcon;
                this.firePropertyChange(AbstractButton.PRESSED_ICON_CHANGED_PROPERTY, oldValue, pressedIcon);
            };
            AbstractButton.prototype.getSelectedIcon = function () {
                return this.selectedIcon;
            };
            AbstractButton.prototype.setSelectedIcon = function (selectedIcon) {
                var oldValue = this.selectedIcon;
                this.selectedIcon = selectedIcon;
                if (selectedIcon !== oldValue) {
                    this.disabledSelectedIcon = null;
                }
                this.firePropertyChange(AbstractButton.SELECTED_ICON_CHANGED_PROPERTY, oldValue, selectedIcon);
            };
            AbstractButton.prototype.getRolloverIcon = function () {
                return this.rolloverIcon;
            };
            AbstractButton.prototype.setRolloverIcon = function (rolloverIcon) {
                var oldValue = this.rolloverIcon;
                this.rolloverIcon = rolloverIcon;
                this.firePropertyChange(AbstractButton.ROLLOVER_ICON_CHANGED_PROPERTY, oldValue, rolloverIcon);
            };
            AbstractButton.prototype.getRolloverSelectedIcon = function () {
                return this.rolloverSelectedIcon;
            };
            AbstractButton.prototype.setRolloverSelectedIcon = function (rolloverSelectedIcon) {
                var oldValue = this.rolloverSelectedIcon;
                this.rolloverSelectedIcon = rolloverSelectedIcon;
                this.firePropertyChange(AbstractButton.ROLLOVER_SELECTED_ICON_CHANGED_PROPERTY, oldValue, rolloverSelectedIcon);
                this.setRolloverEnabled(true);
            };
            AbstractButton.prototype.getDisabledIcon = function () {
                return this.disabledIcon;
            };
            AbstractButton.prototype.setDisabledIcon = function (disabledIcon) {
                var oldValue = this.disabledIcon;
                this.disabledIcon = disabledIcon;
                this.firePropertyChange(AbstractButton.DISABLED_ICON_CHANGED_PROPERTY, oldValue, disabledIcon);
            };
            AbstractButton.prototype.getDisabledSelectedIcon = function () {
                return this.disabledSelectedIcon;
            };
            AbstractButton.prototype.setDisabledSelectedIcon = function (disabledSelectedIcon) {
                var oldValue = this.disabledSelectedIcon;
                this.disabledSelectedIcon = disabledSelectedIcon;
                this.firePropertyChange(AbstractButton.DISABLED_SELECTED_ICON_CHANGED_PROPERTY, oldValue, disabledSelectedIcon);
            };
            AbstractButton.prototype.getVerticalAlignment = function () {
                return this.verticalAlignment;
            };
            AbstractButton.prototype.setVerticalAlignment = function (alignment) {
                if (alignment === this.verticalAlignment)
                    return;
                var oldValue = this.verticalAlignment;
                this.verticalAlignment = this.checkVerticalKey(alignment, "verticalAlignment");
                this.firePropertyChange(AbstractButton.VERTICAL_ALIGNMENT_CHANGED_PROPERTY, oldValue, this.verticalAlignment);
            };
            AbstractButton.prototype.getHorizontalAlignment = function () {
                return this.horizontalAlignment;
            };
            AbstractButton.prototype.setHorizontalAlignment = function (alignment) {
                if (alignment === this.horizontalAlignment)
                    return;
                var oldValue = this.horizontalAlignment;
                this.horizontalAlignment = this.checkHorizontalKey(alignment, "horizontalAlignment");
                this.firePropertyChange(AbstractButton.HORIZONTAL_ALIGNMENT_CHANGED_PROPERTY, oldValue, this.horizontalAlignment);
            };
            AbstractButton.prototype.getVerticalTextPosition = function () {
                return this.verticalTextPosition;
            };
            AbstractButton.prototype.setVerticalTextPosition = function (textPosition) {
                if (textPosition === this.verticalTextPosition)
                    return;
                var oldValue = this.verticalTextPosition;
                this.verticalTextPosition = this.checkVerticalKey(textPosition, "verticalTextPosition");
                this.firePropertyChange(AbstractButton.VERTICAL_TEXT_POSITION_CHANGED_PROPERTY, oldValue, this.verticalTextPosition);
            };
            AbstractButton.prototype.getHorizontalTextPosition = function () {
                return this.horizontalTextPosition;
            };
            AbstractButton.prototype.setHorizontalTextPosition = function (textPosition) {
                if (textPosition === this.horizontalTextPosition)
                    return;
                var oldValue = this.horizontalTextPosition;
                this.horizontalTextPosition = this.checkHorizontalKey(textPosition, "horizontalTextPosition");
                this.firePropertyChange(AbstractButton.HORIZONTAL_TEXT_POSITION_CHANGED_PROPERTY, oldValue, this.horizontalTextPosition);
            };
            AbstractButton.prototype.getIconTextGap = function () {
                return this.iconTextGap;
            };
            AbstractButton.prototype.setIconTextGap = function (iconTextGap) {
                var oldValue = this.iconTextGap;
                this.iconTextGap = iconTextGap;
                this.iconTextGapSet = true;
                this.firePropertyChange("iconTextGap", oldValue, iconTextGap);
            };
            AbstractButton.prototype.checkHorizontalKey = function (key, exception) {
                if ((key === javax.swing.SwingConstants.LEFT) || (key === javax.swing.SwingConstants.CENTER) || (key === javax.swing.SwingConstants.RIGHT) || (key === javax.swing.SwingConstants.LEADING) || (key === javax.swing.SwingConstants.TRAILING)) {
                    return key;
                }
                else {
                    throw new java.lang.IllegalArgumentException(exception);
                }
            };
            AbstractButton.prototype.checkVerticalKey = function (key, exception) {
                if ((key === javax.swing.SwingConstants.TOP) || (key === javax.swing.SwingConstants.CENTER) || (key === javax.swing.SwingConstants.BOTTOM)) {
                    return key;
                }
                else {
                    throw new java.lang.IllegalArgumentException(exception);
                }
            };
            AbstractButton.prototype.setActionCommand = function (actionCommand) {
            };
            AbstractButton.prototype.getActionCommand = function () {
                return this.getText();
            };
            AbstractButton.prototype.setAction = function (a) {
                var oldValue = this.getAction();
                if (this.action == null || !this.action.equals(a)) {
                    this.action = a;
                    if (oldValue != null) {
                        this.removeActionListener(oldValue);
                    }
                    if (this.action != null) {
                        this.addActionListener(this.action);
                    }
                    this.firePropertyChange("action", oldValue, this.action);
                }
            };
            AbstractButton.prototype.getAction = function () {
                return this.action;
            };
            AbstractButton.prototype.isBorderPainted = function () {
                return this.paintBorder;
            };
            AbstractButton.prototype.setBorderPainted = function (b) {
                var oldValue = this.paintBorder;
                this.paintBorder = b;
                this.borderPaintedSet = true;
                this.firePropertyChange(AbstractButton.BORDER_PAINTED_CHANGED_PROPERTY, oldValue, this.paintBorder);
            };
            AbstractButton.prototype.isFocusPainted = function () {
                return this.paintFocus;
            };
            AbstractButton.prototype.setFocusPainted = function (b) {
                var oldValue = this.paintFocus;
                this.paintFocus = b;
                this.firePropertyChange(AbstractButton.FOCUS_PAINTED_CHANGED_PROPERTY, oldValue, this.paintFocus);
            };
            AbstractButton.prototype.isContentAreaFilled = function () {
                return this.contentAreaFilled;
            };
            AbstractButton.prototype.setContentAreaFilled = function (b) {
                var oldValue = this.contentAreaFilled;
                this.contentAreaFilled = b;
                this.contentAreaFilledSet = true;
                this.firePropertyChange(AbstractButton.CONTENT_AREA_FILLED_CHANGED_PROPERTY, oldValue, this.contentAreaFilled);
            };
            AbstractButton.prototype.isRolloverEnabled = function () {
                return this.rolloverEnabled;
            };
            AbstractButton.prototype.setRolloverEnabled = function (b) {
                var oldValue = this.rolloverEnabled;
                this.rolloverEnabled = b;
                this.rolloverEnabledSet = true;
                this.firePropertyChange(AbstractButton.ROLLOVER_ENABLED_CHANGED_PROPERTY, oldValue, this.rolloverEnabled);
            };
            AbstractButton.prototype.getMnemonic = function () {
                return this.mnemonic;
            };
            AbstractButton.prototype.setMnemonic = function (mnemonic) {
            };
            AbstractButton.prototype.setDisplayedMnemonicIndex = function (index) {
                var oldValue = this.mnemonicIndex;
                if (index === -1) {
                    this.mnemonicIndex = -1;
                }
                else {
                    var text_1 = this.getText();
                    var textLength = (text_1 == null) ? 0 : text_1.length;
                    if (index < -1 || index >= textLength) {
                        throw new java.lang.IllegalArgumentException("index == " + index);
                    }
                }
                this.mnemonicIndex = index;
                this.firePropertyChange("displayedMnemonicIndex", oldValue, index);
            };
            AbstractButton.prototype.getDisplayedMnemonicIndex = function () {
                return this.mnemonicIndex;
            };
            AbstractButton.prototype.setMultiClickThreshhold = function (threshhold) {
                if (threshhold < 0) {
                    throw new java.lang.IllegalArgumentException("threshhold must be >= 0");
                }
                this.multiClickThreshhold = threshhold;
            };
            AbstractButton.prototype.getMultiClickThreshhold = function () {
                return this.multiClickThreshhold;
            };
            /**
             * Adds a <code>ChangeListener</code> to the button.
             *
             * @param l
             * the listener to be added
             */
            AbstractButton.prototype.addChangeListener = function (l) {
                this.listenerList.add("javax.swing.event.ChangeListener", l);
            };
            /**
             * Removes a ChangeListener from the button.
             *
             * @param l
             * the listener to be removed
             */
            AbstractButton.prototype.removeChangeListener = function (l) {
                this.listenerList.remove("javax.swing.event.ChangeListener", l);
            };
            /**
             * Returns an array of all the <code>ChangeListener</code>s added to this
             * AbstractButton with addChangeListener().
             *
             * @return all of the <code>ChangeListener</code>s added or an empty array
             * if no listeners have been added
             * @since 1.4
             */
            AbstractButton.prototype.getChangeListeners = function () {
                return this.listenerList.getListeners("javax.swing.event.ChangeListener");
            };
            /**
             * Notifies all listeners that have registered interest for notification on
             * this event type. The event instance is lazily created.
             *
             * @see EventListenerList
             */
            AbstractButton.prototype.fireStateChanged = function () {
                var listeners = this.listenerList.getListenerList();
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "javax.swing.event.ChangeListener") {
                        if (this.changeEvent == null)
                            this.changeEvent = new javax.swing.event.ChangeEvent(this);
                        listeners[i + 1].stateChanged(this.changeEvent);
                    }
                }
            };
            /**
             * Adds an <code>ActionListener</code> to the button.
             *
             * @param l
             * the <code>ActionListener</code> to be added
             */
            AbstractButton.prototype.addActionListener = function (l) {
                this.listenerList.add("java.awt.event.ActionListener", l);
            };
            /**
             * Removes an <code>ActionListener</code> from the button. If the listener
             * is the currently set <code>Action</code> for the button, then the
             * <code>Action</code> is set to <code>null</code>.
             *
             * @param l
             * the listener to be removed
             */
            AbstractButton.prototype.removeActionListener = function (l) {
                if ((l != null) && (this.getAction() === l)) {
                    this.setAction(null);
                }
                else {
                    this.listenerList.remove("java.awt.event.ActionListener", l);
                }
            };
            /**
             * Returns an array of all the <code>ActionListener</code>s added to this
             * AbstractButton with addActionListener().
             *
             * @return all of the <code>ActionListener</code>s added or an empty array
             * if no listeners have been added
             * @since 1.4
             */
            AbstractButton.prototype.getActionListeners = function () {
                return this.listenerList.getListeners("java.awt.event.ActionListener");
            };
            /**
             * Subclasses that want to handle <code>ChangeEvents</code> differently can
             * override this to return another <code>ChangeListener</code>
             * implementation.
             *
             * @return the new <code>ChangeListener</code>
             */
            AbstractButton.prototype.createChangeListener = function () {
                return this.getHandler();
            };
            /**
             * Notifies all listeners that have registered interest for notification on
             * this event type. The event instance is lazily created using the
             * <code>event</code> parameter.
             *
             * @param event
             * the <code>ActionEvent</code> object
             * @see EventListenerList
             */
            AbstractButton.prototype.fireActionPerformed = function (event) {
                var listeners = this.listenerList.getListenerList();
                var e = null;
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "java.awt.event.ActionListener") {
                        if (e == null) {
                            var actionCommand = event.getActionCommand();
                            if (actionCommand == null) {
                                actionCommand = this.getActionCommand();
                            }
                            e = new java.awt.event.ActionEvent(this, java.awt.event.ActionEvent.ACTION_PERFORMED_$LI$(), actionCommand, event.getWhen(), event.getModifiers());
                        }
                        listeners[i + 1].actionPerformed(e);
                    }
                }
            };
            /**
             * Notifies all listeners that have registered interest for notification on
             * this event type. The event instance is lazily created using the
             * <code>event</code> parameter.
             *
             * @param event
             * the <code>ItemEvent</code> object
             * @see EventListenerList
             */
            AbstractButton.prototype.fireItemStateChanged = function (event) {
                var listeners = this.listenerList.getListenerList();
                var e = null;
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "java.awt.event.ItemListener") {
                        if (e == null) {
                            e = new java.awt.event.ItemEvent(this, java.awt.event.ItemEvent.ITEM_STATE_CHANGED_$LI$(), this, event.getStateChange());
                        }
                        listeners[i + 1].itemStateChanged(e);
                    }
                }
            };
            AbstractButton.prototype.createActionListener = function () {
                return this.getHandler();
            };
            AbstractButton.prototype.createItemListener = function () {
                return this.getHandler();
            };
            /**
             * Enables (or disables) the button.
             *
             * @param b
             * true to enable the button, otherwise false
             */
            AbstractButton.prototype.setEnabled = function (b) {
                _super.prototype.setEnabled.call(this, b);
            };
            /**
             * Returns the label text.
             *
             * @return a <code>String</code> containing the label
             * @deprecated - Replaced by <code>getText</code>
             */
            AbstractButton.prototype.getLabel = function () {
                return this.getText();
            };
            /**
             * Sets the label text.
             *
             * @param label
             * a <code>String</code> containing the text
             * @deprecated - Replaced by <code>setText(text)</code>
             * @beaninfo bound: true description: Replace by setText(text)
             */
            AbstractButton.prototype.setLabel = function (label) {
                this.setText(label);
            };
            /**
             * Adds an <code>ItemListener</code> to the <code>checkbox</code>.
             *
             * @param l
             * the <code>ItemListener</code> to be added
             */
            AbstractButton.prototype.addItemListener = function (l) {
                this.listenerList.add("java.awt.event.ItemListener", l);
            };
            /**
             * Removes an <code>ItemListener</code> from the button.
             *
             * @param l
             * the <code>ItemListener</code> to be removed
             */
            AbstractButton.prototype.removeItemListener = function (l) {
                this.listenerList.remove("java.awt.event.ItemListener", l);
            };
            /**
             * Returns an array of all the <code>ItemListener</code>s added to this
             * AbstractButton with addItemListener().
             *
             * @return all of the <code>ItemListener</code>s added or an empty array if
             * no listeners have been added
             * @since 1.4
             */
            AbstractButton.prototype.getItemListeners = function () {
                return this.listenerList.getListeners("java.awt.event.ItemListener");
            };
            /**
             * Returns an array (length 1) containing the label or <code>null</code> if
             * the button is not selected.
             *
             * @return an array containing 1 Object: the text of the button, if the item
             * is selected; otherwise <code>null</code>
             */
            AbstractButton.prototype.getSelectedObjects = function () {
                if (this.isSelected() === false) {
                    return null;
                }
                var selectedObjects = new Array(1);
                selectedObjects[0] = this.getText();
                return selectedObjects;
            };
            AbstractButton.prototype.init = function (text, icon) {
                if (text != null) {
                    this.setText(text);
                }
                if (icon != null) {
                    this.setIcon(icon);
                }
            };
            AbstractButton.prototype.imageUpdate = function (img, infoflags, x, y, w, h) {
                return false;
            };
            AbstractButton.prototype.getHandler = function () {
                if (this.handler == null) {
                    this.handler = new AbstractButton.Handler(this);
                }
                return this.handler;
            };
            AbstractButton.prototype.getModel = function () {
                return this.model;
            };
            AbstractButton.prototype.setModel = function (newModel) {
                var oldModel = this.getModel();
                if (oldModel != null) {
                    oldModel.removeChangeListener(this.changeListener);
                    oldModel.removeActionListener(this.actionListener);
                    oldModel.removeItemListener(this.itemListener);
                    this.changeListener = null;
                    this.actionListener = null;
                    this.itemListener = null;
                }
                this.model = newModel;
                if (newModel != null) {
                    this.changeListener = this.createChangeListener();
                    this.actionListener = this.createActionListener();
                    this.itemListener = this.createItemListener();
                    newModel.addChangeListener(this.changeListener);
                    newModel.addActionListener(this.actionListener);
                    newModel.addItemListener(this.itemListener);
                    _super.prototype.setEnabled.call(this, newModel.isEnabled());
                }
                else {
                    this.mnemonic = ('\u0000').charCodeAt(0);
                }
            };
            /**
             * Identifies a change in the button's margins.
             */
            AbstractButton.MARGIN_CHANGED_PROPERTY = "margin";
            /**
             * Identifies a change in the button's vertical alignment.
             */
            AbstractButton.VERTICAL_ALIGNMENT_CHANGED_PROPERTY = "verticalAlignment";
            /**
             * Identifies a change in the button's horizontal alignment.
             */
            AbstractButton.HORIZONTAL_ALIGNMENT_CHANGED_PROPERTY = "horizontalAlignment";
            /**
             * Identifies a change in the button's vertical text position.
             */
            AbstractButton.VERTICAL_TEXT_POSITION_CHANGED_PROPERTY = "verticalTextPosition";
            /**
             * Identifies a change in the button's horizontal text position.
             */
            AbstractButton.HORIZONTAL_TEXT_POSITION_CHANGED_PROPERTY = "horizontalTextPosition";
            /**
             * Identifies a change to having the border drawn, or having it not drawn.
             */
            AbstractButton.BORDER_PAINTED_CHANGED_PROPERTY = "borderPainted";
            /**
             * Identifies a change to having the border highlighted when focused, or
             * not.
             */
            AbstractButton.FOCUS_PAINTED_CHANGED_PROPERTY = "focusPainted";
            /**
             * Identifies a change from rollover enabled to disabled or back to enabled.
             */
            AbstractButton.ROLLOVER_ENABLED_CHANGED_PROPERTY = "rolloverEnabled";
            /**
             * Identifies a change to having the button paint the content area.
             */
            AbstractButton.CONTENT_AREA_FILLED_CHANGED_PROPERTY = "contentAreaFilled";
            /**
             * Identifies a change to the icon that represents the button.
             */
            AbstractButton.ICON_CHANGED_PROPERTY = "icon";
            /**
             * Identifies a change to the icon used when the button has been pressed.
             */
            AbstractButton.PRESSED_ICON_CHANGED_PROPERTY = "pressedIcon";
            /**
             * Identifies a change to the icon used when the button has been selected.
             */
            AbstractButton.SELECTED_ICON_CHANGED_PROPERTY = "selectedIcon";
            /**
             * Identifies a change to the icon used when the cursor is over the button.
             */
            AbstractButton.ROLLOVER_ICON_CHANGED_PROPERTY = "rolloverIcon";
            /**
             * Identifies a change to the icon used when the cursor is over the button
             * and it has been selected.
             */
            AbstractButton.ROLLOVER_SELECTED_ICON_CHANGED_PROPERTY = "rolloverSelectedIcon";
            /**
             * Identifies a change to the icon used when the button has been disabled.
             */
            AbstractButton.DISABLED_ICON_CHANGED_PROPERTY = "disabledIcon";
            /**
             * Identifies a change to the icon used when the button has been disabled
             * and selected.
             */
            AbstractButton.DISABLED_SELECTED_ICON_CHANGED_PROPERTY = "disabledSelectedIcon";
            return AbstractButton;
        }(javax.swing.JComponent));
        swing.AbstractButton = AbstractButton;
        AbstractButton["__class"] = "javax.swing.AbstractButton";
        AbstractButton["__interfaces"] = ["java.awt.ItemSelectable", "java.awt.HTMLComponent", "javax.swing.SwingConstants", "java.io.Serializable"];
        var AbstractButton;
        (function (AbstractButton) {
            /**
             * Extends <code>ChangeListener</code> to be serializable.
             * <p>
             * <strong>Warning:</strong> Serialized objects of this class will not be
             * compatible with future Swing releases. The current serialization support
             * is appropriate for short term storage or RMI between applications running
             * the same version of Swing. As of 1.4, support for long term storage of
             * all JavaBeans&trade; has been added to the <code>java.beans</code>
             * package. Please see {@link java.beans.XMLEncoder}.
             */
            var ButtonChangeListener = (function () {
                function ButtonChangeListener(__parent) {
                    this.__parent = __parent;
                }
                ButtonChangeListener.prototype.stateChanged = function (e) {
                    this.__parent.getHandler().stateChanged(e);
                };
                return ButtonChangeListener;
            }());
            AbstractButton.ButtonChangeListener = ButtonChangeListener;
            ButtonChangeListener["__class"] = "javax.swing.AbstractButton.ButtonChangeListener";
            ButtonChangeListener["__interfaces"] = ["java.util.EventListener", "javax.swing.event.ChangeListener", "java.io.Serializable"];
            var Handler = (function () {
                function Handler(__parent) {
                    this.__parent = __parent;
                }
                Handler.prototype.stateChanged = function (e) {
                    this.__parent.fireStateChanged();
                };
                Handler.prototype.actionPerformed = function (event) {
                    this.__parent.fireActionPerformed(event);
                };
                Handler.prototype.itemStateChanged = function (event) {
                    this.__parent.fireItemStateChanged(event);
                };
                return Handler;
            }());
            AbstractButton.Handler = Handler;
            Handler["__class"] = "javax.swing.AbstractButton.Handler";
            Handler["__interfaces"] = ["java.util.EventListener", "java.awt.event.ActionListener", "javax.swing.event.ChangeListener", "java.awt.event.ItemListener", "java.io.Serializable"];
        })(AbstractButton = swing.AbstractButton || (swing.AbstractButton = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var JComboBox = (function (_super) {
            __extends(JComboBox, _super);
            function JComboBox(aModel) {
                var _this = this;
                if (((aModel != null && (aModel["__interfaces"] != null && aModel["__interfaces"].indexOf("javax.swing.ComboBoxModel") >= 0 || aModel.constructor != null && aModel.constructor["__interfaces"] != null && aModel.constructor["__interfaces"].indexOf("javax.swing.ComboBoxModel") >= 0)) || aModel === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this);
                    this.maximumRowCount = 8;
                    this.__isEditable = false;
                    this.keySelectionManager = null;
                    this.actionCommand = "comboBoxChanged";
                    this.selectedItemReminder = null;
                    this.firingActionEvent = false;
                    this.selectingItem = false;
                    (function () {
                        _this.setModel(aModel);
                        _this.init();
                    })();
                }
                else if (((aModel != null && aModel instanceof Array) || aModel === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    var items_1 = __args[0];
                    _super.call(this);
                    this.maximumRowCount = 8;
                    this.__isEditable = false;
                    this.keySelectionManager = null;
                    this.actionCommand = "comboBoxChanged";
                    this.selectedItemReminder = null;
                    this.firingActionEvent = false;
                    this.selectingItem = false;
                    (function () {
                        _this.setModel((new javax.swing.DefaultComboBoxModel(items_1)));
                        _this.init();
                    })();
                }
                else if (((aModel != null && aModel instanceof java.util.Vector) || aModel === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    var items_2 = __args[0];
                    _super.call(this);
                    this.maximumRowCount = 8;
                    this.__isEditable = false;
                    this.keySelectionManager = null;
                    this.actionCommand = "comboBoxChanged";
                    this.selectedItemReminder = null;
                    this.firingActionEvent = false;
                    this.selectingItem = false;
                    (function () {
                        _this.setModel((new javax.swing.DefaultComboBoxModel(items_2)));
                        _this.init();
                    })();
                }
                else if (aModel === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this);
                    this.maximumRowCount = 8;
                    this.__isEditable = false;
                    this.keySelectionManager = null;
                    this.actionCommand = "comboBoxChanged";
                    this.selectedItemReminder = null;
                    this.firingActionEvent = false;
                    this.selectingItem = false;
                    (function () {
                        _this.setModel((new javax.swing.DefaultComboBoxModel()));
                        _this.init();
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            JComboBox.prototype.createHTML = function () {
                this.htmlElement = document.createElement("select");
            };
            JComboBox.prototype.getHTMLElement = function () {
                return this.htmlElement;
            };
            JComboBox.prototype.initHTML = function () {
                var _this = this;
                _super.prototype.initHTML.call(this);
                this.getHTMLElement().onchange = function (e) {
                    var i = (_this.getHTMLElement().selectedIndex | 0);
                    _this.fireItemStateChanged(new java.awt.event.ItemEvent(_this, 0, _this.getItemAt(i), java.awt.event.ItemEvent.SELECTED));
                    return e;
                };
                for (var index138 = 0; index138 < this.getHTMLElement().childNodes.length; index138++) {
                    var n = this.getHTMLElement().childNodes[index138];
                    {
                        this.getHTMLElement().removeChild(n);
                    }
                }
                for (var i = 0; i < this.getItemCount(); i++) {
                    var option = document.createElement("option");
                    option.innerHTML = this.getItemAt(i).toString();
                    option.value = this.getItemAt(i).toString();
                    if (this.getSelectedIndex() === i) {
                        option.selected = true;
                    }
                    this.getHTMLElement().appendChild(option);
                }
            };
            JComboBox.prototype.init = function () {
            };
            JComboBox.prototype.setModel = function (aModel) {
                var oldModel = this.dataModel;
                if (oldModel != null) {
                    oldModel.removeListDataListener(this);
                }
                this.dataModel = aModel;
                this.dataModel.addListDataListener(this);
                this.selectedItemReminder = this.dataModel.getSelectedItem();
                this.firePropertyChange("model", oldModel, this.dataModel);
            };
            /**
             * Returns the data model currently used by the <code>JComboBox</code>.
             *
             * @return the <code>ComboBoxModel</code> that provides the displayed list
             * of items
             */
            JComboBox.prototype.getModel = function () {
                return this.dataModel;
            };
            JComboBox.prototype.setLightWeightPopupEnabled = function (aFlag) {
            };
            JComboBox.prototype.setEditable = function (aFlag) {
                var oldFlag = this.__isEditable;
                this.__isEditable = aFlag;
                this.firePropertyChange("editable", oldFlag, this.__isEditable);
            };
            JComboBox.prototype.isEditable = function () {
                return this.__isEditable;
            };
            JComboBox.prototype.setMaximumRowCount = function (count) {
                var oldCount = this.maximumRowCount;
                this.maximumRowCount = count;
                this.firePropertyChange("maximumRowCount", oldCount, this.maximumRowCount);
            };
            JComboBox.prototype.getMaximumRowCount = function () {
                return this.maximumRowCount;
            };
            JComboBox.prototype.setRenderer = function (aRenderer) {
                var oldRenderer = this.renderer;
                this.renderer = aRenderer;
                this.firePropertyChange("renderer", oldRenderer, this.renderer);
            };
            JComboBox.prototype.getRenderer = function () {
                return this.renderer;
            };
            JComboBox.prototype.setEditor = function (anEditor) {
                var oldEditor = this.editor;
                if (this.editor != null) {
                    this.editor.removeActionListener(this);
                }
                this.editor = anEditor;
                if (this.editor != null) {
                    this.editor.addActionListener(this);
                }
                this.firePropertyChange("editor", oldEditor, this.editor);
            };
            JComboBox.prototype.getEditor = function () {
                return this.editor;
            };
            JComboBox.prototype.setSelectedItem = function (anObject) {
                var oldSelection = this.selectedItemReminder;
                var objectToSelect = anObject;
                if (oldSelection == null || !(oldSelection === anObject)) {
                    if (anObject != null && !this.isEditable()) {
                        var found = false;
                        for (var i = 0; i < this.dataModel.getSize(); i++) {
                            var element = this.dataModel.getElementAt(i);
                            if ((anObject === element)) {
                                found = true;
                                objectToSelect = element;
                                break;
                            }
                        }
                        if (!found) {
                            return;
                        }
                    }
                    this.selectingItem = true;
                    this.dataModel.setSelectedItem(objectToSelect);
                    this.selectingItem = false;
                    if (this.selectedItemReminder !== this.dataModel.getSelectedItem()) {
                        this.selectedItemChanged();
                    }
                }
                this.fireActionEvent();
            };
            JComboBox.prototype.getSelectedItem = function () {
                return this.dataModel.getSelectedItem();
            };
            JComboBox.prototype.setSelectedIndex = function (anIndex) {
                var size = this.dataModel.getSize();
                if (anIndex === -1) {
                    this.setSelectedItem(null);
                }
                else if (anIndex < -1 || anIndex >= size) {
                    throw new java.lang.IllegalArgumentException("setSelectedIndex: " + anIndex + " out of bounds");
                }
                else {
                    this.setSelectedItem(this.dataModel.getElementAt(anIndex));
                }
            };
            JComboBox.prototype.getSelectedIndex = function () {
                var sObject = this.dataModel.getSelectedItem();
                var i;
                var c;
                var obj;
                for (i = 0, c = this.dataModel.getSize(); i < c; i++) {
                    obj = this.dataModel.getElementAt(i);
                    if (obj != null && obj === sObject)
                        return i;
                }
                return -1;
            };
            JComboBox.prototype.getPrototypeDisplayValue = function () {
                return this.prototypeDisplayValue;
            };
            JComboBox.prototype.setPrototypeDisplayValue = function (prototypeDisplayValue) {
                var oldValue = this.prototypeDisplayValue;
                this.prototypeDisplayValue = prototypeDisplayValue;
                this.firePropertyChange("prototypeDisplayValue", oldValue, prototypeDisplayValue);
            };
            JComboBox.prototype.addItem = function (item) {
                this.checkMutableComboBoxModel();
                this.dataModel.addElement(item);
            };
            JComboBox.prototype.insertItemAt = function (item, index) {
                this.checkMutableComboBoxModel();
                this.dataModel.insertElementAt(item, index);
            };
            JComboBox.prototype.removeItem = function (anObject) {
                this.checkMutableComboBoxModel();
                this.dataModel.removeElement(anObject);
            };
            JComboBox.prototype.removeItemAt = function (anIndex) {
                this.checkMutableComboBoxModel();
                this.dataModel.removeElementAt(anIndex);
            };
            JComboBox.prototype.removeAllItems = function () {
                this.checkMutableComboBoxModel();
                var model = this.dataModel;
                var size = model.getSize();
                if (model != null && model instanceof javax.swing.DefaultComboBoxModel) {
                    model.removeAllElements();
                }
                else {
                    for (var i = 0; i < size; ++i) {
                        var element = model.getElementAt(0);
                        model.removeElement(element);
                    }
                }
                this.selectedItemReminder = null;
                if (this.isEditable()) {
                    this.editor.setItem(null);
                }
            };
            JComboBox.prototype.checkMutableComboBoxModel = function () {
                if (!(this.dataModel != null && (this.dataModel["__interfaces"] != null && this.dataModel["__interfaces"].indexOf("javax.swing.MutableComboBoxModel") >= 0 || this.dataModel.constructor != null && this.dataModel.constructor["__interfaces"] != null && this.dataModel.constructor["__interfaces"].indexOf("javax.swing.MutableComboBoxModel") >= 0)))
                    throw new Error("Cannot use this method with a non-Mutable data model.");
            };
            JComboBox.prototype.showPopup = function () {
                this.setPopupVisible(true);
            };
            JComboBox.prototype.hidePopup = function () {
                this.setPopupVisible(false);
            };
            JComboBox.prototype.setPopupVisible = function (v) {
            };
            JComboBox.prototype.isPopupVisible = function () {
                return false;
            };
            JComboBox.prototype.addItemListener = function (aListener) {
                this.listenerList.add("java.awt.event.ItemListener", aListener);
            };
            JComboBox.prototype.removeItemListener = function (aListener) {
                this.listenerList.remove("java.awt.event.ItemListener", aListener);
            };
            JComboBox.prototype.getItemListeners = function () {
                return this.listenerList.getListeners("java.awt.event.ItemListener");
            };
            JComboBox.prototype.addActionListener = function (l) {
                this.listenerList.add("java.awt.event.ActionListener", l);
            };
            JComboBox.prototype.removeActionListener = function (l) {
                if ((l != null) && (this.getAction() === l)) {
                    this.setAction(null);
                }
                else {
                    this.listenerList.remove("java.awt.event.ActionListener", l);
                }
            };
            JComboBox.prototype.getActionListeners = function () {
                return this.listenerList.getListeners("java.awt.event.ActionListener");
            };
            JComboBox.prototype.addPopupMenuListener = function (l) {
                this.listenerList.add("javax.swing.event.PopupMenuListener", l);
            };
            JComboBox.prototype.removePopupMenuListener = function (l) {
                this.listenerList.remove("javax.swing.event.PopupMenuListener", l);
            };
            JComboBox.prototype.getPopupMenuListeners = function () {
                return this.listenerList.getListeners("javax.swing.event.PopupMenuListener");
            };
            JComboBox.prototype.firePopupMenuWillBecomeVisible = function () {
                var listeners = this.listenerList.getListenerList();
                var e = null;
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "javax.swing.event.PopupMenuListener") {
                        if (e == null)
                            e = new javax.swing.event.PopupMenuEvent(this);
                        listeners[i + 1].popupMenuWillBecomeVisible(e);
                    }
                }
            };
            JComboBox.prototype.firePopupMenuWillBecomeInvisible = function () {
                var listeners = this.listenerList.getListenerList();
                var e = null;
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "javax.swing.event.PopupMenuListener") {
                        if (e == null)
                            e = new javax.swing.event.PopupMenuEvent(this);
                        listeners[i + 1].popupMenuWillBecomeInvisible(e);
                    }
                }
            };
            JComboBox.prototype.firePopupMenuCanceled = function () {
                var listeners = this.listenerList.getListenerList();
                var e = null;
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "javax.swing.event.PopupMenuListener") {
                        if (e == null)
                            e = new javax.swing.event.PopupMenuEvent(this);
                        listeners[i + 1].popupMenuCanceled(e);
                    }
                }
            };
            JComboBox.prototype.setActionCommand = function (aCommand) {
                this.actionCommand = aCommand;
            };
            JComboBox.prototype.getActionCommand = function () {
                return this.actionCommand;
            };
            JComboBox.prototype.setAction = function (a) {
                var oldValue = this.getAction();
                if (this.action == null || !this.action.equals(a)) {
                    this.action = a;
                    if (oldValue != null) {
                        this.removeActionListener(oldValue);
                        oldValue.removePropertyChangeListener(this.actionPropertyChangeListener);
                        this.actionPropertyChangeListener = null;
                    }
                    this.configurePropertiesFromAction(this.action);
                    if (this.action != null) {
                        if (!this.isListener("java.awt.event.ActionListener", this.action)) {
                            this.addActionListener(this.action);
                        }
                        this.actionPropertyChangeListener = this.createActionPropertyChangeListener(this.action);
                        this.action.addPropertyChangeListener(this.actionPropertyChangeListener);
                    }
                    this.firePropertyChange("action", oldValue, this.action);
                }
            };
            JComboBox.prototype.isListener = function (c, a) {
                var _this = this;
                if (((c != null && c instanceof java.lang.Class) || c === null) && ((a != null && (a["__interfaces"] != null && a["__interfaces"].indexOf("java.awt.event.ActionListener") >= 0 || a.constructor != null && a.constructor["__interfaces"] != null && a.constructor["__interfaces"].indexOf("java.awt.event.ActionListener") >= 0)) || a === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        var isListener = false;
                        var listeners = _this.listenerList.getListenerList();
                        for (var i = listeners.length - 2; i >= 0; i -= 2) {
                            if (listeners[i] === c && listeners[i + 1] === a) {
                                isListener = true;
                            }
                        }
                        return isListener;
                    })();
                }
                else if (((typeof c === 'string') || c === null) && ((a != null && (a["__interfaces"] != null && a["__interfaces"].indexOf("java.awt.event.ActionListener") >= 0 || a.constructor != null && a.constructor["__interfaces"] != null && a.constructor["__interfaces"].indexOf("java.awt.event.ActionListener") >= 0)) || a === null)) {
                    return this.isListener$java_lang_String$java_awt_event_ActionListener(c, a);
                }
                else
                    throw new Error('invalid overload');
            };
            JComboBox.prototype.isListener$java_lang_String$java_awt_event_ActionListener = function (c, a) {
                var isListener = false;
                var listeners = this.listenerList.getListenerList();
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === c && listeners[i + 1] === a) {
                        isListener = true;
                    }
                }
                return isListener;
            };
            JComboBox.prototype.getAction = function () {
                return this.action;
            };
            JComboBox.prototype.configurePropertiesFromAction = function (a) {
                javax.swing.AbstractAction.setEnabledFromAction(this, a);
                javax.swing.AbstractAction.setToolTipTextFromAction(this, a);
                this.setActionCommandFromAction(a);
            };
            JComboBox.prototype.createActionPropertyChangeListener = function (a) {
                return new JComboBox.ComboBoxActionPropertyChangeListener(this, a);
            };
            JComboBox.prototype.actionPropertyChanged = function (action, propertyName) {
                if (propertyName === javax.swing.Action.ACTION_COMMAND_KEY) {
                    this.setActionCommandFromAction(action);
                }
                else if (propertyName === "enabled") {
                    javax.swing.AbstractAction.setEnabledFromAction(this, action);
                }
                else if (javax.swing.Action.SHORT_DESCRIPTION === propertyName) {
                    javax.swing.AbstractAction.setToolTipTextFromAction(this, action);
                }
            };
            JComboBox.prototype.setActionCommandFromAction = function (a) {
                this.setActionCommand((a != null) ? a.getValue(javax.swing.Action.ACTION_COMMAND_KEY) : null);
            };
            JComboBox.prototype.fireItemStateChanged = function (e) {
                var listeners = this.listenerList.getListenerList();
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "java.awt.event.ItemListener") {
                        listeners[i + 1].itemStateChanged(e);
                    }
                }
            };
            JComboBox.prototype.fireActionEvent = function () {
                if (!this.firingActionEvent) {
                    this.firingActionEvent = true;
                    var e = null;
                    var listeners = this.listenerList.getListenerList();
                    var mostRecentEventTime = 0;
                    var modifiers = 0;
                    for (var i = listeners.length - 2; i >= 0; i -= 2) {
                        if (listeners[i] === "java.awt.event.ActionListener") {
                            if (e == null)
                                e = new java.awt.event.ActionEvent(this, java.awt.event.ActionEvent.ACTION_PERFORMED_$LI$(), this.getActionCommand(), mostRecentEventTime, modifiers);
                            listeners[i + 1].actionPerformed(e);
                        }
                    }
                    this.firingActionEvent = false;
                }
            };
            JComboBox.prototype.selectedItemChanged = function () {
                if (this.selectedItemReminder != null) {
                    this.fireItemStateChanged(new java.awt.event.ItemEvent(this, java.awt.event.ItemEvent.ITEM_STATE_CHANGED_$LI$(), this.selectedItemReminder, java.awt.event.ItemEvent.DESELECTED));
                }
                this.selectedItemReminder = this.dataModel.getSelectedItem();
                if (this.selectedItemReminder != null) {
                    this.fireItemStateChanged(new java.awt.event.ItemEvent(this, java.awt.event.ItemEvent.ITEM_STATE_CHANGED_$LI$(), this.selectedItemReminder, java.awt.event.ItemEvent.SELECTED));
                }
            };
            JComboBox.prototype.getSelectedObjects = function () {
                var selectedObject = this.getSelectedItem();
                if (selectedObject == null)
                    return new Array(0);
                else {
                    var result = new Array(1);
                    result[0] = selectedObject;
                    return result;
                }
            };
            JComboBox.prototype.actionPerformed = function (e) {
                var newItem = this.getEditor().getItem();
                this.setPopupVisible(false);
                this.getModel().setSelectedItem(newItem);
                var oldCommand = this.getActionCommand();
                this.setActionCommand("comboBoxEdited");
                this.fireActionEvent();
                this.setActionCommand(oldCommand);
            };
            JComboBox.prototype.contentsChanged = function (e) {
                var oldSelection = this.selectedItemReminder;
                var newSelection = this.dataModel.getSelectedItem();
                if (oldSelection == null || !(oldSelection === newSelection)) {
                    this.selectedItemChanged();
                    if (!this.selectingItem) {
                        this.fireActionEvent();
                    }
                }
            };
            JComboBox.prototype.intervalAdded = function (e) {
                if (this.selectedItemReminder !== this.dataModel.getSelectedItem()) {
                    this.selectedItemChanged();
                }
            };
            JComboBox.prototype.intervalRemoved = function (e) {
                this.contentsChanged(e);
            };
            JComboBox.prototype.selectWithKeyChar = function (keyChar) {
                var index;
                if (this.keySelectionManager == null)
                    this.keySelectionManager = this.createDefaultKeySelectionManager();
                index = this.keySelectionManager.selectionForKey(keyChar, this.getModel());
                if (index !== -1) {
                    this.setSelectedIndex(index);
                    return true;
                }
                else
                    return false;
            };
            JComboBox.prototype.setEnabled = function (b) {
                _super.prototype.setEnabled.call(this, b);
                this.firePropertyChange("enabled", !this.isEnabled(), this.isEnabled());
            };
            JComboBox.prototype.configureEditor = function (anEditor, anItem) {
                anEditor.setItem(anItem);
            };
            JComboBox.prototype.processKeyEvent = function (e) {
                if (e.getKeyCode() === java.awt.event.KeyEvent.VK_TAB) {
                    this.hidePopup();
                }
            };
            JComboBox.prototype.setKeySelectionManager = function (aManager) {
                this.keySelectionManager = aManager;
            };
            JComboBox.prototype.getKeySelectionManager = function () {
                return this.keySelectionManager;
            };
            JComboBox.prototype.getItemCount = function () {
                return this.dataModel.getSize();
            };
            JComboBox.prototype.getItemAt = function (index) {
                return this.dataModel.getElementAt(index);
            };
            JComboBox.prototype.createDefaultKeySelectionManager = function () {
                return new JComboBox.DefaultKeySelectionManager(this);
            };
            JComboBox.prototype.paramString = function () {
                var selectedItemReminderString = (this.selectedItemReminder != null ? this.selectedItemReminder.toString() : "");
                var isEditableString = (this.__isEditable ? "true" : "false");
                return _super.prototype.paramString.call(this) + ",isEditable=" + isEditableString + ",maximumRowCount=" + this.maximumRowCount + ",selectedItemReminder=" + selectedItemReminderString;
            };
            return JComboBox;
        }(javax.swing.JComponent));
        swing.JComboBox = JComboBox;
        JComboBox["__class"] = "javax.swing.JComboBox";
        JComboBox["__interfaces"] = ["java.util.EventListener", "javax.swing.event.ListDataListener", "java.awt.event.ActionListener", "java.awt.ItemSelectable", "java.awt.HTMLComponent", "java.io.Serializable"];
        var JComboBox;
        (function (JComboBox) {
            var ComboBoxActionPropertyChangeListener = (function (_super) {
                __extends(ComboBoxActionPropertyChangeListener, _super);
                function ComboBoxActionPropertyChangeListener(b, a) {
                    _super.call(this, b, a);
                }
                ComboBoxActionPropertyChangeListener.prototype.actionPropertyChanged = function (cb, action, e) {
                    if (((cb != null && cb instanceof javax.swing.JComboBox) || cb === null) && ((action != null && (action["__interfaces"] != null && action["__interfaces"].indexOf("javax.swing.Action") >= 0 || action.constructor != null && action.constructor["__interfaces"] != null && action.constructor["__interfaces"].indexOf("javax.swing.Action") >= 0)) || action === null) && ((e != null && e instanceof java.beans.PropertyChangeEvent) || e === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            cb.actionPropertyChanged(action, e.getPropertyName());
                        })();
                    }
                    else if (((cb != null) || cb === null) && ((action != null && (action["__interfaces"] != null && action["__interfaces"].indexOf("javax.swing.Action") >= 0 || action.constructor != null && action.constructor["__interfaces"] != null && action.constructor["__interfaces"].indexOf("javax.swing.Action") >= 0)) || action === null) && ((e != null && e instanceof java.beans.PropertyChangeEvent) || e === null)) {
                        return this.actionPropertyChanged$javax_swing_JComponent$javax_swing_Action$java_beans_PropertyChangeEvent(cb, action, e);
                    }
                    else
                        throw new Error('invalid overload');
                };
                return ComboBoxActionPropertyChangeListener;
            }(javax.swing.ActionPropertyChangeListener));
            JComboBox.ComboBoxActionPropertyChangeListener = ComboBoxActionPropertyChangeListener;
            ComboBoxActionPropertyChangeListener["__class"] = "javax.swing.JComboBox.ComboBoxActionPropertyChangeListener";
            ComboBoxActionPropertyChangeListener["__interfaces"] = ["java.util.EventListener", "java.beans.PropertyChangeListener", "java.io.Serializable"];
            var DefaultKeySelectionManager = (function () {
                function DefaultKeySelectionManager(__parent) {
                    this.__parent = __parent;
                }
                DefaultKeySelectionManager.prototype.selectionForKey = function (aKey, aModel) {
                    var i;
                    var c;
                    var currentSelection = -1;
                    var selectedItem = aModel.getSelectedItem();
                    var v;
                    var pattern;
                    if (selectedItem != null) {
                        for (i = 0, c = aModel.getSize(); i < c; i++) {
                            if (selectedItem === aModel.getElementAt(i)) {
                                currentSelection = i;
                                break;
                            }
                        }
                    }
                    pattern = ("" + aKey).toLowerCase();
                    aKey = pattern.charAt(0);
                    for (i = ++currentSelection, c = aModel.getSize(); i < c; i++) {
                        var elem = aModel.getElementAt(i);
                        if (elem != null && elem.toString() != null) {
                            v = elem.toString().toLowerCase();
                            if (v.length > 0 && v.charAt(0) === aKey)
                                return i;
                        }
                    }
                    for (i = 0; i < currentSelection; i++) {
                        var elem = aModel.getElementAt(i);
                        if (elem != null && elem.toString() != null) {
                            v = elem.toString().toLowerCase();
                            if (v.length > 0 && v.charAt(0) === aKey)
                                return i;
                        }
                    }
                    return -1;
                };
                return DefaultKeySelectionManager;
            }());
            JComboBox.DefaultKeySelectionManager = DefaultKeySelectionManager;
            DefaultKeySelectionManager["__class"] = "javax.swing.JComboBox.DefaultKeySelectionManager";
            DefaultKeySelectionManager["__interfaces"] = ["javax.swing.JComboBox.KeySelectionManager", "java.io.Serializable"];
        })(JComboBox = swing.JComboBox || (swing.JComboBox = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var JLabel = (function (_super) {
            __extends(JLabel, _super);
            function JLabel(text, icon, horizontalAlignment) {
                var _this = this;
                if (((typeof text === 'string') || text === null) && ((icon != null && (icon["__interfaces"] != null && icon["__interfaces"].indexOf("javax.swing.Icon") >= 0 || icon.constructor != null && icon.constructor["__interfaces"] != null && icon.constructor["__interfaces"].indexOf("javax.swing.Icon") >= 0)) || icon === null) && ((typeof horizontalAlignment === 'number') || horizontalAlignment === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this);
                    this.mnemonic = 0;
                    this.mnemonicIndex = 0;
                    this.disabledIconSet = false;
                    this.verticalAlignment = 0;
                    this.horizontalAlignment = 0;
                    this.verticalTextPosition = 0;
                    this.horizontalTextPosition = 0;
                    this.iconTextGap = 0;
                    (function () {
                        _this.mnemonic = ('\u0000').charCodeAt(0);
                        _this.mnemonicIndex = -1;
                        text = "";
                        _this.defaultIcon = null;
                        _this.disabledIcon = null;
                        _this.disabledIconSet = false;
                        _this.verticalAlignment = javax.swing.SwingConstants.CENTER;
                        horizontalAlignment = javax.swing.SwingConstants.LEADING;
                        _this.verticalTextPosition = javax.swing.SwingConstants.CENTER;
                        _this.horizontalTextPosition = javax.swing.SwingConstants.TRAILING;
                        _this.iconTextGap = 4;
                        _this.labelFor = null;
                        _this.setText(text);
                        _this.setIcon(icon);
                        _this.setHorizontalAlignment(horizontalAlignment);
                    })();
                }
                else if (((typeof text === 'string') || text === null) && ((typeof icon === 'number') || icon === null) && horizontalAlignment === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var horizontalAlignment_1 = __args[1];
                    {
                        var __args_46 = Array.prototype.slice.call(arguments);
                        var icon_1 = null;
                        _super.call(this);
                        this.mnemonic = 0;
                        this.mnemonicIndex = 0;
                        this.disabledIconSet = false;
                        this.verticalAlignment = 0;
                        this.horizontalAlignment = 0;
                        this.verticalTextPosition = 0;
                        this.horizontalTextPosition = 0;
                        this.iconTextGap = 0;
                        (function () {
                            _this.mnemonic = ('\u0000').charCodeAt(0);
                            _this.mnemonicIndex = -1;
                            text = "";
                            _this.defaultIcon = null;
                            _this.disabledIcon = null;
                            _this.disabledIconSet = false;
                            _this.verticalAlignment = javax.swing.SwingConstants.CENTER;
                            horizontalAlignment_1 = javax.swing.SwingConstants.LEADING;
                            _this.verticalTextPosition = javax.swing.SwingConstants.CENTER;
                            _this.horizontalTextPosition = javax.swing.SwingConstants.TRAILING;
                            _this.iconTextGap = 4;
                            _this.labelFor = null;
                            _this.setText(text);
                            _this.setIcon(icon_1);
                            _this.setHorizontalAlignment(horizontalAlignment_1);
                        })();
                    }
                }
                else if (((text != null && (text["__interfaces"] != null && text["__interfaces"].indexOf("javax.swing.Icon") >= 0 || text.constructor != null && text.constructor["__interfaces"] != null && text.constructor["__interfaces"].indexOf("javax.swing.Icon") >= 0)) || text === null) && ((typeof icon === 'number') || icon === null) && horizontalAlignment === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var image = __args[0];
                    var horizontalAlignment_2 = __args[1];
                    {
                        var __args_47 = Array.prototype.slice.call(arguments);
                        var text_2 = null;
                        var icon_2 = image;
                        _super.call(this);
                        this.mnemonic = 0;
                        this.mnemonicIndex = 0;
                        this.disabledIconSet = false;
                        this.verticalAlignment = 0;
                        this.horizontalAlignment = 0;
                        this.verticalTextPosition = 0;
                        this.horizontalTextPosition = 0;
                        this.iconTextGap = 0;
                        (function () {
                            _this.mnemonic = ('\u0000').charCodeAt(0);
                            _this.mnemonicIndex = -1;
                            text_2 = "";
                            _this.defaultIcon = null;
                            _this.disabledIcon = null;
                            _this.disabledIconSet = false;
                            _this.verticalAlignment = javax.swing.SwingConstants.CENTER;
                            horizontalAlignment_2 = javax.swing.SwingConstants.LEADING;
                            _this.verticalTextPosition = javax.swing.SwingConstants.CENTER;
                            _this.horizontalTextPosition = javax.swing.SwingConstants.TRAILING;
                            _this.iconTextGap = 4;
                            _this.labelFor = null;
                            _this.setText(text_2);
                            _this.setIcon(icon_2);
                            _this.setHorizontalAlignment(horizontalAlignment_2);
                        })();
                    }
                }
                else if (((typeof text === 'string') || text === null) && icon === undefined && horizontalAlignment === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_48 = Array.prototype.slice.call(arguments);
                        var icon_3 = null;
                        var horizontalAlignment_3 = javax.swing.SwingConstants.LEADING;
                        _super.call(this);
                        this.mnemonic = 0;
                        this.mnemonicIndex = 0;
                        this.disabledIconSet = false;
                        this.verticalAlignment = 0;
                        this.horizontalAlignment = 0;
                        this.verticalTextPosition = 0;
                        this.horizontalTextPosition = 0;
                        this.iconTextGap = 0;
                        (function () {
                            _this.mnemonic = ('\u0000').charCodeAt(0);
                            _this.mnemonicIndex = -1;
                            text = "";
                            _this.defaultIcon = null;
                            _this.disabledIcon = null;
                            _this.disabledIconSet = false;
                            _this.verticalAlignment = javax.swing.SwingConstants.CENTER;
                            horizontalAlignment_3 = javax.swing.SwingConstants.LEADING;
                            _this.verticalTextPosition = javax.swing.SwingConstants.CENTER;
                            _this.horizontalTextPosition = javax.swing.SwingConstants.TRAILING;
                            _this.iconTextGap = 4;
                            _this.labelFor = null;
                            _this.setText(text);
                            _this.setIcon(icon_3);
                            _this.setHorizontalAlignment(horizontalAlignment_3);
                        })();
                    }
                }
                else if (((text != null && (text["__interfaces"] != null && text["__interfaces"].indexOf("javax.swing.Icon") >= 0 || text.constructor != null && text.constructor["__interfaces"] != null && text.constructor["__interfaces"].indexOf("javax.swing.Icon") >= 0)) || text === null) && icon === undefined && horizontalAlignment === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var image = __args[0];
                    {
                        var __args_49 = Array.prototype.slice.call(arguments);
                        var text_3 = null;
                        var icon_4 = image;
                        var horizontalAlignment_4 = javax.swing.SwingConstants.CENTER;
                        _super.call(this);
                        this.mnemonic = 0;
                        this.mnemonicIndex = 0;
                        this.disabledIconSet = false;
                        this.verticalAlignment = 0;
                        this.horizontalAlignment = 0;
                        this.verticalTextPosition = 0;
                        this.horizontalTextPosition = 0;
                        this.iconTextGap = 0;
                        (function () {
                            _this.mnemonic = ('\u0000').charCodeAt(0);
                            _this.mnemonicIndex = -1;
                            text_3 = "";
                            _this.defaultIcon = null;
                            _this.disabledIcon = null;
                            _this.disabledIconSet = false;
                            _this.verticalAlignment = javax.swing.SwingConstants.CENTER;
                            horizontalAlignment_4 = javax.swing.SwingConstants.LEADING;
                            _this.verticalTextPosition = javax.swing.SwingConstants.CENTER;
                            _this.horizontalTextPosition = javax.swing.SwingConstants.TRAILING;
                            _this.iconTextGap = 4;
                            _this.labelFor = null;
                            _this.setText(text_3);
                            _this.setIcon(icon_4);
                            _this.setHorizontalAlignment(horizontalAlignment_4);
                        })();
                    }
                }
                else if (text === undefined && icon === undefined && horizontalAlignment === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_50 = Array.prototype.slice.call(arguments);
                        var text_4 = "";
                        var icon_5 = null;
                        var horizontalAlignment_5 = javax.swing.SwingConstants.LEADING;
                        _super.call(this);
                        this.mnemonic = 0;
                        this.mnemonicIndex = 0;
                        this.disabledIconSet = false;
                        this.verticalAlignment = 0;
                        this.horizontalAlignment = 0;
                        this.verticalTextPosition = 0;
                        this.horizontalTextPosition = 0;
                        this.iconTextGap = 0;
                        (function () {
                            _this.mnemonic = ('\u0000').charCodeAt(0);
                            _this.mnemonicIndex = -1;
                            text_4 = "";
                            _this.defaultIcon = null;
                            _this.disabledIcon = null;
                            _this.disabledIconSet = false;
                            _this.verticalAlignment = javax.swing.SwingConstants.CENTER;
                            horizontalAlignment_5 = javax.swing.SwingConstants.LEADING;
                            _this.verticalTextPosition = javax.swing.SwingConstants.CENTER;
                            _this.horizontalTextPosition = javax.swing.SwingConstants.TRAILING;
                            _this.iconTextGap = 4;
                            _this.labelFor = null;
                            _this.setText(text_4);
                            _this.setIcon(icon_5);
                            _this.setHorizontalAlignment(horizontalAlignment_5);
                        })();
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            JLabel.prototype.createHTML = function () {
                this.htmlElement = document.createElement("div");
            };
            JLabel.prototype.initHTML = function () {
                _super.prototype.initHTML.call(this);
                while ((this.getHTMLElement().firstChild != null)) {
                    this.getHTMLElement().removeChild(this.getHTMLElement().firstChild);
                }
                ;
                if (this.defaultIcon != null) {
                    this.htmlImageElement = this.defaultIcon.getInternalHTMLImageElement();
                }
                this.htmlLabelElement = document.createElement("label");
                if (this.defaultIcon != null) {
                    this.htmlElement.appendChild(this.htmlImageElement);
                }
                this.htmlLabelElement.innerHTML = this.getText();
                this.htmlElement.appendChild(this.htmlLabelElement);
            };
            JLabel.prototype.getText = function () {
                return this.text;
            };
            JLabel.prototype.setText = function (text) {
                var oldValue = this.text;
                this.text = text;
                this.firePropertyChange("text", oldValue, text);
                if (this.htmlLabelElement != null) {
                    this.htmlLabelElement.innerHTML = text;
                }
            };
            JLabel.prototype.getIcon = function () {
                return this.defaultIcon;
            };
            JLabel.prototype.setIcon = function (icon) {
                var oldValue = this.defaultIcon;
                this.defaultIcon = icon;
                if ((this.defaultIcon !== oldValue) && !this.disabledIconSet) {
                    this.disabledIcon = null;
                }
                this.firePropertyChange("icon", oldValue, this.defaultIcon);
                if (this.htmlElement != null) {
                    this.initHTML();
                }
            };
            JLabel.prototype.getDisabledIcon = function () {
                return this.disabledIcon;
            };
            JLabel.prototype.setDisabledIcon = function (disabledIcon) {
                var oldValue = this.disabledIcon;
                this.disabledIcon = disabledIcon;
                this.disabledIconSet = (disabledIcon != null);
                this.firePropertyChange("disabledIcon", oldValue, disabledIcon);
                if (this.htmlElement != null) {
                    this.initHTML();
                }
            };
            JLabel.prototype.setDisplayedMnemonic$int = function (key) {
                var oldKey = this.mnemonic;
                this.mnemonic = key;
                this.firePropertyChange("displayedMnemonic", oldKey, this.mnemonic);
            };
            JLabel.prototype.setDisplayedMnemonic = function (aChar) {
                var _this = this;
                if (((typeof aChar === 'string') || aChar === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        var vk = java.awt.event.KeyEvent.getExtendedKeyCodeForChar((aChar).charCodeAt(0));
                        if (vk !== java.awt.event.KeyEvent.VK_UNDEFINED) {
                            _this.setDisplayedMnemonic(vk);
                        }
                    })();
                }
                else if (((typeof aChar === 'number') || aChar === null)) {
                    return this.setDisplayedMnemonic$int(aChar);
                }
                else
                    throw new Error('invalid overload');
            };
            JLabel.prototype.getDisplayedMnemonic = function () {
                return this.mnemonic;
            };
            JLabel.prototype.setDisplayedMnemonicIndex = function (index) {
                var oldValue = this.mnemonicIndex;
                if (index === -1) {
                    this.mnemonicIndex = -1;
                }
                else {
                    var text_5 = this.getText();
                    var textLength = (text_5 == null) ? 0 : text_5.length;
                    if (index < -1 || index >= textLength) {
                        throw new java.lang.IllegalArgumentException("index == " + index);
                    }
                }
                this.mnemonicIndex = index;
                this.firePropertyChange("displayedMnemonicIndex", oldValue, index);
            };
            JLabel.prototype.getDisplayedMnemonicIndex = function () {
                return this.mnemonicIndex;
            };
            JLabel.prototype.checkHorizontalKey = function (key, message) {
                if ((key === javax.swing.SwingConstants.LEFT) || (key === javax.swing.SwingConstants.CENTER) || (key === javax.swing.SwingConstants.RIGHT) || (key === javax.swing.SwingConstants.LEADING) || (key === javax.swing.SwingConstants.TRAILING)) {
                    return key;
                }
                else {
                    throw new java.lang.IllegalArgumentException(message);
                }
            };
            JLabel.prototype.checkVerticalKey = function (key, message) {
                if ((key === javax.swing.SwingConstants.TOP) || (key === javax.swing.SwingConstants.CENTER) || (key === javax.swing.SwingConstants.BOTTOM)) {
                    return key;
                }
                else {
                    throw new java.lang.IllegalArgumentException(message);
                }
            };
            JLabel.prototype.getIconTextGap = function () {
                return this.iconTextGap;
            };
            JLabel.prototype.setIconTextGap = function (iconTextGap) {
                var oldValue = this.iconTextGap;
                this.iconTextGap = iconTextGap;
                this.firePropertyChange("iconTextGap", oldValue, iconTextGap);
                if (this.htmlElement != null) {
                    this.initHTML();
                }
            };
            JLabel.prototype.getVerticalAlignment = function () {
                return this.verticalAlignment;
            };
            JLabel.prototype.setVerticalAlignment = function (alignment) {
                if (alignment === this.verticalAlignment)
                    return;
                var oldValue = this.verticalAlignment;
                this.verticalAlignment = this.checkVerticalKey(alignment, "verticalAlignment");
                this.firePropertyChange("verticalAlignment", oldValue, this.verticalAlignment);
                if (this.htmlElement != null) {
                    this.initHTML();
                }
            };
            JLabel.prototype.getHorizontalAlignment = function () {
                return this.horizontalAlignment;
            };
            JLabel.prototype.setHorizontalAlignment = function (alignment) {
                if (alignment === this.horizontalAlignment)
                    return;
                var oldValue = this.horizontalAlignment;
                this.horizontalAlignment = this.checkHorizontalKey(alignment, "horizontalAlignment");
                this.firePropertyChange("horizontalAlignment", oldValue, this.horizontalAlignment);
                if (this.htmlElement != null) {
                    this.initHTML();
                }
            };
            JLabel.prototype.getVerticalTextPosition = function () {
                return this.verticalTextPosition;
            };
            JLabel.prototype.setVerticalTextPosition = function (textPosition) {
                if (textPosition === this.verticalTextPosition)
                    return;
                var old = this.verticalTextPosition;
                this.verticalTextPosition = this.checkVerticalKey(textPosition, "verticalTextPosition");
                this.firePropertyChange("verticalTextPosition", old, this.verticalTextPosition);
                if (this.htmlElement != null) {
                    this.initHTML();
                }
            };
            JLabel.prototype.getHorizontalTextPosition = function () {
                return this.horizontalTextPosition;
            };
            JLabel.prototype.setHorizontalTextPosition = function (textPosition) {
                var old = this.horizontalTextPosition;
                this.horizontalTextPosition = this.checkHorizontalKey(textPosition, "horizontalTextPosition");
                this.firePropertyChange("horizontalTextPosition", old, this.horizontalTextPosition);
                if (this.htmlElement != null) {
                    this.initHTML();
                }
            };
            JLabel.prototype.paramString = function () {
                var textString = (this.text != null ? this.text : "");
                var defaultIconString = ((this.defaultIcon != null) ? this.defaultIcon.toString() : "");
                var disabledIconString = ((this.disabledIcon != null) ? this.disabledIcon.toString() : "");
                var labelForString = (this.labelFor != null ? this.labelFor.toString() : "");
                var verticalAlignmentString;
                if (this.verticalAlignment === javax.swing.SwingConstants.TOP) {
                    verticalAlignmentString = "TOP";
                }
                else if (this.verticalAlignment === javax.swing.SwingConstants.CENTER) {
                    verticalAlignmentString = "CENTER";
                }
                else if (this.verticalAlignment === javax.swing.SwingConstants.BOTTOM) {
                    verticalAlignmentString = "BOTTOM";
                }
                else
                    verticalAlignmentString = "";
                var horizontalAlignmentString;
                if (this.horizontalAlignment === javax.swing.SwingConstants.LEFT) {
                    horizontalAlignmentString = "LEFT";
                }
                else if (this.horizontalAlignment === javax.swing.SwingConstants.CENTER) {
                    horizontalAlignmentString = "CENTER";
                }
                else if (this.horizontalAlignment === javax.swing.SwingConstants.RIGHT) {
                    horizontalAlignmentString = "RIGHT";
                }
                else if (this.horizontalAlignment === javax.swing.SwingConstants.LEADING) {
                    horizontalAlignmentString = "LEADING";
                }
                else if (this.horizontalAlignment === javax.swing.SwingConstants.TRAILING) {
                    horizontalAlignmentString = "TRAILING";
                }
                else
                    horizontalAlignmentString = "";
                var verticalTextPositionString;
                if (this.verticalTextPosition === javax.swing.SwingConstants.TOP) {
                    verticalTextPositionString = "TOP";
                }
                else if (this.verticalTextPosition === javax.swing.SwingConstants.CENTER) {
                    verticalTextPositionString = "CENTER";
                }
                else if (this.verticalTextPosition === javax.swing.SwingConstants.BOTTOM) {
                    verticalTextPositionString = "BOTTOM";
                }
                else
                    verticalTextPositionString = "";
                var horizontalTextPositionString;
                if (this.horizontalTextPosition === javax.swing.SwingConstants.LEFT) {
                    horizontalTextPositionString = "LEFT";
                }
                else if (this.horizontalTextPosition === javax.swing.SwingConstants.CENTER) {
                    horizontalTextPositionString = "CENTER";
                }
                else if (this.horizontalTextPosition === javax.swing.SwingConstants.RIGHT) {
                    horizontalTextPositionString = "RIGHT";
                }
                else if (this.horizontalTextPosition === javax.swing.SwingConstants.LEADING) {
                    horizontalTextPositionString = "LEADING";
                }
                else if (this.horizontalTextPosition === javax.swing.SwingConstants.TRAILING) {
                    horizontalTextPositionString = "TRAILING";
                }
                else
                    horizontalTextPositionString = "";
                return _super.prototype.paramString.call(this) + ",defaultIcon=" + defaultIconString + ",disabledIcon=" + disabledIconString + ",horizontalAlignment=" + horizontalAlignmentString + ",horizontalTextPosition=" + horizontalTextPositionString + ",iconTextGap=" + this.iconTextGap + ",labelFor=" + labelForString + ",text=" + textString + ",verticalAlignment=" + verticalAlignmentString + ",verticalTextPosition=" + verticalTextPositionString;
            };
            JLabel.LABELED_BY_PROPERTY = "labeledBy";
            return JLabel;
        }(javax.swing.JComponent));
        swing.JLabel = JLabel;
        JLabel["__class"] = "javax.swing.JLabel";
        JLabel["__interfaces"] = ["java.awt.HTMLComponent", "javax.swing.SwingConstants", "java.io.Serializable"];
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        /**
         * A component that displays a list of objects and allows the user to select one
         * or more items. A separate model, {@code ListModel}, maintains the contents of
         * the list.
         * <p>
         * It's easy to display an array or Vector of objects, using the {@code JList}
         * constructor that automatically builds a read-only {@code ListModel} instance
         * for you:
         *
         * <pre>
         * {
         * &#64;code
         * // Create a JList that displays strings from an array
         *
         * String[] data = { "one", "two", "three", "four" };
         * JList<String> myList = new JList<String>(data);
         *
         * // Create a JList that displays the superclasses of JList.class, by
         * // creating it with a Vector populated with this data
         *
         * Vector<Class<?>> superClasses = new Vector<Class<?>>();
         * Class<JList> rootClass = javax.swing.JList.class;
         * for (Class<?> cls = rootClass; cls != null; cls = cls.getSuperclass()) {
         * superClasses.addElement(cls);
         * }
         * JList<Class<?>> myList = new JList<Class<?>>(superClasses);
         *
         * // The automatically created model is stored in JList's "model"
         * // property, which you can retrieve
         *
         * ListModel<Class<?>> model = myList.getModel();
         * for (int i = 0; i < model.getSize(); i++) {
         * System.out.println(model.getElementAt(i));
         * }
         * }
         * </pre>
         * <p>
         * A {@code ListModel} can be supplied directly to a {@code JList} by way of a
         * constructor or the {@code setModel} method. The contents need not be static -
         * the number of items, and the values of items can change over time. A correct
         * {@code ListModel} implementation notifies the set of
         * {@code javax.swing.event.ListDataListener}s that have been added to it, each
         * time a change occurs. These changes are characterized by a
         * {@code javax.swing.event.ListDataEvent}, which identifies the range of list
         * indices that have been modified, added, or removed. {@code JList}'s
         * {@code ListUI} is responsible for keeping the visual representation up to
         * date with changes, by listening to the model.
         * <p>
         * Simple, dynamic-content, {@code JList} applications can use the
         * {@code DefaultListModel} class to maintain list elements. This class
         * implements the {@code ListModel} interface and also provides a
         * <code>java.util.Vector</code>-like API. Applications that need a more custom
         * <code>ListModel</code> implementation may instead wish to subclass
         * {@code AbstractListModel}, which provides basic support for managing and
         * notifying listeners. For example, a read-only implementation of
         * {@code AbstractListModel}:
         *
         * <pre>
         * {
         * &#64;code
         * // This list model has about 2^16 elements. Enjoy scrolling.
         *
         * ListModel<String> bigData = new AbstractListModel<String>() {
         * public int getSize() {
         * return Short.MAX_VALUE;
         * }
         *
         * public String getElementAt(int index) {
         * return "Index " + index;
         * }
         * };
         * }
         * </pre>
         * <p>
         * The selection state of a {@code JList} is managed by another separate model,
         * an instance of {@code ListSelectionModel}. {@code JList} is initialized with
         * a selection model on construction, and also contains methods to query or set
         * this selection model. Additionally, {@code JList} provides convenient methods
         * for easily managing the selection. These methods, such as
         * {@code setSelectedIndex} and {@code getSelectedValue}, are cover methods that
         * take care of the details of interacting with the selection model. By default,
         * {@code JList}'s selection model is configured to allow any combination of
         * items to be selected at a time; selection mode
         * {@code MULTIPLE_INTERVAL_SELECTION}. The selection mode can be changed on the
         * selection model directly, or via {@code JList}'s cover method. Responsibility
         * for updating the selection model in response to user gestures lies with the
         * list's {@code ListUI}.
         * <p>
         * A correct {@code ListSelectionModel} implementation notifies the set of
         * {@code javax.swing.event.ListSelectionListener}s that have been added to it
         * each time a change to the selection occurs. These changes are characterized
         * by a {@code javax.swing.event.ListSelectionEvent}, which identifies the range
         * of the selection change.
         * <p>
         * The preferred way to listen for changes in list selection is to add
         * {@code ListSelectionListener}s directly to the {@code JList}. {@code JList}
         * then takes care of listening to the the selection model and notifying your
         * listeners of change.
         * <p>
         * Responsibility for listening to selection changes in order to keep the list's
         * visual representation up to date lies with the list's {@code ListUI}.
         * <p>
         * <a name="renderer"></a> Painting of cells in a {@code JList} is handled by a
         * delegate called a cell renderer, installed on the list as the
         * {@code cellRenderer} property. The renderer provides a
         * {@code java.awt.Component} that is used like a "rubber stamp" to paint the
         * cells. Each time a cell needs to be painted, the list's {@code ListUI} asks
         * the cell renderer for the component, moves it into place, and has it paint
         * the contents of the cell by way of its {@code paint} method. A default cell
         * renderer, which uses a {@code JLabel} component to render, is installed by
         * the lists's {@code ListUI}. You can substitute your own renderer using code
         * like this:
         *
         * <pre>
         * {
         * &#64;code
         * // Display an icon and a string for each object in the list.
         *
         * class MyCellRenderer extends JLabel implements ListCellRenderer<Object> {
         * final static ImageIcon longIcon = new ImageIcon("long.gif");
         * final static ImageIcon shortIcon = new ImageIcon("short.gif");
         *
         * // This is the only method defined by ListCellRenderer.
         * // We just reconfigure the JLabel each time we're called.
         *
         * public Component getListCellRendererComponent(JList<?> list, // the
         * // list
         * Object value, // value to display
         * int index, // cell index
         * boolean isSelected, // is the cell selected
         * boolean cellHasFocus) // does the cell have focus
         * {
         * String s = value.toString();
         * setText(s);
         * setIcon((s.length() > 10) ? longIcon : shortIcon);
         * if (isSelected) {
         * setBackground(list.getSelectionBackground());
         * setForeground(list.getSelectionForeground());
         * } else {
         * setBackground(list.getBackground());
         * setForeground(list.getForeground());
         * }
         * setEnabled(list.isEnabled());
         * setFont(list.getFont());
         * setOpaque(true);
         * return this;
         * }
         * }
         *
         * myList.setCellRenderer(new MyCellRenderer());
         * }
         * </pre>
         * <p>
         * Another job for the cell renderer is in helping to determine sizing
         * information for the list. By default, the list's {@code ListUI} determines
         * the size of cells by asking the cell renderer for its preferred size for each
         * list item. This can be expensive for large lists of items. To avoid these
         * calculations, you can set a {@code fixedCellWidth} and
         * {@code fixedCellHeight} on the list, or have these values calculated
         * automatically based on a single prototype value:
         * <a name="prototype_example"></a>
         *
         * <pre>
         * {
         * &#64;code
         * JList<String> bigDataList = new JList<String>(bigData);
         *
         * // We don't want the JList implementation to compute the width
         * // or height of all of the list cells, so we give it a string
         * // that's as big as we'll need for any cell. It uses this to
         * // compute values for the fixedCellWidth and fixedCellHeight
         * // properties.
         *
         * bigDataList.setPrototypeCellValue("Index 1234567890");
         * }
         * </pre>
         * <p>
         * {@code JList} doesn't implement scrolling directly. To create a list that
         * scrolls, make it the viewport view of a {@code JScrollPane}. For example:
         *
         * <pre>
         * JScrollPane scrollPane = new JScrollPane(myList);
         *
         * // Or in two steps:
         * JScrollPane scrollPane = new JScrollPane();
         * scrollPane.getViewport().setView(myList);
         * </pre>
         * <p>
         * {@code JList} doesn't provide any special handling of double or triple (or N)
         * mouse clicks, but it's easy to add a {@code MouseListener} if you wish to
         * take action on these events. Use the {@code locationToIndex} method to
         * determine what cell was clicked. For example:
         *
         * <pre>
         * MouseListener mouseListener = new MouseAdapter() {
         * public void mouseClicked(MouseEvent e) {
         * if (e.getClickCount() == 2) {
         * int index = list.locationToIndex(e.getPoint());
         * System.out.println("Double clicked on Item " + index);
         * }
         * }
         * };
         * list.addMouseListener(mouseListener);
         * </pre>
         * <p>
         * <strong>Warning:</strong> Swing is not thread safe. For more information see
         * <a href="package-summary.html#threading">Swing's Threading Policy</a>.
         * <p>
         * <strong>Warning:</strong> Serialized objects of this class will not be
         * compatible with future Swing releases. The current serialization support is
         * appropriate for short term storage or RMI between applications running the
         * same version of Swing. As of 1.4, support for long term storage of all
         * JavaBeans&trade; has been added to the <code>java.beans</code> package.
         * Please see {@link java.beans.XMLEncoder}.
         * <p>
         * See <a href=
         * "http://docs.oracle.com/javase/tutorial/uiswing/components/list.html">How to
         * Use Lists</a> in <a href="http://docs.oracle.com/javase/tutorial/">
         * <em>The Java Tutorial</em></a> for further documentation.
         * <p>
         *
         * @see ListModel
         * @see AbstractListModel
         * @see DefaultListModel
         * @see ListSelectionModel
         * @see DefaultListSelectionModel
         * @see ListCellRenderer
         * @see DefaultListCellRenderer
         *
         * @param <E>
         * the type of the elements of this list
         *
         * @beaninfo attribute: isContainer false description: A component which allows
         * for the selection of one or more objects from a list.
         *
         * @author Hans Muller
         */
        var JList = (function (_super) {
            __extends(JList, _super);
            /**
             * Constructs a {@code JList} that displays elements from the specified,
             * {@code non-null}, model. All {@code JList} constructors delegate to this
             * one.
             *
             * @param dataModel
             * the model for the list
             * @exception IllegalArgumentException
             * if the model is {@code null}
             */
            function JList(dataModel) {
                var _this = this;
                if (((dataModel != null && (dataModel["__interfaces"] != null && dataModel["__interfaces"].indexOf("javax.swing.ListModel") >= 0 || dataModel.constructor != null && dataModel.constructor["__interfaces"] != null && dataModel.constructor["__interfaces"].indexOf("javax.swing.ListModel") >= 0)) || dataModel === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this);
                    this.fixedCellWidth = -1;
                    this.fixedCellHeight = -1;
                    this.horizontalScrollIncrement = -1;
                    this.visibleRowCount = 8;
                    this.dropMode = javax.swing.DropMode.USE_SELECTION;
                    this.dragEnabled = false;
                    this.layoutOrientation = 0;
                    (function () {
                        if (dataModel == null) {
                            throw new java.lang.IllegalArgumentException("dataModel must be non null");
                        }
                        _this.layoutOrientation = JList.VERTICAL;
                        _this.dataModel = dataModel;
                        _this.selectionModel = _this.createSelectionModel();
                    })();
                }
                else if (((dataModel != null && dataModel instanceof Array) || dataModel === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    var listData = __args[0];
                    {
                        var __args_51 = Array.prototype.slice.call(arguments);
                        var dataModel_1 = new JList.JList$0(this, listData);
                        _super.call(this);
                        this.fixedCellWidth = -1;
                        this.fixedCellHeight = -1;
                        this.horizontalScrollIncrement = -1;
                        this.visibleRowCount = 8;
                        this.dropMode = javax.swing.DropMode.USE_SELECTION;
                        this.dragEnabled = false;
                        this.layoutOrientation = 0;
                        (function () {
                            if (dataModel_1 == null) {
                                throw new java.lang.IllegalArgumentException("dataModel must be non null");
                            }
                            _this.layoutOrientation = JList.VERTICAL;
                            _this.dataModel = dataModel_1;
                            _this.selectionModel = _this.createSelectionModel();
                        })();
                    }
                }
                else if (((dataModel != null && dataModel instanceof java.util.Vector) || dataModel === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    var listData = __args[0];
                    {
                        var __args_52 = Array.prototype.slice.call(arguments);
                        var dataModel_2 = new JList.JList$1(this, listData);
                        _super.call(this);
                        this.fixedCellWidth = -1;
                        this.fixedCellHeight = -1;
                        this.horizontalScrollIncrement = -1;
                        this.visibleRowCount = 8;
                        this.dropMode = javax.swing.DropMode.USE_SELECTION;
                        this.dragEnabled = false;
                        this.layoutOrientation = 0;
                        (function () {
                            if (dataModel_2 == null) {
                                throw new java.lang.IllegalArgumentException("dataModel must be non null");
                            }
                            _this.layoutOrientation = JList.VERTICAL;
                            _this.dataModel = dataModel_2;
                            _this.selectionModel = _this.createSelectionModel();
                        })();
                    }
                }
                else if (dataModel === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_53 = Array.prototype.slice.call(arguments);
                        var dataModel_3 = new JList.JList$2(this);
                        _super.call(this);
                        this.fixedCellWidth = -1;
                        this.fixedCellHeight = -1;
                        this.horizontalScrollIncrement = -1;
                        this.visibleRowCount = 8;
                        this.dropMode = javax.swing.DropMode.USE_SELECTION;
                        this.dragEnabled = false;
                        this.layoutOrientation = 0;
                        (function () {
                            if (dataModel_3 == null) {
                                throw new java.lang.IllegalArgumentException("dataModel must be non null");
                            }
                            _this.layoutOrientation = JList.VERTICAL;
                            _this.dataModel = dataModel_3;
                            _this.selectionModel = _this.createSelectionModel();
                        })();
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            JList.prototype.createHTML = function () {
            };
            JList.prototype.updateFixedCellSize = function () {
                var cr = this.getCellRenderer();
                var value = this.getPrototypeCellValue();
                if ((cr != null) && (value != null)) {
                    var c = cr.getListCellRendererComponent(this, value, 0, false, false);
                    var f = c.getFont();
                    c.setFont(this.getFont());
                    c.setFont(f);
                }
            };
            /**
             * Returns the "prototypical" cell value -- a value used to calculate a
             * fixed width and height for cells. This can be {@code null} if there is no
             * such value.
             *
             * @return the value of the {@code prototypeCellValue} property
             * @see #setPrototypeCellValue
             */
            JList.prototype.getPrototypeCellValue = function () {
                return this.prototypeCellValue;
            };
            /**
             * Sets the {@code prototypeCellValue} property, and then (if the new value
             * is {@code non-null}), computes the {@code fixedCellWidth} and
             * {@code fixedCellHeight} properties by requesting the cell renderer
             * component for the given value (and index 0) from the cell renderer, and
             * using that component's preferred size.
             * <p>
             * This method is useful when the list is too long to allow the
             * {@code ListUI} to compute the width/height of each cell, and there is a
             * single cell value that is known to occupy as much space as any of the
             * others, a so-called prototype.
             * <p>
             * While all three of the {@code prototypeCellValue},
             * {@code fixedCellHeight}, and {@code fixedCellWidth} properties may be
             * modified by this method, {@code PropertyChangeEvent} notifications are
             * only sent when the {@code prototypeCellValue} property changes.
             * <p>
             * To see an example which sets this property, see the
             * <a href="#prototype_example">class description</a> above.
             * <p>
             * The default value of this property is <code>null</code>.
             * <p>
             * This is a JavaBeans bound property.
             *
             * @param prototypeCellValue
             * the value on which to base <code>fixedCellWidth</code> and
             * <code>fixedCellHeight</code>
             * @see #getPrototypeCellValue
             * @see #setFixedCellWidth
             * @see #setFixedCellHeight
             * @see JComponent#addPropertyChangeListener
             * @beaninfo bound: true attribute: visualUpdate true description: The cell
             * prototype value, used to compute cell width and height.
             */
            JList.prototype.setPrototypeCellValue = function (prototypeCellValue) {
                var oldValue = this.prototypeCellValue;
                this.prototypeCellValue = prototypeCellValue;
                if ((prototypeCellValue != null) && !prototypeCellValue.equals(oldValue)) {
                    this.updateFixedCellSize();
                }
                this.firePropertyChange("prototypeCellValue", oldValue, prototypeCellValue);
            };
            /**
             * Returns the value of the {@code fixedCellWidth} property.
             *
             * @return the fixed cell width
             * @see #setFixedCellWidth
             */
            JList.prototype.getFixedCellWidth = function () {
                return this.fixedCellWidth;
            };
            /**
             * Sets a fixed value to be used for the width of every cell in the list. If
             * {@code width} is -1, cell widths are computed in the {@code ListUI} by
             * applying <code>getPreferredSize</code> to the cell renderer component for
             * each list element.
             * <p>
             * The default value of this property is {@code -1}.
             * <p>
             * This is a JavaBeans bound property.
             *
             * @param width
             * the width to be used for all cells in the list
             * @see #setPrototypeCellValue
             * @see #setFixedCellWidth
             * @see JComponent#addPropertyChangeListener
             * @beaninfo bound: true attribute: visualUpdate true description: Defines a
             * fixed cell width when greater than zero.
             */
            JList.prototype.setFixedCellWidth = function (width) {
                var oldValue = this.fixedCellWidth;
                this.fixedCellWidth = width;
                this.firePropertyChange("fixedCellWidth", oldValue, this.fixedCellWidth);
            };
            /**
             * Returns the value of the {@code fixedCellHeight} property.
             *
             * @return the fixed cell height
             * @see #setFixedCellHeight
             */
            JList.prototype.getFixedCellHeight = function () {
                return this.fixedCellHeight;
            };
            /**
             * Sets a fixed value to be used for the height of every cell in the list.
             * If {@code height} is -1, cell heights are computed in the {@code ListUI}
             * by applying <code>getPreferredSize</code> to the cell renderer component
             * for each list element.
             * <p>
             * The default value of this property is {@code -1}.
             * <p>
             * This is a JavaBeans bound property.
             *
             * @param height
             * the height to be used for for all cells in the list
             * @see #setPrototypeCellValue
             * @see #setFixedCellWidth
             * @see JComponent#addPropertyChangeListener
             * @beaninfo bound: true attribute: visualUpdate true description: Defines a
             * fixed cell height when greater than zero.
             */
            JList.prototype.setFixedCellHeight = function (height) {
                var oldValue = this.fixedCellHeight;
                this.fixedCellHeight = height;
                this.firePropertyChange("fixedCellHeight", oldValue, this.fixedCellHeight);
            };
            /**
             * Returns the object responsible for painting list items.
             *
             * @return the value of the {@code cellRenderer} property
             * @see #setCellRenderer
             */
            JList.prototype.getCellRenderer = function () {
                return this.cellRenderer;
            };
            /**
             * Sets the delegate that is used to paint each cell in the list. The job of
             * a cell renderer is discussed in detail in the <a href="#renderer">class
             * level documentation</a>.
             * <p>
             * If the {@code prototypeCellValue} property is {@code non-null}, setting
             * the cell renderer also causes the {@code fixedCellWidth} and
             * {@code fixedCellHeight} properties to be re-calculated. Only one
             * <code>PropertyChangeEvent</code> is generated however - for the
             * <code>cellRenderer</code> property.
             * <p>
             * The default value of this property is provided by the {@code ListUI}
             * delegate, i.e. by the look and feel implementation.
             * <p>
             * This is a JavaBeans bound property.
             *
             * @param cellRenderer
             * the <code>ListCellRenderer</code> that paints list cells
             * @see #getCellRenderer
             * @beaninfo bound: true attribute: visualUpdate true description: The
             * component used to draw the cells.
             */
            JList.prototype.setCellRenderer = function (cellRenderer) {
                var oldValue = this.cellRenderer;
                this.cellRenderer = cellRenderer;
                if ((cellRenderer != null) && !cellRenderer.equals(oldValue)) {
                    this.updateFixedCellSize();
                }
                this.firePropertyChange("cellRenderer", oldValue, cellRenderer);
            };
            /**
             * Returns the color used to draw the foreground of selected items.
             * {@code DefaultListCellRenderer} uses this color to draw the foreground of
             * items in the selected state, as do the renderers installed by most
             * {@code ListUI} implementations.
             *
             * @return the color to draw the foreground of selected items
             * @see #setSelectionForeground
             * @see DefaultListCellRenderer
             */
            JList.prototype.getSelectionForeground = function () {
                return this.selectionForeground;
            };
            /**
             * Sets the color used to draw the foreground of selected items, which cell
             * renderers can use to render text and graphics.
             * {@code DefaultListCellRenderer} uses this color to draw the foreground of
             * items in the selected state, as do the renderers installed by most
             * {@code ListUI} implementations.
             * <p>
             * The default value of this property is defined by the look and feel
             * implementation.
             * <p>
             * This is a JavaBeans bound property.
             *
             * @param selectionForeground
             * the {@code Color} to use in the foreground for selected list
             * items
             * @see #getSelectionForeground
             * @see #setSelectionBackground
             * @see #setForeground
             * @see #setBackground
             * @see #setFont
             * @see DefaultListCellRenderer
             * @beaninfo bound: true attribute: visualUpdate true description: The
             * foreground color of selected cells.
             */
            JList.prototype.setSelectionForeground = function (selectionForeground) {
                var oldValue = this.selectionForeground;
                this.selectionForeground = selectionForeground;
                this.firePropertyChange("selectionForeground", oldValue, selectionForeground);
            };
            /**
             * Returns the color used to draw the background of selected items.
             * {@code DefaultListCellRenderer} uses this color to draw the background of
             * items in the selected state, as do the renderers installed by most
             * {@code ListUI} implementations.
             *
             * @return the color to draw the background of selected items
             * @see #setSelectionBackground
             * @see DefaultListCellRenderer
             */
            JList.prototype.getSelectionBackground = function () {
                return this.selectionBackground;
            };
            /**
             * Sets the color used to draw the background of selected items, which cell
             * renderers can use fill selected cells. {@code DefaultListCellRenderer}
             * uses this color to fill the background of items in the selected state, as
             * do the renderers installed by most {@code ListUI} implementations.
             * <p>
             * The default value of this property is defined by the look and feel
             * implementation.
             * <p>
             * This is a JavaBeans bound property.
             *
             * @param selectionBackground
             * the {@code Color} to use for the background of selected cells
             * @see #getSelectionBackground
             * @see #setSelectionForeground
             * @see #setForeground
             * @see #setBackground
             * @see #setFont
             * @see DefaultListCellRenderer
             * @beaninfo bound: true attribute: visualUpdate true description: The
             * background color of selected cells.
             */
            JList.prototype.setSelectionBackground = function (selectionBackground) {
                var oldValue = this.selectionBackground;
                this.selectionBackground = selectionBackground;
                this.firePropertyChange("selectionBackground", oldValue, selectionBackground);
            };
            /**
             * Returns the value of the {@code visibleRowCount} property. See the
             * documentation for {@link #setVisibleRowCount} for details on how to
             * interpret this value.
             *
             * @return the value of the {@code visibleRowCount} property.
             * @see #setVisibleRowCount
             */
            JList.prototype.getVisibleRowCount = function () {
                return this.visibleRowCount;
            };
            /**
             * Sets the {@code visibleRowCount} property, which has different meanings
             * depending on the layout orientation: For a {@code VERTICAL} layout
             * orientation, this sets the preferred number of rows to display without
             * requiring scrolling; for other orientations, it affects the wrapping of
             * cells.
             * <p>
             * In {@code VERTICAL} orientation:<br>
             * Setting this property affects the return value of the
             * {@link #getPreferredScrollableViewportSize} method, which is used to
             * calculate the preferred size of an enclosing viewport. See that method's
             * documentation for more details.
             * <p>
             * In {@code HORIZONTAL_WRAP} and {@code VERTICAL_WRAP} orientations:<br>
             * This affects how cells are wrapped. See the documentation of
             * {@link #setLayoutOrientation} for more details.
             * <p>
             * The default value of this property is {@code 8}.
             * <p>
             * Calling this method with a negative value results in the property being
             * set to {@code 0}.
             * <p>
             * This is a JavaBeans bound property.
             *
             * @param visibleRowCount
             * an integer specifying the preferred number of rows to display
             * without requiring scrolling
             * @see #getVisibleRowCount
             * @see #getPreferredScrollableViewportSize
             * @see #setLayoutOrientation
             * @see JComponent#getVisibleRect
             * @see JViewport
             * @beaninfo bound: true attribute: visualUpdate true description: The
             * preferred number of rows to display without requiring scrolling
             */
            JList.prototype.setVisibleRowCount = function (visibleRowCount) {
                var oldValue = this.visibleRowCount;
                this.visibleRowCount = Math.max(0, visibleRowCount);
                this.firePropertyChange("visibleRowCount", oldValue, visibleRowCount);
            };
            /**
             * Returns the layout orientation property for the list: {@code VERTICAL} if
             * the layout is a single column of cells, {@code VERTICAL_WRAP} if the
             * layout is "newspaper style" with the content flowing vertically then
             * horizontally, or {@code HORIZONTAL_WRAP} if the layout is "newspaper
             * style" with the content flowing horizontally then vertically.
             *
             * @return the value of the {@code layoutOrientation} property
             * @see #setLayoutOrientation
             * @since 1.4
             */
            JList.prototype.getLayoutOrientation = function () {
                return this.layoutOrientation;
            };
            /**
             * Defines the way list cells are layed out. Consider a {@code JList} with
             * five cells. Cells can be layed out in one of the following ways:
             *
             * <pre>
             * VERTICAL:          0
             * 1
             * 2
             * 3
             * 4
             *
             * HORIZONTAL_WRAP:   0  1  2
             * 3  4
             *
             * VERTICAL_WRAP:     0  3
             * 1  4
             * 2
             * </pre>
             * <p>
             * A description of these layouts follows:
             *
             * <table border="1" summary=
             * "Describes layouts VERTICAL, HORIZONTAL_WRAP, and VERTICAL_WRAP">
             * <tr>
             * <th>
             * <p style="text-align:left">
             * Value
             * </p>
             * </th>
             * <th>
             * <p style="text-align:left">
             * Description
             * </p>
             * </th>
             * </tr>
             * <tr>
             * <td><code>VERTICAL</code>
             * <td>Cells are layed out vertically in a single column.
             * <tr>
             * <td><code>HORIZONTAL_WRAP</code>
             * <td>Cells are layed out horizontally, wrapping to a new row as necessary.
             * If the {@code visibleRowCount} property is less than or equal to zero,
             * wrapping is determined by the width of the list; otherwise wrapping is
             * done in such a way as to ensure {@code visibleRowCount} rows in the list.
             * <tr>
             * <td><code>VERTICAL_WRAP</code>
             * <td>Cells are layed out vertically, wrapping to a new column as
             * necessary. If the {@code visibleRowCount} property is less than or equal
             * to zero, wrapping is determined by the height of the list; otherwise
             * wrapping is done at {@code visibleRowCount} rows.
             * </table>
             * <p>
             * The default value of this property is <code>VERTICAL</code>.
             *
             * @param layoutOrientation
             * the new layout orientation, one of: {@code VERTICAL},
             * {@code HORIZONTAL_WRAP} or {@code VERTICAL_WRAP}
             * @see #getLayoutOrientation
             * @see #setVisibleRowCount
             * @see #getScrollableTracksViewportHeight
             * @see #getScrollableTracksViewportWidth
             * @throws IllegalArgumentException
             * if {@code layoutOrientation} isn't one of the allowable
             * values
             * @since 1.4
             * @beaninfo bound: true attribute: visualUpdate true description: Defines
             * the way list cells are layed out. enum: VERTICAL JList.VERTICAL
             * HORIZONTAL_WRAP JList.HORIZONTAL_WRAP VERTICAL_WRAP
             * JList.VERTICAL_WRAP
             */
            JList.prototype.setLayoutOrientation = function (layoutOrientation) {
                var oldValue = this.layoutOrientation;
                switch ((layoutOrientation)) {
                    case JList.VERTICAL:
                    case JList.VERTICAL_WRAP:
                    case JList.HORIZONTAL_WRAP:
                        this.layoutOrientation = layoutOrientation;
                        this.firePropertyChange("layoutOrientation", oldValue, layoutOrientation);
                        break;
                    default:
                        throw new java.lang.IllegalArgumentException("layoutOrientation must be one of: VERTICAL, HORIZONTAL_WRAP or VERTICAL_WRAP");
                }
            };
            /**
             * Scrolls the list within an enclosing viewport to make the specified cell
             * completely visible. This calls {@code scrollRectToVisible} with the
             * bounds of the specified cell. For this method to work, the {@code JList}
             * must be within a <code>JViewport</code>.
             * <p>
             * If the given index is outside the list's range of cells, this method
             * results in nothing.
             *
             * @param index
             * the index of the cell to make visible
             * @see JComponent#scrollRectToVisible
             * @see #getVisibleRect
             */
            JList.prototype.ensureIndexIsVisible = function (index) {
                var cellBounds = this.getCellBounds(index, index);
                if (cellBounds != null) {
                }
            };
            /**
             * Turns on or off automatic drag handling. In order to enable automatic
             * drag handling, this property should be set to {@code true}, and the
             * list's {@code TransferHandler} needs to be {@code non-null}. The default
             * value of the {@code dragEnabled} property is {@code false}.
             * <p>
             * The job of honoring this property, and recognizing a user drag gesture,
             * lies with the look and feel implementation, and in particular, the list's
             * {@code ListUI}. When automatic drag handling is enabled, most look and
             * feels (including those that subclass {@code BasicLookAndFeel}) begin a
             * drag and drop operation whenever the user presses the mouse button over
             * an item and then moves the mouse a few pixels. Setting this property to
             * {@code true} can therefore have a subtle effect on how selections behave.
             * <p>
             * If a look and feel is used that ignores this property, you can still
             * begin a drag and drop operation by calling {@code exportAsDrag} on the
             * list's {@code TransferHandler}.
             *
             * @param b
             * whether or not to enable automatic drag handling
             * @see java.awt.GraphicsEnvironment#isHeadless
             * @see #getDragEnabled
             * @see #setTransferHandler
             * @see TransferHandler
             * @since 1.4
             *
             * @beaninfo description: determines whether automatic drag handling is
             * enabled bound: false
             */
            JList.prototype.setDragEnabled = function (b) {
                this.dragEnabled = b;
            };
            /**
             * Returns whether or not automatic drag handling is enabled.
             *
             * @return the value of the {@code dragEnabled} property
             * @see #setDragEnabled
             * @since 1.4
             */
            JList.prototype.getDragEnabled = function () {
                return this.dragEnabled;
            };
            /**
             * Sets the drop mode for this component. For backward compatibility, the
             * default for this property is <code>DropMode.USE_SELECTION</code>. Usage
             * of one of the other modes is recommended, however, for an improved user
             * experience. <code>DropMode.ON</code>, for instance, offers similar
             * behavior of showing items as selected, but does so without affecting the
             * actual selection in the list.
             * <p>
             * <code>JList</code> supports the following drop modes:
             * <ul>
             * <li><code>DropMode.USE_SELECTION</code></li>
             * <li><code>DropMode.ON</code></li>
             * <li><code>DropMode.INSERT</code></li>
             * <li><code>DropMode.ON_OR_INSERT</code></li>
             * </ul>
             * The drop mode is only meaningful if this component has a
             * <code>TransferHandler</code> that accepts drops.
             *
             * @param dropMode
             * the drop mode to use
             * @throws IllegalArgumentException
             * if the drop mode is unsupported or <code>null</code>
             * @see #getDropMode
             * @see #getDropLocation
             * @see #setTransferHandler
             * @see TransferHandler
             * @since 1.6
             */
            JList.prototype.setDropMode = function (dropMode) {
                if (dropMode != null) {
                    switch ((dropMode)) {
                        case javax.swing.DropMode.USE_SELECTION:
                        case javax.swing.DropMode.ON:
                        case javax.swing.DropMode.INSERT:
                        case javax.swing.DropMode.ON_OR_INSERT:
                            this.dropMode = dropMode;
                            return;
                    }
                }
                throw new java.lang.IllegalArgumentException(dropMode + ": Unsupported drop mode for list");
            };
            /**
             * Returns the drop mode for this component.
             *
             * @return the drop mode for this component
             * @see #setDropMode
             * @since 1.6
             */
            JList.prototype.getDropMode = function () {
                return this.dropMode;
            };
            /**
             * Returns the next list element whose {@code toString} value starts with
             * the given prefix.
             *
             * @param prefix
             * the string to test for a match
             * @param startIndex
             * the index for starting the search
             * @param bias
             * the search direction, either Position.Bias.Forward or
             * Position.Bias.Backward.
             * @return the index of the next list element that starts with the prefix;
             * otherwise {@code -1}
             * @exception IllegalArgumentException
             * if prefix is {@code null} or startIndex is out of bounds
             * @since 1.4
             */
            JList.prototype.getNextMatch = function (prefix, startIndex, bias) {
                var model = this.getModel();
                var max = model.getSize();
                if (prefix == null) {
                    throw new java.lang.IllegalArgumentException();
                }
                if (startIndex < 0 || startIndex >= max) {
                    throw new java.lang.IllegalArgumentException();
                }
                prefix = prefix.toUpperCase();
                var increment = (bias === javax.swing.text.Position.Bias.Forward_$LI$()) ? 1 : -1;
                var index = startIndex;
                do {
                    var element = model.getElementAt(index);
                    if (element != null) {
                        var str = void 0;
                        if (typeof element === 'string') {
                            str = element.toUpperCase();
                        }
                        else {
                            str = element.toString();
                            if (str != null) {
                                str = str.toUpperCase();
                            }
                        }
                        if (str != null && (function (str, searchString, position) {
                            if (position === void 0) { position = 0; }
                            return str.substr(position, searchString.length) === searchString;
                        })(str, prefix)) {
                            return index;
                        }
                    }
                    index = (index + increment + max) % max;
                } while ((index !== startIndex));
                return -1;
            };
            /**
             * Returns the cell index closest to the given location in the list's
             * coordinate system. To determine if the cell actually contains the
             * specified location, compare the point against the cell's bounds, as
             * provided by {@code getCellBounds}. This method returns {@code -1} if the
             * model is empty
             * <p>
             * This is a cover method that delegates to the method of the same name in
             * the list's {@code ListUI}. It returns {@code -1} if the list has no
             * {@code ListUI}.
             *
             * @param location
             * the coordinates of the point
             * @return the cell index closest to the given location, or {@code -1}
             */
            JList.prototype.locationToIndex = function (location) {
                throw new Error("not supported");
            };
            /**
             * Returns the origin of the specified item in the list's coordinate system.
             * This method returns {@code null} if the index isn't valid.
             * <p>
             * This is a cover method that delegates to the method of the same name in
             * the list's {@code ListUI}. It returns {@code null} if the list has no
             * {@code ListUI}.
             *
             * @param index
             * the cell index
             * @return the origin of the cell, or {@code null}
             */
            JList.prototype.indexToLocation = function (index) {
                throw new Error("not supported");
            };
            /**
             * Returns the bounding rectangle, in the list's coordinate system, for the
             * range of cells specified by the two indices. These indices can be
             * supplied in any order.
             * <p>
             * If the smaller index is outside the list's range of cells, this method
             * returns {@code null}. If the smaller index is valid, but the larger index
             * is outside the list's range, the bounds of just the first index is
             * returned. Otherwise, the bounds of the valid range is returned.
             * <p>
             * This is a cover method that delegates to the method of the same name in
             * the list's {@code ListUI}. It returns {@code null} if the list has no
             * {@code ListUI}.
             *
             * @param index0
             * the first index in the range
             * @param index1
             * the second index in the range
             * @return the bounding rectangle for the range of cells, or {@code null}
             */
            JList.prototype.getCellBounds = function (index0, index1) {
                throw new Error("not supported");
            };
            /**
             * Returns the data model that holds the list of items displayed by the
             * <code>JList</code> component.
             *
             * @return the <code>ListModel</code> that provides the displayed list of
             * items
             * @see #setModel
             */
            JList.prototype.getModel = function () {
                return this.dataModel;
            };
            /**
             * Sets the model that represents the contents or "value" of the list,
             * notifies property change listeners, and then clears the list's selection.
             * <p>
             * This is a JavaBeans bound property.
             *
             * @param model
             * the <code>ListModel</code> that provides the list of items for
             * display
             * @exception IllegalArgumentException
             * if <code>model</code> is <code>null</code>
             * @see #getModel
             * @see #clearSelection
             * @beaninfo bound: true attribute: visualUpdate true description: The
             * object that contains the data to be drawn by this JList.
             */
            JList.prototype.setModel = function (model) {
                if (model == null) {
                    throw new java.lang.IllegalArgumentException("model must be non null");
                }
                var oldValue = this.dataModel;
                this.dataModel = model;
                this.firePropertyChange("model", oldValue, this.dataModel);
                this.clearSelection();
            };
            /**
             * Constructs a read-only <code>ListModel</code> from an array of items, and
             * calls {@code setModel} with this model.
             * <p>
             * Attempts to pass a {@code null} value to this method results in undefined
             * behavior and, most likely, exceptions. The created model references the
             * given array directly. Attempts to modify the array after invoking this
             * method results in undefined behavior.
             *
             * @param listData
             * an array of {@code E} containing the items to display in the
             * list
             * @see #setModel
             */
            JList.prototype.setListData = function (listData) {
                var _this = this;
                if (((listData != null && listData instanceof Array) || listData === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        _this.setModel(new JList.JList$3(_this, listData));
                    })();
                }
                else if (((listData != null && listData instanceof java.util.Vector) || listData === null)) {
                    return this.setListData$java_util_Vector(listData);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Constructs a read-only <code>ListModel</code> from a <code>Vector</code>
             * and calls {@code setModel} with this model.
             * <p>
             * Attempts to pass a {@code null} value to this method results in undefined
             * behavior and, most likely, exceptions. The created model references the
             * given {@code Vector} directly. Attempts to modify the {@code Vector}
             * after invoking this method results in undefined behavior.
             *
             * @param listData
             * a <code>Vector</code> containing the items to display in the
             * list
             * @see #setModel
             */
            JList.prototype.setListData$java_util_Vector = function (listData) {
                this.setModel(new JList.JList$4(this, listData));
            };
            /**
             * Returns an instance of {@code DefaultListSelectionModel}; called during
             * construction to initialize the list's selection model property.
             *
             * @return a {@code DefaultListSelecitonModel}, used to initialize the
             * list's selection model property during construction
             * @see #setSelectionModel
             * @see DefaultListSelectionModel
             */
            JList.prototype.createSelectionModel = function () {
                return new javax.swing.DefaultListSelectionModel();
            };
            /**
             * Returns the current selection model. The selection model maintains the
             * selection state of the list. See the class level documentation for more
             * details.
             *
             * @return the <code>ListSelectionModel</code> that maintains the list's
             * selections
             *
             * @see #setSelectionModel
             * @see ListSelectionModel
             */
            JList.prototype.getSelectionModel = function () {
                return this.selectionModel;
            };
            /**
             * Notifies {@code ListSelectionListener}s added directly to the list of
             * selection changes made to the selection model. {@code JList} listens for
             * changes made to the selection in the selection model, and forwards
             * notification to listeners added to the list directly, by calling this
             * method.
             * <p>
             * This method constructs a {@code ListSelectionEvent} with this list as the
             * source, and the specified arguments, and sends it to the registered
             * {@code ListSelectionListeners}.
             *
             * @param firstIndex
             * the first index in the range, {@code <= lastIndex}
             * @param lastIndex
             * the last index in the range, {@code >= firstIndex}
             * @param isAdjusting
             * whether or not this is one in a series of multiple events,
             * where changes are still being made
             *
             * @see #addListSelectionListener
             * @see #removeListSelectionListener
             * @see javax.swing.event.ListSelectionEvent
             * @see EventListenerList
             */
            JList.prototype.fireSelectionValueChanged = function (firstIndex, lastIndex, isAdjusting) {
                var listeners = this.listenerList.getListenerList();
                var e = null;
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "javax.swing.event.ListSelectionListener") {
                        if (e == null) {
                            e = new javax.swing.event.ListSelectionEvent(this, firstIndex, lastIndex, isAdjusting);
                        }
                        listeners[i + 1].valueChanged(e);
                    }
                }
            };
            /**
             * Adds a listener to the list, to be notified each time a change to the
             * selection occurs; the preferred way of listening for selection state
             * changes. {@code JList} takes care of listening for selection state
             * changes in the selection model, and notifies the given listener of each
             * change. {@code ListSelectionEvent}s sent to the listener have a
             * {@code source} property set to this list.
             *
             * @param listener
             * the {@code ListSelectionListener} to add
             * @see #getSelectionModel
             * @see #getListSelectionListeners
             */
            JList.prototype.addListSelectionListener = function (listener) {
                if (this.selectionListener == null) {
                    this.selectionListener = new JList.ListSelectionHandler(this);
                    this.getSelectionModel().addListSelectionListener(this.selectionListener);
                }
                this.listenerList.add("javax.swing.event.ListSelectionListener", listener);
            };
            /**
             * Removes a selection listener from the list.
             *
             * @param listener
             * the {@code ListSelectionListener} to remove
             * @see #addListSelectionListener
             * @see #getSelectionModel
             */
            JList.prototype.removeListSelectionListener = function (listener) {
                this.listenerList.remove("javax.swing.event.ListSelectionListener", listener);
            };
            /**
             * Returns an array of all the {@code ListSelectionListener}s added to this
             * {@code JList} by way of {@code addListSelectionListener}.
             *
             * @return all of the {@code ListSelectionListener}s on this list, or an
             * empty array if no listeners have been added
             * @see #addListSelectionListener
             * @since 1.4
             */
            JList.prototype.getListSelectionListeners = function () {
                return this.listenerList.getListeners("javax.swing.event.ListSelectionListener");
            };
            /**
             * Sets the <code>selectionModel</code> for the list to a non-
             * <code>null</code> <code>ListSelectionModel</code> implementation. The
             * selection model handles the task of making single selections, selections
             * of contiguous ranges, and non-contiguous selections.
             * <p>
             * This is a JavaBeans bound property.
             *
             * @param selectionModel
             * the <code>ListSelectionModel</code> that implements the
             * selections
             * @exception IllegalArgumentException
             * if <code>selectionModel</code> is <code>null</code>
             * @see #getSelectionModel
             * @beaninfo bound: true description: The selection model, recording which
             * cells are selected.
             */
            JList.prototype.setSelectionModel = function (selectionModel) {
                if (selectionModel == null) {
                    throw new java.lang.IllegalArgumentException("selectionModel must be non null");
                }
                if (this.selectionListener != null) {
                    this.selectionModel.removeListSelectionListener(this.selectionListener);
                    selectionModel.addListSelectionListener(this.selectionListener);
                }
                var oldValue = this.selectionModel;
                this.selectionModel = selectionModel;
                this.firePropertyChange("selectionModel", oldValue, selectionModel);
            };
            /**
             * Sets the selection mode for the list. This is a cover method that sets
             * the selection mode directly on the selection model.
             * <p>
             * The following list describes the accepted selection modes:
             * <ul>
             * <li>{@code ListSelectionModel.SINGLE_SELECTION} - Only one list index can
             * be selected at a time. In this mode, {@code setSelectionInterval} and
             * {@code addSelectionInterval} are equivalent, both replacing the current
             * selection with the index represented by the second argument (the "lead").
             * <li>{@code ListSelectionModel.SINGLE_INTERVAL_SELECTION} - Only one
             * contiguous interval can be selected at a time. In this mode,
             * {@code addSelectionInterval} behaves like {@code setSelectionInterval}
             * (replacing the current selection}, unless the given interval is
             * immediately adjacent to or overlaps the existing selection, and can be
             * used to grow the selection.
             * <li>{@code ListSelectionModel.MULTIPLE_INTERVAL_SELECTION} - In this
             * mode, there's no restriction on what can be selected. This mode is the
             * default.
             * </ul>
             *
             * @param selectionMode
             * the selection mode
             * @see #getSelectionMode
             * @throws IllegalArgumentException
             * if the selection mode isn't one of those allowed
             * @beaninfo description: The selection mode. enum: SINGLE_SELECTION
             * ListSelectionModel.SINGLE_SELECTION SINGLE_INTERVAL_SELECTION
             * ListSelectionModel.SINGLE_INTERVAL_SELECTION
             * MULTIPLE_INTERVAL_SELECTION
             * ListSelectionModel.MULTIPLE_INTERVAL_SELECTION
             */
            JList.prototype.setSelectionMode = function (selectionMode) {
                this.getSelectionModel().setSelectionMode(selectionMode);
            };
            /**
             * Returns the current selection mode for the list. This is a cover method
             * that delegates to the method of the same name on the list's selection
             * model.
             *
             * @return the current selection mode
             * @see #setSelectionMode
             */
            JList.prototype.getSelectionMode = function () {
                return this.getSelectionModel().getSelectionMode();
            };
            /**
             * Returns the anchor selection index. This is a cover method that delegates
             * to the method of the same name on the list's selection model.
             *
             * @return the anchor selection index
             * @see ListSelectionModel#getAnchorSelectionIndex
             */
            JList.prototype.getAnchorSelectionIndex = function () {
                return this.getSelectionModel().getAnchorSelectionIndex();
            };
            /**
             * Returns the lead selection index. This is a cover method that delegates
             * to the method of the same name on the list's selection model.
             *
             * @return the lead selection index
             * @see ListSelectionModel#getLeadSelectionIndex
             * @beaninfo description: The lead selection index.
             */
            JList.prototype.getLeadSelectionIndex = function () {
                return this.getSelectionModel().getLeadSelectionIndex();
            };
            /**
             * Returns the smallest selected cell index, or {@code -1} if the selection
             * is empty. This is a cover method that delegates to the method of the same
             * name on the list's selection model.
             *
             * @return the smallest selected cell index, or {@code -1}
             * @see ListSelectionModel#getMinSelectionIndex
             */
            JList.prototype.getMinSelectionIndex = function () {
                return this.getSelectionModel().getMinSelectionIndex();
            };
            /**
             * Returns the largest selected cell index, or {@code -1} if the selection
             * is empty. This is a cover method that delegates to the method of the same
             * name on the list's selection model.
             *
             * @return the largest selected cell index
             * @see ListSelectionModel#getMaxSelectionIndex
             */
            JList.prototype.getMaxSelectionIndex = function () {
                return this.getSelectionModel().getMaxSelectionIndex();
            };
            /**
             * Returns {@code true} if the specified index is selected, else
             * {@code false}. This is a cover method that delegates to the method of the
             * same name on the list's selection model.
             *
             * @param index
             * index to be queried for selection state
             * @return {@code true} if the specified index is selected, else
             * {@code false}
             * @see ListSelectionModel#isSelectedIndex
             * @see #setSelectedIndex
             */
            JList.prototype.isSelectedIndex = function (index) {
                return this.getSelectionModel().isSelectedIndex(index);
            };
            /**
             * Returns {@code true} if nothing is selected, else {@code false}. This is
             * a cover method that delegates to the method of the same name on the
             * list's selection model.
             *
             * @return {@code true} if nothing is selected, else {@code false}
             * @see ListSelectionModel#isSelectionEmpty
             * @see #clearSelection
             */
            JList.prototype.isSelectionEmpty = function () {
                return this.getSelectionModel().isSelectionEmpty();
            };
            /**
             * Clears the selection; after calling this method, {@code isSelectionEmpty}
             * will return {@code true}. This is a cover method that delegates to the
             * method of the same name on the list's selection model.
             *
             * @see ListSelectionModel#clearSelection
             * @see #isSelectionEmpty
             */
            JList.prototype.clearSelection = function () {
                this.getSelectionModel().clearSelection();
            };
            /**
             * Selects the specified interval. Both {@code anchor} and {@code lead}
             * indices are included. {@code anchor} doesn't have to be less than or
             * equal to {@code lead}. This is a cover method that delegates to the
             * method of the same name on the list's selection model.
             * <p>
             * Refer to the documentation of the selection model class being used for
             * details on how values less than {@code 0} are handled.
             *
             * @param anchor
             * the first index to select
             * @param lead
             * the last index to select
             * @see ListSelectionModel#setSelectionInterval
             * @see DefaultListSelectionModel#setSelectionInterval
             * @see #createSelectionModel
             * @see #addSelectionInterval
             * @see #removeSelectionInterval
             */
            JList.prototype.setSelectionInterval = function (anchor, lead) {
                this.getSelectionModel().setSelectionInterval(anchor, lead);
            };
            /**
             * Sets the selection to be the union of the specified interval with current
             * selection. Both the {@code anchor} and {@code lead} indices are included.
             * {@code anchor} doesn't have to be less than or equal to {@code lead}.
             * This is a cover method that delegates to the method of the same name on
             * the list's selection model.
             * <p>
             * Refer to the documentation of the selection model class being used for
             * details on how values less than {@code 0} are handled.
             *
             * @param anchor
             * the first index to add to the selection
             * @param lead
             * the last index to add to the selection
             * @see ListSelectionModel#addSelectionInterval
             * @see DefaultListSelectionModel#addSelectionInterval
             * @see #createSelectionModel
             * @see #setSelectionInterval
             * @see #removeSelectionInterval
             */
            JList.prototype.addSelectionInterval = function (anchor, lead) {
                this.getSelectionModel().addSelectionInterval(anchor, lead);
            };
            /**
             * Sets the selection to be the set difference of the specified interval and
             * the current selection. Both the {@code index0} and {@code index1} indices
             * are removed. {@code index0} doesn't have to be less than or equal to
             * {@code index1}. This is a cover method that delegates to the method of
             * the same name on the list's selection model.
             * <p>
             * Refer to the documentation of the selection model class being used for
             * details on how values less than {@code 0} are handled.
             *
             * @param index0
             * the first index to remove from the selection
             * @param index1
             * the last index to remove from the selection
             * @see ListSelectionModel#removeSelectionInterval
             * @see DefaultListSelectionModel#removeSelectionInterval
             * @see #createSelectionModel
             * @see #setSelectionInterval
             * @see #addSelectionInterval
             */
            JList.prototype.removeSelectionInterval = function (index0, index1) {
                this.getSelectionModel().removeSelectionInterval(index0, index1);
            };
            /**
             * Sets the selection model's {@code valueIsAdjusting} property. When
             * {@code true}, upcoming changes to selection should be considered part of
             * a single change. This property is used internally and developers
             * typically need not call this method. For example, when the model is being
             * updated in response to a user drag, the value of the property is set to
             * {@code true} when the drag is initiated and set to {@code false} when the
             * drag is finished. This allows listeners to update only when a change has
             * been finalized, rather than handling all of the intermediate values.
             * <p>
             * You may want to use this directly if making a series of changes that
             * should be considered part of a single change.
             * <p>
             * This is a cover method that delegates to the method of the same name on
             * the list's selection model. See the documentation for
             * {@link javax.swing.ListSelectionModel#setValueIsAdjusting} for more
             * details.
             *
             * @param b
             * the new value for the property
             * @see ListSelectionModel#setValueIsAdjusting
             * @see javax.swing.event.ListSelectionEvent#getValueIsAdjusting
             * @see #getValueIsAdjusting
             */
            JList.prototype.setValueIsAdjusting = function (b) {
                this.getSelectionModel().setValueIsAdjusting(b);
            };
            /**
             * Returns the value of the selection model's {@code isAdjusting} property.
             * <p>
             * This is a cover method that delegates to the method of the same name on
             * the list's selection model.
             *
             * @return the value of the selection model's {@code isAdjusting} property.
             *
             * @see #setValueIsAdjusting
             * @see ListSelectionModel#getValueIsAdjusting
             */
            JList.prototype.getValueIsAdjusting = function () {
                return this.getSelectionModel().getValueIsAdjusting();
            };
            /**
             * Returns an array of all of the selected indices, in increasing order.
             *
             * @return all of the selected indices, in increasing order, or an empty
             * array if nothing is selected
             * @see #removeSelectionInterval
             * @see #addListSelectionListener
             */
            JList.prototype.getSelectedIndices = function () {
                var sm = this.getSelectionModel();
                var iMin = sm.getMinSelectionIndex();
                var iMax = sm.getMaxSelectionIndex();
                if ((iMin < 0) || (iMax < 0)) {
                    return new Array(0);
                }
                var rvTmp = new Array(1 + (iMax - iMin));
                var n = 0;
                for (var i = iMin; i <= iMax; i++) {
                    if (sm.isSelectedIndex(i)) {
                        rvTmp[n++] = i;
                    }
                }
                var rv = new Array(n);
                java.lang.System.arraycopy(rvTmp, 0, rv, 0, n);
                return rv;
            };
            /**
             * Selects a single cell. Does nothing if the given index is greater than or
             * equal to the model size. This is a convenience method that uses
             * {@code setSelectionInterval} on the selection model. Refer to the
             * documentation for the selection model class being used for details on how
             * values less than {@code 0} are handled.
             *
             * @param index
             * the index of the cell to select
             * @see ListSelectionModel#setSelectionInterval
             * @see #isSelectedIndex
             * @see #addListSelectionListener
             * @beaninfo description: The index of the selected cell.
             */
            JList.prototype.setSelectedIndex = function (index) {
                if (index >= this.getModel().getSize()) {
                    return;
                }
                this.getSelectionModel().setSelectionInterval(index, index);
            };
            /**
             * Changes the selection to be the set of indices specified by the given
             * array. Indices greater than or equal to the model size are ignored. This
             * is a convenience method that clears the selection and then uses
             * {@code addSelectionInterval} on the selection model to add the indices.
             * Refer to the documentation of the selection model class being used for
             * details on how values less than {@code 0} are handled.
             *
             * @param indices
             * an array of the indices of the cells to select,
             * {@code non-null}
             * @see ListSelectionModel#addSelectionInterval
             * @see #isSelectedIndex
             * @see #addListSelectionListener
             * @throws NullPointerException
             * if the given array is {@code null}
             */
            JList.prototype.setSelectedIndices = function (indices) {
                var sm = this.getSelectionModel();
                sm.clearSelection();
                var size = this.getModel().getSize();
                for (var index139 = 0; index139 < indices.length; index139++) {
                    var i = indices[index139];
                    {
                        if (i < size) {
                            sm.addSelectionInterval(i, i);
                        }
                    }
                }
            };
            /**
             * Returns an array of all the selected values, in increasing order based on
             * their indices in the list.
             *
             * @return the selected values, or an empty array if nothing is selected
             * @see #isSelectedIndex
             * @see #getModel
             * @see #addListSelectionListener
             *
             * @deprecated As of JDK 1.7, replaced by {@link #getSelectedValuesList()}
             */
            JList.prototype.getSelectedValues = function () {
                var sm = this.getSelectionModel();
                var dm = this.getModel();
                var iMin = sm.getMinSelectionIndex();
                var iMax = sm.getMaxSelectionIndex();
                if ((iMin < 0) || (iMax < 0)) {
                    return new Array(0);
                }
                var rvTmp = new Array(1 + (iMax - iMin));
                var n = 0;
                for (var i = iMin; i <= iMax; i++) {
                    if (sm.isSelectedIndex(i)) {
                        rvTmp[n++] = dm.getElementAt(i);
                    }
                }
                var rv = new Array(n);
                java.lang.System.arraycopy(rvTmp, 0, rv, 0, n);
                return rv;
            };
            /**
             * Returns a list of all the selected items, in increasing order based on
             * their indices in the list.
             *
             * @return the selected items, or an empty list if nothing is selected
             * @see #isSelectedIndex
             * @see #getModel
             * @see #addListSelectionListener
             *
             * @since 1.7
             */
            JList.prototype.getSelectedValuesList = function () {
                var sm = this.getSelectionModel();
                var dm = this.getModel();
                var iMin = sm.getMinSelectionIndex();
                var iMax = sm.getMaxSelectionIndex();
                if ((iMin < 0) || (iMax < 0)) {
                    return java.util.Collections.emptyList();
                }
                var selectedItems = (new java.util.ArrayList());
                for (var i = iMin; i <= iMax; i++) {
                    if (sm.isSelectedIndex(i)) {
                        selectedItems.add(dm.getElementAt(i));
                    }
                }
                return selectedItems;
            };
            /**
             * Returns the smallest selected cell index; <i>the selection</i> when only
             * a single item is selected in the list. When multiple items are selected,
             * it is simply the smallest selected index. Returns {@code -1} if there is
             * no selection.
             * <p>
             * This method is a cover that delegates to {@code getMinSelectionIndex}.
             *
             * @return the smallest selected cell index
             * @see #getMinSelectionIndex
             * @see #addListSelectionListener
             */
            JList.prototype.getSelectedIndex = function () {
                return this.getMinSelectionIndex();
            };
            /**
             * Returns the value for the smallest selected cell index; <i>the selected
             * value</i> when only a single item is selected in the list. When multiple
             * items are selected, it is simply the value for the smallest selected
             * index. Returns {@code null} if there is no selection.
             * <p>
             * This is a convenience method that simply returns the model value for
             * {@code getMinSelectionIndex}.
             *
             * @return the first selected value
             * @see #getMinSelectionIndex
             * @see #getModel
             * @see #addListSelectionListener
             */
            JList.prototype.getSelectedValue = function () {
                var i = this.getMinSelectionIndex();
                return (i === -1) ? null : this.getModel().getElementAt(i);
            };
            /**
             * Selects the specified object from the list.
             *
             * @param anObject
             * the object to select
             * @param shouldScroll
             * {@code true} if the list should scroll to display the selected
             * object, if one exists; otherwise {@code false}
             */
            JList.prototype.setSelectedValue = function (anObject, shouldScroll) {
                if (anObject == null)
                    this.setSelectedIndex(-1);
                else if (!(anObject === this.getSelectedValue())) {
                    var i = void 0;
                    var c = void 0;
                    var dm = this.getModel();
                    for (i = 0, c = dm.getSize(); i < c; i++)
                        if ((anObject === dm.getElementAt(i))) {
                            this.setSelectedIndex(i);
                            if (shouldScroll)
                                this.ensureIndexIsVisible(i);
                            return;
                        }
                    this.setSelectedIndex(-1);
                }
            };
            /**
             * Returns a {@code String} representation of this {@code JList}. This
             * method is intended to be used only for debugging purposes, and the
             * content and format of the returned {@code String} may vary between
             * implementations. The returned {@code String} may be empty, but may not be
             * {@code null}.
             *
             * @return a {@code String} representation of this {@code JList}.
             */
            JList.prototype.paramString = function () {
                var selectionForegroundString = (this.selectionForeground != null ? this.selectionForeground.toString() : "");
                var selectionBackgroundString = (this.selectionBackground != null ? this.selectionBackground.toString() : "");
                return _super.prototype.paramString.call(this) + ",fixedCellHeight=" + this.fixedCellHeight + ",fixedCellWidth=" + this.fixedCellWidth + ",horizontalScrollIncrement=" + this.horizontalScrollIncrement + ",selectionBackground=" + selectionBackgroundString + ",selectionForeground=" + selectionForegroundString + ",visibleRowCount=" + this.visibleRowCount + ",layoutOrientation=" + this.layoutOrientation;
            };
            /**
             * Indicates a vertical layout of cells, in a single column; the default
             * layout.
             *
             * @see #setLayoutOrientation
             * @since 1.4
             */
            JList.VERTICAL = 0;
            /**
             * Indicates a "newspaper style" layout with cells flowing vertically then
             * horizontally.
             *
             * @see #setLayoutOrientation
             * @since 1.4
             */
            JList.VERTICAL_WRAP = 1;
            /**
             * Indicates a "newspaper style" layout with cells flowing horizontally then
             * vertically.
             *
             * @see #setLayoutOrientation
             * @since 1.4
             */
            JList.HORIZONTAL_WRAP = 2;
            return JList;
        }(javax.swing.JComponent));
        swing.JList = JList;
        JList["__class"] = "javax.swing.JList";
        JList["__interfaces"] = ["java.awt.HTMLComponent", "java.io.Serializable"];
        var JList;
        (function (JList) {
            var ListSelectionHandler = (function () {
                function ListSelectionHandler(__parent) {
                    this.__parent = __parent;
                }
                ListSelectionHandler.prototype.valueChanged = function (e) {
                    this.__parent.fireSelectionValueChanged(e.getFirstIndex(), e.getLastIndex(), e.getValueIsAdjusting());
                };
                return ListSelectionHandler;
            }());
            JList.ListSelectionHandler = ListSelectionHandler;
            ListSelectionHandler["__class"] = "javax.swing.JList.ListSelectionHandler";
            ListSelectionHandler["__interfaces"] = ["java.util.EventListener", "javax.swing.event.ListSelectionListener", "java.io.Serializable"];
            var JList$0 = (function (_super) {
                __extends(JList$0, _super);
                function JList$0(__parent, listData) {
                    _super.call(this);
                    this.listData = listData;
                    this.__parent = __parent;
                }
                JList$0.prototype.getSize = function () {
                    return this.listData.length;
                };
                JList$0.prototype.getElementAt = function (i) {
                    return this.listData[i];
                };
                return JList$0;
            }(javax.swing.AbstractListModel));
            JList.JList$0 = JList$0;
            var JList$1 = (function (_super) {
                __extends(JList$1, _super);
                function JList$1(__parent, listData) {
                    _super.call(this);
                    this.listData = listData;
                    this.__parent = __parent;
                }
                JList$1.prototype.getSize = function () {
                    return this.listData.size();
                };
                JList$1.prototype.getElementAt = function (i) {
                    return this.listData.elementAt(i);
                };
                return JList$1;
            }(javax.swing.AbstractListModel));
            JList.JList$1 = JList$1;
            var JList$2 = (function (_super) {
                __extends(JList$2, _super);
                function JList$2(__parent) {
                    _super.call(this);
                    this.__parent = __parent;
                }
                JList$2.prototype.getSize = function () {
                    return 0;
                };
                JList$2.prototype.getElementAt = function (i) {
                    throw new java.lang.IndexOutOfBoundsException("No Data Model");
                };
                return JList$2;
            }(javax.swing.AbstractListModel));
            JList.JList$2 = JList$2;
            var JList$3 = (function (_super) {
                __extends(JList$3, _super);
                function JList$3(__parent, listData) {
                    _super.call(this);
                    this.listData = listData;
                    this.__parent = __parent;
                }
                JList$3.prototype.getSize = function () {
                    return this.listData.length;
                };
                JList$3.prototype.getElementAt = function (i) {
                    return this.listData[i];
                };
                return JList$3;
            }(javax.swing.AbstractListModel));
            JList.JList$3 = JList$3;
            var JList$4 = (function (_super) {
                __extends(JList$4, _super);
                function JList$4(__parent, listData) {
                    _super.call(this);
                    this.listData = listData;
                    this.__parent = __parent;
                }
                JList$4.prototype.getSize = function () {
                    return this.listData.size();
                };
                JList$4.prototype.getElementAt = function (i) {
                    return this.listData.elementAt(i);
                };
                return JList$4;
            }(javax.swing.AbstractListModel));
            JList.JList$4 = JList$4;
        })(JList = swing.JList || (swing.JList = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var JPanel = (function (_super) {
            __extends(JPanel, _super);
            /**
             * Creates a new JPanel with the specified layout manager and buffering
             * strategy.
             *
             * @param layout
             * the LayoutManager to use
             * @param isDoubleBuffered
             * a boolean, true for double-buffering, which uses additional
             * memory space to achieve fast, flicker-free updates
             */
            function JPanel(layout, isDoubleBuffered) {
                var _this = this;
                if (((layout != null && (layout["__interfaces"] != null && layout["__interfaces"].indexOf("java.awt.LayoutManager") >= 0 || layout.constructor != null && layout.constructor["__interfaces"] != null && layout.constructor["__interfaces"].indexOf("java.awt.LayoutManager") >= 0)) || layout === null) && ((typeof isDoubleBuffered === 'boolean') || isDoubleBuffered === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this);
                    (function () {
                        _this.setLayout(layout);
                    })();
                }
                else if (((layout != null && (layout["__interfaces"] != null && layout["__interfaces"].indexOf("java.awt.LayoutManager") >= 0 || layout.constructor != null && layout.constructor["__interfaces"] != null && layout.constructor["__interfaces"].indexOf("java.awt.LayoutManager") >= 0)) || layout === null) && isDoubleBuffered === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_54 = Array.prototype.slice.call(arguments);
                        var isDoubleBuffered_1 = true;
                        _super.call(this);
                        (function () {
                            _this.setLayout(layout);
                        })();
                    }
                }
                else if (((typeof layout === 'boolean') || layout === null) && isDoubleBuffered === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var isDoubleBuffered_2 = __args[0];
                    {
                        var __args_55 = Array.prototype.slice.call(arguments);
                        var layout_2 = new java.awt.FlowLayout();
                        _super.call(this);
                        (function () {
                            _this.setLayout(layout_2);
                        })();
                    }
                }
                else if (layout === undefined && isDoubleBuffered === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_56 = Array.prototype.slice.call(arguments);
                        var isDoubleBuffered_3 = true;
                        {
                            var __args_57 = Array.prototype.slice.call(arguments);
                            var layout_3 = new java.awt.FlowLayout();
                            _super.call(this);
                            (function () {
                                _this.setLayout(layout_3);
                            })();
                        }
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            JPanel.prototype.getGraphics = function () {
                return new java.awt.WebGraphics2D(this.htmlCanvas);
            };
            JPanel.prototype.createHTML = function () {
                if (this.htmlElement != null) {
                    return;
                }
                this.htmlElement = document.createElement("div");
            };
            JPanel.prototype.setBackground = function (background) {
                _super.prototype.setBackground.call(this, background);
                if (this.htmlElement != null) {
                    this.htmlElement.style.backgroundColor = null;
                }
                if (this.htmlCanvas != null) {
                    if (background != null) {
                        this.htmlCanvas.style.backgroundColor = background.toHTML();
                    }
                }
            };
            JPanel.prototype.doPaintInternal = function () {
                if (this.htmlCanvas.width === 0 && this.htmlCanvas.height === 0) {
                    this.htmlCanvas.width = this.htmlElement.offsetWidth;
                    this.htmlCanvas.height = this.htmlElement.offsetHeight;
                }
                _super.prototype.doPaintInternal.call(this);
            };
            JPanel.prototype.initHTML = function () {
                var _this = this;
                _super.prototype.initHTML.call(this);
                console.info("INIT JPANEL");
                if (this.htmlCanvas == null) {
                    this.htmlCanvas = document.createElement("canvas");
                    this.htmlElement.appendChild(this.htmlCanvas);
                    window.onresize = function (e) {
                        console.info("resizing");
                        _this.htmlCanvas.width = _this.htmlElement.offsetWidth;
                        _this.htmlCanvas.height = _this.htmlElement.offsetHeight;
                        _this.repaint();
                        return e;
                    };
                }
                if (this.getBackground() != null) {
                    this.htmlElement.style.backgroundColor = null;
                    this.htmlCanvas.style.backgroundColor = this.getBackground().toHTML();
                }
                this.htmlCanvas.width = this.htmlElement.offsetWidth;
                this.htmlCanvas.height = this.htmlElement.offsetHeight;
                this.htmlCanvas.style.position = "absolute";
            };
            /**
             * Returns a string that specifies the name of the L&amp;F class that
             * renders this component.
             *
             * @return "PanelUI"
             * @see JComponent#getUIClassID
             * @see UIDefaults#getUI
             * @beaninfo expert: true description: A string that specifies the name of
             * the L&amp;F class.
             */
            JPanel.prototype.getUIClassID = function () {
                return JPanel.uiClassID;
            };
            JPanel.prototype.paramString = function () {
                return _super.prototype.paramString.call(this);
            };
            /**
             * @see #getUIClassID
             * @see #readObject
             */
            JPanel.uiClassID = "PanelUI";
            return JPanel;
        }(javax.swing.JComponent));
        swing.JPanel = JPanel;
        JPanel["__class"] = "javax.swing.JPanel";
        JPanel["__interfaces"] = ["java.awt.HTMLComponent", "java.io.Serializable"];
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var JRootPane = (function (_super) {
            __extends(JRootPane, _super);
            /**
             * Creates a <code>JRootPane</code>, setting up its <code>glassPane</code>,
             * <code>layeredPane</code>, and <code>contentPane</code>.
             */
            function JRootPane() {
                _super.call(this);
                this.windowDecorationStyle = 0;
                this.setLayout(new java.awt.NoLayout());
                this.setContentPane(this.createContentPane());
            }
            JRootPane.prototype.createHTML = function () {
                if (this.htmlElement != null) {
                    return;
                }
                this.htmlElement = document.createElement("div");
            };
            /**
             * Returns a constant identifying the type of Window decorations the
             * <code>JRootPane</code> is providing.
             *
             * @return One of <code>NONE</code>, <code>FRAME</code>,
             * <code>PLAIN_DIALOG</code>, <code>INFORMATION_DIALOG</code>,
             * <code>ERROR_DIALOG</code>, <code>COLOR_CHOOSER_DIALOG</code>,
             * <code>FILE_CHOOSER_DIALOG</code>, <code>QUESTION_DIALOG</code> or
             * <code>WARNING_DIALOG</code>.
             * @see #setWindowDecorationStyle
             * @since 1.4
             */
            JRootPane.prototype.getWindowDecorationStyle = function () {
                return this.windowDecorationStyle;
            };
            JRootPane.prototype.setWindowDecorationStyle = function (windowDecorationStyle) {
                if (windowDecorationStyle < 0 || windowDecorationStyle > JRootPane.WARNING_DIALOG) {
                    throw new java.lang.IllegalArgumentException("Invalid decoration style");
                }
                var oldWindowDecorationStyle = this.getWindowDecorationStyle();
                this.windowDecorationStyle = windowDecorationStyle;
                this.firePropertyChange("windowDecorationStyle", oldWindowDecorationStyle, windowDecorationStyle);
            };
            /**
             * Returns a string that specifies the name of the L&amp;F class that
             * renders this component.
             *
             * @return the string "RootPaneUI"
             *
             * @see JComponent#getUIClassID
             * @see UIDefaults#getUI
             */
            JRootPane.prototype.getUIClassID = function () {
                return JRootPane.uiClassID;
            };
            JRootPane.prototype.createContentPane = function () {
                var c = new javax.swing.JPanel();
                c.setName(this.getName() + ".contentPane");
                c.setLayout(new java.awt.BorderLayout());
                return c;
            };
            /**
             * Sets the content pane -- the container that holds the components parented
             * by the root pane.
             * <p>
             * Swing's painting architecture requires an opaque <code>JComponent</code>
             * in the containment hierarchy. This is typically provided by the content
             * pane. If you replace the content pane it is recommended you replace it
             * with an opaque <code>JComponent</code>.
             *
             * @param content
             * the <code>Container</code> to use for component-contents
             * @exception java.awt.IllegalComponentStateException
             * (a runtime exception) if the content pane parameter is
             * <code>null</code>
             */
            JRootPane.prototype.setContentPane = function (content) {
                if (content == null)
                    throw new java.awt.IllegalComponentStateException("contentPane cannot be set to null.");
                this.contentPane = content;
                this.add(this.contentPane);
            };
            /**
             * Returns the content pane -- the container that holds the components
             * parented by the root pane.
             *
             * @return the <code>Container</code> that holds the component-contents
             */
            JRootPane.prototype.getContentPane = function () {
                return this.contentPane;
            };
            /**
             * Sets the <code>defaultButton</code> property, which determines the
             * current default button for this <code>JRootPane</code>. The default
             * button is the button which will be activated when a UI-defined activation
             * event (typically the <b>Enter</b> key) occurs in the root pane regardless
             * of whether or not the button has keyboard focus (unless there is another
             * component within the root pane which consumes the activation event, such
             * as a <code>JTextPane</code>). For default activation to work, the button
             * must be an enabled descendent of the root pane when activation occurs. To
             * remove a default button from this root pane, set this property to
             * <code>null</code>.
             *
             * @see JButton#isDefaultButton
             * @param defaultButton
             * the <code>JButton</code> which is to be the default button
             *
             * @beaninfo description: The button activated by default in this root pane
             */
            JRootPane.prototype.setDefaultButton = function (defaultButton) {
                var oldDefault = this.defaultButton;
                if (oldDefault !== defaultButton) {
                    this.defaultButton = defaultButton;
                    if (oldDefault != null) {
                        oldDefault.repaint();
                    }
                    if (defaultButton != null) {
                        defaultButton.repaint();
                    }
                }
                this.firePropertyChange("defaultButton", oldDefault, defaultButton);
            };
            /**
             * Returns the value of the <code>defaultButton</code> property.
             *
             * @return the <code>JButton</code> which is currently the default button
             * @see #setDefaultButton
             */
            JRootPane.prototype.getDefaultButton = function () {
                return this.defaultButton;
            };
            JRootPane.uiClassID = "RootPaneUI";
            /**
             * Constant used for the windowDecorationStyle property. Indicates that the
             * <code>JRootPane</code> should not provide any sort of Window decorations.
             *
             * @since 1.4
             */
            JRootPane.NONE = 0;
            /**
             * Constant used for the windowDecorationStyle property. Indicates that the
             * <code>JRootPane</code> should provide decorations appropriate for a
             * Frame.
             *
             * @since 1.4
             */
            JRootPane.FRAME = 1;
            /**
             * Constant used for the windowDecorationStyle property. Indicates that the
             * <code>JRootPane</code> should provide decorations appropriate for a
             * Dialog.
             *
             * @since 1.4
             */
            JRootPane.PLAIN_DIALOG = 2;
            /**
             * Constant used for the windowDecorationStyle property. Indicates that the
             * <code>JRootPane</code> should provide decorations appropriate for a
             * Dialog used to display an informational message.
             *
             * @since 1.4
             */
            JRootPane.INFORMATION_DIALOG = 3;
            /**
             * Constant used for the windowDecorationStyle property. Indicates that the
             * <code>JRootPane</code> should provide decorations appropriate for a
             * Dialog used to display an error message.
             *
             * @since 1.4
             */
            JRootPane.ERROR_DIALOG = 4;
            /**
             * Constant used for the windowDecorationStyle property. Indicates that the
             * <code>JRootPane</code> should provide decorations appropriate for a
             * Dialog used to display a <code>JColorChooser</code>.
             *
             * @since 1.4
             */
            JRootPane.COLOR_CHOOSER_DIALOG = 5;
            /**
             * Constant used for the windowDecorationStyle property. Indicates that the
             * <code>JRootPane</code> should provide decorations appropriate for a
             * Dialog used to display a <code>JFileChooser</code>.
             *
             * @since 1.4
             */
            JRootPane.FILE_CHOOSER_DIALOG = 6;
            /**
             * Constant used for the windowDecorationStyle property. Indicates that the
             * <code>JRootPane</code> should provide decorations appropriate for a
             * Dialog used to present a question to the user.
             *
             * @since 1.4
             */
            JRootPane.QUESTION_DIALOG = 7;
            /**
             * Constant used for the windowDecorationStyle property. Indicates that the
             * <code>JRootPane</code> should provide decorations appropriate for a
             * Dialog used to display a warning message.
             *
             * @since 1.4
             */
            JRootPane.WARNING_DIALOG = 8;
            return JRootPane;
        }(javax.swing.JComponent));
        swing.JRootPane = JRootPane;
        JRootPane["__class"] = "javax.swing.JRootPane";
        JRootPane["__interfaces"] = ["java.awt.HTMLComponent", "java.io.Serializable"];
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        /**
         * <code>JSeparator</code> provides a general purpose component for
         * implementing divider lines - most commonly used as a divider
         * between menu items that breaks them up into logical groupings.
         * Instead of using <code>JSeparator</code> directly,
         * you can use the <code>JMenu</code> or <code>JPopupMenu</code>
         * <code>addSeparator</code> method to create and add a separator.
         * <code>JSeparator</code>s may also be used elsewhere in a GUI
         * wherever a visual divider is useful.
         *
         * <p>
         *
         * For more information and examples see
         * <a
         * href="http://docs.oracle.com/javase/tutorial/uiswing/components/menu.html">How to Use Menus</a>,
         * a section in <em>The Java Tutorial.</em>
         * <p>
         * <strong>Warning:</strong> Swing is not thread safe. For more
         * information see <a
         * href="package-summary.html#threading">Swing's Threading
         * Policy</a>.
         * <p>
         * <strong>Warning:</strong>
         * Serialized objects of this class will not be compatible with
         * future Swing releases. The current serialization support is
         * appropriate for short term storage or RMI between applications running
         * the same version of Swing.  As of 1.4, support for long term storage
         * of all JavaBeans&trade;
         * has been added to the <code>java.beans</code> package.
         * Please see {@link java.beans.XMLEncoder}.
         *
         * @beaninfo
         * attribute: isContainer false
         * description: A divider between menu items.
         *
         * @author Georges Saab
         * @author Jeff Shapiro
         */
        var JSeparator = (function (_super) {
            __extends(JSeparator, _super);
            /**
             * Creates a new separator with the specified horizontal or
             * vertical orientation.
             *
             * @param orientation an integer specifying
             * <code>SwingConstants.HORIZONTAL</code> or
             * <code>SwingConstants.VERTICAL</code>
             * @exception IllegalArgumentException if <code>orientation</code>
             * is neither <code>SwingConstants.HORIZONTAL</code> nor
             * <code>SwingConstants.VERTICAL</code>
             */
            function JSeparator(orientation) {
                if (orientation === void 0) { orientation = javax.swing.SwingConstants.HORIZONTAL; }
                _super.call(this);
                this.orientation = javax.swing.SwingConstants.HORIZONTAL;
                this.checkOrientation(orientation);
                this.orientation = orientation;
            }
            JSeparator.prototype.createHTML = function () {
            };
            /**
             * Returns the name of the L&amp;F class that renders this component.
             *
             * @return the string "SeparatorUI"
             * @see JComponent#getUIClassID
             * @see UIDefaults#getUI
             */
            JSeparator.prototype.getUIClassID = function () {
                return JSeparator.uiClassID;
            };
            /**
             * Returns the orientation of this separator.
             *
             * @return   The value of the orientation property, one of the
             * following constants defined in <code>SwingConstants</code>:
             * <code>VERTICAL</code>, or
             * <code>HORIZONTAL</code>.
             *
             * @see SwingConstants
             * @see #setOrientation
             */
            JSeparator.prototype.getOrientation = function () {
                return this.orientation;
            };
            /**
             * Sets the orientation of the separator.
             * The default value of this property is HORIZONTAL.
             * @param orientation  either <code>SwingConstants.HORIZONTAL</code>
             * or <code>SwingConstants.VERTICAL</code>
             * @exception IllegalArgumentException  if <code>orientation</code>
             * is neither <code>SwingConstants.HORIZONTAL</code>
             * nor <code>SwingConstants.VERTICAL</code>
             *
             * @see SwingConstants
             * @see #getOrientation
             * @beaninfo
             * bound: true
             * preferred: true
             * enum: HORIZONTAL SwingConstants.HORIZONTAL
             * VERTICAL   SwingConstants.VERTICAL
             * attribute: visualUpdate true
             * description: The orientation of the separator.
             */
            JSeparator.prototype.setOrientation = function (orientation) {
                if (this.orientation === orientation) {
                    return;
                }
                var oldValue = this.orientation;
                this.checkOrientation(orientation);
                this.orientation = orientation;
                this.firePropertyChange("orientation", oldValue, orientation);
                this.revalidate();
                this.repaint();
            };
            JSeparator.prototype.checkOrientation = function (orientation) {
                switch ((orientation)) {
                    case javax.swing.SwingConstants.VERTICAL:
                    case javax.swing.SwingConstants.HORIZONTAL:
                        break;
                    default:
                        throw new java.lang.IllegalArgumentException("orientation must be one of: VERTICAL, HORIZONTAL");
                }
            };
            /**
             * Returns a string representation of this <code>JSeparator</code>.
             * This method
             * is intended to be used only for debugging purposes, and the
             * content and format of the returned string may vary between
             * implementations. The returned string may be empty but may not
             * be <code>null</code>.
             *
             * @return  a string representation of this <code>JSeparator</code>
             */
            JSeparator.prototype.paramString = function () {
                var orientationString = (this.orientation === javax.swing.SwingConstants.HORIZONTAL ? "HORIZONTAL" : "VERTICAL");
                return _super.prototype.paramString.call(this) + ",orientation=" + orientationString;
            };
            /**
             * @see #getUIClassID
             * @see #readObject
             */
            JSeparator.uiClassID = "SeparatorUI";
            return JSeparator;
        }(javax.swing.JComponent));
        swing.JSeparator = JSeparator;
        JSeparator["__class"] = "javax.swing.JSeparator";
        JSeparator["__interfaces"] = ["java.awt.HTMLComponent", "java.io.Serializable"];
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var JSlider = (function (_super) {
            __extends(JSlider, _super);
            function JSlider(orientation, min, max, value) {
                var _this = this;
                if (((typeof orientation === 'number') || orientation === null) && ((typeof min === 'number') || min === null) && ((typeof max === 'number') || max === null) && ((typeof value === 'number') || value === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this);
                    this.paintTicks = false;
                    this.paintTrack = true;
                    this.paintLabels = false;
                    this.isInverted = false;
                    this.snapToTicks = false;
                    this.snapToValue = true;
                    this.changeListener = this.createChangeListener();
                    this.changeEvent = null;
                    this.majorTickSpacing = 0;
                    this.minorTickSpacing = 0;
                    this.orientation = 0;
                    (function () {
                        _this.checkOrientation(orientation);
                        _this.orientation = orientation;
                        _this.setModel(new javax.swing.DefaultBoundedRangeModel(value, 0, min, max));
                    })();
                }
                else if (((typeof orientation === 'number') || orientation === null) && ((typeof min === 'number') || min === null) && ((typeof max === 'number') || max === null) && value === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var min_1 = __args[0];
                    var max_1 = __args[1];
                    var value_1 = __args[2];
                    {
                        var __args_58 = Array.prototype.slice.call(arguments);
                        var orientation_1 = javax.swing.SwingConstants.HORIZONTAL;
                        _super.call(this);
                        this.paintTicks = false;
                        this.paintTrack = true;
                        this.paintLabels = false;
                        this.isInverted = false;
                        this.snapToTicks = false;
                        this.snapToValue = true;
                        this.changeListener = this.createChangeListener();
                        this.changeEvent = null;
                        this.majorTickSpacing = 0;
                        this.minorTickSpacing = 0;
                        this.orientation = 0;
                        (function () {
                            _this.checkOrientation(orientation_1);
                            _this.orientation = orientation_1;
                            _this.setModel(new javax.swing.DefaultBoundedRangeModel(value_1, 0, min_1, max_1));
                        })();
                    }
                }
                else if (((typeof orientation === 'number') || orientation === null) && ((typeof min === 'number') || min === null) && max === undefined && value === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var min_2 = __args[0];
                    var max_2 = __args[1];
                    {
                        var __args_59 = Array.prototype.slice.call(arguments);
                        var orientation_2 = javax.swing.SwingConstants.HORIZONTAL;
                        var value_2 = ((__args_59[1] + __args_59[2]) / 2 | 0);
                        _super.call(this);
                        this.paintTicks = false;
                        this.paintTrack = true;
                        this.paintLabels = false;
                        this.isInverted = false;
                        this.snapToTicks = false;
                        this.snapToValue = true;
                        this.changeListener = this.createChangeListener();
                        this.changeEvent = null;
                        this.majorTickSpacing = 0;
                        this.minorTickSpacing = 0;
                        this.orientation = 0;
                        (function () {
                            _this.checkOrientation(orientation_2);
                            _this.orientation = orientation_2;
                            _this.setModel(new javax.swing.DefaultBoundedRangeModel(value_2, 0, min_2, max_2));
                        })();
                    }
                }
                else if (((orientation != null && (orientation["__interfaces"] != null && orientation["__interfaces"].indexOf("javax.swing.BoundedRangeModel") >= 0 || orientation.constructor != null && orientation.constructor["__interfaces"] != null && orientation.constructor["__interfaces"].indexOf("javax.swing.BoundedRangeModel") >= 0)) || orientation === null) && min === undefined && max === undefined && value === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var brm_1 = __args[0];
                    _super.call(this);
                    this.paintTicks = false;
                    this.paintTrack = true;
                    this.paintLabels = false;
                    this.isInverted = false;
                    this.snapToTicks = false;
                    this.snapToValue = true;
                    this.changeListener = this.createChangeListener();
                    this.changeEvent = null;
                    this.majorTickSpacing = 0;
                    this.minorTickSpacing = 0;
                    this.orientation = 0;
                    (function () {
                        _this.orientation = javax.swing.SwingConstants.HORIZONTAL;
                        _this.setModel(brm_1);
                    })();
                }
                else if (((typeof orientation === 'number') || orientation === null) && min === undefined && max === undefined && value === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_60 = Array.prototype.slice.call(arguments);
                        var min_3 = 0;
                        var max_3 = 100;
                        var value_3 = 50;
                        _super.call(this);
                        this.paintTicks = false;
                        this.paintTrack = true;
                        this.paintLabels = false;
                        this.isInverted = false;
                        this.snapToTicks = false;
                        this.snapToValue = true;
                        this.changeListener = this.createChangeListener();
                        this.changeEvent = null;
                        this.majorTickSpacing = 0;
                        this.minorTickSpacing = 0;
                        this.orientation = 0;
                        (function () {
                            _this.checkOrientation(orientation);
                            _this.orientation = orientation;
                            _this.setModel(new javax.swing.DefaultBoundedRangeModel(value_3, 0, min_3, max_3));
                        })();
                    }
                }
                else if (orientation === undefined && min === undefined && max === undefined && value === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_61 = Array.prototype.slice.call(arguments);
                        var orientation_3 = javax.swing.SwingConstants.HORIZONTAL;
                        var min_4 = 0;
                        var max_4 = 100;
                        var value_4 = 50;
                        _super.call(this);
                        this.paintTicks = false;
                        this.paintTrack = true;
                        this.paintLabels = false;
                        this.isInverted = false;
                        this.snapToTicks = false;
                        this.snapToValue = true;
                        this.changeListener = this.createChangeListener();
                        this.changeEvent = null;
                        this.majorTickSpacing = 0;
                        this.minorTickSpacing = 0;
                        this.orientation = 0;
                        (function () {
                            _this.checkOrientation(orientation_3);
                            _this.orientation = orientation_3;
                            _this.setModel(new javax.swing.DefaultBoundedRangeModel(value_4, 0, min_4, max_4));
                        })();
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            JSlider.prototype.getHTMLElement = function () {
                return _super.prototype.getHTMLElement.call(this);
            };
            JSlider.prototype.createHTML = function () {
                var _this = this;
                if (this.htmlElement != null) {
                    return;
                }
                this.htmlElement = document.createElement("input");
                this.getHTMLElement().type = "range";
                this.htmlElement.onchange = function (e) {
                    _this.setValue(javaemul.internal.IntegerHelper.parseInt(_this.getHTMLElement().value));
                    return null;
                };
            };
            JSlider.prototype.initHTML = function () {
                _super.prototype.initHTML.call(this);
                this.getHTMLElement().min = "" + this.getMinimum();
                this.getHTMLElement().max = "" + this.getMaximum();
                this.getHTMLElement().step = "" + this.getMajorTickSpacing();
                this.getHTMLElement().value = "" + this.getValue();
                try {
                    if (this.getHTMLElement().hasAttribute("orient")) {
                        this.getHTMLElement().setAttribute("orient", this.getOrientation() === javax.swing.SwingConstants.VERTICAL ? "vertical" : "horizontal");
                    }
                    if (this.getHTMLElement().hasAttribute("-webkit-appearance")) {
                        this.getHTMLElement().setAttribute("-webkit-appearance", this.getOrientation() === javax.swing.SwingConstants.VERTICAL ? "slider-vertical" : "slider-horizontal");
                    }
                    if (this.getHTMLElement().hasAttribute("writing-mode")) {
                        this.getHTMLElement().setAttribute("writing-mode", this.getOrientation() === javax.swing.SwingConstants.VERTICAL ? "bt-lr" : null);
                    }
                }
                catch (e) {
                    console.info("cannot apply orientation");
                }
                ;
            };
            JSlider.prototype.checkOrientation = function (orientation) {
                switch ((orientation)) {
                    case javax.swing.SwingConstants.VERTICAL:
                    case javax.swing.SwingConstants.HORIZONTAL:
                        break;
                    default:
                        throw new java.lang.IllegalArgumentException("orientation must be one of: VERTICAL, HORIZONTAL");
                }
            };
            JSlider.prototype.getUIClassID = function () {
                return JSlider.uiClassID;
            };
            JSlider.prototype.createChangeListener = function () {
                return new JSlider.ModelListener(this);
            };
            JSlider.prototype.addChangeListener = function (l) {
                this.listenerList.add("javax.swing.event.ChangeListener", l);
            };
            JSlider.prototype.removeChangeListener = function (l) {
                this.listenerList.remove("javax.swing.event.ChangeListener", l);
            };
            JSlider.prototype.getChangeListeners = function () {
                return this.listenerList.getListeners("javax.swing.event.ChangeListener");
            };
            JSlider.prototype.fireStateChanged = function () {
                var listeners = this.listenerList.getListenerList();
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "javax.swing.event.ChangeListener") {
                        if (this.changeEvent == null) {
                            this.changeEvent = new javax.swing.event.ChangeEvent(this);
                        }
                        listeners[i + 1].stateChanged(this.changeEvent);
                    }
                }
            };
            JSlider.prototype.getModel = function () {
                return this.sliderModel;
            };
            JSlider.prototype.setModel = function (newModel) {
                var oldModel = this.getModel();
                if (oldModel != null) {
                    oldModel.removeChangeListener(this.changeListener);
                }
                this.sliderModel = newModel;
                if (newModel != null) {
                    newModel.addChangeListener(this.changeListener);
                }
                if (this.htmlElement != null) {
                    this.initHTML();
                }
                this.firePropertyChange("model", oldModel, this.sliderModel);
            };
            JSlider.prototype.getValue = function () {
                return this.getModel().getValue();
            };
            JSlider.prototype.setValue = function (n) {
                var m = this.getModel();
                var oldValue = m.getValue();
                if (oldValue === n) {
                    return;
                }
                m.setValue(n);
            };
            JSlider.prototype.getMinimum = function () {
                return this.getModel().getMinimum();
            };
            JSlider.prototype.setMinimum = function (minimum) {
                var oldMin = this.getModel().getMinimum();
                this.getModel().setMinimum(minimum);
                if (this.htmlElement != null) {
                    this.initHTML();
                }
                this.firePropertyChange("minimum", javaemul.internal.IntegerHelper.valueOf(oldMin), javaemul.internal.IntegerHelper.valueOf(minimum));
            };
            JSlider.prototype.getMaximum = function () {
                return this.getModel().getMaximum();
            };
            JSlider.prototype.setMaximum = function (maximum) {
                var oldMax = this.getModel().getMaximum();
                this.getModel().setMaximum(maximum);
                if (this.htmlElement != null) {
                    this.initHTML();
                }
                this.firePropertyChange("maximum", javaemul.internal.IntegerHelper.valueOf(oldMax), javaemul.internal.IntegerHelper.valueOf(maximum));
            };
            JSlider.prototype.getValueIsAdjusting = function () {
                return this.getModel().getValueIsAdjusting();
            };
            JSlider.prototype.setValueIsAdjusting = function (b) {
                var m = this.getModel();
                m.setValueIsAdjusting(b);
            };
            JSlider.prototype.getExtent = function () {
                return this.getModel().getExtent();
            };
            JSlider.prototype.setExtent = function (extent) {
                this.getModel().setExtent(extent);
            };
            /**
             * Return this slider's vertical or horizontal orientation.
             *
             * @return {@code SwingConstants.VERTICAL} or
             * {@code SwingConstants.HORIZONTAL}
             * @see #setOrientation
             */
            JSlider.prototype.getOrientation = function () {
                return this.orientation;
            };
            JSlider.prototype.setOrientation = function (orientation) {
                this.checkOrientation(orientation);
                var oldValue = this.orientation;
                this.orientation = orientation;
                this.firePropertyChange("orientation", oldValue, orientation);
                if (orientation !== oldValue) {
                    if (this.htmlElement != null) {
                        this.initHTML();
                    }
                }
            };
            /**
             * {@inheritDoc}
             *
             * @since 1.6
             */
            JSlider.prototype.setFont = function (font) {
                _super.prototype.setFont.call(this, font);
            };
            /**
             * This method returns the major tick spacing. The number that is returned
             * represents the distance, measured in values, between each major tick
             * mark. If you have a slider with a range from 0 to 50 and the major tick
             * spacing is set to 10, you will get major ticks next to the following
             * values: 0, 10, 20, 30, 40, 50.
             *
             * @return the number of values between major ticks
             * @see #setMajorTickSpacing
             */
            JSlider.prototype.getMajorTickSpacing = function () {
                return this.majorTickSpacing;
            };
            JSlider.prototype.setMajorTickSpacing = function (n) {
                var oldValue = this.majorTickSpacing;
                this.majorTickSpacing = n;
                this.firePropertyChange("majorTickSpacing", oldValue, this.majorTickSpacing);
                if (this.htmlElement != null) {
                    this.initHTML();
                }
            };
            JSlider.prototype.getMinorTickSpacing = function () {
                return this.minorTickSpacing;
            };
            JSlider.prototype.setMinorTickSpacing = function (n) {
                var oldValue = this.minorTickSpacing;
                this.minorTickSpacing = n;
                this.firePropertyChange("minorTickSpacing", oldValue, this.minorTickSpacing);
                if (this.htmlElement != null) {
                    this.initHTML();
                }
            };
            JSlider.prototype.getSnapToTicks = function () {
                return this.snapToTicks;
            };
            JSlider.prototype.getSnapToValue = function () {
                return this.snapToValue;
            };
            JSlider.prototype.setSnapToTicks = function (b) {
                var oldValue = this.snapToTicks;
                this.snapToTicks = b;
                this.firePropertyChange("snapToTicks", oldValue, this.snapToTicks);
            };
            JSlider.prototype.setSnapToValue = function (b) {
                var oldValue = this.snapToValue;
                this.snapToValue = b;
                this.firePropertyChange("snapToValue", oldValue, this.snapToValue);
            };
            JSlider.prototype.getPaintTicks = function () {
                return this.paintTicks;
            };
            JSlider.prototype.setPaintTicks = function (b) {
                var oldValue = this.paintTicks;
                this.paintTicks = b;
                this.firePropertyChange("paintTicks", oldValue, this.paintTicks);
                if (this.paintTicks !== oldValue) {
                    this.revalidate();
                    this.repaint();
                }
            };
            JSlider.prototype.getPaintTrack = function () {
                return this.paintTrack;
            };
            JSlider.prototype.setPaintTrack = function (b) {
                var oldValue = this.paintTrack;
                this.paintTrack = b;
                this.firePropertyChange("paintTrack", oldValue, this.paintTrack);
                if (this.paintTrack !== oldValue) {
                    this.repaint();
                }
            };
            JSlider.prototype.getPaintLabels = function () {
                return this.paintLabels;
            };
            JSlider.prototype.setPaintLabels = function (b) {
                var oldValue = this.paintLabels;
                this.paintLabels = b;
                this.firePropertyChange("paintLabels", oldValue, this.paintLabels);
                if (this.paintLabels !== oldValue) {
                    this.revalidate();
                    this.repaint();
                }
            };
            /**
             * Returns a string representation of this JSlider. This method is intended
             * to be used only for debugging purposes, and the content and format of the
             * returned string may vary between implementations. The returned string may
             * be empty but may not be <code>null</code>.
             *
             * @return a string representation of this JSlider.
             */
            JSlider.prototype.paramString = function () {
                var paintTicksString = (this.paintTicks ? "true" : "false");
                var paintTrackString = (this.paintTrack ? "true" : "false");
                var paintLabelsString = (this.paintLabels ? "true" : "false");
                var isInvertedString = (this.isInverted ? "true" : "false");
                var snapToTicksString = (this.snapToTicks ? "true" : "false");
                var snapToValueString = (this.snapToValue ? "true" : "false");
                var orientationString = (this.orientation === javax.swing.SwingConstants.HORIZONTAL ? "HORIZONTAL" : "VERTICAL");
                return _super.prototype.paramString.call(this) + ",isInverted=" + isInvertedString + ",majorTickSpacing=" + this.majorTickSpacing + ",minorTickSpacing=" + this.minorTickSpacing + ",orientation=" + orientationString + ",paintLabels=" + paintLabelsString + ",paintTicks=" + paintTicksString + ",paintTrack=" + paintTrackString + ",snapToTicks=" + snapToTicksString + ",snapToValue=" + snapToValueString;
            };
            /**
             * @see #getUIClassID
             * @see #readObject
             */
            JSlider.uiClassID = "SliderUI";
            return JSlider;
        }(javax.swing.JComponent));
        swing.JSlider = JSlider;
        JSlider["__class"] = "javax.swing.JSlider";
        JSlider["__interfaces"] = ["java.awt.HTMLComponent", "javax.swing.SwingConstants", "java.io.Serializable"];
        var JSlider;
        (function (JSlider) {
            var ModelListener = (function () {
                function ModelListener(__parent) {
                    this.__parent = __parent;
                }
                ModelListener.prototype.stateChanged = function (e) {
                    this.__parent.fireStateChanged();
                };
                return ModelListener;
            }());
            JSlider.ModelListener = ModelListener;
            ModelListener["__class"] = "javax.swing.JSlider.ModelListener";
            ModelListener["__interfaces"] = ["java.util.EventListener", "javax.swing.event.ChangeListener", "java.io.Serializable"];
        })(JSlider = swing.JSlider || (swing.JSlider = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var text;
        (function (text_6) {
            var JTextComponent = (function (_super) {
                __extends(JTextComponent, _super);
                function JTextComponent() {
                    _super.call(this);
                    this.text = "";
                    this.editable = true;
                }
                JTextComponent.prototype.getText = function () {
                    return this.text;
                };
                JTextComponent.prototype.setText = function (text) {
                    this.text = text;
                };
                JTextComponent.prototype.isEditable = function () {
                    return this.editable;
                };
                JTextComponent.prototype.setEditable = function (editable) {
                    this.editable = editable;
                };
                return JTextComponent;
            }(javax.swing.JComponent));
            text_6.JTextComponent = JTextComponent;
            JTextComponent["__class"] = "javax.swing.text.JTextComponent";
            JTextComponent["__interfaces"] = ["java.awt.HTMLComponent", "java.io.Serializable"];
        })(text = swing.text || (swing.text = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var event;
        (function (event) {
            /**
             * MenuKeyEvent is used to notify interested parties that
             * the menu element has received a KeyEvent forwarded to it
             * in a menu tree.
             * <p>
             * <strong>Warning:</strong>
             * Serialized objects of this class will not be compatible with
             * future Swing releases. The current serialization support is
             * appropriate for short term storage or RMI between applications running
             * the same version of Swing.  As of 1.4, support for long term storage
             * of all JavaBeans&trade;
             * has been added to the <code>java.beans</code> package.
             * Please see {@link java.beans.XMLEncoder}.
             *
             * @author Georges Saab
             */
            var MenuKeyEvent = (function (_super) {
                __extends(MenuKeyEvent, _super);
                /**
                 * Constructs a MenuKeyEvent object.
                 *
                 * @param source     the Component that originated the event
                 * (typically <code>this</code>)
                 * @param id         an int specifying the type of event, as defined
                 * in {@link java.awt.event.KeyEvent}
                 * @param when       a long identifying the time the event occurred
                 * @param modifiers     an int specifying any modifier keys held down,
                 * as specified in {@link java.awt.event.InputEvent}
                 * @param keyCode    an int specifying the specific key that was pressed
                 * @param keyChar    a char specifying the key's character value, if any
                 * -- null if the key has no character value
                 * @param p          an array of MenuElement objects specifying a path
                 * to a menu item affected by the drag
                 * @param m          a MenuSelectionManager object that handles selections
                 */
                function MenuKeyEvent(source, id, when, modifiers, keyCode, keyChar, p, m) {
                    _super.call(this, source, id, when, modifiers, keyCode, keyChar);
                    this.path = p;
                    this.manager = m;
                }
                /**
                 * Returns the path to the menu item referenced by this event.
                 *
                 * @return an array of MenuElement objects representing the path value
                 */
                MenuKeyEvent.prototype.getPath = function () {
                    return this.path;
                };
                /**
                 * Returns the current menu selection manager.
                 *
                 * @return a MenuSelectionManager object
                 */
                MenuKeyEvent.prototype.getMenuSelectionManager = function () {
                    return this.manager;
                };
                return MenuKeyEvent;
            }(java.awt.event.KeyEvent));
            event.MenuKeyEvent = MenuKeyEvent;
            MenuKeyEvent["__class"] = "javax.swing.event.MenuKeyEvent";
            MenuKeyEvent["__interfaces"] = ["java.io.Serializable"];
        })(event = swing.event || (swing.event = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var sun;
(function (sun) {
    var awt;
    (function (awt) {
        var ExtendedKeyCodes = (function () {
            function ExtendedKeyCodes() {
            }
            ExtendedKeyCodes.__static_initialize = function () { if (!ExtendedKeyCodes.__static_initialized) {
                ExtendedKeyCodes.__static_initialized = true;
                ExtendedKeyCodes.__static_initializer_0();
            } };
            ExtendedKeyCodes.regularKeyCodesMap_$LI$ = function () { ExtendedKeyCodes.__static_initialize(); if (ExtendedKeyCodes.regularKeyCodesMap == null)
                ExtendedKeyCodes.regularKeyCodesMap = new java.util.HashMap(98, 1.0); return ExtendedKeyCodes.regularKeyCodesMap; };
            ;
            ExtendedKeyCodes.extendedKeyCodesSet_$LI$ = function () { ExtendedKeyCodes.__static_initialize(); if (ExtendedKeyCodes.extendedKeyCodesSet == null)
                ExtendedKeyCodes.extendedKeyCodesSet = new java.util.HashSet(501, 1.0); return ExtendedKeyCodes.extendedKeyCodesSet; };
            ;
            ExtendedKeyCodes.getExtendedKeyCodeForChar = function (c) {
                var uc = javaemul.internal.CharacterHelper.toUpperCase(c);
                var lc = javaemul.internal.CharacterHelper.toLowerCase(c);
                if (ExtendedKeyCodes.regularKeyCodesMap_$LI$().containsKey(c)) {
                    if (ExtendedKeyCodes.regularKeyCodesMap_$LI$().containsKey(uc)) {
                        return ExtendedKeyCodes.regularKeyCodesMap_$LI$().get(uc);
                    }
                    return ExtendedKeyCodes.regularKeyCodesMap_$LI$().get(c);
                }
                uc += 16777216;
                lc += 16777216;
                if (ExtendedKeyCodes.extendedKeyCodesSet_$LI$().contains(uc)) {
                    return uc;
                }
                else if (ExtendedKeyCodes.extendedKeyCodesSet_$LI$().contains(lc)) {
                    return lc;
                }
                return java.awt.event.KeyEvent.VK_UNDEFINED;
            };
            ExtendedKeyCodes.__static_initializer_0 = function () {
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(8, java.awt.event.KeyEvent.VK_BACK_SPACE);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(9, java.awt.event.KeyEvent.VK_TAB);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(10, java.awt.event.KeyEvent.VK_ENTER);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(27, java.awt.event.KeyEvent.VK_ESCAPE);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(8364, java.awt.event.KeyEvent.VK_EURO_SIGN);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(32, java.awt.event.KeyEvent.VK_SPACE);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(33, java.awt.event.KeyEvent.VK_EXCLAMATION_MARK);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(34, java.awt.event.KeyEvent.VK_QUOTEDBL);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(35, java.awt.event.KeyEvent.VK_NUMBER_SIGN);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(36, java.awt.event.KeyEvent.VK_DOLLAR);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(38, java.awt.event.KeyEvent.VK_AMPERSAND);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(39, java.awt.event.KeyEvent.VK_QUOTE);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(40, java.awt.event.KeyEvent.VK_LEFT_PARENTHESIS);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(41, java.awt.event.KeyEvent.VK_RIGHT_PARENTHESIS);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(42, java.awt.event.KeyEvent.VK_ASTERISK);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(43, java.awt.event.KeyEvent.VK_PLUS);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(44, java.awt.event.KeyEvent.VK_COMMA);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(45, java.awt.event.KeyEvent.VK_MINUS);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(46, java.awt.event.KeyEvent.VK_PERIOD);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(47, java.awt.event.KeyEvent.VK_SLASH);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(48, java.awt.event.KeyEvent.VK_0);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(49, java.awt.event.KeyEvent.VK_1);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(50, java.awt.event.KeyEvent.VK_2);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(51, java.awt.event.KeyEvent.VK_3);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(52, java.awt.event.KeyEvent.VK_4);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(53, java.awt.event.KeyEvent.VK_5);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(54, java.awt.event.KeyEvent.VK_6);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(55, java.awt.event.KeyEvent.VK_7);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(56, java.awt.event.KeyEvent.VK_8);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(57, java.awt.event.KeyEvent.VK_9);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(58, java.awt.event.KeyEvent.VK_COLON);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(59, java.awt.event.KeyEvent.VK_SEMICOLON);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(60, java.awt.event.KeyEvent.VK_LESS);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(61, java.awt.event.KeyEvent.VK_EQUALS);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(62, java.awt.event.KeyEvent.VK_GREATER);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(64, java.awt.event.KeyEvent.VK_AT);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(65, java.awt.event.KeyEvent.VK_A);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(66, java.awt.event.KeyEvent.VK_B);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(67, java.awt.event.KeyEvent.VK_C);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(68, java.awt.event.KeyEvent.VK_D);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(69, java.awt.event.KeyEvent.VK_E);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(70, java.awt.event.KeyEvent.VK_F);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(71, java.awt.event.KeyEvent.VK_G);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(72, java.awt.event.KeyEvent.VK_H);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(73, java.awt.event.KeyEvent.VK_I);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(74, java.awt.event.KeyEvent.VK_J);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(75, java.awt.event.KeyEvent.VK_K);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(76, java.awt.event.KeyEvent.VK_L);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(77, java.awt.event.KeyEvent.VK_M);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(78, java.awt.event.KeyEvent.VK_N);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(79, java.awt.event.KeyEvent.VK_O);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(80, java.awt.event.KeyEvent.VK_P);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(81, java.awt.event.KeyEvent.VK_Q);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(82, java.awt.event.KeyEvent.VK_R);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(83, java.awt.event.KeyEvent.VK_S);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(84, java.awt.event.KeyEvent.VK_T);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(85, java.awt.event.KeyEvent.VK_U);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(86, java.awt.event.KeyEvent.VK_V);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(87, java.awt.event.KeyEvent.VK_W);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(88, java.awt.event.KeyEvent.VK_X);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(89, java.awt.event.KeyEvent.VK_Y);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(90, java.awt.event.KeyEvent.VK_Z);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(91, java.awt.event.KeyEvent.VK_OPEN_BRACKET);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(92, java.awt.event.KeyEvent.VK_BACK_SLASH);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(93, java.awt.event.KeyEvent.VK_CLOSE_BRACKET);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(94, java.awt.event.KeyEvent.VK_CIRCUMFLEX);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(95, java.awt.event.KeyEvent.VK_UNDERSCORE);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(96, java.awt.event.KeyEvent.VK_BACK_QUOTE);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(97, java.awt.event.KeyEvent.VK_A);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(98, java.awt.event.KeyEvent.VK_B);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(99, java.awt.event.KeyEvent.VK_C);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(100, java.awt.event.KeyEvent.VK_D);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(101, java.awt.event.KeyEvent.VK_E);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(102, java.awt.event.KeyEvent.VK_F);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(103, java.awt.event.KeyEvent.VK_G);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(104, java.awt.event.KeyEvent.VK_H);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(105, java.awt.event.KeyEvent.VK_I);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(106, java.awt.event.KeyEvent.VK_J);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(107, java.awt.event.KeyEvent.VK_K);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(108, java.awt.event.KeyEvent.VK_L);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(109, java.awt.event.KeyEvent.VK_M);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(110, java.awt.event.KeyEvent.VK_N);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(111, java.awt.event.KeyEvent.VK_O);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(112, java.awt.event.KeyEvent.VK_P);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(113, java.awt.event.KeyEvent.VK_Q);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(114, java.awt.event.KeyEvent.VK_R);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(115, java.awt.event.KeyEvent.VK_S);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(116, java.awt.event.KeyEvent.VK_T);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(117, java.awt.event.KeyEvent.VK_U);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(118, java.awt.event.KeyEvent.VK_V);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(119, java.awt.event.KeyEvent.VK_W);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(120, java.awt.event.KeyEvent.VK_X);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(121, java.awt.event.KeyEvent.VK_Y);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(122, java.awt.event.KeyEvent.VK_Z);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(123, java.awt.event.KeyEvent.VK_BRACELEFT);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(125, java.awt.event.KeyEvent.VK_BRACERIGHT);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(127, java.awt.event.KeyEvent.VK_DELETE);
                ExtendedKeyCodes.regularKeyCodesMap_$LI$().put(161, java.awt.event.KeyEvent.VK_INVERTED_EXCLAMATION_MARK);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 96);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 124);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 126);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 162);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 163);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 165);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 167);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 168);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 171);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 176);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 177);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 178);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 179);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 180);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 181);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 182);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 183);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 185);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 186);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 187);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 188);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 189);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 190);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 191);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 196);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 197);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 198);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 199);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 209);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 214);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 215);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 216);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 223);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 224);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 225);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 226);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 228);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 229);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 230);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 231);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 232);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 233);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 234);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 235);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 236);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 237);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 238);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 240);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 241);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 242);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 243);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 244);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 245);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 246);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 247);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 248);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 249);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 250);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 251);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 252);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 253);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 254);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 261);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 731);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 322);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 318);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 347);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 353);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 351);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 357);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 382);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 380);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 259);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 263);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 269);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 281);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 283);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 273);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 328);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 337);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 369);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 345);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 367);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 355);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 729);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 304);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 295);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 293);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 305);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 287);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 309);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 267);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 265);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 289);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 285);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 365);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 349);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 312);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 343);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 316);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 275);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 291);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 359);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 331);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 257);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 303);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 279);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 299);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 326);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 333);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 311);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 371);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 363);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 339);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12540);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12450);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12452);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12454);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12456);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12458);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12459);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12461);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12463);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12465);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12467);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12469);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12471);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12473);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12475);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12477);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12479);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12481);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12484);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12486);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12488);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12490);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12491);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12492);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12493);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12494);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12495);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12498);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12501);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12504);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12507);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12510);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12511);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12512);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12513);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12514);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12516);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12518);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12520);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12521);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12522);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12523);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12524);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12525);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12527);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12531);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12443);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 12444);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1776);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1777);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1778);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1779);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1780);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1781);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1782);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1783);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1784);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1785);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1648);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1662);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1670);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1548);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1748);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1632);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1633);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1634);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1635);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1636);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1637);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1638);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1639);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1640);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1641);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1563);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1569);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1572);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1574);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1575);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1576);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1577);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1578);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1579);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1580);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1581);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1582);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1583);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1584);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1585);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1586);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1587);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1588);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1589);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1590);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1591);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1592);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1593);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1594);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1601);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1602);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1603);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1604);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1605);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1606);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1607);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1608);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1609);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1610);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1614);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1615);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1616);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1618);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1688);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1700);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1705);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1711);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1726);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1740);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1740);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1746);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1171);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1175);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1179);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1181);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1187);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1199);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1201);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1203);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1209);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1211);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1241);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1257);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1106);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1107);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1105);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1108);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1109);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1110);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1111);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1112);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1113);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1114);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1115);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1116);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1169);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1118);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1119);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 8470);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1102);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1072);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1073);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1094);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1076);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1077);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1092);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1075);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1093);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1080);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1081);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1082);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1083);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1084);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1085);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1086);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1087);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1103);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1088);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1089);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1090);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1091);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1078);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1074);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1100);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1099);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1079);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1096);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1101);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1097);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1095);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1098);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 8213);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 945);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 946);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 947);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 948);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 949);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 950);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 951);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 952);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 953);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 954);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 955);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 956);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 957);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 958);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 959);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 960);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 961);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 963);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 962);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 964);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 965);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 966);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 967);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 968);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 969);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 8592);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 8594);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 8595);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 8211);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 8220);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 8221);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 8222);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1488);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1489);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1490);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1491);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1492);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1493);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1494);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1495);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1496);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1497);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1498);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1499);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1500);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1501);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1502);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1503);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1504);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1505);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1506);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1507);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1508);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1509);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1510);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1511);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1512);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1513);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1514);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3585);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3586);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3587);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3588);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3589);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3591);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3592);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3594);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3596);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3604);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3605);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3606);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3607);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3609);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3610);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3611);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3612);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3613);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3614);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3615);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3616);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3617);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3618);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3619);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3621);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3623);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3626);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3627);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3629);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3632);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3633);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3634);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3635);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3636);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3637);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3638);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3639);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3640);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3641);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3647);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3648);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3649);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3651);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3652);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3653);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3654);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3655);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3656);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3657);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3664);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3665);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3666);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3667);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3668);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3669);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3670);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3671);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3672);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 3673);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1415);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1417);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1417);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1373);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1373);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1371);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1371);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1374);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1374);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1377);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1378);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1379);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1380);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1381);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1382);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1383);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1384);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1385);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1386);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1387);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1388);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1389);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1390);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1391);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1392);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1393);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1394);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1395);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1396);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1397);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1398);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1399);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1400);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1401);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1402);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1403);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1404);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1405);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1406);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1407);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1408);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1409);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1410);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1411);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1412);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1413);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 1414);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4304);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4305);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4306);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4307);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4308);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4309);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4310);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4311);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4312);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4313);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4314);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4315);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4316);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4317);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4318);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4319);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4320);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4321);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4322);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4323);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4324);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4325);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4326);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4327);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4328);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4329);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4330);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4331);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4332);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4333);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4334);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4335);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 4336);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 487);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 601);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 7865);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 7883);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 7885);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 7909);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 417);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 432);
                ExtendedKeyCodes.extendedKeyCodesSet_$LI$().add(16777216 + 8363);
            };
            ExtendedKeyCodes.__static_initialized = false;
            return ExtendedKeyCodes;
        }());
        awt.ExtendedKeyCodes = ExtendedKeyCodes;
        ExtendedKeyCodes["__class"] = "sun.awt.ExtendedKeyCodes";
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var java;
(function (java) {
    var awt;
    (function (awt) {
        var event;
        (function (event) {
            /**
             * An event which indicates that the mouse wheel was rotated in a component.
             * <P>
             * A wheel mouse is a mouse which has a wheel in place of the middle button.
             * This wheel can be rotated towards or away from the user.  Mouse wheels are
             * most often used for scrolling, though other uses are possible.
             * <P>
             * A MouseWheelEvent object is passed to every <code>MouseWheelListener</code>
             * object which registered to receive the "interesting" mouse events using the
             * component's <code>addMouseWheelListener</code> method.  Each such listener
             * object gets a <code>MouseEvent</code> containing the mouse event.
             * <P>
             * Due to the mouse wheel's special relationship to scrolling Components,
             * MouseWheelEvents are delivered somewhat differently than other MouseEvents.
             * This is because while other MouseEvents usually affect a change on
             * the Component directly under the mouse
             * cursor (for instance, when clicking a button), MouseWheelEvents often have
             * an effect away from the mouse cursor (moving the wheel while
             * over a Component inside a ScrollPane should scroll one of the
             * Scrollbars on the ScrollPane).
             * <P>
             * MouseWheelEvents start delivery from the Component underneath the
             * mouse cursor.  If MouseWheelEvents are not enabled on the
             * Component, the event is delivered to the first ancestor
             * Container with MouseWheelEvents enabled.  This will usually be
             * a ScrollPane with wheel scrolling enabled.  The source
             * Component and x,y coordinates will be relative to the event's
             * final destination (the ScrollPane).  This allows a complex
             * GUI to be installed without modification into a ScrollPane, and
             * for all MouseWheelEvents to be delivered to the ScrollPane for
             * scrolling.
             * <P>
             * Some AWT Components are implemented using native widgets which
             * display their own scrollbars and handle their own scrolling.
             * The particular Components for which this is true will vary from
             * platform to platform.  When the mouse wheel is
             * moved over one of these Components, the event is delivered straight to
             * the native widget, and not propagated to ancestors.
             * <P>
             * Platforms offer customization of the amount of scrolling that
             * should take place when the mouse wheel is moved.  The two most
             * common settings are to scroll a certain number of "units"
             * (commonly lines of text in a text-based component) or an entire "block"
             * (similar to page-up/page-down).  The MouseWheelEvent offers
             * methods for conforming to the underlying platform settings.  These
             * platform settings can be changed at any time by the user.  MouseWheelEvents
             * reflect the most recent settings.
             * <P>
             * The <code>MouseWheelEvent</code> class includes methods for
             * getting the number of "clicks" by which the mouse wheel is rotated.
             * The {@link #getWheelRotation} method returns the integer number
             * of "clicks" corresponding to the number of notches by which the wheel was
             * rotated. In addition to this method, the <code>MouseWheelEvent</code>
             * class provides the {@link #getPreciseWheelRotation} method which returns
             * a double number of "clicks" in case a partial rotation occurred.
             * The {@link #getPreciseWheelRotation} method is useful if a mouse supports
             * a high-resolution wheel, such as a freely rotating wheel with no
             * notches. Applications can benefit by using this method to process
             * mouse wheel events more precisely, and thus, making visual perception
             * smoother.
             *
             * @author Brent Christian
             * @see MouseWheelListener
             * @see java.awt.ScrollPane
             * @see java.awt.ScrollPane#setWheelScrollingEnabled(boolean)
             * @see javax.swing.JScrollPane
             * @see javax.swing.JScrollPane#setWheelScrollingEnabled(boolean)
             * @since 1.4
             */
            var MouseWheelEvent = (function (_super) {
                __extends(MouseWheelEvent, _super);
                /**
                 * Constructs a <code>MouseWheelEvent</code> object with the specified
                 * source component, type, modifiers, coordinates, absolute coordinates,
                 * scroll type, scroll amount, and wheel rotation.
                 * <p>Note that passing in an invalid <code>id</code> parameter results
                 * in unspecified behavior. This method throws an
                 * <code>IllegalArgumentException</code> if <code>source</code> equals
                 * <code>null</code>.
                 * <p>Even if inconsistent values for relative and absolute coordinates
                 * are passed to the constructor, a <code>MouseWheelEvent</code> instance
                 * is still created and no exception is thrown.
                 *
                 * @param source         the <code>Component</code> that originated the event
                 * @param id             the integer value that identifies the event
                 * @param when           a long value that gives the time when the event occurred
                 * @param modifiers      the modifier keys down during event
                 * (shift, ctrl, alt, meta)
                 * @param x              the horizontal <code>x</code> coordinate for the
                 * mouse location
                 * @param y              the vertical <code>y</code> coordinate for the
                 * mouse location
                 * @param xAbs           the absolute horizontal <code>x</code> coordinate for
                 * the mouse location
                 * @param yAbs           the absolute vertical <code>y</code> coordinate for
                 * the mouse location
                 * @param clickCount     the number of mouse clicks associated with the event
                 * @param popupTrigger   a boolean value, <code>true</code> if this event is a trigger
                 * for a popup-menu
                 * @param scrollType     the type of scrolling which should take place in
                 * response to this event;  valid values are
                 * <code>WHEEL_UNIT_SCROLL</code> and
                 * <code>WHEEL_BLOCK_SCROLL</code>
                 * @param  scrollAmount  for scrollType <code>WHEEL_UNIT_SCROLL</code>,
                 * the number of units to be scrolled
                 * @param wheelRotation  the integer number of "clicks" by which the mouse wheel
                 * was rotated
                 * @param preciseWheelRotation the double number of "clicks" by which the mouse wheel
                 * was rotated
                 *
                 * @throws IllegalArgumentException if <code>source</code> is null
                 * @see MouseEvent#MouseEvent(java.awt.Component, int, long, int, int, int, int, boolean)
                 * @see MouseEvent#MouseEvent(java.awt.Component, int, long, int, int, int, int, int, int, boolean, int)
                 * @since 1.7
                 */
                function MouseWheelEvent(source, id, when, modifiers, x, y, xAbs, yAbs, clickCount, popupTrigger, scrollType, scrollAmount, wheelRotation, preciseWheelRotation) {
                    var _this = this;
                    if (((source != null && source instanceof java.awt.Component) || source === null) && ((typeof id === 'number') || id === null) && ((typeof when === 'number') || when === null) && ((typeof modifiers === 'number') || modifiers === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof xAbs === 'number') || xAbs === null) && ((typeof yAbs === 'number') || yAbs === null) && ((typeof clickCount === 'number') || clickCount === null) && ((typeof popupTrigger === 'boolean') || popupTrigger === null) && ((typeof scrollType === 'number') || scrollType === null) && ((typeof scrollAmount === 'number') || scrollAmount === null) && ((typeof wheelRotation === 'number') || wheelRotation === null) && ((typeof preciseWheelRotation === 'number') || preciseWheelRotation === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        _super.call(this, source, id, when, modifiers, x, y, xAbs, yAbs, clickCount, popupTrigger, java.awt.event.MouseEvent.NOBUTTON);
                        this.scrollType = 0;
                        this.scrollAmount = 0;
                        this.wheelRotation = 0;
                        this.preciseWheelRotation = 0;
                        (function () {
                            _this.scrollType = scrollType;
                            _this.scrollAmount = scrollAmount;
                            _this.wheelRotation = wheelRotation;
                            _this.preciseWheelRotation = preciseWheelRotation;
                        })();
                    }
                    else if (((source != null && source instanceof java.awt.Component) || source === null) && ((typeof id === 'number') || id === null) && ((typeof when === 'number') || when === null) && ((typeof modifiers === 'number') || modifiers === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof xAbs === 'number') || xAbs === null) && ((typeof yAbs === 'number') || yAbs === null) && ((typeof clickCount === 'number') || clickCount === null) && ((typeof popupTrigger === 'boolean') || popupTrigger === null) && ((typeof scrollType === 'number') || scrollType === null) && ((typeof scrollAmount === 'number') || scrollAmount === null) && ((typeof wheelRotation === 'number') || wheelRotation === null) && preciseWheelRotation === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        {
                            var __args_62 = Array.prototype.slice.call(arguments);
                            var preciseWheelRotation_1 = __args_62[12];
                            _super.call(this, source, id, when, modifiers, x, y, xAbs, yAbs, clickCount, popupTrigger, java.awt.event.MouseEvent.NOBUTTON);
                            this.scrollType = 0;
                            this.scrollAmount = 0;
                            this.wheelRotation = 0;
                            this.preciseWheelRotation = 0;
                            (function () {
                                _this.scrollType = scrollType;
                                _this.scrollAmount = scrollAmount;
                                _this.wheelRotation = wheelRotation;
                                _this.preciseWheelRotation = preciseWheelRotation_1;
                            })();
                        }
                    }
                    else if (((source != null && source instanceof java.awt.Component) || source === null) && ((typeof id === 'number') || id === null) && ((typeof when === 'number') || when === null) && ((typeof modifiers === 'number') || modifiers === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof xAbs === 'number') || xAbs === null) && ((typeof yAbs === 'boolean') || yAbs === null) && ((typeof clickCount === 'number') || clickCount === null) && ((typeof popupTrigger === 'number') || popupTrigger === null) && ((typeof scrollType === 'number') || scrollType === null) && scrollAmount === undefined && wheelRotation === undefined && preciseWheelRotation === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        var clickCount_3 = __args[6];
                        var popupTrigger_3 = __args[7];
                        var scrollType_1 = __args[8];
                        var scrollAmount_1 = __args[9];
                        var wheelRotation_1 = __args[10];
                        {
                            var __args_63 = Array.prototype.slice.call(arguments);
                            var xAbs_3 = 0;
                            var yAbs_3 = 0;
                            {
                                var __args_64 = Array.prototype.slice.call(arguments);
                                var preciseWheelRotation_2 = __args_64[12];
                                _super.call(this, source, id, when, modifiers, x, y, xAbs_3, yAbs_3, clickCount_3, popupTrigger_3, java.awt.event.MouseEvent.NOBUTTON);
                                this.scrollType = 0;
                                this.scrollAmount = 0;
                                this.wheelRotation = 0;
                                this.preciseWheelRotation = 0;
                                (function () {
                                    _this.scrollType = scrollType_1;
                                    _this.scrollAmount = scrollAmount_1;
                                    _this.wheelRotation = wheelRotation_1;
                                    _this.preciseWheelRotation = preciseWheelRotation_2;
                                })();
                            }
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns the type of scrolling that should take place in response to this
                 * event.  This is determined by the native platform.  Legal values are:
                 * <ul>
                 * <li> MouseWheelEvent.WHEEL_UNIT_SCROLL
                 * <li> MouseWheelEvent.WHEEL_BLOCK_SCROLL
                 * </ul>
                 *
                 * @return either MouseWheelEvent.WHEEL_UNIT_SCROLL or
                 * MouseWheelEvent.WHEEL_BLOCK_SCROLL, depending on the configuration of
                 * the native platform.
                 * @see java.awt.Adjustable#getUnitIncrement
                 * @see java.awt.Adjustable#getBlockIncrement
                 * @see javax.swing.Scrollable#getScrollableUnitIncrement
                 * @see javax.swing.Scrollable#getScrollableBlockIncrement
                 */
                MouseWheelEvent.prototype.getScrollType = function () {
                    return this.scrollType;
                };
                /**
                 * Returns the number of units that should be scrolled per
                 * click of mouse wheel rotation.
                 * Only valid if <code>getScrollType</code> returns
                 * <code>MouseWheelEvent.WHEEL_UNIT_SCROLL</code>
                 *
                 * @return number of units to scroll, or an undefined value if
                 * <code>getScrollType</code> returns
                 * <code>MouseWheelEvent.WHEEL_BLOCK_SCROLL</code>
                 * @see #getScrollType
                 */
                MouseWheelEvent.prototype.getScrollAmount = function () {
                    return this.scrollAmount;
                };
                /**
                 * Returns the number of "clicks" the mouse wheel was rotated, as an integer.
                 * A partial rotation may occur if the mouse supports a high-resolution wheel.
                 * In this case, the method returns zero until a full "click" has been accumulated.
                 *
                 * @return negative values if the mouse wheel was rotated up/away from
                 * the user, and positive values if the mouse wheel was rotated down/
                 * towards the user
                 * @see #getPreciseWheelRotation
                 */
                MouseWheelEvent.prototype.getWheelRotation = function () {
                    return this.wheelRotation;
                };
                /**
                 * Returns the number of "clicks" the mouse wheel was rotated, as a double.
                 * A partial rotation may occur if the mouse supports a high-resolution wheel.
                 * In this case, the return value will include a fractional "click".
                 *
                 * @return negative values if the mouse wheel was rotated up or away from
                 * the user, and positive values if the mouse wheel was rotated down or
                 * towards the user
                 * @see #getWheelRotation
                 * @since 1.7
                 */
                MouseWheelEvent.prototype.getPreciseWheelRotation = function () {
                    return this.preciseWheelRotation;
                };
                /**
                 * This is a convenience method to aid in the implementation of
                 * the common-case MouseWheelListener - to scroll a ScrollPane or
                 * JScrollPane by an amount which conforms to the platform settings.
                 * (Note, however, that <code>ScrollPane</code> and
                 * <code>JScrollPane</code> already have this functionality built in.)
                 * <P>
                 * This method returns the number of units to scroll when scroll type is
                 * MouseWheelEvent.WHEEL_UNIT_SCROLL, and should only be called if
                 * <code>getScrollType</code> returns MouseWheelEvent.WHEEL_UNIT_SCROLL.
                 * <P>
                 * Direction of scroll, amount of wheel movement,
                 * and platform settings for wheel scrolling are all accounted for.
                 * This method does not and cannot take into account value of the
                 * Adjustable/Scrollable unit increment, as this will vary among
                 * scrolling components.
                 * <P>
                 * A simplified example of how this method might be used in a
                 * listener:
                 * <pre>
                 * mouseWheelMoved(MouseWheelEvent event) {
                 * ScrollPane sp = getScrollPaneFromSomewhere();
                 * Adjustable adj = sp.getVAdjustable()
                 * if (MouseWheelEvent.getScrollType() == WHEEL_UNIT_SCROLL) {
                 * int totalScrollAmount =
                 * event.getUnitsToScroll() *
                 * adj.getUnitIncrement();
                 * adj.setValue(adj.getValue() + totalScrollAmount);
                 * }
                 * }
                 * </pre>
                 *
                 * @return the number of units to scroll based on the direction and amount
                 * of mouse wheel rotation, and on the wheel scrolling settings of the
                 * native platform
                 * @see #getScrollType
                 * @see #getScrollAmount
                 * @see MouseWheelListener
                 * @see java.awt.Adjustable
                 * @see java.awt.Adjustable#getUnitIncrement
                 * @see javax.swing.Scrollable
                 * @see javax.swing.Scrollable#getScrollableUnitIncrement
                 * @see java.awt.ScrollPane
                 * @see java.awt.ScrollPane#setWheelScrollingEnabled
                 * @see javax.swing.JScrollPane
                 * @see javax.swing.JScrollPane#setWheelScrollingEnabled
                 */
                MouseWheelEvent.prototype.getUnitsToScroll = function () {
                    return this.scrollAmount * this.wheelRotation;
                };
                /**
                 * Returns a parameter string identifying this event.
                 * This method is useful for event-logging and for debugging.
                 *
                 * @return a string identifying the event and its attributes
                 */
                MouseWheelEvent.prototype.paramString = function () {
                    var scrollTypeStr = null;
                    if (this.getScrollType() === MouseWheelEvent.WHEEL_UNIT_SCROLL) {
                        scrollTypeStr = "WHEEL_UNIT_SCROLL";
                    }
                    else if (this.getScrollType() === MouseWheelEvent.WHEEL_BLOCK_SCROLL) {
                        scrollTypeStr = "WHEEL_BLOCK_SCROLL";
                    }
                    else {
                        scrollTypeStr = "unknown scroll type";
                    }
                    return _super.prototype.paramString.call(this) + ",scrollType=" + scrollTypeStr + ",scrollAmount=" + this.getScrollAmount() + ",wheelRotation=" + this.getWheelRotation() + ",preciseWheelRotation=" + this.getPreciseWheelRotation();
                };
                /**
                 * Constant representing scrolling by "units" (like scrolling with the
                 * arrow keys)
                 *
                 * @see #getScrollType
                 */
                MouseWheelEvent.WHEEL_UNIT_SCROLL = 0;
                /**
                 * Constant representing scrolling by a "block" (like scrolling
                 * with page-up, page-down keys)
                 *
                 * @see #getScrollType
                 */
                MouseWheelEvent.WHEEL_BLOCK_SCROLL = 1;
                MouseWheelEvent.serialVersionUID = 6459879390515399677;
                return MouseWheelEvent;
            }(java.awt.event.MouseEvent));
            event.MouseWheelEvent = MouseWheelEvent;
            MouseWheelEvent["__class"] = "java.awt.event.MouseWheelEvent";
            MouseWheelEvent["__interfaces"] = ["java.io.Serializable"];
        })(event = awt.event || (awt.event = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        /**
         * Simplified version.
         */
        var JApplet = (function (_super) {
            __extends(JApplet, _super);
            /**
             * Creates a swing applet instance.
             * <p>
             * This constructor sets the component's locale property to the value
             * returned by <code>JComponent.getDefaultLocale</code>.
             *
             * @exception java.awt.HeadlessException
             * if GraphicsEnvironment.isHeadless() returns true.
             * @see java.awt.GraphicsEnvironment#isHeadless
             * @see JComponent#getDefaultLocale
             */
            function JApplet() {
                _super.call(this);
                /**
                 * If true then calls to <code>add</code> and <code>setLayout</code> will be
                 * forwarded to the <code>contentPane</code>. This is initially false, but
                 * is set to true when the <code>JApplet</code> is constructed.
                 *
                 * @see #isRootPaneCheckingEnabled
                 * @see #setRootPaneCheckingEnabled
                 * @see javax.swing.RootPaneContainer
                 */
                this.rootPaneCheckingEnabled = false;
                this.setForeground(java.awt.Color.black_$LI$());
                this.setBackground(java.awt.Color.white_$LI$());
                this.setLayout(new java.awt.BorderLayout());
                this.setRootPane(this.createRootPane());
                this.rootPaneCheckingEnabled = true;
            }
            /**
             * Called by the constructor methods to create the default rootPane.
             */
            JApplet.prototype.createRootPane = function () {
                var rp = new javax.swing.JRootPane();
                return rp;
            };
            JApplet.prototype.addImpl = function (comp, constraints, index) {
                if (this.rootPaneCheckingEnabled && this.getContentPane() != null) {
                    this.getContentPane().add(comp, constraints, index);
                }
                else {
                    _super.prototype.addImpl.call(this, comp, constraints, index);
                }
            };
            /**
             * Just calls <code>paint(g)</code>. This method was overridden to prevent
             * an unnecessary call to clear the background.
             */
            JApplet.prototype.update = function (g) {
                this.paint(g);
            };
            /**
             * Removes the specified component from the container. If <code>comp</code>
             * is not the <code>rootPane</code>, this will forward the call to the
             * <code>contentPane</code>. This will do nothing if <code>comp</code> is
             * not a child of the <code>JFrame</code> or <code>contentPane</code>.
             *
             * @param comp
             * the component to be removed
             * @throws NullPointerException
             * if <code>comp</code> is null
             * @see #add
             * @see javax.swing.RootPaneContainer
             */
            JApplet.prototype.remove = function (comp) {
                var _this = this;
                if (((comp != null && comp instanceof java.awt.Component) || comp === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        if (comp === _this.rootPane) {
                            _super.prototype.remove.call(_this, comp);
                        }
                        else {
                            _this.getContentPane().remove(comp);
                        }
                    })();
                }
                else if (((typeof comp === 'number') || comp === null)) {
                    return this.remove$int(comp);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Sets the <code>LayoutManager</code>. Overridden to conditionally forward
             * the call to the <code>contentPane</code>. Refer to
             * {@link javax.swing.RootPaneContainer} for more information.
             *
             * @param manager
             * the <code>LayoutManager</code>
             * @see #setRootPaneCheckingEnabled
             * @see javax.swing.RootPaneContainer
             */
            JApplet.prototype.setLayout = function (manager) {
                if (this.rootPane != null) {
                    this.getContentPane().setLayout(manager);
                }
                else {
                    _super.prototype.setLayout.call(this, manager);
                }
            };
            /**
             * Returns the rootPane object for this applet.
             *
             * @see #setRootPane
             * @see RootPaneContainer#getRootPane
             */
            JApplet.prototype.getRootPane = function () {
                return this.rootPane;
            };
            /**
             * Sets the rootPane property. This method is called by the constructor.
             *
             * @param root
             * the rootPane object for this applet
             *
             * @see #getRootPane
             *
             * @beaninfo hidden: true description: the RootPane object for this applet.
             */
            JApplet.prototype.setRootPane = function (root) {
                if (this.rootPane != null) {
                    this.remove(this.rootPane);
                }
                this.rootPane = root;
                if (this.rootPane != null) {
                    this.add(this.rootPane, java.awt.BorderLayout.CENTER);
                }
            };
            /**
             * Returns the contentPane object for this applet.
             *
             * @see #setContentPane
             * @see RootPaneContainer#getContentPane
             */
            JApplet.prototype.getContentPane = function () {
                if (this.rootPane != null) {
                    return this.getRootPane().getContentPane();
                }
                else {
                    return null;
                }
            };
            /**
             * Sets the contentPane property. This method is called by the constructor.
             *
             * @param contentPane
             * the contentPane object for this applet
             *
             * @exception java.awt.IllegalComponentStateException
             * (a runtime exception) if the content pane parameter is
             * null
             * @see #getContentPane
             * @see RootPaneContainer#setContentPane
             *
             * @beaninfo hidden: true description: The client area of the applet where
             * child components are normally inserted.
             */
            JApplet.prototype.setContentPane = function (contentPane) {
                this.getRootPane().setContentPane(contentPane);
            };
            /**
             * Returns a string representation of this JApplet. This method is intended
             * to be used only for debugging purposes, and the content and format of the
             * returned string may vary between implementations. The returned string may
             * be empty but may not be <code>null</code>.
             *
             * @return a string representation of this JApplet.
             */
            JApplet.prototype.paramString = function () {
                var rootPaneString = (this.rootPane != null ? this.rootPane.toString() : "");
                var rootPaneCheckingEnabledString = (this.rootPaneCheckingEnabled ? "true" : "false");
                return _super.prototype.paramString.call(this) + ",rootPane=" + rootPaneString + ",rootPaneCheckingEnabled=" + rootPaneCheckingEnabledString;
            };
            return JApplet;
        }(java.applet.Applet));
        swing.JApplet = JApplet;
        JApplet["__class"] = "javax.swing.JApplet";
        JApplet["__interfaces"] = ["java.awt.HTMLComponent", "javax.swing.RootPaneContainer"];
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var JFrame = (function (_super) {
            __extends(JFrame, _super);
            function JFrame(title) {
                var _this = this;
                if (((typeof title === 'string') || title === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this, title);
                    this.defaultCloseOperation = javax.swing.WindowConstants.HIDE_ON_CLOSE;
                    this.rootPaneCheckingEnabled = false;
                    (function () {
                        _this.frameInit();
                    })();
                }
                else if (title === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this);
                    this.defaultCloseOperation = javax.swing.WindowConstants.HIDE_ON_CLOSE;
                    this.rootPaneCheckingEnabled = false;
                }
                else
                    throw new Error('invalid overload');
            }
            JFrame.prototype.frameInit = function () {
                this.setLayout(new java.awt.BorderLayout());
                this.setRootPane(this.createRootPane());
                this.rootPaneCheckingEnabled = true;
            };
            JFrame.prototype.createRootPane = function () {
                var rp = new javax.swing.JRootPane();
                return rp;
            };
            JFrame.prototype.setRootPane = function (root) {
                if (this.rootPane != null) {
                    this.remove(this.rootPane);
                }
                this.rootPane = root;
                if (this.rootPane != null) {
                    this.add(this.rootPane, java.awt.BorderLayout.CENTER);
                }
            };
            JFrame.prototype.getContentPane = function () {
                if (this.rootPane != null) {
                    return this.getRootPane().getContentPane();
                }
                else {
                    return null;
                }
            };
            JFrame.prototype.getRootPane = function () {
                return this.rootPane;
            };
            JFrame.prototype.setContentPane = function (contentPane) {
                this.getRootPane().setContentPane(contentPane);
            };
            JFrame.prototype.setDefaultCloseOperation = function (operation) {
                if (operation !== javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE && operation !== javax.swing.WindowConstants.HIDE_ON_CLOSE && operation !== javax.swing.WindowConstants.DISPOSE_ON_CLOSE && operation !== JFrame.EXIT_ON_CLOSE) {
                    throw new java.lang.IllegalArgumentException("defaultCloseOperation must be one of: DO_NOTHING_ON_CLOSE, HIDE_ON_CLOSE, DISPOSE_ON_CLOSE, or EXIT_ON_CLOSE");
                }
                if (this.defaultCloseOperation !== operation) {
                    var oldValue = this.defaultCloseOperation;
                    this.defaultCloseOperation = operation;
                    this.firePropertyChange("defaultCloseOperation", oldValue, operation);
                }
            };
            JFrame.EXIT_ON_CLOSE = 3;
            return JFrame;
        }(java.awt.Frame));
        swing.JFrame = JFrame;
        JFrame["__class"] = "javax.swing.JFrame";
        JFrame["__interfaces"] = ["java.awt.HTMLComponent", "javax.swing.RootPaneContainer", "javax.swing.WindowConstants"];
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var JButton = (function (_super) {
            __extends(JButton, _super);
            function JButton(label) {
                _super.call(this);
                this.label = label;
                this.actionCommand = label;
            }
            JButton.prototype.getHTMLElement = function () {
                return _super.prototype.getHTMLElement.call(this);
            };
            JButton.prototype.createHTML = function () {
                if (this.htmlElement != null) {
                    return;
                }
                this.htmlElement = document.createElement("button");
            };
            JButton.prototype.initHTML = function () {
                _super.prototype.initHTML.call(this);
                this.htmlElement.innerHTML = this.label;
                this.initActionListener();
            };
            JButton.prototype.initActionListener = function () {
                var _this = this;
                if (this.actionListener != null) {
                    this.htmlElement.onclick = function (e) {
                        console.log("htmlElement clicked: " + _this.actionCommand);
                        _this.actionListener.actionPerformed(new java.awt.event.ActionEvent(_this, 0, _this.actionCommand));
                        return e;
                    };
                }
            };
            JButton.prototype.addActionListener = function (actionListener) {
                this.actionListener = actionListener;
                if (this.htmlElement != null) {
                    this.initActionListener();
                }
            };
            JButton.prototype.setBackground = function (background) {
                this.background = background;
            };
            return JButton;
        }(javax.swing.AbstractButton));
        swing.JButton = JButton;
        JButton["__class"] = "javax.swing.JButton";
        JButton["__interfaces"] = ["java.awt.ItemSelectable", "java.awt.HTMLComponent", "javax.swing.SwingConstants", "java.io.Serializable"];
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        /**
         * An implementation of an item in a menu. A menu item is essentially a button
         * sitting in a list. When the user selects the "button", the action
         * associated with the menu item is performed. A <code>JMenuItem</code>
         * contained in a <code>JPopupMenu</code> performs exactly that function.
         * <p>
         * Menu items can be configured, and to some degree controlled, by
         * <code><a href="Action.html">Action</a></code>s.  Using an
         * <code>Action</code> with a menu item has many benefits beyond directly
         * configuring a menu item.  Refer to <a href="Action.html#buttonActions">
         * Swing Components Supporting <code>Action</code></a> for more
         * details, and you can find more information in <a
         * href="http://docs.oracle.com/javase/tutorial/uiswing/misc/action.html">How
         * to Use Actions</a>, a section in <em>The Java Tutorial</em>.
         * <p>
         * For further documentation and for examples, see
         * <a
         * href="http://docs.oracle.com/javase/tutorial/uiswing/components/menu.html">How to Use Menus</a>
         * in <em>The Java Tutorial.</em>
         * <p>
         * <strong>Warning:</strong> Swing is not thread safe. For more
         * information see <a
         * href="package-summary.html#threading">Swing's Threading
         * Policy</a>.
         * <p>
         * <strong>Warning:</strong>
         * Serialized objects of this class will not be compatible with
         * future Swing releases. The current serialization support is
         * appropriate for short term storage or RMI between applications running
         * the same version of Swing.  As of 1.4, support for long term storage
         * of all JavaBeans&trade;
         * has been added to the <code>java.beans</code> package.
         * Please see {@link java.beans.XMLEncoder}.
         *
         * @beaninfo
         * attribute: isContainer false
         * description: An item which can be selected in a menu.
         *
         * @author Georges Saab
         * @author David Karlton
         * @see JPopupMenu
         * @see JMenu
         * @see JCheckBoxMenuItem
         * @see JRadioButtonMenuItem
         */
        var JMenuItem = (function (_super) {
            __extends(JMenuItem, _super);
            /**
             * Creates a <code>JMenuItem</code> with the specified text and icon.
             *
             * @param text the text of the <code>JMenuItem</code>
             * @param icon the icon of the <code>JMenuItem</code>
             */
            function JMenuItem(text, icon) {
                var _this = this;
                if (((typeof text === 'string') || text === null) && ((icon != null && (icon["__interfaces"] != null && icon["__interfaces"].indexOf("javax.swing.Icon") >= 0 || icon.constructor != null && icon.constructor["__interfaces"] != null && icon.constructor["__interfaces"].indexOf("javax.swing.Icon") >= 0)) || icon === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this);
                    this.isMouseDragged = false;
                    (function () {
                        _this.setModel(new javax.swing.DefaultButtonModel());
                        _this.init(text, icon);
                    })();
                }
                else if (((typeof text === 'string') || text === null) && ((typeof icon === 'number') || icon === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    var mnemonic_1 = __args[1];
                    _super.call(this);
                    this.isMouseDragged = false;
                    (function () {
                        _this.setModel(new javax.swing.DefaultButtonModel());
                        _this.init(text, null);
                        _this.setMnemonic(mnemonic_1);
                    })();
                }
                else if (((text != null && (text["__interfaces"] != null && text["__interfaces"].indexOf("javax.swing.Icon") >= 0 || text.constructor != null && text.constructor["__interfaces"] != null && text.constructor["__interfaces"].indexOf("javax.swing.Icon") >= 0)) || text === null) && icon === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var icon_6 = __args[0];
                    {
                        var __args_65 = Array.prototype.slice.call(arguments);
                        var text_7 = null;
                        _super.call(this);
                        this.isMouseDragged = false;
                        (function () {
                            _this.setModel(new javax.swing.DefaultButtonModel());
                            _this.init(text_7, icon_6);
                        })();
                    }
                }
                else if (((typeof text === 'string') || text === null) && icon === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_66 = Array.prototype.slice.call(arguments);
                        var icon_7 = null;
                        _super.call(this);
                        this.isMouseDragged = false;
                        (function () {
                            _this.setModel(new javax.swing.DefaultButtonModel());
                            _this.init(text, icon_7);
                        })();
                    }
                }
                else if (((text != null && (text["__interfaces"] != null && text["__interfaces"].indexOf("javax.swing.Action") >= 0 || text.constructor != null && text.constructor["__interfaces"] != null && text.constructor["__interfaces"].indexOf("javax.swing.Action") >= 0)) || text === null) && icon === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var a_5 = __args[0];
                    {
                        var __args_67 = Array.prototype.slice.call(arguments);
                        {
                            var __args_68 = Array.prototype.slice.call(arguments);
                            var text_8 = null;
                            var icon_8 = null;
                            _super.call(this);
                            this.isMouseDragged = false;
                            (function () {
                                _this.setModel(new javax.swing.DefaultButtonModel());
                                _this.init(text_8, icon_8);
                            })();
                        }
                    }
                    (function () {
                        _this.setAction(a_5);
                    })();
                }
                else if (text === undefined && icon === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_69 = Array.prototype.slice.call(arguments);
                        var text_9 = null;
                        var icon_9 = null;
                        _super.call(this);
                        this.isMouseDragged = false;
                        (function () {
                            _this.setModel(new javax.swing.DefaultButtonModel());
                            _this.init(text_9, icon_9);
                        })();
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            JMenuItem.prototype.createHTML = function () {
            };
            /**
             * {@inheritDoc}
             */
            JMenuItem.prototype.setModel = function (newModel) {
                _super.prototype.setModel.call(this, newModel);
                if (newModel != null && newModel instanceof javax.swing.DefaultButtonModel) {
                    newModel.setMenuItem(true);
                }
            };
            /**
             * Initializes the menu item with the specified text and icon.
             *
             * @param text the text of the <code>JMenuItem</code>
             * @param icon the icon of the <code>JMenuItem</code>
             */
            JMenuItem.prototype.init = function (text, icon) {
                if (text != null) {
                    this.setText(text);
                }
                if (icon != null) {
                    this.setIcon(icon);
                }
                this.addFocusListener(new JMenuItem.MenuItemFocusListener());
                this.setFocusPainted(false);
            };
            /**
             * Returns the suffix used to construct the name of the L&amp;F class used to
             * render this component.
             *
             * @return the string "MenuItemUI"
             * @see JComponent#getUIClassID
             * @see UIDefaults#getUI
             */
            JMenuItem.prototype.getUIClassID = function () {
                return JMenuItem.uiClassID;
            };
            /**
             * Identifies the menu item as "armed". If the mouse button is
             * released while it is over this item, the menu's action event
             * will fire. If the mouse button is released elsewhere, the
             * event will not fire and the menu item will be disarmed.
             *
             * @param b true to arm the menu item so it can be selected
             * @beaninfo
             * description: Mouse release will fire an action event
             * hidden: true
             */
            JMenuItem.prototype.setArmed = function (b) {
                var model = this.getModel();
                var oldValue = model.isArmed();
                if (model.isArmed() !== b) {
                    model.setArmed(b);
                }
            };
            /**
             * Returns whether the menu item is "armed".
             *
             * @return true if the menu item is armed, and it can be selected
             * @see #setArmed
             */
            JMenuItem.prototype.isArmed = function () {
                var model = this.getModel();
                return model.isArmed();
            };
            /**
             * Returns the <code>KeyStroke</code> which serves as an accelerator
             * for the menu item.
             * @return a <code>KeyStroke</code> object identifying the
             * accelerator key
             */
            JMenuItem.prototype.setIconFromAction = function (a) {
                var icon = null;
                if (a != null) {
                    icon = a.getValue(javax.swing.Action.SMALL_ICON);
                }
                this.setIcon(icon);
            };
            JMenuItem.prototype.largeIconChanged = function (a) {
            };
            JMenuItem.prototype.smallIconChanged = function (a) {
                this.setIconFromAction(a);
            };
            /**
             * Processes a key event forwarded from the
             * <code>MenuSelectionManager</code> and changes the menu selection,
             * if necessary, by using <code>MenuSelectionManager</code>'s API.
             * <p>
             * Note: you do not have to forward the event to sub-components.
             * This is done automatically by the <code>MenuSelectionManager</code>.
             *
             * @param e  a <code>KeyEvent</code>
             * @param path the <code>MenuElement</code> path array
             * @param manager   the <code>MenuSelectionManager</code>
             */
            JMenuItem.prototype.processKeyEvent = function (e, path, manager) {
                var _this = this;
                if (((e != null && e instanceof java.awt.event.KeyEvent) || e === null) && ((path != null && path instanceof Array) || path === null) && ((manager != null && manager instanceof javax.swing.MenuSelectionManager) || manager === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        var mke = new javax.swing.event.MenuKeyEvent(e.getComponent(), e.getID(), e.getWhen(), e.getModifiers(), e.getKeyCode(), e.getKeyChar(), path, manager);
                        _this.processMenuKeyEvent(mke);
                        if (mke.isConsumed()) {
                            e.consume();
                        }
                    })();
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Handles a keystroke in a menu.
             *
             * @param e  a <code>MenuKeyEvent</code> object
             */
            JMenuItem.prototype.processMenuKeyEvent = function (e) {
                switch ((e.getID())) {
                    case java.awt.event.KeyEvent.KEY_PRESSED_$LI$():
                        this.fireMenuKeyPressed(e);
                        break;
                    case java.awt.event.KeyEvent.KEY_RELEASED_$LI$():
                        this.fireMenuKeyReleased(e);
                        break;
                    case java.awt.event.KeyEvent.KEY_TYPED_$LI$():
                        this.fireMenuKeyTyped(e);
                        break;
                    default:
                        break;
                }
            };
            /**
             * Notifies all listeners that have registered interest for
             * notification on this event type.
             *
             * @param event a <code>MenuKeyEvent</code>
             * @see EventListenerList
             */
            JMenuItem.prototype.fireMenuKeyPressed = function (event) {
                var listeners = this.listenerList.getListenerList();
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "javax.swing.event.MenuKeyListener") {
                        listeners[i + 1].menuKeyPressed(event);
                    }
                }
            };
            /**
             * Notifies all listeners that have registered interest for
             * notification on this event type.
             *
             * @param event a <code>MenuKeyEvent</code>
             * @see EventListenerList
             */
            JMenuItem.prototype.fireMenuKeyReleased = function (event) {
                var listeners = this.listenerList.getListenerList();
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "javax.swing.event.MenuKeyListener") {
                        listeners[i + 1].menuKeyReleased(event);
                    }
                }
            };
            /**
             * Notifies all listeners that have registered interest for
             * notification on this event type.
             *
             * @param event a <code>MenuKeyEvent</code>
             * @see EventListenerList
             */
            JMenuItem.prototype.fireMenuKeyTyped = function (event) {
                var listeners = this.listenerList.getListenerList();
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "javax.swing.event.MenuKeyListener") {
                        listeners[i + 1].menuKeyTyped(event);
                    }
                }
            };
            /**
             * Called by the <code>MenuSelectionManager</code> when the
             * <code>MenuElement</code> is selected or unselected.
             *
             * @param isIncluded  true if this menu item is on the part of the menu
             * path that changed, false if this menu is part of the
             * a menu path that changed, but this particular part of
             * that path is still the same
             * @see MenuSelectionManager#setSelectedPath(MenuElement[])
             */
            JMenuItem.prototype.menuSelectionChanged = function (isIncluded) {
                this.setArmed(isIncluded);
            };
            /**
             * This method returns an array containing the sub-menu
             * components for this menu component.
             *
             * @return an array of <code>MenuElement</code>s
             */
            JMenuItem.prototype.getSubElements = function () {
                return new Array(0);
            };
            /**
             * Returns the <code>java.awt.Component</code> used to paint
             * this object. The returned component will be used to convert
             * events and detect if an event is inside a menu component.
             *
             * @return the <code>Component</code> that paints this menu item
             */
            JMenuItem.prototype.getComponent$ = function () {
                return this;
            };
            /**
             * Adds a <code>MenuKeyListener</code> to the menu item.
             *
             * @param l the <code>MenuKeyListener</code> to be added
             */
            JMenuItem.prototype.addMenuKeyListener = function (l) {
                this.listenerList.add("javax.swing.event.MenuKeyListener", l);
            };
            /**
             * Removes a <code>MenuKeyListener</code> from the menu item.
             *
             * @param l the <code>MenuKeyListener</code> to be removed
             */
            JMenuItem.prototype.removeMenuKeyListener = function (l) {
                this.listenerList.remove("javax.swing.event.MenuKeyListener", l);
            };
            /**
             * Returns an array of all the <code>MenuKeyListener</code>s added
             * to this JMenuItem with addMenuKeyListener().
             *
             * @return all of the <code>MenuKeyListener</code>s added or an empty
             * array if no listeners have been added
             * @since 1.4
             */
            JMenuItem.prototype.getMenuKeyListeners = function () {
                return this.listenerList.getListeners("javax.swing.event.MenuKeyListener");
            };
            /**
             * Returns a string representation of this <code>JMenuItem</code>.
             * This method is intended to be used only for debugging purposes,
             * and the content and format of the returned string may vary between
             * implementations. The returned string may be empty but may not
             * be <code>null</code>.
             *
             * @return  a string representation of this <code>JMenuItem</code>
             */
            JMenuItem.prototype.paramString = function () {
                return _super.prototype.paramString.call(this);
            };
            /**
             * @see #getUIClassID
             * @see #readObject
             */
            JMenuItem.uiClassID = "MenuItemUI";
            JMenuItem.TRACE = false;
            JMenuItem.VERBOSE = false;
            JMenuItem.DEBUG = false;
            return JMenuItem;
        }(javax.swing.AbstractButton));
        swing.JMenuItem = JMenuItem;
        JMenuItem["__class"] = "javax.swing.JMenuItem";
        JMenuItem["__interfaces"] = ["java.awt.ItemSelectable", "java.awt.HTMLComponent", "javax.swing.MenuElement", "javax.swing.SwingConstants", "java.io.Serializable"];
        var JMenuItem;
        (function (JMenuItem) {
            var MenuItemFocusListener = (function () {
                function MenuItemFocusListener() {
                }
                MenuItemFocusListener.prototype.focusGained = function (event) {
                };
                MenuItemFocusListener.prototype.focusLost = function (event) {
                    var mi = event.getSource();
                    if (mi.isFocusPainted()) {
                        mi.repaint();
                    }
                };
                return MenuItemFocusListener;
            }());
            JMenuItem.MenuItemFocusListener = MenuItemFocusListener;
            MenuItemFocusListener["__class"] = "javax.swing.JMenuItem.MenuItemFocusListener";
            MenuItemFocusListener["__interfaces"] = ["java.util.EventListener", "java.awt.event.FocusListener", "java.io.Serializable"];
        })(JMenuItem = swing.JMenuItem || (swing.JMenuItem = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var JToggleButton = (function (_super) {
            __extends(JToggleButton, _super);
            function JToggleButton(text, icon, selected) {
                var _this = this;
                if (((typeof text === 'string') || text === null) && ((icon != null && (icon["__interfaces"] != null && icon["__interfaces"].indexOf("javax.swing.Icon") >= 0 || icon.constructor != null && icon.constructor["__interfaces"] != null && icon.constructor["__interfaces"].indexOf("javax.swing.Icon") >= 0)) || icon === null) && ((typeof selected === 'boolean') || selected === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this);
                    this.buttonCreated = false;
                    (function () {
                        _this.setModel(new JToggleButton.ToggleButtonModel());
                        _this.model.setSelected(selected);
                        _this.init(text, icon);
                    })();
                }
                else if (((typeof text === 'string') || text === null) && ((icon != null && (icon["__interfaces"] != null && icon["__interfaces"].indexOf("javax.swing.Icon") >= 0 || icon.constructor != null && icon.constructor["__interfaces"] != null && icon.constructor["__interfaces"].indexOf("javax.swing.Icon") >= 0)) || icon === null) && selected === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_70 = Array.prototype.slice.call(arguments);
                        var selected_1 = false;
                        _super.call(this);
                        this.buttonCreated = false;
                        (function () {
                            _this.setModel(new JToggleButton.ToggleButtonModel());
                            _this.model.setSelected(selected_1);
                            _this.init(text, icon);
                        })();
                    }
                }
                else if (((text != null && (text["__interfaces"] != null && text["__interfaces"].indexOf("javax.swing.Icon") >= 0 || text.constructor != null && text.constructor["__interfaces"] != null && text.constructor["__interfaces"].indexOf("javax.swing.Icon") >= 0)) || text === null) && ((typeof icon === 'boolean') || icon === null) && selected === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var icon_10 = __args[0];
                    var selected_2 = __args[1];
                    {
                        var __args_71 = Array.prototype.slice.call(arguments);
                        var text_10 = null;
                        _super.call(this);
                        this.buttonCreated = false;
                        (function () {
                            _this.setModel(new JToggleButton.ToggleButtonModel());
                            _this.model.setSelected(selected_2);
                            _this.init(text_10, icon_10);
                        })();
                    }
                }
                else if (((typeof text === 'string') || text === null) && ((typeof icon === 'boolean') || icon === null) && selected === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var selected_3 = __args[1];
                    {
                        var __args_72 = Array.prototype.slice.call(arguments);
                        var icon_11 = null;
                        _super.call(this);
                        this.buttonCreated = false;
                        (function () {
                            _this.setModel(new JToggleButton.ToggleButtonModel());
                            _this.model.setSelected(selected_3);
                            _this.init(text, icon_11);
                        })();
                    }
                }
                else if (((text != null && (text["__interfaces"] != null && text["__interfaces"].indexOf("javax.swing.Icon") >= 0 || text.constructor != null && text.constructor["__interfaces"] != null && text.constructor["__interfaces"].indexOf("javax.swing.Icon") >= 0)) || text === null) && icon === undefined && selected === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var icon_12 = __args[0];
                    {
                        var __args_73 = Array.prototype.slice.call(arguments);
                        var text_11 = null;
                        var selected_4 = false;
                        _super.call(this);
                        this.buttonCreated = false;
                        (function () {
                            _this.setModel(new JToggleButton.ToggleButtonModel());
                            _this.model.setSelected(selected_4);
                            _this.init(text_11, icon_12);
                        })();
                    }
                }
                else if (((typeof text === 'string') || text === null) && icon === undefined && selected === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_74 = Array.prototype.slice.call(arguments);
                        var icon_13 = null;
                        var selected_5 = false;
                        _super.call(this);
                        this.buttonCreated = false;
                        (function () {
                            _this.setModel(new JToggleButton.ToggleButtonModel());
                            _this.model.setSelected(selected_5);
                            _this.init(text, icon_13);
                        })();
                    }
                }
                else if (((text != null && (text["__interfaces"] != null && text["__interfaces"].indexOf("javax.swing.Action") >= 0 || text.constructor != null && text.constructor["__interfaces"] != null && text.constructor["__interfaces"].indexOf("javax.swing.Action") >= 0)) || text === null) && icon === undefined && selected === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var a_6 = __args[0];
                    {
                        var __args_75 = Array.prototype.slice.call(arguments);
                        {
                            var __args_76 = Array.prototype.slice.call(arguments);
                            var text_12 = null;
                            var icon_14 = null;
                            var selected_6 = false;
                            _super.call(this);
                            this.buttonCreated = false;
                            (function () {
                                _this.setModel(new JToggleButton.ToggleButtonModel());
                                _this.model.setSelected(selected_6);
                                _this.init(text_12, icon_14);
                            })();
                        }
                    }
                    (function () {
                        _this.setAction(a_6);
                    })();
                }
                else if (text === undefined && icon === undefined && selected === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_77 = Array.prototype.slice.call(arguments);
                        var text_13 = null;
                        var icon_15 = null;
                        var selected_7 = false;
                        _super.call(this);
                        this.buttonCreated = false;
                        (function () {
                            _this.setModel(new JToggleButton.ToggleButtonModel());
                            _this.model.setSelected(selected_7);
                            _this.init(text_13, icon_15);
                        })();
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            JToggleButton.prototype.paramString = function () {
                return _super.prototype.paramString.call(this);
            };
            JToggleButton.prototype.createHTML = function () {
                if (this.htmlElement != null) {
                    return;
                }
                this.htmlElement = document.createElement("button");
                this.buttonCreated = true;
            };
            JToggleButton.prototype.initHTML = function () {
                _super.prototype.initHTML.call(this);
                if (this.buttonCreated) {
                    this.htmlElement.innerHTML = this.getText();
                }
            };
            JToggleButton.serialVersionUID = 1;
            return JToggleButton;
        }(javax.swing.AbstractButton));
        swing.JToggleButton = JToggleButton;
        JToggleButton["__class"] = "javax.swing.JToggleButton";
        JToggleButton["__interfaces"] = ["java.awt.ItemSelectable", "java.awt.HTMLComponent", "javax.swing.SwingConstants", "java.io.Serializable"];
        var JToggleButton;
        (function (JToggleButton) {
            var ToggleButtonModel = (function (_super) {
                __extends(ToggleButtonModel, _super);
                /**
                 * Creates a new ToggleButton Model
                 */
                function ToggleButtonModel() {
                    _super.call(this);
                }
                /**
                 * Checks if the button is selected.
                 */
                ToggleButtonModel.prototype.isSelected = function () {
                    return (this.stateMask & javax.swing.DefaultButtonModel.SELECTED_$LI$()) !== 0;
                };
                /**
                 * Sets the selected state of the button.
                 *
                 * @param b
                 * true selects the toggle button, false deselects the toggle
                 * button.
                 */
                ToggleButtonModel.prototype.setSelected = function (b) {
                    var group = this.getGroup();
                    if (group != null) {
                        group.setSelected(this, b);
                        b = group.isSelected(this);
                    }
                    if (this.isSelected() === b) {
                        return;
                    }
                    if (b) {
                        this.stateMask |= javax.swing.DefaultButtonModel.SELECTED_$LI$();
                    }
                    else {
                        this.stateMask &= ~javax.swing.DefaultButtonModel.SELECTED_$LI$();
                    }
                    this.fireStateChanged();
                    this.fireItemStateChanged(new java.awt.event.ItemEvent(this, java.awt.event.ItemEvent.ITEM_STATE_CHANGED_$LI$(), this, this.isSelected() ? java.awt.event.ItemEvent.SELECTED : java.awt.event.ItemEvent.DESELECTED));
                };
                /**
                 * Sets the pressed state of the toggle button.
                 */
                ToggleButtonModel.prototype.setPressed = function (b) {
                    if ((this.isPressed() === b) || !this.isEnabled()) {
                        return;
                    }
                    if (b === false && this.isArmed()) {
                        this.setSelected(!this.isSelected());
                    }
                    if (b) {
                        this.stateMask |= javax.swing.DefaultButtonModel.PRESSED_$LI$();
                    }
                    else {
                        this.stateMask &= ~javax.swing.DefaultButtonModel.PRESSED_$LI$();
                    }
                    this.fireStateChanged();
                    if (!this.isPressed() && this.isArmed()) {
                        var modifiers = 0;
                        this.fireActionPerformed(new java.awt.event.ActionEvent(this, java.awt.event.ActionEvent.ACTION_PERFORMED_$LI$(), this.getActionCommand(), 0, modifiers));
                    }
                };
                return ToggleButtonModel;
            }(javax.swing.DefaultButtonModel));
            JToggleButton.ToggleButtonModel = ToggleButtonModel;
            ToggleButtonModel["__class"] = "javax.swing.JToggleButton.ToggleButtonModel";
            ToggleButtonModel["__interfaces"] = ["java.awt.ItemSelectable", "javax.swing.ButtonModel", "java.io.Serializable"];
        })(JToggleButton = swing.JToggleButton || (swing.JToggleButton = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var JTextArea = (function (_super) {
            __extends(JTextArea, _super);
            function JTextArea(doc, text, rows, columns) {
                var _this = this;
                if (((doc != null) || doc === null) && ((typeof text === 'string') || text === null) && ((typeof rows === 'number') || rows === null) && ((typeof columns === 'number') || columns === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this);
                    this.rows = 0;
                    this.columns = 0;
                    this.columnWidth = 0;
                    this.rowHeight = 0;
                    this.wrap = false;
                    this.word = false;
                    (function () {
                        _this.rows = rows;
                        _this.columns = columns;
                        if (text != null) {
                            _this.setText(text);
                        }
                        if (rows < 0) {
                            throw new java.lang.IllegalArgumentException("rows: " + rows);
                        }
                        if (columns < 0) {
                            throw new java.lang.IllegalArgumentException("columns: " + columns);
                        }
                    })();
                }
                else if (((typeof doc === 'string') || doc === null) && ((typeof text === 'number') || text === null) && ((typeof rows === 'number') || rows === null) && columns === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var text_14 = __args[0];
                    var rows_1 = __args[1];
                    var columns_1 = __args[2];
                    {
                        var __args_78 = Array.prototype.slice.call(arguments);
                        var doc_1 = null;
                        _super.call(this);
                        this.rows = 0;
                        this.columns = 0;
                        this.columnWidth = 0;
                        this.rowHeight = 0;
                        this.wrap = false;
                        this.word = false;
                        (function () {
                            _this.rows = rows_1;
                            _this.columns = columns_1;
                            if (text_14 != null) {
                                _this.setText(text_14);
                            }
                            if (rows_1 < 0) {
                                throw new java.lang.IllegalArgumentException("rows: " + rows_1);
                            }
                            if (columns_1 < 0) {
                                throw new java.lang.IllegalArgumentException("columns: " + columns_1);
                            }
                        })();
                    }
                }
                else if (((typeof doc === 'number') || doc === null) && ((typeof text === 'number') || text === null) && rows === undefined && columns === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var rows_2 = __args[0];
                    var columns_2 = __args[1];
                    {
                        var __args_79 = Array.prototype.slice.call(arguments);
                        var doc_2 = null;
                        var text_15 = null;
                        _super.call(this);
                        this.rows = 0;
                        this.columns = 0;
                        this.columnWidth = 0;
                        this.rowHeight = 0;
                        this.wrap = false;
                        this.word = false;
                        (function () {
                            _this.rows = rows_2;
                            _this.columns = columns_2;
                            if (text_15 != null) {
                                _this.setText(text_15);
                            }
                            if (rows_2 < 0) {
                                throw new java.lang.IllegalArgumentException("rows: " + rows_2);
                            }
                            if (columns_2 < 0) {
                                throw new java.lang.IllegalArgumentException("columns: " + columns_2);
                            }
                        })();
                    }
                }
                else if (((typeof doc === 'string') || doc === null) && text === undefined && rows === undefined && columns === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var text_16 = __args[0];
                    {
                        var __args_80 = Array.prototype.slice.call(arguments);
                        var doc_3 = null;
                        var rows_3 = 0;
                        var columns_3 = 0;
                        _super.call(this);
                        this.rows = 0;
                        this.columns = 0;
                        this.columnWidth = 0;
                        this.rowHeight = 0;
                        this.wrap = false;
                        this.word = false;
                        (function () {
                            _this.rows = rows_3;
                            _this.columns = columns_3;
                            if (text_16 != null) {
                                _this.setText(text_16);
                            }
                            if (rows_3 < 0) {
                                throw new java.lang.IllegalArgumentException("rows: " + rows_3);
                            }
                            if (columns_3 < 0) {
                                throw new java.lang.IllegalArgumentException("columns: " + columns_3);
                            }
                        })();
                    }
                }
                else if (doc === undefined && text === undefined && rows === undefined && columns === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_81 = Array.prototype.slice.call(arguments);
                        var doc_4 = null;
                        var text_17 = null;
                        var rows_4 = 0;
                        var columns_4 = 0;
                        _super.call(this);
                        this.rows = 0;
                        this.columns = 0;
                        this.columnWidth = 0;
                        this.rowHeight = 0;
                        this.wrap = false;
                        this.word = false;
                        (function () {
                            _this.rows = rows_4;
                            _this.columns = columns_4;
                            if (text_17 != null) {
                                _this.setText(text_17);
                            }
                            if (rows_4 < 0) {
                                throw new java.lang.IllegalArgumentException("rows: " + rows_4);
                            }
                            if (columns_4 < 0) {
                                throw new java.lang.IllegalArgumentException("columns: " + columns_4);
                            }
                        })();
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            JTextArea.prototype.getHTMLElement = function () {
                return this.htmlElement;
            };
            JTextArea.prototype.createHTML = function () {
                if (this.htmlElement != null) {
                    return;
                }
                this.htmlElement = document.createElement("textarea");
            };
            JTextArea.prototype.initHTML = function () {
                _super.prototype.initHTML.call(this);
                this.getHTMLElement().value = this.text;
                this.getHTMLElement().rows = this.rows;
                this.getHTMLElement().cols = this.columns;
                this.getHTMLElement().readOnly = !this.editable;
            };
            JTextArea.prototype.getUIClassID = function () {
                return JTextArea.uiClassID;
            };
            JTextArea.prototype.setLineWrap = function (wrap) {
                var old = this.wrap;
                this.wrap = wrap;
                this.firePropertyChange("lineWrap", old, wrap);
            };
            JTextArea.prototype.getLineWrap = function () {
                return this.wrap;
            };
            JTextArea.prototype.setWrapStyleWord = function (word) {
                var old = this.word;
                this.word = word;
                this.firePropertyChange("wrapStyleWord", old, word);
            };
            JTextArea.prototype.getWrapStyleWord = function () {
                return this.word;
            };
            JTextArea.prototype.insert = function (str, pos) {
                this.setText(([(this.text).slice(0, pos), str, (this.text).slice(pos)]).join(""));
            };
            JTextArea.prototype.append = function (str) {
                this.setText(this.text + str);
            };
            JTextArea.prototype.setText = function (text) {
                _super.prototype.setText.call(this, text);
                if (this.htmlElement != null) {
                    this.getHTMLElement().value = text;
                }
            };
            JTextArea.prototype.setEditable = function (editable) {
                _super.prototype.setEditable.call(this, editable);
                if (this.htmlElement != null) {
                    this.getHTMLElement().readOnly = !editable;
                }
            };
            JTextArea.prototype.replaceRange = function (str, start, end) {
                this.setText(this.text.substring(0, start) + str + this.text.substring(end));
            };
            JTextArea.prototype.getRows = function () {
                return this.rows;
            };
            JTextArea.prototype.setRows = function (rows) {
                var oldVal = this.rows;
                if (rows < 0) {
                    throw new java.lang.IllegalArgumentException("rows less than zero.");
                }
                if (rows !== oldVal) {
                    this.rows = rows;
                    if (this.htmlElement != null) {
                        this.getHTMLElement().rows = rows;
                    }
                    this.invalidate();
                }
            };
            JTextArea.prototype.getColumns = function () {
                return this.columns;
            };
            JTextArea.prototype.setColumns = function (columns) {
                var oldVal = this.columns;
                if (columns < 0) {
                    throw new java.lang.IllegalArgumentException("columns less than zero.");
                }
                if (columns !== oldVal) {
                    this.columns = columns;
                    if (this.htmlElement != null) {
                        this.getHTMLElement().cols = columns;
                    }
                    this.invalidate();
                }
            };
            JTextArea.prototype.paramString = function () {
                var wrapString = (this.wrap ? "true" : "false");
                var wordString = (this.word ? "true" : "false");
                return _super.prototype.paramString.call(this) + ",colums=" + this.columns + ",columWidth=" + this.columnWidth + ",rows=" + this.rows + ",rowHeight=" + this.rowHeight + ",word=" + wordString + ",wrap=" + wrapString;
            };
            JTextArea.uiClassID = "TextAreaUI";
            return JTextArea;
        }(javax.swing.text.JTextComponent));
        swing.JTextArea = JTextArea;
        JTextArea["__class"] = "javax.swing.JTextArea";
        JTextArea["__interfaces"] = ["java.awt.HTMLComponent", "java.io.Serializable"];
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var JTextField = (function (_super) {
            __extends(JTextField, _super);
            function JTextField(doc, text, columns) {
                var _this = this;
                if (((doc != null) || doc === null) && ((typeof text === 'string') || text === null) && ((typeof columns === 'number') || columns === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this);
                    this.horizontalAlignment = javax.swing.SwingConstants.LEADING;
                    this.columns = 0;
                    this.columnWidth = 0;
                    (function () {
                        if (columns < 0) {
                            throw new java.lang.IllegalArgumentException("columns less than zero.");
                        }
                        _this.columns = columns;
                        if (text != null) {
                            _this.setText(text);
                        }
                    })();
                }
                else if (((typeof doc === 'string') || doc === null) && ((typeof text === 'number') || text === null) && columns === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var text_18 = __args[0];
                    var columns_5 = __args[1];
                    {
                        var __args_82 = Array.prototype.slice.call(arguments);
                        var doc_5 = null;
                        _super.call(this);
                        this.horizontalAlignment = javax.swing.SwingConstants.LEADING;
                        this.columns = 0;
                        this.columnWidth = 0;
                        (function () {
                            if (columns_5 < 0) {
                                throw new java.lang.IllegalArgumentException("columns less than zero.");
                            }
                            _this.columns = columns_5;
                            if (text_18 != null) {
                                _this.setText(text_18);
                            }
                        })();
                    }
                }
                else if (((typeof doc === 'string') || doc === null) && text === undefined && columns === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var text_19 = __args[0];
                    {
                        var __args_83 = Array.prototype.slice.call(arguments);
                        var doc_6 = null;
                        var columns_6 = 0;
                        _super.call(this);
                        this.horizontalAlignment = javax.swing.SwingConstants.LEADING;
                        this.columns = 0;
                        this.columnWidth = 0;
                        (function () {
                            if (columns_6 < 0) {
                                throw new java.lang.IllegalArgumentException("columns less than zero.");
                            }
                            _this.columns = columns_6;
                            if (text_19 != null) {
                                _this.setText(text_19);
                            }
                        })();
                    }
                }
                else if (((typeof doc === 'number') || doc === null) && text === undefined && columns === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var columns_7 = __args[0];
                    {
                        var __args_84 = Array.prototype.slice.call(arguments);
                        var doc_7 = null;
                        var text_20 = null;
                        _super.call(this);
                        this.horizontalAlignment = javax.swing.SwingConstants.LEADING;
                        this.columns = 0;
                        this.columnWidth = 0;
                        (function () {
                            if (columns_7 < 0) {
                                throw new java.lang.IllegalArgumentException("columns less than zero.");
                            }
                            _this.columns = columns_7;
                            if (text_20 != null) {
                                _this.setText(text_20);
                            }
                        })();
                    }
                }
                else if (doc === undefined && text === undefined && columns === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_85 = Array.prototype.slice.call(arguments);
                        var doc_8 = null;
                        var text_21 = null;
                        var columns_8 = 0;
                        _super.call(this);
                        this.horizontalAlignment = javax.swing.SwingConstants.LEADING;
                        this.columns = 0;
                        this.columnWidth = 0;
                        (function () {
                            if (columns_8 < 0) {
                                throw new java.lang.IllegalArgumentException("columns less than zero.");
                            }
                            _this.columns = columns_8;
                            if (text_21 != null) {
                                _this.setText(text_21);
                            }
                        })();
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            JTextField.prototype.getHTMLElement = function () {
                return this.htmlElement;
            };
            JTextField.prototype.createHTML = function () {
                if (this.htmlElement != null) {
                    return;
                }
                this.htmlElement = document.createElement("input");
                this.htmlElement.setAttribute("type", "text");
            };
            JTextField.prototype.initHTML = function () {
                _super.prototype.initHTML.call(this);
                this.getHTMLElement().value = this.text;
                this.getHTMLElement().readOnly = !this.editable;
                this.initActionListeners();
            };
            JTextField.prototype.initActionListeners = function () {
                var _this = this;
                {
                    var array141 = this.getActionListeners();
                    for (var index140 = 0; index140 < array141.length; index140++) {
                        var actionListener = array141[index140];
                        {
                            this.htmlElement.addEventListener("click", (function (actionListener) {
                                return function (e) {
                                    actionListener.actionPerformed(new java.awt.event.ActionEvent(_this, 0, null));
                                    return e;
                                };
                            })(actionListener));
                        }
                    }
                }
            };
            JTextField.prototype.setText = function (text) {
                _super.prototype.setText.call(this, text);
                if (this.htmlElement != null) {
                    this.getHTMLElement().value = text;
                }
            };
            JTextField.prototype.setEditable = function (editable) {
                _super.prototype.setEditable.call(this, editable);
                if (this.htmlElement != null) {
                    this.getHTMLElement().readOnly = !editable;
                }
            };
            /**
             * Gets the class ID for a UI.
             *
             * @return the string "TextFieldUI"
             * @see JComponent#getUIClassID
             * @see UIDefaults#getUI
             */
            JTextField.prototype.getUIClassID = function () {
                return JTextField.uiClassID;
            };
            /**
             * Returns the horizontal alignment of the text. Valid keys are:
             * <ul>
             * <li><code>JTextField.LEFT</code>
             * <li><code>JTextField.CENTER</code>
             * <li><code>JTextField.RIGHT</code>
             * <li><code>JTextField.LEADING</code>
             * <li><code>JTextField.TRAILING</code>
             * </ul>
             *
             * @return the horizontal alignment
             */
            JTextField.prototype.getHorizontalAlignment = function () {
                return this.horizontalAlignment;
            };
            JTextField.prototype.setHorizontalAlignment = function (alignment) {
                if (alignment === this.horizontalAlignment)
                    return;
                var oldValue = this.horizontalAlignment;
                if ((alignment === javax.swing.SwingConstants.LEFT) || (alignment === javax.swing.SwingConstants.CENTER) || (alignment === javax.swing.SwingConstants.RIGHT) || (alignment === javax.swing.SwingConstants.LEADING) || (alignment === javax.swing.SwingConstants.TRAILING)) {
                    this.horizontalAlignment = alignment;
                }
                else {
                    throw new java.lang.IllegalArgumentException("horizontalAlignment");
                }
                this.firePropertyChange("horizontalAlignment", oldValue, this.horizontalAlignment);
                this.invalidate();
                this.repaint();
            };
            /**
             * Returns the number of columns in this <code>TextField</code>.
             *
             * @return the number of columns &gt;= 0
             */
            JTextField.prototype.getColumns = function () {
                return this.columns;
            };
            /**
             * Sets the number of columns in this <code>TextField</code>, and then
             * invalidate the layout.
             *
             * @param columns
             * the number of columns &gt;= 0
             * @exception IllegalArgumentException
             * if <code>columns</code> is less than 0
             * @beaninfo description: the number of columns preferred for display
             */
            JTextField.prototype.setColumns = function (columns) {
                var oldVal = this.columns;
                if (columns < 0) {
                    throw new java.lang.IllegalArgumentException("columns less than zero.");
                }
                if (columns !== oldVal) {
                    this.columns = columns;
                    this.invalidate();
                }
            };
            /**
             * Returns the preferred size <code>Dimensions</code> needed for this
             * <code>TextField</code>. If a non-zero number of columns has been set, the
             * width is set to the columns multiplied by the column width.
             *
             * @return the dimension of this textfield
             */
            JTextField.prototype.getPreferredSize = function () {
                var size = _super.prototype.getPreferredSize.call(this);
                return size;
            };
            /**
             * Sets the current font. This removes cached row height and column width so
             * the new font will be reflected. <code>revalidate</code> is called after
             * setting the font.
             *
             * @param f
             * the new font
             */
            JTextField.prototype.setFont = function (f) {
                _super.prototype.setFont.call(this, f);
                this.columnWidth = 0;
            };
            /**
             * Adds the specified action listener to receive action events from this
             * textfield.
             *
             * @param l
             * the action listener to be added
             */
            JTextField.prototype.addActionListener = function (l) {
                this.listenerList.add("java.awt.event.ActionListener", l);
            };
            /**
             * Removes the specified action listener so that it no longer receives
             * action events from this textfield.
             *
             * @param l
             * the action listener to be removed
             */
            JTextField.prototype.removeActionListener = function (l) {
                if ((l != null) && (this.getAction() === l)) {
                    this.setAction(null);
                }
                else {
                    this.listenerList.remove("java.awt.event.ActionListener", l);
                }
            };
            /**
             * Returns an array of all the <code>ActionListener</code>s added to this
             * JTextField with addActionListener().
             *
             * @return all of the <code>ActionListener</code>s added or an empty array
             * if no listeners have been added
             * @since 1.4
             */
            JTextField.prototype.getActionListeners = function () {
                return this.listenerList.getListeners("java.awt.event.ActionListener");
            };
            /**
             * Notifies all listeners that have registered interest for notification on
             * this event type. The event instance is lazily created. The listener list
             * is processed in last to first order.
             *
             * @see EventListenerList
             */
            JTextField.prototype.fireActionPerformed = function () {
                var listeners = this.listenerList.getListenerList();
                var modifiers = 0;
                var e = new java.awt.event.ActionEvent(this, java.awt.event.ActionEvent.ACTION_PERFORMED_$LI$(), (this.command != null) ? this.command : this.getText(), 0, modifiers);
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "java.awt.event.ActionListener") {
                        listeners[i + 1].actionPerformed(e);
                    }
                }
            };
            JTextField.prototype.setActionCommand = function (command) {
                this.command = command;
            };
            JTextField.prototype.setAction = function (a) {
                var oldValue = this.getAction();
                if (this.action == null || !this.action.equals(a)) {
                    this.action = a;
                    if (oldValue != null) {
                        this.removeActionListener(oldValue);
                        oldValue.removePropertyChangeListener(this.actionPropertyChangeListener);
                        this.actionPropertyChangeListener = null;
                    }
                    this.configurePropertiesFromAction(this.action);
                    if (this.action != null) {
                        if (!this.isListener("java.awt.event.ActionListener", this.action)) {
                            this.addActionListener(this.action);
                        }
                        this.actionPropertyChangeListener = this.createActionPropertyChangeListener(this.action);
                        this.action.addPropertyChangeListener(this.actionPropertyChangeListener);
                    }
                    this.firePropertyChange("action", oldValue, this.action);
                }
            };
            JTextField.prototype.isListener = function (c, a) {
                var _this = this;
                if (((c != null && c instanceof java.lang.Class) || c === null) && ((a != null && (a["__interfaces"] != null && a["__interfaces"].indexOf("java.awt.event.ActionListener") >= 0 || a.constructor != null && a.constructor["__interfaces"] != null && a.constructor["__interfaces"].indexOf("java.awt.event.ActionListener") >= 0)) || a === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        var isListener = false;
                        var listeners = _this.listenerList.getListenerList();
                        for (var i = listeners.length - 2; i >= 0; i -= 2) {
                            if (listeners[i] === c && listeners[i + 1] === a) {
                                isListener = true;
                            }
                        }
                        return isListener;
                    })();
                }
                else if (((typeof c === 'string') || c === null) && ((a != null && (a["__interfaces"] != null && a["__interfaces"].indexOf("java.awt.event.ActionListener") >= 0 || a.constructor != null && a.constructor["__interfaces"] != null && a.constructor["__interfaces"].indexOf("java.awt.event.ActionListener") >= 0)) || a === null)) {
                    return this.isListener$java_lang_String$java_awt_event_ActionListener(c, a);
                }
                else
                    throw new Error('invalid overload');
            };
            JTextField.prototype.isListener$java_lang_String$java_awt_event_ActionListener = function (c, a) {
                var isListener = false;
                var listeners = this.listenerList.getListenerList();
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === c && listeners[i + 1] === a) {
                        isListener = true;
                    }
                }
                return isListener;
            };
            JTextField.prototype.getAction = function () {
                return this.action;
            };
            JTextField.prototype.configurePropertiesFromAction = function (a) {
                javax.swing.AbstractAction.setEnabledFromAction(this, a);
                javax.swing.AbstractAction.setToolTipTextFromAction(this, a);
                this.setActionCommandFromAction(a);
            };
            JTextField.prototype.actionPropertyChanged = function (action, propertyName) {
                if (propertyName === javax.swing.Action.ACTION_COMMAND_KEY) {
                    this.setActionCommandFromAction(action);
                }
                else if (propertyName === "enabled") {
                    javax.swing.AbstractAction.setEnabledFromAction(this, action);
                }
                else if (propertyName === javax.swing.Action.SHORT_DESCRIPTION) {
                    javax.swing.AbstractAction.setToolTipTextFromAction(this, action);
                }
            };
            JTextField.prototype.setActionCommandFromAction = function (action) {
                this.setActionCommand((action == null) ? null : action.getValue(javax.swing.Action.ACTION_COMMAND_KEY));
            };
            JTextField.prototype.createActionPropertyChangeListener = function (a) {
                return new JTextField.TextFieldActionPropertyChangeListener(this, a);
            };
            /**
             * Fetches the command list for the editor. This is the list of commands
             * supported by the plugged-in UI augmented by the collection of commands
             * that the editor itself supports. These are useful for binding to events,
             * such as in a keymap.
             *
             * @return the command list
             */
            JTextField.prototype.getActions = function () {
                return JTextField.defaultActions_$LI$();
            };
            /**
             * Processes action events occurring on this textfield by dispatching them
             * to any registered <code>ActionListener</code> objects. This is normally
             * called by the controller registered with textfield.
             */
            JTextField.prototype.postActionEvent = function () {
                this.fireActionPerformed();
            };
            /**
             * Returns true if the receiver has an <code>ActionListener</code>
             * installed.
             */
            JTextField.prototype.hasActionListener = function () {
                var listeners = this.listenerList.getListenerList();
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "java.awt.event.ActionListener") {
                        return true;
                    }
                }
                return false;
            };
            JTextField.defaultActions_$LI$ = function () { if (JTextField.defaultActions == null)
                JTextField.defaultActions = []; return JTextField.defaultActions; };
            ;
            /**
             * Returns a string representation of this <code>JTextField</code>. This
             * method is intended to be used only for debugging purposes, and the
             * content and format of the returned string may vary between
             * implementations. The returned string may be empty but may not be
             * <code>null</code>.
             *
             * @return a string representation of this <code>JTextField</code>
             */
            JTextField.prototype.paramString = function () {
                var horizontalAlignmentString;
                if (this.horizontalAlignment === javax.swing.SwingConstants.LEFT) {
                    horizontalAlignmentString = "LEFT";
                }
                else if (this.horizontalAlignment === javax.swing.SwingConstants.CENTER) {
                    horizontalAlignmentString = "CENTER";
                }
                else if (this.horizontalAlignment === javax.swing.SwingConstants.RIGHT) {
                    horizontalAlignmentString = "RIGHT";
                }
                else if (this.horizontalAlignment === javax.swing.SwingConstants.LEADING) {
                    horizontalAlignmentString = "LEADING";
                }
                else if (this.horizontalAlignment === javax.swing.SwingConstants.TRAILING) {
                    horizontalAlignmentString = "TRAILING";
                }
                else
                    horizontalAlignmentString = "";
                var commandString = (this.command != null ? this.command : "");
                return _super.prototype.paramString.call(this) + ",columns=" + this.columns + ",columnWidth=" + this.columnWidth + ",command=" + commandString + ",horizontalAlignment=" + horizontalAlignmentString;
            };
            /**
             * Name of the action to send notification that the contents of the field
             * have been accepted. Typically this is bound to a carriage-return.
             */
            JTextField.notifyAction = "notify-field-accept";
            /**
             * @see #getUIClassID
             * @see #readObject
             */
            JTextField.uiClassID = "TextFieldUI";
            return JTextField;
        }(javax.swing.text.JTextComponent));
        swing.JTextField = JTextField;
        JTextField["__class"] = "javax.swing.JTextField";
        JTextField["__interfaces"] = ["java.awt.HTMLComponent", "javax.swing.SwingConstants", "java.io.Serializable"];
        var JTextField;
        (function (JTextField) {
            var TextFieldActionPropertyChangeListener = (function (_super) {
                __extends(TextFieldActionPropertyChangeListener, _super);
                function TextFieldActionPropertyChangeListener(tf, a) {
                    _super.call(this, tf, a);
                }
                TextFieldActionPropertyChangeListener.prototype.actionPropertyChanged = function (textField, action, e) {
                    if (((textField != null && textField instanceof javax.swing.JTextField) || textField === null) && ((action != null && (action["__interfaces"] != null && action["__interfaces"].indexOf("javax.swing.Action") >= 0 || action.constructor != null && action.constructor["__interfaces"] != null && action.constructor["__interfaces"].indexOf("javax.swing.Action") >= 0)) || action === null) && ((e != null && e instanceof java.beans.PropertyChangeEvent) || e === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        return (function () {
                            textField.actionPropertyChanged(action, e.getPropertyName());
                        })();
                    }
                    else if (((textField != null) || textField === null) && ((action != null && (action["__interfaces"] != null && action["__interfaces"].indexOf("javax.swing.Action") >= 0 || action.constructor != null && action.constructor["__interfaces"] != null && action.constructor["__interfaces"].indexOf("javax.swing.Action") >= 0)) || action === null) && ((e != null && e instanceof java.beans.PropertyChangeEvent) || e === null)) {
                        return this.actionPropertyChanged$javax_swing_JComponent$javax_swing_Action$java_beans_PropertyChangeEvent(textField, action, e);
                    }
                    else
                        throw new Error('invalid overload');
                };
                return TextFieldActionPropertyChangeListener;
            }(javax.swing.ActionPropertyChangeListener));
            JTextField.TextFieldActionPropertyChangeListener = TextFieldActionPropertyChangeListener;
            TextFieldActionPropertyChangeListener["__class"] = "javax.swing.JTextField.TextFieldActionPropertyChangeListener";
            TextFieldActionPropertyChangeListener["__interfaces"] = ["java.util.EventListener", "java.beans.PropertyChangeListener", "java.io.Serializable"];
        })(JTextField = swing.JTextField || (swing.JTextField = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        /**
         * An implementation of a menu -- a popup window containing
         * <code>JMenuItem</code>s that is displayed when the user selects an item on
         * the <code>JMenuBar</code>. In addition to <code>JMenuItem</code>s, a
         * <code>JMenu</code> can also contain <code>JSeparator</code>s.
         * <p>
         * In essence, a menu is a button with an associated <code>JPopupMenu</code>.
         * When the "button" is pressed, the <code>JPopupMenu</code> appears. If the
         * "button" is on the <code>JMenuBar</code>, the menu is a top-level window. If
         * the "button" is another menu item, then the <code>JPopupMenu</code> is
         * "pull-right" menu.
         * <p>
         * Menus can be configured, and to some degree controlled, by
         * <code><a href="Action.html">Action</a></code>s. Using an <code>Action</code>
         * with a menu has many benefits beyond directly configuring a menu. Refer to
         * <a href="Action.html#buttonActions"> Swing Components Supporting
         * <code>Action</code></a> for more details, and you can find more information
         * in
         * <a href="http://docs.oracle.com/javase/tutorial/uiswing/misc/action.html">How
         * to Use Actions</a>, a section in <em>The Java Tutorial</em>.
         * <p>
         * For information and examples of using menus see <a href=
         * "http://docs.oracle.com/javase/tutorial/uiswing/components/menu.html">How to
         * Use Menus</a>, a section in <em>The Java Tutorial.</em>
         * <p>
         * <strong>Warning:</strong> Swing is not thread safe. For more information see
         * <a href="package-summary.html#threading">Swing's Threading Policy</a>.
         * <p>
         * <strong>Warning:</strong> Serialized objects of this class will not be
         * compatible with future Swing releases. The current serialization support is
         * appropriate for short term storage or RMI between applications running the
         * same version of Swing. As of 1.4, support for long term storage of all
         * JavaBeans&trade; has been added to the <code>java.beans</code> package.
         * Please see {@link java.beans.XMLEncoder}.
         *
         * @beaninfo attribute: isContainer true description: A popup window containing
         * menu items displayed in a menu bar.
         *
         * @author Georges Saab
         * @author David Karlton
         * @author Arnaud Weber
         * @see JMenuItem
         * @see JSeparator
         * @see JMenuBar
         * @see JPopupMenu
         */
        var JMenu = (function (_super) {
            __extends(JMenu, _super);
            /**
             * Constructs a new <code>JMenu</code> with the supplied string as its text
             * and specified as a tear-off menu or not.
             *
             * @param s
             * the text for the menu label
             * @param b
             * can the menu be torn off (not yet implemented)
             */
            function JMenu(s, b) {
                var _this = this;
                if (((typeof s === 'string') || s === null) && ((typeof b === 'boolean') || b === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_86 = Array.prototype.slice.call(arguments);
                        _super.call(this, s);
                        this.menuChangeListener = null;
                        this.menuEvent = null;
                        this.delay = 0;
                    }
                }
                else if (((typeof s === 'string') || s === null) && b === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    _super.call(this, s);
                    this.menuChangeListener = null;
                    this.menuEvent = null;
                    this.delay = 0;
                }
                else if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("javax.swing.Action") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("javax.swing.Action") >= 0)) || s === null) && b === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    var a_7 = __args[0];
                    {
                        var __args_87 = Array.prototype.slice.call(arguments);
                        {
                            var __args_88 = Array.prototype.slice.call(arguments);
                            var s_1 = "";
                            _super.call(this, s_1);
                            this.menuChangeListener = null;
                            this.menuEvent = null;
                            this.delay = 0;
                        }
                    }
                    (function () {
                        _this.setAction(a_7);
                    })();
                }
                else if (s === undefined && b === undefined) {
                    var __args = Array.prototype.slice.call(arguments);
                    {
                        var __args_89 = Array.prototype.slice.call(arguments);
                        var s_2 = "";
                        _super.call(this, s_2);
                        this.menuChangeListener = null;
                        this.menuEvent = null;
                        this.delay = 0;
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Overriden to do nothing. We want JMenu to be focusable, but
             * <code>JMenuItem</code> doesn't want to be, thus we override this do
             * nothing. We don't invoke <code>setFocusable(true)</code> after super's
             * constructor has completed as this has the side effect that
             * <code>JMenu</code> will be considered traversable via the keyboard, which
             * we don't want. Making a Component traversable by the keyboard after
             * invoking <code>setFocusable(true)</code> is OK, as
             * <code>setFocusable</code> is new API and is speced as such, but
             * internally we don't want to use it like this else we change the keyboard
             * traversability.
             */
            JMenu.prototype.initFocusability = function () {
            };
            /**
             * Returns the name of the L&amp;F class that renders this component.
             *
             * @return the string "MenuUI"
             * @see JComponent#getUIClassID
             * @see UIDefaults#getUI
             */
            JMenu.prototype.getUIClassID = function () {
                return JMenu.uiClassID;
            };
            /**
             * Sets the data model for the "menu button" -- the label that the user
             * clicks to open or close the menu.
             *
             * @param newModel
             * the <code>ButtonModel</code>
             * @see #getModel
             * @beaninfo description: The menu's model bound: true expert: true hidden:
             * true
             */
            JMenu.prototype.setModel = function (newModel) {
                var oldModel = this.getModel();
                _super.prototype.setModel.call(this, newModel);
                if (oldModel != null && this.menuChangeListener != null) {
                    oldModel.removeChangeListener(this.menuChangeListener);
                    this.menuChangeListener = null;
                }
                this.model = newModel;
                if (newModel != null) {
                    this.menuChangeListener = this.createMenuChangeListener();
                    newModel.addChangeListener(this.menuChangeListener);
                }
            };
            /**
             * Returns true if the menu is currently selected (highlighted).
             *
             * @return true if the menu is selected, else false
             */
            JMenu.prototype.isSelected = function () {
                return this.getModel().isSelected();
            };
            /**
             * Sets the selection status of the menu.
             *
             * @param b
             * true to select (highlight) the menu; false to de-select the
             * menu
             * @beaninfo description: When the menu is selected, its popup child is
             * shown. expert: true hidden: true
             */
            JMenu.prototype.setSelected = function (b) {
                var model = this.getModel();
                if (b !== model.isSelected()) {
                    this.getModel().setSelected(b);
                }
            };
            /**
             * Returns true if the menu's popup window is visible.
             *
             * @return true if the menu is visible, else false
             */
            JMenu.prototype.isPopupMenuVisible = function () {
                this.ensurePopupMenuCreated();
                return this.popupMenu.isVisible();
            };
            /**
             * Sets the visibility of the menu's popup. If the menu is not enabled, this
             * method will have no effect.
             *
             * @param b
             * a boolean value -- true to make the menu visible, false to
             * hide it
             * @beaninfo description: The popup menu's visibility expert: true hidden:
             * true
             */
            JMenu.prototype.setPopupMenuVisible = function (b) {
                if (JMenu.DEBUG) {
                    console.info("in JMenu.setPopupMenuVisible " + b);
                }
            };
            /**
             * Computes the origin for the <code>JMenu</code>'s popup menu. This method
             * uses Look and Feel properties named <code>Menu.menuPopupOffsetX</code>,
             * <code>Menu.menuPopupOffsetY</code>, <code>Menu.submenuPopupOffsetX</code>
             * , and <code>Menu.submenuPopupOffsetY</code> to adjust the exact location
             * of popup.
             *
             * @return a <code>Point</code> in the coordinate space of the menu which
             * should be used as the origin of the <code>JMenu</code>'s popup
             * menu
             *
             * @since 1.3
             */
            JMenu.prototype.getPopupMenuOrigin = function () {
                var x = 0;
                var y = 0;
                return new java.awt.Point(x, y);
            };
            /**
             * Returns the suggested delay, in milliseconds, before submenus are popped
             * up or down. Each look and feel (L&amp;F) may determine its own policy for
             * observing the <code>delay</code> property. In most cases, the delay is
             * not observed for top level menus or while dragging. The default for
             * <code>delay</code> is 0. This method is a property of the look and feel
             * code and is used to manage the idiosyncrasies of the various UI
             * implementations.
             *
             *
             * @return the <code>delay</code> property
             */
            JMenu.prototype.getDelay = function () {
                return this.delay;
            };
            /**
             * Sets the suggested delay before the menu's <code>PopupMenu</code> is
             * popped up or down. Each look and feel (L&amp;F) may determine it's own
             * policy for observing the delay property. In most cases, the delay is not
             * observed for top level menus or while dragging. This method is a property
             * of the look and feel code and is used to manage the idiosyncrasies of the
             * various UI implementations.
             *
             * @param d
             * the number of milliseconds to delay
             * @exception IllegalArgumentException
             * if <code>d</code> is less than 0
             * @beaninfo description: The delay between menu selection and making the
             * popup menu visible expert: true
             */
            JMenu.prototype.setDelay = function (d) {
                if (d < 0)
                    throw new java.lang.IllegalArgumentException("Delay must be a positive integer");
                this.delay = d;
            };
            JMenu.prototype.ensurePopupMenuCreated = function () {
            };
            /**
             * Sets the location of the popup component.
             *
             * @param x
             * the x coordinate of the popup's new position
             * @param y
             * the y coordinate of the popup's new position
             */
            JMenu.prototype.setMenuLocation = function (x, y) {
                if (this.popupMenu != null)
                    this.popupMenu.setLocation(x, y);
            };
            /**
             * Appends a menu item to the end of this menu. Returns the menu item added.
             *
             * @param menuItem
             * the <code>JMenuitem</code> to be added
             * @return the <code>JMenuItem</code> added
             */
            JMenu.prototype.add$javax_swing_JMenuItem = function (menuItem) {
                this.ensurePopupMenuCreated();
                return this.popupMenu.add(menuItem);
            };
            /**
             * Appends a component to the end of this menu. Returns the component added.
             *
             * @param c
             * the <code>Component</code> to add
             * @return the <code>Component</code> added
             */
            JMenu.prototype.add$java_awt_Component = function (c) {
                this.ensurePopupMenuCreated();
                this.popupMenu.add(c);
                return c;
            };
            /**
             * Adds the specified component to this container at the given position. If
             * <code>index</code> equals -1, the component will be appended to the end.
             *
             * @param c
             * the <code>Component</code> to add
             * @param index
             * the position at which to insert the component
             * @return the <code>Component</code> added
             * @see #remove
             * @see java.awt.Container#add(Component, int)
             */
            JMenu.prototype.add$java_awt_Component$int = function (c, index) {
                this.ensurePopupMenuCreated();
                this.popupMenu.add(c, index);
                return c;
            };
            /**
             * Creates a new menu item with the specified text and appends it to the end
             * of this menu.
             *
             * @param s
             * the string for the menu item to be added
             */
            JMenu.prototype.add$java_lang_String = function (s) {
                return this.add(new javax.swing.JMenuItem(s));
            };
            /**
             * Creates a new menu item attached to the specified <code>Action</code>
             * object and appends it to the end of this menu.
             *
             * @param a
             * the <code>Action</code> for the menu item to be added
             * @see Action
             */
            JMenu.prototype.add$javax_swing_Action = function (a) {
                var mi = this.createActionComponent(a);
                mi.setAction(a);
                this.add(mi);
                return mi;
            };
            /**
             * Factory method which creates the <code>JMenuItem</code> for
             * <code>Action</code>s added to the <code>JMenu</code>.
             *
             * @param a
             * the <code>Action</code> for the menu item to be added
             * @return the new menu item
             * @see Action
             *
             * @since 1.3
             */
            JMenu.prototype.createActionComponent = function (a) {
                var mi = (function (target) {
                    return target;
                })(new javax.swing.JMenuItem());
                return mi;
            };
            /**
             * Appends a new separator to the end of the menu.
             */
            JMenu.prototype.addSeparator = function () {
                this.ensurePopupMenuCreated();
                this.popupMenu.addSeparator();
            };
            /**
             * Inserts a new menu item with the specified text at a given position.
             *
             * @param s
             * the text for the menu item to add
             * @param pos
             * an integer specifying the position at which to add the new
             * menu item
             * @exception IllegalArgumentException
             * when the value of <code>pos</code> &lt; 0
             */
            JMenu.prototype.insert = function (s, pos) {
                var _this = this;
                if (((typeof s === 'string') || s === null) && ((typeof pos === 'number') || pos === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        if (pos < 0) {
                            throw new java.lang.IllegalArgumentException("index less than zero.");
                        }
                        _this.ensurePopupMenuCreated();
                        _this.popupMenu.insert(new javax.swing.JMenuItem(s), pos);
                    })();
                }
                else if (((s != null && s instanceof javax.swing.JMenuItem) || s === null) && ((typeof pos === 'number') || pos === null)) {
                    return this.insert$javax_swing_JMenuItem$int(s, pos);
                }
                else if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("javax.swing.Action") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("javax.swing.Action") >= 0)) || s === null) && ((typeof pos === 'number') || pos === null)) {
                    return this.insert$javax_swing_Action$int(s, pos);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Inserts the specified <code>JMenuitem</code> at a given position.
             *
             * @param mi
             * the <code>JMenuitem</code> to add
             * @param pos
             * an integer specifying the position at which to add the new
             * <code>JMenuitem</code>
             * @return the new menu item
             * @exception IllegalArgumentException
             * if the value of <code>pos</code> &lt; 0
             */
            JMenu.prototype.insert$javax_swing_JMenuItem$int = function (mi, pos) {
                if (pos < 0) {
                    throw new java.lang.IllegalArgumentException("index less than zero.");
                }
                this.ensurePopupMenuCreated();
                this.popupMenu.insert(mi, pos);
                return mi;
            };
            /**
             * Inserts a new menu item attached to the specified <code>Action</code>
             * object at a given position.
             *
             * @param a
             * the <code>Action</code> object for the menu item to add
             * @param pos
             * an integer specifying the position at which to add the new
             * menu item
             * @exception IllegalArgumentException
             * if the value of <code>pos</code> &lt; 0
             */
            JMenu.prototype.insert$javax_swing_Action$int = function (a, pos) {
                if (pos < 0) {
                    throw new java.lang.IllegalArgumentException("index less than zero.");
                }
                this.ensurePopupMenuCreated();
                var mi = new javax.swing.JMenuItem(a);
                this.popupMenu.insert(mi, pos);
                return mi;
            };
            /**
             * Inserts a separator at the specified position.
             *
             * @param index
             * an integer specifying the position at which to insert the menu
             * separator
             * @exception IllegalArgumentException
             * if the value of <code>index</code> &lt; 0
             */
            JMenu.prototype.insertSeparator = function (index) {
                if (index < 0) {
                    throw new java.lang.IllegalArgumentException("index less than zero.");
                }
                this.ensurePopupMenuCreated();
                this.popupMenu.insert(new javax.swing.JPopupMenu.Separator(), index);
            };
            /**
             * Returns the <code>JMenuItem</code> at the specified position. If the
             * component at <code>pos</code> is not a menu item, <code>null</code> is
             * returned. This method is included for AWT compatibility.
             *
             * @param pos
             * an integer specifying the position
             * @exception IllegalArgumentException
             * if the value of <code>pos</code> &lt; 0
             * @return the menu item at the specified position; or <code>null</code> if
             * the item as the specified position is not a menu item
             */
            JMenu.prototype.getItem = function (pos) {
                if (pos < 0) {
                    throw new java.lang.IllegalArgumentException("index less than zero.");
                }
                var c = this.getMenuComponent(pos);
                if (c != null && c instanceof javax.swing.JMenuItem) {
                    var mi = c;
                    return mi;
                }
                return null;
            };
            /**
             * Returns the number of items on the menu, including separators. This
             * method is included for AWT compatibility.
             *
             * @return an integer equal to the number of items on the menu
             * @see #getMenuComponentCount
             */
            JMenu.prototype.getItemCount = function () {
                return this.getMenuComponentCount();
            };
            /**
             * Returns true if the menu can be torn off. This method is not yet
             * implemented.
             *
             * @return true if the menu can be torn off, else false
             * @exception Error
             * if invoked -- this method is not yet implemented
             */
            JMenu.prototype.isTearOff = function () {
                throw new Error("boolean isTearOff() {} not yet implemented");
            };
            /**
             * Removes the specified menu item from this menu. If there is no popup
             * menu, this method will have no effect.
             *
             * @param item
             * the <code>JMenuItem</code> to be removed from the menu
             */
            JMenu.prototype.remove = function (item) {
                var _this = this;
                if (((item != null && item instanceof javax.swing.JMenuItem) || item === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        if (_this.popupMenu != null)
                            _this.popupMenu.remove(item);
                    })();
                }
                else if (((item != null && item instanceof java.awt.Component) || item === null)) {
                    return this.remove$java_awt_Component(item);
                }
                else if (((typeof item === 'number') || item === null)) {
                    return this.remove$int(item);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Removes the menu item at the specified index from this menu.
             *
             * @param pos
             * the position of the item to be removed
             * @exception IllegalArgumentException
             * if the value of <code>pos</code> &lt; 0, or if
             * <code>pos</code> is greater than the number of menu items
             */
            JMenu.prototype.remove$int = function (pos) {
                if (pos < 0) {
                    throw new java.lang.IllegalArgumentException("index less than zero.");
                }
                if (pos > this.getItemCount()) {
                    throw new java.lang.IllegalArgumentException("index greater than the number of items.");
                }
                if (this.popupMenu != null)
                    this.popupMenu.remove(pos);
            };
            /**
             * Removes the component <code>c</code> from this menu.
             *
             * @param c
             * the component to be removed
             */
            JMenu.prototype.remove$java_awt_Component = function (c) {
                if (this.popupMenu != null)
                    this.popupMenu.remove(c);
            };
            /**
             * Removes all menu items from this menu.
             */
            JMenu.prototype.removeAll = function () {
                if (this.popupMenu != null)
                    this.popupMenu.removeAll();
            };
            /**
             * Returns the number of components on the menu.
             *
             * @return an integer containing the number of components on the menu
             */
            JMenu.prototype.getMenuComponentCount = function () {
                var componentCount = 0;
                if (this.popupMenu != null)
                    componentCount = this.popupMenu.getComponentCount();
                return componentCount;
            };
            /**
             * Returns the component at position <code>n</code>.
             *
             * @param n
             * the position of the component to be returned
             * @return the component requested, or <code>null</code> if there is no
             * popup menu
             */
            JMenu.prototype.getMenuComponent = function (n) {
                if (this.popupMenu != null)
                    return this.popupMenu.getComponent(n);
                return null;
            };
            /**
             * Returns an array of <code>Component</code>s of the menu's subcomponents.
             * Note that this returns all <code>Component</code>s in the popup menu,
             * including separators.
             *
             * @return an array of <code>Component</code>s or an empty array if there is
             * no popup menu
             */
            JMenu.prototype.getMenuComponents = function () {
                if (this.popupMenu != null)
                    return this.popupMenu.getComponents();
                return new Array(0);
            };
            /**
             * Returns true if the menu is a 'top-level menu', that is, if it is the
             * direct child of a menubar.
             *
             * @return true if the menu is activated from the menu bar; false if the
             * menu is activated from a menu item on another menu
             */
            JMenu.prototype.isTopLevelMenu = function () {
                return false;
            };
            /**
             * Returns true if the specified component exists in the submenu hierarchy.
             *
             * @param c
             * the <code>Component</code> to be tested
             * @return true if the <code>Component</code> exists, false otherwise
             */
            JMenu.prototype.isMenuComponent = function (c) {
                if (c === this)
                    return true;
                if (c != null && c instanceof javax.swing.JPopupMenu) {
                    var comp = c;
                    if (comp === this.getPopupMenu())
                        return true;
                }
                var ncomponents = this.getMenuComponentCount();
                var component = this.getMenuComponents();
                for (var i = 0; i < ncomponents; i++) {
                    var comp2 = component[i];
                    if (comp2 === c)
                        return true;
                    if (comp2 != null && comp2 instanceof javax.swing.JMenu) {
                        var subMenu = comp2;
                        if (subMenu.isMenuComponent(c))
                            return true;
                    }
                }
                return false;
            };
            /**
             * Returns the popupmenu associated with this menu. If there is no
             * popupmenu, it will create one.
             */
            JMenu.prototype.getPopupMenu = function () {
                this.ensurePopupMenuCreated();
                return this.popupMenu;
            };
            /**
             * Adds a listener for menu events.
             *
             * @param l
             * the listener to be added
             */
            JMenu.prototype.addMenuListener = function (l) {
                this.listenerList.add("javax.swing.event.MenuListener", l);
            };
            /**
             * Removes a listener for menu events.
             *
             * @param l
             * the listener to be removed
             */
            JMenu.prototype.removeMenuListener = function (l) {
                this.listenerList.remove("javax.swing.event.MenuListener", l);
            };
            /**
             * Returns an array of all the <code>MenuListener</code>s added to this
             * JMenu with addMenuListener().
             *
             * @return all of the <code>MenuListener</code>s added or an empty array if
             * no listeners have been added
             * @since 1.4
             */
            JMenu.prototype.getMenuListeners = function () {
                return this.listenerList.getListeners("javax.swing.event.MenuListener");
            };
            /**
             * Notifies all listeners that have registered interest for notification on
             * this event type. The event instance is created lazily.
             *
             * @exception Error
             * if there is a <code>null</code> listener
             * @see EventListenerList
             */
            JMenu.prototype.fireMenuSelected = function () {
                if (JMenu.DEBUG) {
                    console.info("In JMenu.fireMenuSelected");
                }
                var listeners = this.listenerList.getListenerList();
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "javax.swing.event.MenuListener") {
                        if (listeners[i + 1] == null) {
                            throw new Error(this.getText() + " has a NULL Listener!! " + i);
                        }
                        else {
                            if (this.menuEvent == null)
                                this.menuEvent = new javax.swing.event.MenuEvent(this);
                            listeners[i + 1].menuSelected(this.menuEvent);
                        }
                    }
                }
            };
            /**
             * Notifies all listeners that have registered interest for notification on
             * this event type. The event instance is created lazily.
             *
             * @exception Error
             * if there is a <code>null</code> listener
             * @see EventListenerList
             */
            JMenu.prototype.fireMenuDeselected = function () {
                if (JMenu.DEBUG) {
                    console.info("In JMenu.fireMenuDeselected");
                }
                var listeners = this.listenerList.getListenerList();
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "javax.swing.event.MenuListener") {
                        if (listeners[i + 1] == null) {
                            throw new Error(this.getText() + " has a NULL Listener!! " + i);
                        }
                        else {
                            if (this.menuEvent == null)
                                this.menuEvent = new javax.swing.event.MenuEvent(this);
                            listeners[i + 1].menuDeselected(this.menuEvent);
                        }
                    }
                }
            };
            /**
             * Notifies all listeners that have registered interest for notification on
             * this event type. The event instance is created lazily.
             *
             * @exception Error
             * if there is a <code>null</code> listener
             * @see EventListenerList
             */
            JMenu.prototype.fireMenuCanceled = function () {
                if (JMenu.DEBUG) {
                    console.info("In JMenu.fireMenuCanceled");
                }
                var listeners = this.listenerList.getListenerList();
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "javax.swing.event.MenuListener") {
                        if (listeners[i + 1] == null) {
                            throw new Error(this.getText() + " has a NULL Listener!! " + i);
                        }
                        else {
                            if (this.menuEvent == null)
                                this.menuEvent = new javax.swing.event.MenuEvent(this);
                            listeners[i + 1].menuCanceled(this.menuEvent);
                        }
                    }
                }
            };
            JMenu.prototype.configureAcceleratorFromAction = function (a) {
            };
            JMenu.prototype.createMenuChangeListener = function () {
                return new JMenu.MenuChangeListener(this);
            };
            /**
             * Messaged when the menubar selection changes to activate or deactivate
             * this menu. Overrides <code>JMenuItem.menuSelectionChanged</code>.
             *
             * @param isIncluded
             * true if this menu is active, false if it is not
             */
            JMenu.prototype.menuSelectionChanged = function (isIncluded) {
                if (JMenu.DEBUG) {
                    console.info("In JMenu.menuSelectionChanged to " + isIncluded);
                }
                this.setSelected(isIncluded);
            };
            /**
             * Returns an array of <code>MenuElement</code>s containing the submenu for
             * this menu component. If popup menu is <code>null</code> returns an empty
             * array. This method is required to conform to the <code>MenuElement</code>
             * interface. Note that since <code>JSeparator</code>s do not conform to the
             * <code>MenuElement</code> interface, this array will only contain
             * <code>JMenuItem</code>s.
             *
             * @return an array of <code>MenuElement</code> objects
             */
            JMenu.prototype.getSubElements = function () {
                if (this.popupMenu == null)
                    return new Array(0);
                else {
                    var result = new Array(1);
                    result[0] = this.popupMenu;
                    return result;
                }
            };
            /**
             * Returns the <code>java.awt.Component</code> used to paint this
             * <code>MenuElement</code>. The returned component is used to convert
             * events and detect if an event is inside a menu component.
             */
            JMenu.prototype.getComponent$ = function () {
                return this;
            };
            /**
             * Processes key stroke events such as mnemonics and accelerators.
             *
             * @param evt
             * the key event to be processed
             */
            JMenu.prototype.processKeyEvent$java_awt_event_KeyEvent = function (evt) {
            };
            /**
             * Programmatically performs a "click". This overrides the method
             * <code>AbstractButton.doClick</code> in order to make the menu pop up.
             *
             * @param pressTime
             * indicates the number of milliseconds the button was pressed
             * for
             */
            JMenu.prototype.doClick = function (pressTime) {
                if (((typeof pressTime === 'number') || pressTime === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                    })();
                }
                else if (pressTime === undefined) {
                    return this.doClick$();
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Returns a string representation of this <code>JMenu</code>. This method
             * is intended to be used only for debugging purposes, and the content and
             * format of the returned string may vary between implementations. The
             * returned string may be empty but may not be <code>null</code>.
             *
             * @return a string representation of this JMenu.
             */
            JMenu.prototype.paramString = function () {
                return _super.prototype.paramString.call(this);
            };
            /**
             * @see #getUIClassID
             * @see #readObject
             */
            JMenu.uiClassID = "MenuUI";
            JMenu.DEBUG = false;
            return JMenu;
        }(javax.swing.JMenuItem));
        swing.JMenu = JMenu;
        JMenu["__class"] = "javax.swing.JMenu";
        JMenu["__interfaces"] = ["java.awt.ItemSelectable", "java.awt.HTMLComponent", "javax.swing.MenuElement", "javax.swing.SwingConstants", "java.io.Serializable"];
        var JMenu;
        (function (JMenu) {
            var MenuChangeListener = (function () {
                function MenuChangeListener(__parent) {
                    this.__parent = __parent;
                    this.isSelected = false;
                }
                MenuChangeListener.prototype.stateChanged = function (e) {
                    var model = e.getSource();
                    var modelSelected = model.isSelected();
                    if (modelSelected !== this.isSelected) {
                        if (modelSelected === true) {
                            this.__parent.fireMenuSelected();
                        }
                        else {
                            this.__parent.fireMenuDeselected();
                        }
                        this.isSelected = modelSelected;
                    }
                };
                return MenuChangeListener;
            }());
            JMenu.MenuChangeListener = MenuChangeListener;
            MenuChangeListener["__class"] = "javax.swing.JMenu.MenuChangeListener";
            MenuChangeListener["__interfaces"] = ["java.util.EventListener", "javax.swing.event.ChangeListener", "java.io.Serializable"];
        })(JMenu = swing.JMenu || (swing.JMenu = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        /**
         * An implementation of a popup menu -- a small window that pops up and displays
         * a series of choices. A <code>JPopupMenu</code> is used for the menu that
         * appears when the user selects an item on the menu bar. It is also used for
         * "pull-right" menu that appears when the selects a menu item that activates
         * it. Finally, a <code>JPopupMenu</code> can also be used anywhere else you
         * want a menu to appear. For example, when the user right-clicks in a specified
         * area.
         * <p>
         * For information and examples of using popup menus, see <a href=
         * "http://docs.oracle.com/javase/tutorial/uiswing/components/menu.html">How to
         * Use Menus</a> in <em>The Java Tutorial.</em>
         * <p>
         * <strong>Warning:</strong> Swing is not thread safe. For more information see
         * <a href="package-summary.html#threading">Swing's Threading Policy</a>.
         * <p>
         * <strong>Warning:</strong> Serialized objects of this class will not be
         * compatible with future Swing releases. The current serialization support is
         * appropriate for short term storage or RMI between applications running the
         * same version of Swing. As of 1.4, support for long term storage of all
         * JavaBeans&trade; has been added to the <code>java.beans</code> package.
         * Please see {@link java.beans.XMLEncoder}.
         *
         * @beaninfo attribute: isContainer false description: A small window that pops
         * up and displays a series of choices.
         *
         * @author Georges Saab
         * @author David Karlton
         * @author Arnaud Weber
         */
        var JPopupMenu = (function (_super) {
            __extends(JPopupMenu, _super);
            /**
             * Constructs a <code>JPopupMenu</code> with the specified title.
             *
             * @param label
             * the string that a UI may use to display as a title for the
             * popup menu.
             */
            function JPopupMenu(label) {
                if (label === void 0) { label = null; }
                _super.call(this);
                this.label = null;
                this.paintBorder = true;
                this.margin = null;
                this.desiredLocationX = 0;
                this.desiredLocationY = 0;
                this.label = label;
                this.setSelectionModel(new javax.swing.DefaultSingleSelectionModel());
            }
            JPopupMenu.prototype.createHTML = function () {
            };
            JPopupMenu.classLock_$LI$ = function () { if (JPopupMenu.classLock == null)
                JPopupMenu.classLock = new Object(); return JPopupMenu.classLock; };
            ;
            /**
             * Returns the name of the L&amp;F class that renders this component.
             *
             * @return the string "PopupMenuUI"
             * @see JComponent#getUIClassID
             * @see UIDefaults#getUI
             */
            JPopupMenu.prototype.getUIClassID = function () {
                return JPopupMenu.uiClassID;
            };
            /**
             * Returns the model object that handles single selections.
             *
             * @return the <code>selectionModel</code> property
             * @see SingleSelectionModel
             */
            JPopupMenu.prototype.getSelectionModel = function () {
                return this.selectionModel;
            };
            /**
             * Sets the model object to handle single selections.
             *
             * @param model
             * the new <code>SingleSelectionModel</code>
             * @see SingleSelectionModel
             * @beaninfo description: The selection model for the popup menu expert:
             * true
             */
            JPopupMenu.prototype.setSelectionModel = function (model) {
                this.selectionModel = model;
            };
            /**
             * Appends the specified menu item to the end of this menu.
             *
             * @param menuItem
             * the <code>JMenuItem</code> to add
             * @return the <code>JMenuItem</code> added
             */
            JPopupMenu.prototype.add$javax_swing_JMenuItem = function (menuItem) {
                _super.prototype.add.call(this, menuItem);
                return menuItem;
            };
            /**
             * Creates a new menu item with the specified text and appends it to the end
             * of this menu.
             *
             * @param s
             * the string for the menu item to be added
             */
            JPopupMenu.prototype.add$java_lang_String = function (s) {
                return this.add(new javax.swing.JMenuItem(s));
            };
            /**
             * Appends a new menu item to the end of the menu which dispatches the
             * specified <code>Action</code> object.
             *
             * @param a
             * the <code>Action</code> to add to the menu
             * @return the new menu item
             * @see Action
             */
            JPopupMenu.prototype.add$javax_swing_Action = function (a) {
                var mi = this.createActionComponent(a);
                mi.setAction(a);
                this.add(mi);
                return mi;
            };
            /**
             * Factory method which creates the <code>JMenuItem</code> for
             * <code>Actions</code> added to the <code>JPopupMenu</code>.
             *
             * @param a
             * the <code>Action</code> for the menu item to be added
             * @return the new menu item
             * @see Action
             *
             * @since 1.3
             */
            JPopupMenu.prototype.createActionComponent = function (a) {
                var mi = (function (target) {
                    return target;
                })(new javax.swing.JMenuItem());
                return mi;
            };
            /**
             * Returns a properly configured <code>PropertyChangeListener</code> which
             * updates the control as changes to the <code>Action</code> occur.
             */
            JPopupMenu.prototype.createActionChangeListener = function (b) {
                return null;
            };
            JPopupMenu.prototype.remove = function (item) {
                if (((item != null && item instanceof java.awt.Component) || item === null)) {
                    return this.remove$java_awt_Component(item);
                }
                else if (((typeof item === 'number') || item === null)) {
                    return this.remove$int(item);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Removes the component at the specified index from this popup menu.
             *
             * @param pos
             * the position of the item to be removed
             * @exception IllegalArgumentException
             * if the value of <code>pos</code> &lt; 0, or if the value
             * of <code>pos</code> is greater than the number of items
             */
            JPopupMenu.prototype.remove$int = function (pos) {
                if (pos < 0) {
                    throw new java.lang.IllegalArgumentException("index less than zero.");
                }
                if (pos > this.getComponentCount() - 1) {
                    throw new java.lang.IllegalArgumentException("index greater than the number of items.");
                }
                _super.prototype.remove.call(this, pos);
            };
            /**
             * Returns the popup menu's label
             *
             * @return a string containing the popup menu's label
             * @see #setLabel
             */
            JPopupMenu.prototype.getLabel = function () {
                return this.label;
            };
            /**
             * Sets the popup menu's label. Different look and feels may choose to
             * display or not display this.
             *
             * @param label
             * a string specifying the label for the popup menu
             *
             * @see #setLabel
             * @beaninfo description: The label for the popup menu. bound: true
             */
            JPopupMenu.prototype.setLabel = function (label) {
                var oldValue = this.label;
                this.label = label;
                this.firePropertyChange("label", oldValue, label);
                if (this.htmlElement != null) {
                    this.initHTML();
                }
            };
            /**
             * Appends a new separator at the end of the menu.
             */
            JPopupMenu.prototype.addSeparator = function () {
                this.add(new JPopupMenu.Separator());
            };
            /**
             * Inserts a menu item for the specified <code>Action</code> object at a
             * given position.
             *
             * @param a
             * the <code>Action</code> object to insert
             * @param index
             * specifies the position at which to insert the
             * <code>Action</code>, where 0 is the first
             * @exception IllegalArgumentException
             * if <code>index</code> &lt; 0
             * @see Action
             */
            JPopupMenu.prototype.insert = function (a, index) {
                var _this = this;
                if (((a != null && (a["__interfaces"] != null && a["__interfaces"].indexOf("javax.swing.Action") >= 0 || a.constructor != null && a.constructor["__interfaces"] != null && a.constructor["__interfaces"].indexOf("javax.swing.Action") >= 0)) || a === null) && ((typeof index === 'number') || index === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        var mi = _this.createActionComponent(a);
                        mi.setAction(a);
                        _this.insert(mi, index);
                    })();
                }
                else if (((a != null && a instanceof java.awt.Component) || a === null) && ((typeof index === 'number') || index === null)) {
                    return this.insert$java_awt_Component$int(a, index);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Inserts the specified component into the menu at a given position.
             *
             * @param component
             * the <code>Component</code> to insert
             * @param index
             * specifies the position at which to insert the component, where
             * 0 is the first
             * @exception IllegalArgumentException
             * if <code>index</code> &lt; 0
             */
            JPopupMenu.prototype.insert$java_awt_Component$int = function (component, index) {
                if (index < 0) {
                    throw new java.lang.IllegalArgumentException("index less than zero.");
                }
                var nitems = this.getComponentCount();
                var tempItems = (new java.util.Vector());
                for (var i = index; i < nitems; i++) {
                    tempItems.addElement(this.getComponent(index));
                    this.remove(index);
                }
                this.add(component);
                for (var index142 = tempItems.iterator(); index142.hasNext();) {
                    var tempItem = index142.next();
                    {
                        this.add(tempItem);
                    }
                }
            };
            /**
             * Adds a <code>PopupMenu</code> listener.
             *
             * @param l
             * the <code>PopupMenuListener</code> to add
             */
            JPopupMenu.prototype.addPopupMenuListener = function (l) {
                this.listenerList.add("javax.swing.event.PopupMenuListener", l);
            };
            /**
             * Removes a <code>PopupMenu</code> listener.
             *
             * @param l
             * the <code>PopupMenuListener</code> to remove
             */
            JPopupMenu.prototype.removePopupMenuListener = function (l) {
                this.listenerList.remove("javax.swing.event.PopupMenuListener", l);
            };
            /**
             * Returns an array of all the <code>PopupMenuListener</code>s added to this
             * JMenuItem with addPopupMenuListener().
             *
             * @return all of the <code>PopupMenuListener</code>s added or an empty
             * array if no listeners have been added
             * @since 1.4
             */
            JPopupMenu.prototype.getPopupMenuListeners = function () {
                return this.listenerList.getListeners("javax.swing.event.PopupMenuListener");
            };
            /**
             * Adds a <code>MenuKeyListener</code> to the popup menu.
             *
             * @param l
             * the <code>MenuKeyListener</code> to be added
             * @since 1.5
             */
            JPopupMenu.prototype.addMenuKeyListener = function (l) {
                this.listenerList.add("javax.swing.event.MenuKeyListener", l);
            };
            /**
             * Removes a <code>MenuKeyListener</code> from the popup menu.
             *
             * @param l
             * the <code>MenuKeyListener</code> to be removed
             * @since 1.5
             */
            JPopupMenu.prototype.removeMenuKeyListener = function (l) {
                this.listenerList.remove("javax.swing.event.MenuKeyListener", l);
            };
            /**
             * Returns an array of all the <code>MenuKeyListener</code>s added to this
             * JPopupMenu with addMenuKeyListener().
             *
             * @return all of the <code>MenuKeyListener</code>s added or an empty array
             * if no listeners have been added
             * @since 1.5
             */
            JPopupMenu.prototype.getMenuKeyListeners = function () {
                return this.listenerList.getListeners("javax.swing.event.MenuKeyListener");
            };
            /**
             * Notifies <code>PopupMenuListener</code>s that this popup menu will become
             * visible.
             */
            JPopupMenu.prototype.firePopupMenuWillBecomeVisible = function () {
                var listeners = this.listenerList.getListenerList();
                var e = null;
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "javax.swing.event.PopupMenuListener") {
                        if (e == null)
                            e = new javax.swing.event.PopupMenuEvent(this);
                        listeners[i + 1].popupMenuWillBecomeVisible(e);
                    }
                }
            };
            /**
             * Notifies <code>PopupMenuListener</code>s that this popup menu will become
             * invisible.
             */
            JPopupMenu.prototype.firePopupMenuWillBecomeInvisible = function () {
                var listeners = this.listenerList.getListenerList();
                var e = null;
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "javax.swing.event.PopupMenuListener") {
                        if (e == null)
                            e = new javax.swing.event.PopupMenuEvent(this);
                        listeners[i + 1].popupMenuWillBecomeInvisible(e);
                    }
                }
            };
            /**
             * Notifies <code>PopupMenuListeners</code> that this popup menu is
             * cancelled.
             */
            JPopupMenu.prototype.firePopupMenuCanceled = function () {
                var listeners = this.listenerList.getListenerList();
                var e = null;
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "javax.swing.event.PopupMenuListener") {
                        if (e == null)
                            e = new javax.swing.event.PopupMenuEvent(this);
                        listeners[i + 1].popupMenuCanceled(e);
                    }
                }
            };
            JPopupMenu.prototype.pack = function () {
            };
            /**
             * Retrieves <code>Popup</code> instance from the <code>PopupMenuUI</code>
             * that has had <code>show</code> invoked on it. If the current
             * <code>popup</code> is non-null, this will invoke <code>dispose</code> of
             * it, and then <code>show</code> the new one.
             * <p>
             * This does NOT fire any events, it is up the caller to dispatch the
             * necessary events.
             */
            JPopupMenu.prototype.showPopup = function () {
            };
            /**
             * Sets the location of the upper left corner of the popup menu using x, y
             * coordinates.
             * <p>
             * The method changes the geometry-related data. Therefore, the native
             * windowing system may ignore such requests, or it may modify the requested
             * data, so that the {@code JPopupMenu} object is placed and sized in a way
             * that corresponds closely to the desktop settings.
             *
             * @param x
             * the x coordinate of the popup's new position in the screen's
             * coordinate space
             * @param y
             * the y coordinate of the popup's new position in the screen's
             * coordinate space
             * @beaninfo description: The location of the popup menu.
             */
            JPopupMenu.prototype.setLocation = function (x, y) {
                var _this = this;
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        var oldX = _this.desiredLocationX;
                        var oldY = _this.desiredLocationY;
                        _this.desiredLocationX = x;
                        _this.desiredLocationY = y;
                    })();
                }
                else if (((x != null && x instanceof java.awt.Point) || x === null) && y === undefined) {
                    return this.setLocation$java_awt_Point(x);
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Returns true if the popup menu is a standalone popup menu rather than the
             * submenu of a <code>JMenu</code>.
             *
             * @return true if this menu is a standalone popup menu, otherwise false
             */
            JPopupMenu.prototype.isPopupMenu = function () {
                return ((this.invoker != null) && !(this.invoker != null && this.invoker instanceof javax.swing.JMenu));
            };
            /**
             * Returns the component which is the 'invoker' of this popup menu.
             *
             * @return the <code>Component</code> in which the popup menu is displayed
             */
            JPopupMenu.prototype.getInvoker = function () {
                return this.invoker;
            };
            /**
             * Returns the component at the specified index.
             *
             * @param i
             * the index of the component, where 0 is the first
             * @return the <code>Component</code> at that index
             * @deprecated replaced by {@link java.awt.Container#getComponent(int)}
             */
            JPopupMenu.prototype.getComponentAtIndex = function (i) {
                return this.getComponent(i);
            };
            /**
             * Returns the index of the specified component.
             *
             * @param c
             * the <code>Component</code> to find
             * @return the index of the component, where 0 is the first; or -1 if the
             * component is not found
             */
            JPopupMenu.prototype.getComponentIndex = function (c) {
                var ncomponents = this.getComponentCount();
                var component = this.getComponents();
                for (var i = 0; i < ncomponents; i++) {
                    var comp = component[i];
                    if (comp === c)
                        return i;
                }
                return -1;
            };
            /**
             * Sets the currently selected component, This will result in a change to
             * the selection model.
             *
             * @param sel
             * the <code>Component</code> to select
             * @beaninfo description: The selected component on the popup menu expert:
             * true hidden: true
             */
            JPopupMenu.prototype.setSelected = function (sel) {
                var model = this.getSelectionModel();
                var index = this.getComponentIndex(sel);
                model.setSelectedIndex(index);
            };
            /**
             * Checks whether the border should be painted.
             *
             * @return true if the border is painted, false otherwise
             * @see #setBorderPainted
             */
            JPopupMenu.prototype.isBorderPainted = function () {
                return this.paintBorder;
            };
            /**
             * Sets whether the border should be painted.
             *
             * @param b
             * if true, the border is painted.
             * @see #isBorderPainted
             * @beaninfo description: Is the border of the popup menu painted
             */
            JPopupMenu.prototype.setBorderPainted = function (b) {
                this.paintBorder = b;
            };
            /**
             * Returns the margin, in pixels, between the popup menu's border and its
             * containers.
             *
             * @return an <code>Insets</code> object containing the margin values.
             */
            JPopupMenu.prototype.getMargin = function () {
                if (this.margin == null) {
                    return new java.awt.Insets(0, 0, 0, 0);
                }
                else {
                    return this.margin;
                }
            };
            /**
             * Examines the list of menu items to determine whether <code>popup</code>
             * is a popup menu.
             *
             * @param popup
             * a <code>JPopupMenu</code>
             * @return true if <code>popup</code>
             */
            JPopupMenu.prototype.isSubPopupMenu = function (popup) {
                var ncomponents = this.getComponentCount();
                var component = this.getComponents();
                for (var i = 0; i < ncomponents; i++) {
                    var comp = component[i];
                    if (comp != null && comp instanceof javax.swing.JMenu) {
                        var menu = comp;
                        var subPopup = menu.getPopupMenu();
                        if (subPopup === popup)
                            return true;
                        if (subPopup.isSubPopupMenu(popup))
                            return true;
                    }
                }
                return false;
            };
            JPopupMenu.getFrame = function (c) {
                var w = c;
                while ((!(w != null && w instanceof java.awt.Frame) && (w != null))) {
                    w = w.getParent();
                }
                ;
                return w;
            };
            /**
             * Returns a string representation of this <code>JPopupMenu</code>. This
             * method is intended to be used only for debugging purposes, and the
             * content and format of the returned string may vary between
             * implementations. The returned string may be empty but may not be
             * <code>null</code>.
             *
             * @return a string representation of this <code>JPopupMenu</code>.
             */
            JPopupMenu.prototype.paramString = function () {
                var labelString = (this.label != null ? this.label : "");
                var paintBorderString = (this.paintBorder ? "true" : "false");
                var marginString = (this.margin != null ? this.margin.toString() : "");
                return _super.prototype.paramString.call(this) + ",desiredLocationX=" + this.desiredLocationX + ",desiredLocationY=" + this.desiredLocationY + ",label=" + labelString + ",margin=" + marginString + ",paintBorder=" + paintBorderString;
            };
            /**
             * This method is required to conform to the <code>MenuElement</code>
             * interface, but it not implemented.
             *
             * @see MenuElement#processMouseEvent(MouseEvent, MenuElement[],
             * MenuSelectionManager)
             */
            JPopupMenu.prototype.processMouseEvent = function (event, path, manager) {
            };
            /**
             * Processes a key event forwarded from the
             * <code>MenuSelectionManager</code> and changes the menu selection, if
             * necessary, by using <code>MenuSelectionManager</code>'s API.
             * <p>
             * Note: you do not have to forward the event to sub-components. This is
             * done automatically by the <code>MenuSelectionManager</code>.
             *
             * @param e
             * a <code>KeyEvent</code>
             * @param path
             * the <code>MenuElement</code> path array
             * @param manager
             * the <code>MenuSelectionManager</code>
             */
            JPopupMenu.prototype.processKeyEvent = function (e, path, manager) {
                var _this = this;
                if (((e != null && e instanceof java.awt.event.KeyEvent) || e === null) && ((path != null && path instanceof Array) || path === null) && ((manager != null && manager instanceof javax.swing.MenuSelectionManager) || manager === null)) {
                    var __args = Array.prototype.slice.call(arguments);
                    return (function () {
                        var mke = new javax.swing.event.MenuKeyEvent(e.getComponent(), e.getID(), e.getWhen(), e.getModifiers(), e.getKeyCode(), e.getKeyChar(), path, manager);
                        _this.processMenuKeyEvent(mke);
                        if (mke.isConsumed()) {
                            e.consume();
                        }
                    })();
                }
                else
                    throw new Error('invalid overload');
            };
            /**
             * Handles a keystroke in a menu.
             *
             * @param e
             * a <code>MenuKeyEvent</code> object
             * @since 1.5
             */
            JPopupMenu.prototype.processMenuKeyEvent = function (e) {
                switch ((e.getID())) {
                    case java.awt.event.KeyEvent.KEY_PRESSED_$LI$():
                        this.fireMenuKeyPressed(e);
                        break;
                    case java.awt.event.KeyEvent.KEY_RELEASED_$LI$():
                        this.fireMenuKeyReleased(e);
                        break;
                    case java.awt.event.KeyEvent.KEY_TYPED_$LI$():
                        this.fireMenuKeyTyped(e);
                        break;
                    default:
                        break;
                }
            };
            /**
             * Notifies all listeners that have registered interest for notification on
             * this event type.
             *
             * @param event
             * a <code>MenuKeyEvent</code>
             * @see EventListenerList
             */
            JPopupMenu.prototype.fireMenuKeyPressed = function (event) {
                var listeners = this.listenerList.getListenerList();
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "javax.swing.event.MenuKeyListener") {
                        listeners[i + 1].menuKeyPressed(event);
                    }
                }
            };
            /**
             * Notifies all listeners that have registered interest for notification on
             * this event type.
             *
             * @param event
             * a <code>MenuKeyEvent</code>
             * @see EventListenerList
             */
            JPopupMenu.prototype.fireMenuKeyReleased = function (event) {
                var listeners = this.listenerList.getListenerList();
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "javax.swing.event.MenuKeyListener") {
                        listeners[i + 1].menuKeyReleased(event);
                    }
                }
            };
            /**
             * Notifies all listeners that have registered interest for notification on
             * this event type.
             *
             * @param event
             * a <code>MenuKeyEvent</code>
             * @see EventListenerList
             */
            JPopupMenu.prototype.fireMenuKeyTyped = function (event) {
                var listeners = this.listenerList.getListenerList();
                for (var i = listeners.length - 2; i >= 0; i -= 2) {
                    if (listeners[i] === "javax.swing.event.MenuKeyListener") {
                        listeners[i + 1].menuKeyTyped(event);
                    }
                }
            };
            /**
             * Messaged when the menubar selection changes to activate or deactivate
             * this menu. This implements the <code>javax.swing.MenuElement</code>
             * interface. Overrides <code>MenuElement.menuSelectionChanged</code>.
             *
             * @param isIncluded
             * true if this menu is active, false if it is not
             * @see MenuElement#menuSelectionChanged(boolean)
             */
            JPopupMenu.prototype.menuSelectionChanged = function (isIncluded) {
                if (JPopupMenu.DEBUG) {
                    console.info("In JPopupMenu.menuSelectionChanged " + isIncluded);
                }
                if (this.invoker != null && this.invoker instanceof javax.swing.JMenu) {
                    var m = this.invoker;
                    if (isIncluded)
                        m.setPopupMenuVisible(true);
                    else
                        m.setPopupMenuVisible(false);
                }
                if (this.isPopupMenu() && !isIncluded)
                    this.setVisible(false);
            };
            /**
             * Returns an array of <code>MenuElement</code>s containing the submenu for
             * this menu component. It will only return items conforming to the
             * <code>JMenuElement</code> interface. If popup menu is <code>null</code>
             * returns an empty array. This method is required to conform to the
             * <code>MenuElement</code> interface.
             *
             * @return an array of <code>MenuElement</code> objects
             * @see MenuElement#getSubElements
             */
            JPopupMenu.prototype.getSubElements = function () {
                var result;
                var tmp = (new java.util.Vector());
                var c = this.getComponentCount();
                var i;
                var m;
                for (i = 0; i < c; i++) {
                    m = this.getComponent(i);
                    if (m != null && (m["__interfaces"] != null && m["__interfaces"].indexOf("javax.swing.MenuElement") >= 0 || m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("javax.swing.MenuElement") >= 0))
                        tmp.addElement(m);
                }
                result = new Array(tmp.size());
                for (i = 0, c = tmp.size(); i < c; i++)
                    result[i] = tmp.elementAt(i);
                return result;
            };
            /**
             * Returns this <code>JPopupMenu</code> component.
             *
             * @return this <code>JPopupMenu</code> object
             * @see MenuElement#getComponent
             */
            JPopupMenu.prototype.getComponent$ = function () {
                return this;
            };
            /**
             * @see #getUIClassID
             * @see #readObject
             */
            JPopupMenu.uiClassID = "PopupMenuUI";
            JPopupMenu.TRACE = false;
            JPopupMenu.VERBOSE = false;
            JPopupMenu.DEBUG = false;
            return JPopupMenu;
        }(javax.swing.JComponent));
        swing.JPopupMenu = JPopupMenu;
        JPopupMenu["__class"] = "javax.swing.JPopupMenu";
        JPopupMenu["__interfaces"] = ["java.awt.HTMLComponent", "javax.swing.MenuElement", "java.io.Serializable"];
        var JPopupMenu;
        (function (JPopupMenu) {
            /**
             * A popup menu-specific separator.
             */
            var Separator = (function (_super) {
                __extends(Separator, _super);
                function Separator() {
                    _super.call(this, javax.swing.SwingConstants.HORIZONTAL);
                }
                /**
                 * Returns the name of the L&amp;F class that renders this component.
                 *
                 * @return the string "PopupMenuSeparatorUI"
                 * @see JComponent#getUIClassID
                 * @see UIDefaults#getUI
                 */
                Separator.prototype.getUIClassID = function () {
                    return "PopupMenuSeparatorUI";
                };
                return Separator;
            }(javax.swing.JSeparator));
            JPopupMenu.Separator = Separator;
            Separator["__class"] = "javax.swing.JPopupMenu.Separator";
            Separator["__interfaces"] = ["java.awt.HTMLComponent", "java.io.Serializable"];
        })(JPopupMenu = swing.JPopupMenu || (swing.JPopupMenu = {}));
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
var javax;
(function (javax) {
    var swing;
    (function (swing) {
        var JCheckBox = (function (_super) {
            __extends(JCheckBox, _super);
            function JCheckBox(label, state) {
                if (label === void 0) { label = ""; }
                if (state === void 0) { state = false; }
                _super.call(this);
                this.state = false;
                this.label = label;
                this.state = state;
                this.itemListeners = (new Array());
            }
            JCheckBox.prototype.createHTML = function () {
                console.info("create HTML jcheckbox");
                if (this.htmlElement != null) {
                    return;
                }
                this.htmlElement = document.createElement("label");
                this.htmlElement.appendChild(this.htmlLabel = document.createTextNode(""));
                this.htmlCheckbox = document.createElement("input");
                this.htmlCheckbox.type = "checkbox";
                this.htmlElement.appendChild(this.htmlCheckbox);
            };
            JCheckBox.prototype.initHTML = function () {
                var _this = this;
                console.info("init HTML jcheckbox");
                _super.prototype.initHTML.call(this);
                this.htmlCheckbox.checked = this.state;
                this.htmlLabel.data = this.label;
                this.htmlCheckbox.onclick = function (e) {
                    console.info(e + " / " + _this.htmlCheckbox.checked);
                    _this.setState(_this.htmlCheckbox.checked);
                    _this.processItemEvent(new java.awt.event.ItemEvent(_this, 0, null, _this.htmlCheckbox.checked ? java.awt.event.ItemEvent.SELECTED : java.awt.event.ItemEvent.DESELECTED));
                    return e;
                };
            };
            JCheckBox.prototype.constructComponentName = function () {
                {
                    return JCheckBox.base + JCheckBox.nameCounter++;
                }
                ;
            };
            JCheckBox.prototype.getLabel = function () {
                return this.label;
            };
            JCheckBox.prototype.setLabel = function (label) {
                {
                    if (label !== this.label && (this.label == null || !(this.label === label))) {
                        this.label = label;
                    }
                }
                ;
            };
            JCheckBox.prototype.getState = function () {
                return this.state;
            };
            JCheckBox.prototype.setStateInternal = function (state) {
                this.state = state;
                if (this.htmlCheckbox != null) {
                    this.htmlCheckbox.checked = state;
                }
            };
            JCheckBox.prototype.setState = function (state) {
                this.setStateInternal(state);
            };
            JCheckBox.prototype.getSelectedObjects = function () {
                if (this.state) {
                    var items = new Array(1);
                    items[0] = this.label;
                    return items;
                }
                return null;
            };
            JCheckBox.prototype.addItemListener = function (l) {
                if (l == null) {
                    return;
                }
                this.itemListeners.push(l);
            };
            JCheckBox.prototype.removeItemListener = function (l) {
                if (l == null) {
                    return;
                }
                var index = (this.itemListeners.indexOf(l) | 0);
                if (index > -1) {
                    this.itemListeners.splice(index, 1);
                }
            };
            JCheckBox.prototype.getItemListeners = function () {
                return this.itemListeners;
            };
            JCheckBox.prototype.getListeners = function (listenerType) {
                var result = (new Array());
                for (var i = 0; i < this.itemListeners.length; i++) {
                    if (this.itemListeners[i].constructor === listenerType) {
                        result.push((this.itemListeners[i]));
                    }
                }
                return result;
            };
            JCheckBox.prototype.processItemEvent = function (e) {
                for (var index143 = 0; index143 < this.itemListeners.length; index143++) {
                    var listener = this.itemListeners[index143];
                    {
                        listener.itemStateChanged(e);
                    }
                }
            };
            JCheckBox.prototype.paramString = function () {
                var str = _super.prototype.paramString.call(this);
                var label = this.label;
                if (label != null) {
                    str += ",label=" + label;
                }
                return str + ",state=" + this.state;
            };
            JCheckBox.base = "checkbox";
            JCheckBox.nameCounter = 0;
            JCheckBox.serialVersionUID = 7270714317450821763;
            return JCheckBox;
        }(javax.swing.JToggleButton));
        swing.JCheckBox = JCheckBox;
        JCheckBox["__class"] = "javax.swing.JCheckBox";
        JCheckBox["__interfaces"] = ["java.awt.ItemSelectable", "java.awt.HTMLComponent", "javax.swing.SwingConstants", "java.io.Serializable"];
    })(swing = javax.swing || (javax.swing = {}));
})(javax || (javax = {}));
javax.swing.JPopupMenu.classLock_$LI$();
javax.swing.JTextField.defaultActions_$LI$();
sun.awt.ExtendedKeyCodes.extendedKeyCodesSet_$LI$();
sun.awt.ExtendedKeyCodes.regularKeyCodesMap_$LI$();
sun.awt.ExtendedKeyCodes.__static_initialize();
java.awt.Frame.MAXIMIZED_BOTH_$LI$();
java.awt.Frame.MOVE_CURSOR_$LI$();
java.awt.Frame.HAND_CURSOR_$LI$();
java.awt.Frame.E_RESIZE_CURSOR_$LI$();
java.awt.Frame.W_RESIZE_CURSOR_$LI$();
java.awt.Frame.S_RESIZE_CURSOR_$LI$();
java.awt.Frame.N_RESIZE_CURSOR_$LI$();
java.awt.Frame.NE_RESIZE_CURSOR_$LI$();
java.awt.Frame.NW_RESIZE_CURSOR_$LI$();
java.awt.Frame.SE_RESIZE_CURSOR_$LI$();
java.awt.Frame.SW_RESIZE_CURSOR_$LI$();
java.awt.Frame.WAIT_CURSOR_$LI$();
java.awt.Frame.TEXT_CURSOR_$LI$();
java.awt.Frame.CROSSHAIR_CURSOR_$LI$();
java.awt.Frame.DEFAULT_CURSOR_$LI$();
java.applet.Applet.__static_initialize();
java.awt.event.MouseEvent.MOUSE_WHEEL_$LI$();
java.awt.event.MouseEvent.MOUSE_DRAGGED_$LI$();
java.awt.event.MouseEvent.MOUSE_EXITED_$LI$();
java.awt.event.MouseEvent.MOUSE_ENTERED_$LI$();
java.awt.event.MouseEvent.MOUSE_MOVED_$LI$();
java.awt.event.MouseEvent.MOUSE_RELEASED_$LI$();
java.awt.event.MouseEvent.MOUSE_PRESSED_$LI$();
java.awt.event.MouseEvent.MOUSE_CLICKED_$LI$();
java.awt.event.KeyEvent.VK_SEPARATOR_$LI$();
java.awt.event.KeyEvent.KEY_RELEASED_$LI$();
java.awt.event.KeyEvent.KEY_PRESSED_$LI$();
java.awt.event.KeyEvent.KEY_TYPED_$LI$();
java.awt.event.WindowEvent.WINDOW_LAST_$LI$();
java.awt.event.WindowEvent.WINDOW_STATE_CHANGED_$LI$();
java.awt.event.WindowEvent.WINDOW_LOST_FOCUS_$LI$();
java.awt.event.WindowEvent.WINDOW_GAINED_FOCUS_$LI$();
java.awt.event.WindowEvent.WINDOW_DEACTIVATED_$LI$();
java.awt.event.WindowEvent.WINDOW_ACTIVATED_$LI$();
java.awt.event.WindowEvent.WINDOW_DEICONIFIED_$LI$();
java.awt.event.WindowEvent.WINDOW_ICONIFIED_$LI$();
java.awt.event.WindowEvent.WINDOW_CLOSED_$LI$();
java.awt.event.WindowEvent.WINDOW_CLOSING_$LI$();
java.awt.event.WindowEvent.WINDOW_OPENED_$LI$();
java.awt.event.InputEvent.HIGH_MODIFIERS_$LI$();
java.awt.event.InputEvent.JDK_1_3_MODIFIERS_$LI$();
java.awt.event.InputEvent.FIRST_HIGH_BIT_$LI$();
java.awt.event.InputEvent.BUTTON_DOWN_MASK_$LI$();
java.awt.event.InputEvent.ALT_GRAPH_DOWN_MASK_$LI$();
java.awt.event.InputEvent.BUTTON3_DOWN_MASK_$LI$();
java.awt.event.InputEvent.BUTTON2_DOWN_MASK_$LI$();
java.awt.event.InputEvent.BUTTON1_DOWN_MASK_$LI$();
java.awt.event.InputEvent.ALT_DOWN_MASK_$LI$();
java.awt.event.InputEvent.META_DOWN_MASK_$LI$();
java.awt.event.InputEvent.CTRL_DOWN_MASK_$LI$();
java.awt.event.InputEvent.SHIFT_DOWN_MASK_$LI$();
java.awt.event.InputEvent.BUTTON3_MASK_$LI$();
java.awt.event.InputEvent.BUTTON2_MASK_$LI$();
java.awt.event.InputEvent.BUTTON1_MASK_$LI$();
java.awt.event.InputEvent.ALT_GRAPH_MASK_$LI$();
java.awt.event.InputEvent.ALT_MASK_$LI$();
java.awt.event.InputEvent.META_MASK_$LI$();
java.awt.event.InputEvent.CTRL_MASK_$LI$();
java.awt.event.InputEvent.SHIFT_MASK_$LI$();
java.awt.event.FocusEvent.FOCUS_LOST_$LI$();
java.awt.event.FocusEvent.FOCUS_GAINED_$LI$();
java.awt.event.ContainerEvent.COMPONENT_REMOVED_$LI$();
java.awt.event.ContainerEvent.COMPONENT_ADDED_$LI$();
sun.awt.geom.AreaOp.EmptyChainList_$LI$();
sun.awt.geom.AreaOp.EmptyLinkList_$LI$();
sun.awt.geom.AreaOp.YXTopComparator_$LI$();
java.beans.PropertyChangeSupport.PropertyChangeListenerMap.EMPTY_$LI$();
java.awt.geom.Path2D.Iterator.curvecoords_$LI$();
java.awt.geom.Path2D.SEG_CLOSE_$LI$();
java.awt.geom.Path2D.SEG_CUBICTO_$LI$();
java.awt.geom.Path2D.SEG_QUADTO_$LI$();
java.awt.geom.Path2D.SEG_LINETO_$LI$();
java.awt.geom.Path2D.SEG_MOVETO_$LI$();
java.awt.geom.Path2D.WIND_NON_ZERO_$LI$();
java.awt.geom.Path2D.WIND_EVEN_ODD_$LI$();
java.awt.event.ActionEvent.ACTION_PERFORMED_$LI$();
java.awt.event.ActionEvent.ALT_MASK_$LI$();
java.awt.event.ActionEvent.META_MASK_$LI$();
java.awt.event.ActionEvent.CTRL_MASK_$LI$();
java.awt.event.ActionEvent.SHIFT_MASK_$LI$();
java.awt.event.TextEvent.TEXT_VALUE_CHANGED_$LI$();
java.awt.event.ItemEvent.ITEM_STATE_CHANGED_$LI$();
java.awt.event.ComponentEvent.COMPONENT_HIDDEN_$LI$();
java.awt.event.ComponentEvent.COMPONENT_SHOWN_$LI$();
java.awt.event.ComponentEvent.COMPONENT_RESIZED_$LI$();
java.awt.event.ComponentEvent.COMPONENT_MOVED_$LI$();
java.awt.event.AdjustmentEvent.ADJUSTMENT_VALUE_CHANGED_$LI$();
javax.swing.text.Position.Bias.Backward_$LI$();
javax.swing.text.Position.Bias.Forward_$LI$();
javax.swing.event.EventListenerList.NULL_ARRAY_$LI$();
javax.swing.DefaultListSelectionModel.MAX_$LI$();
javax.swing.DefaultButtonModel.ROLLOVER_$LI$();
javax.swing.DefaultButtonModel.ENABLED_$LI$();
javax.swing.DefaultButtonModel.PRESSED_$LI$();
javax.swing.DefaultButtonModel.SELECTED_$LI$();
javax.swing.DefaultButtonModel.ARMED_$LI$();
java.awt.geom.RoundRectIterator.types_$LI$();
java.awt.geom.RoundRectIterator.ctrlpts_$LI$();
java.awt.geom.RoundRectIterator.acv_$LI$();
java.awt.geom.RoundRectIterator.cv_$LI$();
java.awt.geom.RoundRectIterator.c_$LI$();
java.awt.geom.RoundRectIterator.b_$LI$();
java.awt.geom.RoundRectIterator.a_$LI$();
java.awt.geom.RoundRectIterator.angle_$LI$();
java.awt.geom.EllipseIterator.ctrlpts_$LI$();
java.awt.geom.EllipseIterator.ncv_$LI$();
java.awt.geom.EllipseIterator.pcv_$LI$();
java.awt.geom.Area.EmptyCurves_$LI$();
java.awt.geom.AffineTransform.rot90conversion_$LI$();
java.awt.geom.AffineTransform.HI_SHEAR_$LI$();
java.awt.geom.AffineTransform.HI_SCALE_$LI$();
java.awt.geom.AffineTransform.HI_TRANSLATE_$LI$();
java.awt.geom.AffineTransform.HI_IDENTITY_$LI$();
java.awt.geom.AffineTransform.TYPE_MASK_ROTATION_$LI$();
java.awt.geom.AffineTransform.TYPE_MASK_SCALE_$LI$();
java.awt.Event.LOST_FOCUS_$LI$();
java.awt.Event.GOT_FOCUS_$LI$();
java.awt.Event.SAVE_FILE_$LI$();
java.awt.Event.LOAD_FILE_$LI$();
java.awt.Event.ACTION_EVENT_$LI$();
java.awt.Event.LIST_DESELECT_$LI$();
java.awt.Event.LIST_SELECT_$LI$();
java.awt.Event.SCROLL_END_$LI$();
java.awt.Event.SCROLL_BEGIN_$LI$();
java.awt.Event.SCROLL_ABSOLUTE_$LI$();
java.awt.Event.SCROLL_PAGE_DOWN_$LI$();
java.awt.Event.SCROLL_PAGE_UP_$LI$();
java.awt.Event.SCROLL_LINE_DOWN_$LI$();
java.awt.Event.SCROLL_LINE_UP_$LI$();
java.awt.Event.MOUSE_DRAG_$LI$();
java.awt.Event.MOUSE_EXIT_$LI$();
java.awt.Event.MOUSE_ENTER_$LI$();
java.awt.Event.MOUSE_MOVE_$LI$();
java.awt.Event.MOUSE_UP_$LI$();
java.awt.Event.MOUSE_DOWN_$LI$();
java.awt.Event.KEY_ACTION_RELEASE_$LI$();
java.awt.Event.KEY_ACTION_$LI$();
java.awt.Event.KEY_RELEASE_$LI$();
java.awt.Event.KEY_PRESS_$LI$();
java.awt.Event.WINDOW_MOVED_$LI$();
java.awt.Event.WINDOW_DEICONIFY_$LI$();
java.awt.Event.WINDOW_ICONIFY_$LI$();
java.awt.Event.WINDOW_EXPOSE_$LI$();
java.awt.Event.WINDOW_DESTROY_$LI$();
java.awt.Event.ALT_MASK_$LI$();
java.awt.Event.META_MASK_$LI$();
java.awt.Event.CTRL_MASK_$LI$();
java.awt.Event.SHIFT_MASK_$LI$();
java.awt.Cursor.cursorProperties_$LI$();
java.awt.Cursor.predefinedPrivate_$LI$();
java.awt.Cursor.predefined_$LI$();
java.awt.Color.BLUE_$LI$();
java.awt.Color.blue_$LI$();
java.awt.Color.CYAN_$LI$();
java.awt.Color.cyan_$LI$();
java.awt.Color.MAGENTA_$LI$();
java.awt.Color.magenta_$LI$();
java.awt.Color.GREEN_$LI$();
java.awt.Color.green_$LI$();
java.awt.Color.YELLOW_$LI$();
java.awt.Color.yellow_$LI$();
java.awt.Color.ORANGE_$LI$();
java.awt.Color.orange_$LI$();
java.awt.Color.PINK_$LI$();
java.awt.Color.pink_$LI$();
java.awt.Color.RED_$LI$();
java.awt.Color.red_$LI$();
java.awt.Color.BLACK_$LI$();
java.awt.Color.black_$LI$();
java.awt.Color.DARK_GRAY_$LI$();
java.awt.Color.darkGray_$LI$();
java.awt.Color.GRAY_$LI$();
java.awt.Color.gray_$LI$();
java.awt.Color.LIGHT_GRAY_$LI$();
java.awt.Color.lightGray_$LI$();
java.awt.Color.WHITE_$LI$();
java.awt.Color.white_$LI$();
java.awt.BorderLayout.LINE_END_$LI$();
java.awt.BorderLayout.LINE_START_$LI$();
java.awt.BorderLayout.PAGE_END_$LI$();
java.awt.BorderLayout.PAGE_START_$LI$();
